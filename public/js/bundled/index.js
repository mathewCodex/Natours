// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function() {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"7BNkR":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "92514f05e45deafc";
module.bundle.HMR_BUNDLE_ID = "8912e3a81bba04c7";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F1() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                } // Render the fancy html overlay
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
            document.body.appendChild(overlay);
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>\n          ").concat(stack, "\n        </pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>' + hint + '</div>';
            }).join(''), "\n        </div>\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') {
        reloadCSS();
        return;
    }
    var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
    if (deps) {
        var fn = new Function('require', 'module', 'exports', asset.output);
        modules[asset.id] = [
            fn,
            deps
        ];
    } else if (bundle.parent) hmrApply(bundle.parent, asset);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    return getParents(module.bundle.root, id).some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"hkC5c":[function(require,module,exports) {
var _login = require("./login");
var _mapBox = require("./mapBox");
var _updateSettings = require("./updateSettings");
var _stripe = require("./stripe");
var _alert = require("./alert");
//DOM ELEMENT
const mapBox = document.getElementById("map");
const loginForm = document.querySelector(".form");
const logOutBtn = document.querySelector(".nav__el--logout");
const newData = document.querySelector(".form-user-data");
const userPasswordForm = document.querySelector(".form-user-password");
const bookBtn = document.getElementById("book-tour");
//DELEGATION
if (mapBox) {
    const locations = JSON.parse(mapBox.dataset.locations);
    _mapBox.displayMap(locations);
}
if (loginForm) loginForm.addEventListener("submit", (e)=>{
    e.preventDefault();
    const email = document.getElementById("email").value;
    const password = document.getElementById("password").value;
    _login.login(email, password);
});
if (logOutBtn) logOutBtn.addEventListener("click", _login.logout);
///
// if (newData) {
//   newData.addEventListener("submit", (e) => {
//     e.preventDefault();
//     const name = document.getElementById("name").value;
//     const email = document.getElementById("email").value;
//    updateSettings({name, email}, 'data');
//   });
// }
if (newData) newData.addEventListener("submit", (e)=>{
    e.preventDefault();
    const form = new FormData();
    form.append('name', document.getElementById("name").value);
    form.append('email', document.getElementById("email").value);
    form.append("photo", document.getElementById("photo").files[0]);
    _updateSettings.updateSettings(form, "data");
    console.log(form);
});
if (userPasswordForm) userPasswordForm.addEventListener("submit", async (e)=>{
    e.preventDefault();
    document.querySelector(".btn--save-password").textContent = "Updating...";
    const passwordCurrent = document.getElementById("password-current").value;
    const password = document.getElementById("password").value;
    const passwordConfirm = document.getElementById("password-confirm").value;
    await _updateSettings.updateSettings({
        passwordCurrent,
        password,
        passwordConfirm
    }, "password");
    ///making the field cleared after data input
    document.querySelector(".btn--save-password").textContent = "Save Password";
    document.getElementById("password-current").value = "";
    document.getElementById("password").value = "";
    document.getElementById("password-confirm").value = "";
});
//adding a booking funtion
if (bookBtn) bookBtn.addEventListener('click', (e)=>{
    e.target.textContent = 'Processing...';
    const { tourId  } = e.target.dataset;
    _stripe.bookTour(tourId);
});
const alertMessage = document.querySelector('body').dataset.alert;
if (alertMessage) _alert.showAlert('success', alertMessage, 20);

},{"./login":"6OOUb","./mapBox":"2sWFm","./updateSettings":"4HHsO","./stripe":"effgQ","./alert":"ehTc8"}],"6OOUb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "login", ()=>login
);
parcelHelpers.export(exports, "logout", ()=>logout
);
// /* eslint disable */
// import axios from 'axios';
// import { showAlert } from "./alert";
// export const login = async (email, password) => {
//     console.log(email,password)
//     console.log('login')
//     try{
//     // http://127.0.0.1:3000/api/v1/users/login
//     // http://localhost:3000/api/v1/users/login
//   // Send a POST request
//   const request = await fetch("http://localhost:3000/api/v1/users/login", {
//     method: "POST",
//     headers: {
//       Accept: "application/json",
//       "Content-Type": "application/json",
//     },
//     body: JSON.stringify({
//       email,
//       password,
//     }),
//   });
//   const response = await request.json();
//   console.log(response)
//     if (response.status === "success") {
//       showAlert("success", "Logged in successfully!");
//       // go to home page
//       window.setTimeout(() => {
//         location.assign("/views");
//       }, 500);
//     }
// } catch(err){
//       showAlert('error',err.response.data.message); 
// }
// }
// //logout function
// // export const logout = async () => {
// //   try{
// //     // const res = await fetch('http://localhost:3000/api/v1/users/logout',{
// //     //   method: 'GET'
// //     // }); 
// //     const res = await fetch("http://localhost:3000/api/v1/users/logout", {
// //       method: "GET",
// //     });
// //     console.log(res)
// //     if((res.status === 200)) location.assign("/login")
// //     //  if(res.status === )
// //   }catch(err){
// //     showAlert('error','Error logging out try again') 
// //     // console.log(err)
// //   }
// // }
// //using Axios
// ////
// export const logout = async () => {
//   try {
//     const res = await axios({
//       method: "GET",
//       url: "http://localhost:3000/api/v1/users/logout",
//     });
//     if ((res.data.status = "success")) location.reload(true);
//   } catch (err) {
//     console.log(err.response);
//     showAlert("error", "Error logging out! Try again.");
//   }
// };
// //-------------------------//
// //
// // export const login = async (email,password) => {
// //     alert("logged IN")
// // console.log('Logged In');
// // console.log(email,password)
// //     try{
// //      alert(email,password)
// // const res =  await axios({
// //         method:'POST',
// //         url: 'http://localhost:3000/api/v1/users/login',
// //         data: {
// //             email,
// //             password,
// //              withCredentials: true
// //         }
// //     });
// //     //checking if our api call was successfull
// //     if(res.data.status === 'success'){
// //         alert('Logged In successfully');
// //         window.setTimeout(() => {
// //             //using location.assign to load another page
// //             location.assign('/')
// //         }, 1500)
// //     }
// // }catch(err){
// //     alert(err.response.data.message)
// // }
// // }
/* eslint-disable */ var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _alert = require("./alert");
const login = async (email, password)=>{
    try {
        const res = await _axiosDefault.default({
            method: 'POST',
            url: 'http://localhost:3000/api/v1/users/login',
            data: {
                email,
                password
            }
        });
        if (res.data.status === 'success') {
            _alert.showAlert('success', 'Logged in successfully!');
            window.setTimeout(()=>{
                location.assign('/views');
            }, 1500);
        }
    } catch (err) {
        _alert.showAlert('error', err.response.data.message);
    }
};
const logout = async ()=>{
    try {
        const res = await _axiosDefault.default({
            method: 'GET',
            url: 'http://localhost:3000/api/v1/users/logout'
        });
        res.data.status = 'success';
        location.assign('/login');
    } catch (err) {
        console.log(err.response);
        _alert.showAlert('error', 'Error logging out! Try again.');
    }
};

},{"./alert":"ehTc8","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn","axios":"giwFZ"}],"ehTc8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hideAlert", ()=>hideAlert
);
parcelHelpers.export(exports, "showAlert", ()=>showAlert
);
const hideAlert = ()=>{
    const el = document.querySelector('.alert');
    //removing one element from the 
    if (el) el.parentElement.removeChild(el);
};
const showAlert = (type, msg, time = 7)=>{
    hideAlert();
    const marKup = `<div class="alert alert--${type}"> ${msg}</div>`;
    document.querySelector('body').insertAdjacentHTML('afterbegin', marKup);
    console.log("show");
    window.setTimeout(hideAlert, time * 1000);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"6FiJn":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule') return;
        // Skip duplicate re-exports when they have the same value.
        if (key in dest && dest[key] === source[key]) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"giwFZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_axiosJsDefault.default
);
parcelHelpers.export(exports, "Axios", ()=>Axios
);
parcelHelpers.export(exports, "AxiosError", ()=>AxiosError
);
parcelHelpers.export(exports, "CanceledError", ()=>CanceledError
);
parcelHelpers.export(exports, "isCancel", ()=>isCancel
);
parcelHelpers.export(exports, "CancelToken", ()=>CancelToken
);
parcelHelpers.export(exports, "VERSION", ()=>VERSION
);
parcelHelpers.export(exports, "all", ()=>all
);
parcelHelpers.export(exports, "Cancel", ()=>Cancel
);
parcelHelpers.export(exports, "isAxiosError", ()=>isAxiosError
);
parcelHelpers.export(exports, "spread", ()=>spread
);
parcelHelpers.export(exports, "toFormData", ()=>toFormData
);
parcelHelpers.export(exports, "AxiosHeaders", ()=>AxiosHeaders
);
parcelHelpers.export(exports, "HttpStatusCode", ()=>HttpStatusCode
);
parcelHelpers.export(exports, "formToJSON", ()=>formToJSON
);
parcelHelpers.export(exports, "mergeConfig", ()=>mergeConfig
);
var _axiosJs = require("./lib/axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const { Axios , AxiosError , CanceledError , isCancel , CancelToken , VERSION , all , Cancel , isAxiosError , spread , toFormData , AxiosHeaders , HttpStatusCode , formToJSON , mergeConfig  } = _axiosJsDefault.default;

},{"./lib/axios.js":"ayfCy","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"ayfCy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _axiosJs = require("./core/Axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
var _mergeConfigJs = require("./core/mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _indexJs = require("./defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("./helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
var _canceledErrorJs = require("./cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _cancelTokenJs = require("./cancel/CancelToken.js");
var _cancelTokenJsDefault = parcelHelpers.interopDefault(_cancelTokenJs);
var _isCancelJs = require("./cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _dataJs = require("./env/data.js");
var _toFormDataJs = require("./helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _axiosErrorJs = require("./core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _spreadJs = require("./helpers/spread.js");
var _spreadJsDefault = parcelHelpers.interopDefault(_spreadJs);
var _isAxiosErrorJs = require("./helpers/isAxiosError.js");
var _isAxiosErrorJsDefault = parcelHelpers.interopDefault(_isAxiosErrorJs);
var _axiosHeadersJs = require("./core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _httpStatusCodeJs = require("./helpers/HttpStatusCode.js");
var _httpStatusCodeJsDefault = parcelHelpers.interopDefault(_httpStatusCodeJs);
'use strict';
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    const context = new _axiosJsDefault.default(defaultConfig);
    const instance = _bindJsDefault.default(_axiosJsDefault.default.prototype.request, context);
    // Copy axios.prototype to instance
    _utilsJsDefault.default.extend(instance, _axiosJsDefault.default.prototype, context, {
        allOwnKeys: true
    });
    // Copy context to instance
    _utilsJsDefault.default.extend(instance, context, null, {
        allOwnKeys: true
    });
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return createInstance(_mergeConfigJsDefault.default(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
const axios = createInstance(_indexJsDefault.default);
// Expose Axios class to allow class inheritance
axios.Axios = _axiosJsDefault.default;
// Expose Cancel & CancelToken
axios.CanceledError = _canceledErrorJsDefault.default;
axios.CancelToken = _cancelTokenJsDefault.default;
axios.isCancel = _isCancelJsDefault.default;
axios.VERSION = _dataJs.VERSION;
axios.toFormData = _toFormDataJsDefault.default;
// Expose AxiosError class
axios.AxiosError = _axiosErrorJsDefault.default;
// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = _spreadJsDefault.default;
// Expose isAxiosError
axios.isAxiosError = _isAxiosErrorJsDefault.default;
// Expose mergeConfig
axios.mergeConfig = _mergeConfigJsDefault.default;
axios.AxiosHeaders = _axiosHeadersJsDefault.default;
axios.formToJSON = (thing)=>_formDataToJSONJsDefault.default(_utilsJsDefault.default.isHTMLForm(thing) ? new FormData(thing) : thing)
;
axios.HttpStatusCode = _httpStatusCodeJsDefault.default;
axios.default = axios;
exports.default = axios;

},{"./utils.js":"2JN6N","./helpers/bind.js":"7inTS","./core/Axios.js":"e8U2S","./core/mergeConfig.js":"75jxX","./defaults/index.js":"6u83V","./helpers/formDataToJSON.js":"bSqWz","./cancel/CanceledError.js":"l0dHi","./cancel/CancelToken.js":"931qi","./cancel/isCancel.js":"7RXGw","./env/data.js":"lSeIg","./helpers/toFormData.js":"gB8ey","./core/AxiosError.js":"a4u3f","./helpers/spread.js":"bALTH","./helpers/isAxiosError.js":"80bXL","./core/AxiosHeaders.js":"eiGcK","./helpers/HttpStatusCode.js":"gGhaf","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"2JN6N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var global = arguments[3];
'use strict';
// utils is a library of generic helper functions non-specific to axios
const { toString  } = Object.prototype;
const { getPrototypeOf  } = Object;
const kindOf = ((cache)=>(thing)=>{
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    }
)(Object.create(null));
const kindOfTest = (type)=>{
    type = type.toLowerCase();
    return (thing)=>kindOf(thing) === type
    ;
};
const typeOfTest = (type)=>(thing)=>typeof thing === type
;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */ const { isArray  } = Array;
/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */ const isUndefined = typeOfTest('undefined');
/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ const isArrayBuffer = kindOfTest('ArrayBuffer');
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
    else result = val && val.buffer && isArrayBuffer(val.buffer);
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */ const isString = typeOfTest('string');
/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ const isFunction = typeOfTest('function');
/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */ const isNumber = typeOfTest('number');
/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */ const isObject = (thing)=>thing !== null && typeof thing === 'object'
;
/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */ const isBoolean = (thing)=>thing === true || thing === false
;
/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */ const isPlainObject = (val)=>{
    if (kindOf(val) !== 'object') return false;
    const prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */ const isDate = kindOfTest('Date');
/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFile = kindOfTest('File');
/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */ const isBlob = kindOfTest('Blob');
/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFileList = kindOfTest('FileList');
/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */ const isStream = (val)=>isObject(val) && isFunction(val.pipe)
;
/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */ const isFormData = (thing)=>{
    const pattern = '[object FormData]';
    return thing && (typeof FormData === 'function' && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
};
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ const isURLSearchParams = kindOfTest('URLSearchParams');
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */ const trim = (str)=>str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
;
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */ function forEach(obj, fn, { allOwnKeys =false  } = {
}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') return;
    let i;
    let l;
    // Force an array if not already something iterable
    if (typeof obj !== 'object') /*eslint no-param-reassign:0*/ obj = [
        obj
    ];
    if (isArray(obj)) // Iterate over array values
    for(i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
    else {
        // Iterate over object keys
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for(i = 0; i < len; i++){
            key = keys[i];
            fn.call(null, obj[key], key, obj);
        }
    }
}
function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while((i--) > 0){
        _key = keys[i];
        if (key === _key.toLowerCase()) return _key;
    }
    return null;
}
const _global = (()=>{
    /*eslint no-undef:0*/ if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
})();
const isContextDefined = (context)=>!isUndefined(context) && context !== _global
;
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */ function merge() {
    const { caseless  } = isContextDefined(this) && this || {
    };
    const result = {
    };
    const assignValue = (val, key)=>{
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) result[targetKey] = merge(result[targetKey], val);
        else if (isPlainObject(val)) result[targetKey] = merge({
        }, val);
        else if (isArray(val)) result[targetKey] = val.slice();
        else result[targetKey] = val;
    };
    for(let i = 0, l = arguments.length; i < l; i++)arguments[i] && forEach(arguments[i], assignValue);
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */ const extend = (a, b, thisArg, { allOwnKeys  } = {
})=>{
    forEach(b, (val, key)=>{
        if (thisArg && isFunction(val)) a[key] = _bindJsDefault.default(val, thisArg);
        else a[key] = val;
    }, {
        allOwnKeys
    });
    return a;
};
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */ const stripBOM = (content)=>{
    if (content.charCodeAt(0) === 65279) content = content.slice(1);
    return content;
};
/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */ const inherits = (constructor, superConstructor, props, descriptors)=>{
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, 'super', {
        value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
};
/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */ const toFlatObject = (sourceObj, destObj, filter, propFilter)=>{
    let props;
    let i;
    let prop;
    const merged = {
    };
    destObj = destObj || {
    };
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;
    do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while((i--) > 0){
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
            }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
    }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype)
    return destObj;
};
/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */ const endsWith = (str, searchString, position)=>{
    str = String(str);
    if (position === undefined || position > str.length) position = str.length;
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
};
/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */ const toArray = (thing)=>{
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while((i--) > 0)arr[i] = thing[i];
    return arr;
};
/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */ // eslint-disable-next-line func-names
const isTypedArray = ((TypedArray)=>{
    // eslint-disable-next-line func-names
    return (thing)=>{
        return TypedArray && thing instanceof TypedArray;
    };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));
/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */ const forEachEntry = (obj, fn)=>{
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while((result = iterator.next()) && !result.done){
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
    }
};
/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */ const matchAll = (regExp, str)=>{
    let matches;
    const arr = [];
    while((matches = regExp.exec(str)) !== null)arr.push(matches);
    return arr;
};
/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ const isHTMLForm = kindOfTest('HTMLFormElement');
const toCamelCase = (str)=>{
    return str.toLowerCase().replace(/[_-\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
    });
};
/* Creating a function that will check if an object has a property. */ const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty1  })=>(obj, prop)=>hasOwnProperty1.call(obj, prop)
)(Object.prototype);
/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */ const isRegExp = kindOfTest('RegExp');
const reduceDescriptors = (obj, reducer)=>{
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {
    };
    forEach(descriptors, (descriptor, name)=>{
        if (reducer(descriptor, name, obj) !== false) reducedDescriptors[name] = descriptor;
    });
    Object.defineProperties(obj, reducedDescriptors);
};
/**
 * Makes all methods read-only
 * @param {Object} obj
 */ const freezeMethods = (obj)=>{
    reduceDescriptors(obj, (descriptor, name)=>{
        // skip restricted props in strict mode
        if (isFunction(obj) && [
            'arguments',
            'caller',
            'callee'
        ].indexOf(name) !== -1) return false;
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ('writable' in descriptor) {
            descriptor.writable = false;
            return;
        }
        if (!descriptor.set) descriptor.set = ()=>{
            throw Error('Can not rewrite read-only method \'' + name + '\'');
        };
    });
};
const toObjectSet = (arrayOrString, delimiter)=>{
    const obj = {
    };
    const define = (arr)=>{
        arr.forEach((value)=>{
            obj[value] = true;
        });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
};
const noop = ()=>{
};
const toFiniteNumber = (value, defaultValue)=>{
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
};
const toJSONObject = (obj)=>{
    const stack = new Array(10);
    const visit = (source, i)=>{
        if (isObject(source)) {
            if (stack.indexOf(source) >= 0) return;
            if (!('toJSON' in source)) {
                stack[i] = source;
                const target = isArray(source) ? [] : {
                };
                forEach(source, (value, key)=>{
                    const reducedValue = visit(value, i + 1);
                    !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
            }
        }
        return source;
    };
    return visit(obj, 0);
};
exports.default = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    toJSONObject
};

},{"./helpers/bind.js":"7inTS","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"7inTS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
'use strict';
function bind(fn, thisArg) {
    return function wrap() {
        return fn.apply(thisArg, arguments);
    };
}
exports.default = bind;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"e8U2S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _buildURLJs = require("../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _interceptorManagerJs = require("./InterceptorManager.js");
var _interceptorManagerJsDefault = parcelHelpers.interopDefault(_interceptorManagerJs);
var _dispatchRequestJs = require("./dispatchRequest.js");
var _dispatchRequestJsDefault = parcelHelpers.interopDefault(_dispatchRequestJs);
var _mergeConfigJs = require("./mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _buildFullPathJs = require("./buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _validatorJs = require("../helpers/validator.js");
var _validatorJsDefault = parcelHelpers.interopDefault(_validatorJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
'use strict';
const validators = _validatorJsDefault.default.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */ class Axios {
    constructor(instanceConfig){
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new _interceptorManagerJsDefault.default(),
            response: new _interceptorManagerJsDefault.default()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === 'string') {
            config = config || {
            };
            config.url = configOrUrl;
        } else config = configOrUrl || {
        };
        config = _mergeConfigJsDefault.default(this.defaults, config);
        const { transitional , paramsSerializer , headers  } = config;
        if (transitional !== undefined) _validatorJsDefault.default.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
        if (paramsSerializer !== undefined) _validatorJsDefault.default.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
        }, true);
        // Set config.method
        config.method = (config.method || this.defaults.method || 'get').toLowerCase();
        let contextHeaders;
        // Flatten headers
        contextHeaders = headers && _utilsJsDefault.default.merge(headers.common, headers[config.method]);
        contextHeaders && _utilsJsDefault.default.forEach([
            'delete',
            'get',
            'head',
            'post',
            'put',
            'patch',
            'common'
        ], (method)=>{
            delete headers[method];
        });
        config.headers = _axiosHeadersJsDefault.default.concat(contextHeaders, headers);
        // filter out skipped interceptors
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) return;
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
            const chain = [
                _dispatchRequestJsDefault.default.bind(this),
                undefined
            ];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while(i < len)promise = promise.then(chain[i++], chain[i++]);
            return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while(i < len){
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
                newConfig = onFulfilled(newConfig);
            } catch (error) {
                onRejected.call(this, error);
                break;
            }
        }
        try {
            promise = _dispatchRequestJsDefault.default.call(this, newConfig);
        } catch (error) {
            return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while(i < len)promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        return promise;
    }
    getUri(config) {
        config = _mergeConfigJsDefault.default(this.defaults, config);
        const fullPath = _buildFullPathJsDefault.default(config.baseURL, config.url);
        return _buildURLJsDefault.default(fullPath, config.params, config.paramsSerializer);
    }
}
// Provide aliases for supported request methods
_utilsJsDefault.default.forEach([
    'delete',
    'get',
    'head',
    'options'
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request(_mergeConfigJsDefault.default(config || {
        }, {
            method,
            url,
            data: (config || {
            }).data
        }));
    };
});
_utilsJsDefault.default.forEach([
    'post',
    'put',
    'patch'
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
            return this.request(_mergeConfigJsDefault.default(config || {
            }, {
                method,
                headers: isForm ? {
                    'Content-Type': 'multipart/form-data'
                } : {
                },
                url,
                data
            }));
        };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});
exports.default = Axios;

},{"./../utils.js":"2JN6N","../helpers/buildURL.js":"gl3dL","./InterceptorManager.js":"jlE2z","./dispatchRequest.js":"3QEkU","./mergeConfig.js":"75jxX","./buildFullPath.js":"kIGFE","../helpers/validator.js":"1SQTT","./AxiosHeaders.js":"eiGcK","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"gl3dL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosURLSearchParamsJs = require("../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
'use strict';
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */ function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/ if (!params) return url;
    const _encode = options && options.encode || encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) serializedParams = serializeFn(params, options);
    else serializedParams = _utilsJsDefault.default.isURLSearchParams(params) ? params.toString() : new _axiosURLSearchParamsJsDefault.default(params, options).toString(_encode);
    if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }
    return url;
}
exports.default = buildURL;

},{"../utils.js":"2JN6N","../helpers/AxiosURLSearchParams.js":"1gWgP","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"1gWgP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
'use strict';
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */ function encode(str) {
    const charMap = {
        '!': '%21',
        "'": '%27',
        '(': '%28',
        ')': '%29',
        '~': '%7E',
        '%20': '+',
        '%00': '\x00'
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
    });
}
/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */ function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && _toFormDataJsDefault.default(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
    this._pairs.push([
        name,
        value
    ]);
};
prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + '=' + _encode(pair[1]);
    }, '').join('&');
};
exports.default = AxiosURLSearchParams;

},{"./toFormData.js":"gB8ey","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"gB8ey":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _formDataJs = require("../env/classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var Buffer = require("buffer").Buffer;
'use strict';
/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */ function isVisitable(thing) {
    return _utilsJsDefault.default.isPlainObject(thing) || _utilsJsDefault.default.isArray(thing);
}
/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */ function removeBrackets(key) {
    return _utilsJsDefault.default.endsWith(key, '[]') ? key.slice(0, -2) : key;
}
/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */ function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? '[' + token + ']' : token;
    }).join(dots ? '.' : '');
}
/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */ function isFlatArray(arr) {
    return _utilsJsDefault.default.isArray(arr) && !arr.some(isVisitable);
}
const predicates = _utilsJsDefault.default.toFlatObject(_utilsJsDefault.default, {
}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
});
/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */ function isSpecCompliant(thing) {
    return thing && _utilsJsDefault.default.isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator];
}
/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/ /**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */ function toFormData(obj, formData, options) {
    if (!_utilsJsDefault.default.isObject(obj)) throw new TypeError('target must be an object');
    // eslint-disable-next-line no-param-reassign
    formData = formData || new (_formDataJsDefault.default || FormData)();
    // eslint-disable-next-line no-param-reassign
    options = _utilsJsDefault.default.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
    }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !_utilsJsDefault.default.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
    const useBlob = _Blob && isSpecCompliant(formData);
    if (!_utilsJsDefault.default.isFunction(visitor)) throw new TypeError('visitor must be a function');
    function convertValue(value) {
        if (value === null) return '';
        if (_utilsJsDefault.default.isDate(value)) return value.toISOString();
        if (!useBlob && _utilsJsDefault.default.isBlob(value)) throw new _axiosErrorJsDefault.default('Blob is not supported. Use a Buffer instead.');
        if (_utilsJsDefault.default.isArrayBuffer(value) || _utilsJsDefault.default.isTypedArray(value)) return useBlob && typeof Blob === 'function' ? new Blob([
            value
        ]) : Buffer.from(value);
        return value;
    }
    /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */ function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === 'object') {
            if (_utilsJsDefault.default.endsWith(key, '{}')) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
            } else if (_utilsJsDefault.default.isArray(value) && isFlatArray(value) || _utilsJsDefault.default.isFileList(value) || _utilsJsDefault.default.endsWith(key, '[]') && (arr = _utilsJsDefault.default.toArray(value))) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                    !(_utilsJsDefault.default.isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary
                    indexes === true ? renderKey([
                        key
                    ], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
                });
                return false;
            }
        }
        if (isVisitable(value)) return true;
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
    });
    function build(value, path) {
        if (_utilsJsDefault.default.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) throw Error('Circular reference detected in ' + path.join('.'));
        stack.push(value);
        _utilsJsDefault.default.forEach(value, function each(el, key) {
            const result = !(_utilsJsDefault.default.isUndefined(el) || el === null) && visitor.call(formData, el, _utilsJsDefault.default.isString(key) ? key.trim() : key, path, exposedHelpers);
            if (result === true) build(el, path ? path.concat(key) : [
                key
            ]);
        });
        stack.pop();
    }
    if (!_utilsJsDefault.default.isObject(obj)) throw new TypeError('data must be an object');
    build(obj);
    return formData;
}
exports.default = toFormData;

},{"buffer":"jbNs5","../utils.js":"2JN6N","../core/AxiosError.js":"a4u3f","../env/classes/FormData.js":"ivuvC","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"jbNs5":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
var base64 = require('base64-js');
var ieee754 = require('ieee754');
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 2147483647;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare1(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 2147483647) byteOffset = 2147483647;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 255 // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 127);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while((++i) < byteLength1 && (mul *= 256))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var val = this[offset + --byteLength1];
    var mul = 1;
    while(byteLength1 > 0 && (mul *= 256))val += this[offset + --byteLength1] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while((++i) < byteLength1 && (mul *= 256))val += this[offset + i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength1);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var i = byteLength1;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 256))val += this[offset + --i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength1);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength1) - 1;
        checkInt(this, value, offset, byteLength1, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while((++i) < byteLength1 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength1;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength1) - 1;
        checkInt(this, value, offset, byteLength1, maxBytes, 0);
    }
    var i = byteLength1 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while((--i) >= 0 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength1;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength1 - 1);
        checkInt(this, value, offset, byteLength1, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while((++i) < byteLength1 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength1;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength1 - 1);
        checkInt(this, value, offset, byteLength1, limit - 1, -limit);
    }
    var i = byteLength1 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while((--i) >= 0 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength1;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 55295 && codePoint < 57344) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 56319) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 255);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"base64-js":"bX3uK","ieee754":"98Dcv"}],"bX3uK":[function(require,module,exports) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len1 = b64.length;
    if (len1 % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len1;
    var placeHoldersLen = validLen === len1 ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len1 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i1;
    for(i1 = 0; i1 < len1; i1 += 4){
        tmp = revLookup[b64.charCodeAt(i1)] << 18 | revLookup[b64.charCodeAt(i1 + 1)] << 12 | revLookup[b64.charCodeAt(i1 + 2)] << 6 | revLookup[b64.charCodeAt(i1 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i1)] << 2 | revLookup[b64.charCodeAt(i1 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i1)] << 10 | revLookup[b64.charCodeAt(i1 + 1)] << 4 | revLookup[b64.charCodeAt(i1 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i1 = start; i1 < end; i1 += 3){
        tmp = (uint8[i1] << 16 & 16711680) + (uint8[i1 + 1] << 8 & 65280) + (uint8[i1 + 2] & 255);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len1 = uint8.length;
    var extraBytes = len1 % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i1 = 0, len2 = len1 - extraBytes; i1 < len2; i1 += maxChunkLength)parts.push(encodeChunk(uint8, i1, i1 + maxChunkLength > len2 ? len2 : i1 + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len1 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len1 - 2] << 8) + uint8[len1 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + '=');
    }
    return parts.join('');
}

},{}],"98Dcv":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"a4u3f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
'use strict';
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */ function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    else this.stack = new Error().stack;
    this.message = message;
    this.name = 'AxiosError';
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
}
_utilsJsDefault.default.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: _utilsJsDefault.default.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        };
    }
});
const prototype = AxiosError.prototype;
const descriptors = {
};
[
    'ERR_BAD_OPTION_VALUE',
    'ERR_BAD_OPTION',
    'ECONNABORTED',
    'ETIMEDOUT',
    'ERR_NETWORK',
    'ERR_FR_TOO_MANY_REDIRECTS',
    'ERR_DEPRECATED',
    'ERR_BAD_RESPONSE',
    'ERR_BAD_REQUEST',
    'ERR_CANCELED',
    'ERR_NOT_SUPPORT',
    'ERR_INVALID_URL'
].forEach((code)=>{
    descriptors[code] = {
        value: code
    };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {
    value: true
});
// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps)=>{
    const axiosError = Object.create(prototype);
    _utilsJsDefault.default.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
    }, (prop)=>{
        return prop !== 'isAxiosError';
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
};
exports.default = AxiosError;

},{"../utils.js":"2JN6N","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"ivuvC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _formData = require("form-data");
var _formDataDefault = parcelHelpers.interopDefault(_formData);
exports.default = _formDataDefault.default;

},{"form-data":"bSul9","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"bSul9":[function(require,module,exports) {
/* eslint-env browser */ module.exports = typeof self == 'object' ? self.FormData : window.FormData;

},{}],"jlE2z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
'use strict';
class InterceptorManager {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(fulfilled, rejected, options) {
        this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(id) {
        if (this.handlers[id]) this.handlers[id] = null;
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        if (this.handlers) this.handlers = [];
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(fn) {
        _utilsJsDefault.default.forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) fn(h);
        });
    }
}
exports.default = InterceptorManager;

},{"./../utils.js":"2JN6N","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"3QEkU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _transformDataJs = require("./transformData.js");
var _transformDataJsDefault = parcelHelpers.interopDefault(_transformDataJs);
var _isCancelJs = require("../cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("../adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
'use strict';
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) config.cancelToken.throwIfRequested();
    if (config.signal && config.signal.aborted) throw new _canceledErrorJsDefault.default(null, config);
}
function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = _axiosHeadersJsDefault.default.from(config.headers);
    // Transform request data
    config.data = _transformDataJsDefault.default.call(config, config.transformRequest);
    if ([
        'post',
        'put',
        'patch'
    ].indexOf(config.method) !== -1) config.headers.setContentType('application/x-www-form-urlencoded', false);
    const adapter = _adaptersJsDefault.default.getAdapter(config.adapter || _indexJsDefault.default.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = _transformDataJsDefault.default.call(config, config.transformResponse, response);
        response.headers = _axiosHeadersJsDefault.default.from(response.headers);
        return response;
    }, function onAdapterRejection(reason) {
        if (!_isCancelJsDefault.default(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = _transformDataJsDefault.default.call(config, config.transformResponse, reason.response);
                reason.response.headers = _axiosHeadersJsDefault.default.from(reason.response.headers);
            }
        }
        return Promise.reject(reason);
    });
}
exports.default = dispatchRequest;

},{"./transformData.js":"lLnP8","../cancel/isCancel.js":"7RXGw","../defaults/index.js":"6u83V","../cancel/CanceledError.js":"l0dHi","../core/AxiosHeaders.js":"eiGcK","../adapters/adapters.js":"uHN55","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"lLnP8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
'use strict';
function transformData(fns, response) {
    const config = this || _indexJsDefault.default;
    const context = response || config;
    const headers = _axiosHeadersJsDefault.default.from(context.headers);
    let data = context.data;
    _utilsJsDefault.default.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
}
exports.default = transformData;

},{"./../utils.js":"2JN6N","../defaults/index.js":"6u83V","../core/AxiosHeaders.js":"eiGcK","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"6u83V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _transitionalJs = require("./transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _toFormDataJs = require("../helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _toURLEncodedFormJs = require("../helpers/toURLEncodedForm.js");
var _toURLEncodedFormJsDefault = parcelHelpers.interopDefault(_toURLEncodedFormJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("../helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
'use strict';
const DEFAULT_CONTENT_TYPE = {
    'Content-Type': undefined
};
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */ function stringifySafely(rawValue, parser, encoder) {
    if (_utilsJsDefault.default.isString(rawValue)) try {
        (parser || JSON.parse)(rawValue);
        return _utilsJsDefault.default.trim(rawValue);
    } catch (e) {
        if (e.name !== 'SyntaxError') throw e;
    }
    return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
    transitional: _transitionalJsDefault.default,
    adapter: [
        'xhr',
        'http'
    ],
    transformRequest: [
        function transformRequest(data, headers) {
            const contentType = headers.getContentType() || '';
            const hasJSONContentType = contentType.indexOf('application/json') > -1;
            const isObjectPayload = _utilsJsDefault.default.isObject(data);
            if (isObjectPayload && _utilsJsDefault.default.isHTMLForm(data)) data = new FormData(data);
            const isFormData = _utilsJsDefault.default.isFormData(data);
            if (isFormData) {
                if (!hasJSONContentType) return data;
                return hasJSONContentType ? JSON.stringify(_formDataToJSONJsDefault.default(data)) : data;
            }
            if (_utilsJsDefault.default.isArrayBuffer(data) || _utilsJsDefault.default.isBuffer(data) || _utilsJsDefault.default.isStream(data) || _utilsJsDefault.default.isFile(data) || _utilsJsDefault.default.isBlob(data)) return data;
            if (_utilsJsDefault.default.isArrayBufferView(data)) return data.buffer;
            if (_utilsJsDefault.default.isURLSearchParams(data)) {
                headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
                return data.toString();
            }
            let isFileList;
            if (isObjectPayload) {
                if (contentType.indexOf('application/x-www-form-urlencoded') > -1) return _toURLEncodedFormJsDefault.default(data, this.formSerializer).toString();
                if ((isFileList = _utilsJsDefault.default.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
                    const _FormData = this.env && this.env.FormData;
                    return _toFormDataJsDefault.default(isFileList ? {
                        'files[]': data
                    } : data, _FormData && new _FormData(), this.formSerializer);
                }
            }
            if (isObjectPayload || hasJSONContentType) {
                headers.setContentType('application/json', false);
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            const transitional = this.transitional || defaults.transitional;
            const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            const JSONRequested = this.responseType === 'json';
            if (data && _utilsJsDefault.default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                const silentJSONParsing = transitional && transitional.silentJSONParsing;
                const strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === 'SyntaxError') throw _axiosErrorJsDefault.default.from(e, _axiosErrorJsDefault.default.ERR_BAD_RESPONSE, this, null, this.response);
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: _indexJsDefault.default.classes.FormData,
        Blob: _indexJsDefault.default.classes.Blob
    },
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            'Accept': 'application/json, text/plain, */*'
        }
    }
};
_utilsJsDefault.default.forEach([
    'delete',
    'get',
    'head'
], function forEachMethodNoData(method) {
    defaults.headers[method] = {
    };
});
_utilsJsDefault.default.forEach([
    'post',
    'put',
    'patch'
], function forEachMethodWithData(method) {
    defaults.headers[method] = _utilsJsDefault.default.merge(DEFAULT_CONTENT_TYPE);
});
exports.default = defaults;

},{"../utils.js":"2JN6N","../core/AxiosError.js":"a4u3f","./transitional.js":"bDFGg","../helpers/toFormData.js":"gB8ey","../helpers/toURLEncodedForm.js":"iWBdL","../platform/index.js":"afzv7","../helpers/formDataToJSON.js":"bSqWz","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"bDFGg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
'use strict';
exports.default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"iWBdL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
'use strict';
function toURLEncodedForm(data, options) {
    return _toFormDataJsDefault.default(data, new _indexJsDefault.default.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
            if (_indexJsDefault.default.isNode && _utilsJsDefault.default.isBuffer(value)) {
                this.append(key, value.toString('base64'));
                return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
        }
    }, options));
}
exports.default = toURLEncodedForm;

},{"../utils.js":"2JN6N","./toFormData.js":"gB8ey","../platform/index.js":"afzv7","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"afzv7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_indexJsDefault.default
);
var _indexJs = require("./node/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);

},{"./node/index.js":"qllfV","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"qllfV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _urlsearchParamsJs = require("./classes/URLSearchParams.js");
var _urlsearchParamsJsDefault = parcelHelpers.interopDefault(_urlsearchParamsJs);
var _formDataJs = require("./classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */ const isStandardBrowserEnv = (()=>{
    let product;
    if (typeof navigator !== 'undefined' && ((product = navigator.product) === 'ReactNative' || product === 'NativeScript' || product === 'NS')) return false;
    return typeof window !== 'undefined' && typeof document !== 'undefined';
})();
/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */ const isStandardBrowserWebWorkerEnv = (()=>{
    return typeof WorkerGlobalScope !== 'undefined' && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
})();
exports.default = {
    isBrowser: true,
    classes: {
        URLSearchParams: _urlsearchParamsJsDefault.default,
        FormData: _formDataJsDefault.default,
        Blob
    },
    isStandardBrowserEnv,
    isStandardBrowserWebWorkerEnv,
    protocols: [
        'http',
        'https',
        'file',
        'blob',
        'url',
        'data'
    ]
};

},{"./classes/URLSearchParams.js":"cFJeb","./classes/FormData.js":"4vwcl","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"cFJeb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosURLSearchParamsJs = require("../../../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
'use strict';
exports.default = typeof URLSearchParams !== 'undefined' ? URLSearchParams : _axiosURLSearchParamsJsDefault.default;

},{"../../../helpers/AxiosURLSearchParams.js":"1gWgP","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"4vwcl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
'use strict';
exports.default = FormData;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"bSqWz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
'use strict';
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */ function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return _utilsJsDefault.default.matchAll(/\w+|\[(\w*)]/g, name).map((match)=>{
        return match[0] === '[]' ? '' : match[1] || match[0];
    });
}
/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */ function arrayToObject(arr) {
    const obj = {
    };
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for(i = 0; i < len; i++){
        key = keys[i];
        obj[key] = arr[key];
    }
    return obj;
}
/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */ function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
        let name = path[index++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && _utilsJsDefault.default.isArray(target) ? target.length : name;
        if (isLast) {
            if (_utilsJsDefault.default.hasOwnProp(target, name)) target[name] = [
                target[name],
                value
            ];
            else target[name] = value;
            return !isNumericKey;
        }
        if (!target[name] || !_utilsJsDefault.default.isObject(target[name])) target[name] = [];
        const result = buildPath(path, value, target[name], index);
        if (result && _utilsJsDefault.default.isArray(target[name])) target[name] = arrayToObject(target[name]);
        return !isNumericKey;
    }
    if (_utilsJsDefault.default.isFormData(formData) && _utilsJsDefault.default.isFunction(formData.entries)) {
        const obj = {
        };
        _utilsJsDefault.default.forEachEntry(formData, (name, value)=>{
            buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
    }
    return null;
}
exports.default = formDataToJSON;

},{"../utils.js":"2JN6N","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"eiGcK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _parseHeadersJs = require("../helpers/parseHeaders.js");
var _parseHeadersJsDefault = parcelHelpers.interopDefault(_parseHeadersJs);
'use strict';
const $internals = Symbol('internals');
function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
    if (value === false || value == null) return value;
    return _utilsJsDefault.default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while(match = tokensRE.exec(str))tokens[match[1]] = match[2];
    return tokens;
}
function isValidHeaderName(str) {
    return /^[-_a-zA-Z]+$/.test(str.trim());
}
function matchHeaderValue(context, value, header, filter) {
    if (_utilsJsDefault.default.isFunction(filter)) return filter.call(this, value, header);
    if (!_utilsJsDefault.default.isString(value)) return;
    if (_utilsJsDefault.default.isString(filter)) return value.indexOf(filter) !== -1;
    if (_utilsJsDefault.default.isRegExp(filter)) return filter.test(value);
}
function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str)=>{
        return char.toUpperCase() + str;
    });
}
function buildAccessors(obj, header) {
    const accessorName = _utilsJsDefault.default.toCamelCase(' ' + header);
    [
        'get',
        'set',
        'has'
    ].forEach((methodName)=>{
        Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
        });
    });
}
class AxiosHeaders {
    constructor(headers){
        headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
        const self = this;
        function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) throw new Error('header name must be a non-empty string');
            const key = _utilsJsDefault.default.findKey(self, lHeader);
            if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) self[key || _header] = normalizeValue(_value);
        }
        const setHeaders = (headers1, _rewrite)=>_utilsJsDefault.default.forEach(headers1, (_value, _header)=>setHeader(_value, _header, _rewrite)
            )
        ;
        if (_utilsJsDefault.default.isPlainObject(header) || header instanceof this.constructor) setHeaders(header, valueOrRewrite);
        else if (_utilsJsDefault.default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) setHeaders(_parseHeadersJsDefault.default(header), valueOrRewrite);
        else header != null && setHeader(valueOrRewrite, header, rewrite);
        return this;
    }
    get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
            const key = _utilsJsDefault.default.findKey(this, header);
            if (key) {
                const value = this[key];
                if (!parser) return value;
                if (parser === true) return parseTokens(value);
                if (_utilsJsDefault.default.isFunction(parser)) return parser.call(this, value, key);
                if (_utilsJsDefault.default.isRegExp(parser)) return parser.exec(value);
                throw new TypeError('parser must be boolean|regexp|function');
            }
        }
    }
    has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
            const key = _utilsJsDefault.default.findKey(this, header);
            return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
    }
    delete(header, matcher) {
        const self = this;
        let deleted = false;
        function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
                const key = _utilsJsDefault.default.findKey(self, _header);
                if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
                    delete self[key];
                    deleted = true;
                }
            }
        }
        if (_utilsJsDefault.default.isArray(header)) header.forEach(deleteHeader);
        else deleteHeader(header);
        return deleted;
    }
    clear() {
        return Object.keys(this).forEach(this.delete.bind(this));
    }
    normalize(format) {
        const self = this;
        const headers1 = {
        };
        _utilsJsDefault.default.forEach(this, (value, header)=>{
            const key = _utilsJsDefault.default.findKey(headers1, header);
            if (key) {
                self[key] = normalizeValue(value);
                delete self[header];
                return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) delete self[header];
            self[normalized] = normalizeValue(value);
            headers1[normalized] = true;
        });
        return this;
    }
    concat(...targets) {
        return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
        const obj = Object.create(null);
        _utilsJsDefault.default.forEach(this, (value, header)=>{
            value != null && value !== false && (obj[header] = asStrings && _utilsJsDefault.default.isArray(value) ? value.join(', ') : value);
        });
        return obj;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([header, value])=>header + ': ' + value
        ).join('\n');
    }
    get [Symbol.toStringTag]() {
        return 'AxiosHeaders';
    }
    static from(thing) {
        return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target)=>computed.set(target)
        );
        return computed;
    }
    static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
            accessors: {
            }
        };
        const accessors = internals.accessors;
        const prototype = this.prototype;
        function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
                buildAccessors(prototype, _header);
                accessors[lHeader] = true;
            }
        }
        _utilsJsDefault.default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
    }
}
AxiosHeaders.accessor([
    'Content-Type',
    'Content-Length',
    'Accept',
    'Accept-Encoding',
    'User-Agent',
    'Authorization'
]);
_utilsJsDefault.default.freezeMethods(AxiosHeaders.prototype);
_utilsJsDefault.default.freezeMethods(AxiosHeaders);
exports.default = AxiosHeaders;

},{"../utils.js":"2JN6N","../helpers/parseHeaders.js":"FdcfW","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"FdcfW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
'use strict';
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = _utilsJsDefault.default.toObjectSet([
    'age',
    'authorization',
    'content-length',
    'content-type',
    'etag',
    'expires',
    'from',
    'host',
    'if-modified-since',
    'if-unmodified-since',
    'last-modified',
    'location',
    'max-forwards',
    'proxy-authorization',
    'referer',
    'retry-after',
    'user-agent'
]);
exports.default = (rawHeaders)=>{
    const parsed = {
    };
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
        i = line.indexOf(':');
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) return;
        if (key === 'set-cookie') {
            if (parsed[key]) parsed[key].push(val);
            else parsed[key] = [
                val
            ];
        } else parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    });
    return parsed;
};

},{"./../utils.js":"2JN6N","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"7RXGw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
'use strict';
function isCancel(value) {
    return !!(value && value.__CANCEL__);
}
exports.default = isCancel;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"l0dHi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
'use strict';
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */ function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    _axiosErrorJsDefault.default.call(this, message == null ? 'canceled' : message, _axiosErrorJsDefault.default.ERR_CANCELED, config, request);
    this.name = 'CanceledError';
}
_utilsJsDefault.default.inherits(CanceledError, _axiosErrorJsDefault.default, {
    __CANCEL__: true
});
exports.default = CanceledError;

},{"../core/AxiosError.js":"a4u3f","../utils.js":"2JN6N","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"uHN55":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _httpJs = require("./http.js");
var _httpJsDefault = parcelHelpers.interopDefault(_httpJs);
var _xhrJs = require("./xhr.js");
var _xhrJsDefault = parcelHelpers.interopDefault(_xhrJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
const knownAdapters = {
    http: _httpJsDefault.default,
    xhr: _xhrJsDefault.default
};
_utilsJsDefault.default.forEach(knownAdapters, (fn, value)=>{
    if (fn) {
        try {
            Object.defineProperty(fn, 'name', {
                value
            });
        } catch (e) {
        // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, 'adapterName', {
            value
        });
    }
});
exports.default = {
    getAdapter: (adapters)=>{
        adapters = _utilsJsDefault.default.isArray(adapters) ? adapters : [
            adapters
        ];
        const { length  } = adapters;
        let nameOrAdapter;
        let adapter;
        for(let i = 0; i < length; i++){
            nameOrAdapter = adapters[i];
            if (adapter = _utilsJsDefault.default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) break;
        }
        if (!adapter) {
            if (adapter === false) throw new _axiosErrorJsDefault.default(`Adapter ${nameOrAdapter} is not supported by the environment`, 'ERR_NOT_SUPPORT');
            throw new Error(_utilsJsDefault.default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`);
        }
        if (!_utilsJsDefault.default.isFunction(adapter)) throw new TypeError('adapter is not a function');
        return adapter;
    },
    adapters: knownAdapters
};

},{"../utils.js":"2JN6N","./http.js":"dMI8G","./xhr.js":"1boub","../core/AxiosError.js":"a4u3f","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"dMI8G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"1boub":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _settleJs = require("./../core/settle.js");
var _settleJsDefault = parcelHelpers.interopDefault(_settleJs);
var _cookiesJs = require("./../helpers/cookies.js");
var _cookiesJsDefault = parcelHelpers.interopDefault(_cookiesJs);
var _buildURLJs = require("./../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _buildFullPathJs = require("../core/buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _isURLSameOriginJs = require("./../helpers/isURLSameOrigin.js");
var _isURLSameOriginJsDefault = parcelHelpers.interopDefault(_isURLSameOriginJs);
var _transitionalJs = require("../defaults/transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _parseProtocolJs = require("../helpers/parseProtocol.js");
var _parseProtocolJsDefault = parcelHelpers.interopDefault(_parseProtocolJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _speedometerJs = require("../helpers/speedometer.js");
var _speedometerJsDefault = parcelHelpers.interopDefault(_speedometerJs);
'use strict';
function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = _speedometerJsDefault.default(50, 250);
    return (e)=>{
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : undefined;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
            loaded,
            total,
            progress: total ? loaded / total : undefined,
            bytes: progressBytes,
            rate: rate ? rate : undefined,
            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
            event: e
        };
        data[isDownloadStream ? 'download' : 'upload'] = true;
        listener(data);
    };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
exports.default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = _axiosHeadersJsDefault.default.from(config.headers).normalize();
        const responseType = config.responseType;
        let onCanceled;
        function done() {
            if (config.cancelToken) config.cancelToken.unsubscribe(onCanceled);
            if (config.signal) config.signal.removeEventListener('abort', onCanceled);
        }
        if (_utilsJsDefault.default.isFormData(requestData) && (_indexJsDefault.default.isStandardBrowserEnv || _indexJsDefault.default.isStandardBrowserWebWorkerEnv)) requestHeaders.setContentType(false); // Let the browser set it
        let request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            const username = config.auth.username || '';
            const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
            requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
        }
        const fullPath = _buildFullPathJsDefault.default(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), _buildURLJsDefault.default(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        function onloadend() {
            if (!request) return;
            // Prepare the response
            const responseHeaders = _axiosHeadersJsDefault.default.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
            const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
            const response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config,
                request
            };
            _settleJsDefault.default(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ('onloadend' in request) // Use onloadend if available
        request.onloadend = onloadend;
        else // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) return;
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) return;
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
        };
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) return;
            reject(new _axiosErrorJsDefault.default('Request aborted', _axiosErrorJsDefault.default.ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(new _axiosErrorJsDefault.default('Network Error', _axiosErrorJsDefault.default.ERR_NETWORK, config, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
            const transitional = config.transitional || _transitionalJsDefault.default;
            if (config.timeoutErrorMessage) timeoutErrorMessage = config.timeoutErrorMessage;
            reject(new _axiosErrorJsDefault.default(timeoutErrorMessage, transitional.clarifyTimeoutError ? _axiosErrorJsDefault.default.ETIMEDOUT : _axiosErrorJsDefault.default.ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (_indexJsDefault.default.isStandardBrowserEnv) {
            // Add xsrf header
            const xsrfValue = (config.withCredentials || _isURLSameOriginJsDefault.default(fullPath)) && config.xsrfCookieName && _cookiesJsDefault.default.read(config.xsrfCookieName);
            if (xsrfValue) requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);
        // Add headers to the request
        if ('setRequestHeader' in request) _utilsJsDefault.default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
        });
        // Add withCredentials to request if needed
        if (!_utilsJsDefault.default.isUndefined(config.withCredentials)) request.withCredentials = !!config.withCredentials;
        // Add responseType to request if needed
        if (responseType && responseType !== 'json') request.responseType = config.responseType;
        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
        if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = (cancel)=>{
                if (!request) return;
                reject(!cancel || cancel.type ? new _canceledErrorJsDefault.default(null, config, request) : cancel);
                request.abort();
                request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
        }
        const protocol = _parseProtocolJsDefault.default(fullPath);
        if (protocol && _indexJsDefault.default.protocols.indexOf(protocol) === -1) {
            reject(new _axiosErrorJsDefault.default('Unsupported protocol ' + protocol + ':', _axiosErrorJsDefault.default.ERR_BAD_REQUEST, config));
            return;
        }
        // Send the request
        request.send(requestData || null);
    });
};

},{"./../utils.js":"2JN6N","./../core/settle.js":"fAu8d","./../helpers/cookies.js":"7S7bg","./../helpers/buildURL.js":"gl3dL","../core/buildFullPath.js":"kIGFE","./../helpers/isURLSameOrigin.js":"0iwYo","../defaults/transitional.js":"bDFGg","../core/AxiosError.js":"a4u3f","../cancel/CanceledError.js":"l0dHi","../helpers/parseProtocol.js":"bqlJP","../platform/index.js":"afzv7","../core/AxiosHeaders.js":"eiGcK","../helpers/speedometer.js":"cFUxm","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"fAu8d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosErrorJs = require("./AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
'use strict';
function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
    else reject(new _axiosErrorJsDefault.default('Request failed with status code ' + response.status, [
        _axiosErrorJsDefault.default.ERR_BAD_REQUEST,
        _axiosErrorJsDefault.default.ERR_BAD_RESPONSE
    ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
}
exports.default = settle;

},{"./AxiosError.js":"a4u3f","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"7S7bg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
'use strict';
exports.default = _indexJsDefault.default.isStandardBrowserEnv ? // Standard browser envs support document.cookie
(function standardBrowserEnv() {
    return {
        write: function write(name, value, expires, path, domain, secure) {
            const cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));
            if (_utilsJsDefault.default.isNumber(expires)) cookie.push('expires=' + new Date(expires).toGMTString());
            if (_utilsJsDefault.default.isString(path)) cookie.push('path=' + path);
            if (_utilsJsDefault.default.isString(domain)) cookie.push('domain=' + domain);
            if (secure === true) cookie.push('secure');
            document.cookie = cookie.join('; ');
        },
        read: function read(name) {
            const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
        }
    };
})() : // Non standard browser env (web workers, react-native) lack needed support.
(function nonStandardBrowserEnv() {
    return {
        write: function write() {
        },
        read: function read() {
            return null;
        },
        remove: function remove() {
        }
    };
})();

},{"./../utils.js":"2JN6N","../platform/index.js":"afzv7","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"kIGFE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isAbsoluteURLJs = require("../helpers/isAbsoluteURL.js");
var _isAbsoluteURLJsDefault = parcelHelpers.interopDefault(_isAbsoluteURLJs);
var _combineURLsJs = require("../helpers/combineURLs.js");
var _combineURLsJsDefault = parcelHelpers.interopDefault(_combineURLsJs);
'use strict';
function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !_isAbsoluteURLJsDefault.default(requestedURL)) return _combineURLsJsDefault.default(baseURL, requestedURL);
    return requestedURL;
}
exports.default = buildFullPath;

},{"../helpers/isAbsoluteURL.js":"4mjEY","../helpers/combineURLs.js":"eb6lJ","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"4mjEY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
'use strict';
function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
exports.default = isAbsoluteURL;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"eb6lJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
'use strict';
function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
}
exports.default = combineURLs;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"0iwYo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
'use strict';
exports.default = _indexJsDefault.default.isStandardBrowserEnv ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
(function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        let href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        const parsed = _utilsJsDefault.default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
})() : // Non standard browser envs (web workers, react-native) lack needed support.
(function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
})();

},{"./../utils.js":"2JN6N","../platform/index.js":"afzv7","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"bqlJP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
'use strict';
function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || '';
}
exports.default = parseProtocol;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"cFUxm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
'use strict';
/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */ function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) firstSampleTS = now;
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while(i !== head){
            bytesCount += bytes[i++];
            i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) tail = (tail + 1) % samplesCount;
        if (now - firstSampleTS < min) return;
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
}
exports.default = speedometer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"75jxX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
'use strict';
const headersToObject = (thing)=>thing instanceof _axiosHeadersJsDefault.default ? thing.toJSON() : thing
;
function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {
    };
    const config = {
    };
    function getMergedValue(target, source, caseless) {
        if (_utilsJsDefault.default.isPlainObject(target) && _utilsJsDefault.default.isPlainObject(source)) return _utilsJsDefault.default.merge.call({
            caseless
        }, target, source);
        else if (_utilsJsDefault.default.isPlainObject(source)) return _utilsJsDefault.default.merge({
        }, source);
        else if (_utilsJsDefault.default.isArray(source)) return source.slice();
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
        if (!_utilsJsDefault.default.isUndefined(b)) return getMergedValue(a, b, caseless);
        else if (!_utilsJsDefault.default.isUndefined(a)) return getMergedValue(undefined, a, caseless);
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
        if (!_utilsJsDefault.default.isUndefined(b)) return getMergedValue(undefined, b);
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
        if (!_utilsJsDefault.default.isUndefined(b)) return getMergedValue(undefined, b);
        else if (!_utilsJsDefault.default.isUndefined(a)) return getMergedValue(undefined, a);
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
        if (prop in config2) return getMergedValue(a, b);
        else if (prop in config1) return getMergedValue(undefined, a);
    }
    const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b)=>mergeDeepProperties(headersToObject(a), headersToObject(b), true)
    };
    _utilsJsDefault.default.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        _utilsJsDefault.default.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
}
exports.default = mergeConfig;

},{"../utils.js":"2JN6N","./AxiosHeaders.js":"eiGcK","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"1SQTT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataJs = require("../env/data.js");
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
'use strict';
const validators = {
};
// eslint-disable-next-line func-names
[
    'object',
    'boolean',
    'number',
    'function',
    'string',
    'symbol'
].forEach((type, i)=>{
    validators[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
    };
});
const deprecatedWarnings = {
};
/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return '[Axios v' + _dataJs.VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
    }
    // eslint-disable-next-line func-names
    return (value, opt, opts)=>{
        if (validator === false) throw new _axiosErrorJsDefault.default(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), _axiosErrorJsDefault.default.ERR_DEPRECATED);
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== 'object') throw new _axiosErrorJsDefault.default('options must be an object', _axiosErrorJsDefault.default.ERR_BAD_OPTION_VALUE);
    const keys = Object.keys(options);
    let i = keys.length;
    while((i--) > 0){
        const opt = keys[i];
        const validator = schema[opt];
        if (validator) {
            const value = options[opt];
            const result = value === undefined || validator(value, opt, options);
            if (result !== true) throw new _axiosErrorJsDefault.default('option ' + opt + ' must be ' + result, _axiosErrorJsDefault.default.ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (allowUnknown !== true) throw new _axiosErrorJsDefault.default('Unknown option ' + opt, _axiosErrorJsDefault.default.ERR_BAD_OPTION);
    }
}
exports.default = {
    assertOptions,
    validators
};

},{"../env/data.js":"lSeIg","../core/AxiosError.js":"a4u3f","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"lSeIg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION
);
const VERSION = "1.2.6";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"931qi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _canceledErrorJs = require("./CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
'use strict';
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */ class CancelToken {
    constructor(executor){
        if (typeof executor !== 'function') throw new TypeError('executor must be a function.');
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        const token = this;
        // eslint-disable-next-line func-names
        this.promise.then((cancel)=>{
            if (!token._listeners) return;
            let i = token._listeners.length;
            while((i--) > 0)token._listeners[i](cancel);
            token._listeners = null;
        });
        // eslint-disable-next-line func-names
        this.promise.then = (onfulfilled)=>{
            let _resolve;
            // eslint-disable-next-line func-names
            const promise = new Promise((resolve)=>{
                token.subscribe(resolve);
                _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
                token.unsubscribe(_resolve);
            };
            return promise;
        };
        executor(function cancel(message, config, request) {
            if (token.reason) // Cancellation has already been requested
            return;
            token.reason = new _canceledErrorJsDefault.default(message, config, request);
            resolvePromise(token.reason);
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) throw this.reason;
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(listener) {
        if (this.reason) {
            listener(this.reason);
            return;
        }
        if (this._listeners) this._listeners.push(listener);
        else this._listeners = [
            listener
        ];
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(listener) {
        if (!this._listeners) return;
        const index = this._listeners.indexOf(listener);
        if (index !== -1) this._listeners.splice(index, 1);
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let cancel1;
        const token1 = new CancelToken(function executor1(c) {
            cancel1 = c;
        });
        return {
            token: token1,
            cancel: cancel1
        };
    }
}
exports.default = CancelToken;

},{"./CanceledError.js":"l0dHi","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"bALTH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
'use strict';
function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
}
exports.default = spread;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"80bXL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
'use strict';
function isAxiosError(payload) {
    return _utilsJsDefault.default.isObject(payload) && payload.isAxiosError === true;
}
exports.default = isAxiosError;

},{"./../utils.js":"2JN6N","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"gGhaf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value])=>{
    HttpStatusCode[value] = key;
});
exports.default = HttpStatusCode;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"2sWFm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "displayMap", ()=>displayMap
);
/* eslint-disable */ var _mapboxGlCss = require("mapbox-gl/dist/mapbox-gl.css");
var _mapboxGl = require("mapbox-gl");
var _mapboxGlDefault = parcelHelpers.interopDefault(_mapboxGl);
const displayMap = (locations)=>{
    _mapboxGlDefault.default.accessToken = "pk.eyJ1IjoibWF0aGV3Y29kZXgiLCJhIjoiY2xieWZ6aDRuMWd1NjNvbnl2emZ0ZHEzOCJ9.JQB5KDl_SUax9YUmQITT0Q";
    var map = new _mapboxGlDefault.default.Map({
        container: "map",
        style: "mapbox://styles/mathewcodex/clc4q8w7i001i14quluef0nme",
        scrollZoom: false
    });
    //creating a bount variable
    const bounds = new _mapboxGlDefault.default.LngLatBounds();
    locations.forEach((loc)=>{
        //create Marker
        const el = document.createElement("div");
        el.className = "marker";
        //add Marker
        new _mapboxGlDefault.default.Marker({
            element: el,
            anchor: "bottom"
        }).setLngLat(loc.coordinates).addTo(map);
        //addd popup
        new _mapboxGlDefault.default.Popup({
            offset: 30
        }).setLngLat(loc.coordinates).setHTML(`<p>Day ${loc.day}: ${loc.description}</p>`).addTo(map);
        //extending boundary  to includes the current location
        bounds.extend(loc.coordinates);
    });
    //making the maP fit bounds
    map.fitBounds(bounds, {
        padding: {
            top: 200,
            bottom: 150,
            left: 100,
            right: 100
        }
    });
};

},{"mapbox-gl/dist/mapbox-gl.css":"g3NPc","mapbox-gl":"iKlXa","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}],"g3NPc":[function() {},{}],"iKlXa":[function(require,module,exports) {
/* Mapbox GL JS is Copyright © 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */ (function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.mapboxgl = factory());
})(this, function() {
    'use strict';
    /* eslint-disable */ var shared, worker, mapboxgl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
        if (!shared) shared = chunk;
        else if (!worker) worker = chunk;
        else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {
            };
            shared(sharedChunk);
            mapboxgl = chunk(sharedChunk);
            if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([
                workerBundleString
            ], {
                type: 'text/javascript'
            }));
        }
    }
    define([
        "exports"
    ], function(t3) {
        var e2 = "undefined" != typeof self ? self : {
        }, r2 = "2.12.0";
        let n1;
        const i3 = {
            API_URL: "https://api.mapbox.com",
            get API_URL_REGEX () {
                if (null == n1) {
                    const t1 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                    try {
                        n1 = t1;
                    } catch (e1) {
                        n1 = t1;
                    }
                }
                return n1;
            },
            get API_TILEJSON_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
            },
            get API_SPRITE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
            },
            get API_FONTS_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
            },
            get API_STYLE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
            },
            get API_CDN_URL_REGEX () {
                return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
            },
            get EVENTS_URL () {
                return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;
            },
            SESSION_PATH: "/map-sessions/v1",
            FEEDBACK_URL: "https://apps.mapbox.com/feedback",
            TILE_URL_VERSION: "v4",
            RASTER_URL_PREFIX: "raster/v1",
            REQUIRE_ACCESS_TOKEN: !0,
            ACCESS_TOKEN: null,
            MAX_PARALLEL_IMAGE_REQUESTS: 16
        }, s3 = {
            supported: !1,
            testSupport: function(t1) {
                !l1 && o2 && (u3 ? c1(t1) : a2 = t1);
            }
        };
        let a2, o2, l1 = !1, u3 = !1;
        function c1(t1) {
            const e1 = t1.createTexture();
            t1.bindTexture(t1.TEXTURE_2D, e1);
            try {
                if (t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, o2), t1.isContextLost()) return;
                s3.supported = !0;
            } catch (t2) {
            }
            t1.deleteTexture(e1), l1 = !0;
        }
        e2.document && (o2 = e2.document.createElement("img"), o2.onload = function() {
            a2 && c1(a2), a2 = null, u3 = !0;
        }, o2.onerror = function() {
            l1 = !0, a2 = null;
        }, o2.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const h2 = "01";
        var p2 = f2;
        function f2(t1, e1, r1, n1) {
            this.cx = 3 * t1, this.bx = 3 * (r1 - t1) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e1, this.by = 3 * (n1 - e1) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t1, this.p1y = e1, this.p2x = r1, this.p2y = n1;
        }
        f2.prototype = {
            sampleCurveX: function(t1) {
                return ((this.ax * t1 + this.bx) * t1 + this.cx) * t1;
            },
            sampleCurveY: function(t1) {
                return ((this.ay * t1 + this.by) * t1 + this.cy) * t1;
            },
            sampleCurveDerivativeX: function(t1) {
                return (3 * this.ax * t1 + 2 * this.bx) * t1 + this.cx;
            },
            solveCurveX: function(t1, e1) {
                if ((void 0) === e1 && (e1 = 0.000001), t1 < 0) return 0;
                if (t1 > 1) return 1;
                for(var r1 = t1, n1 = 0; n1 < 8; n1++){
                    var i1 = this.sampleCurveX(r1) - t1;
                    if (Math.abs(i1) < e1) return r1;
                    var s1 = this.sampleCurveDerivativeX(r1);
                    if (Math.abs(s1) < 0.000001) break;
                    r1 -= i1 / s1;
                }
                var a1 = 0, o1 = 1;
                for(r1 = t1, n1 = 0; n1 < 20 && (i1 = this.sampleCurveX(r1), !(Math.abs(i1 - t1) < e1)); n1++)t1 > i1 ? a1 = r1 : o1 = r1, r1 = 0.5 * (o1 - a1) + a1;
                return r1;
            },
            solve: function(t1, e1) {
                return this.sampleCurveY(this.solveCurveX(t1, e1));
            }
        };
        var d2 = y1;
        function y1(t1, e1) {
            this.x = t1, this.y = e1;
        }
        y1.prototype = {
            clone: function() {
                return new y1(this.x, this.y);
            },
            add: function(t1) {
                return this.clone()._add(t1);
            },
            sub: function(t1) {
                return this.clone()._sub(t1);
            },
            multByPoint: function(t1) {
                return this.clone()._multByPoint(t1);
            },
            divByPoint: function(t1) {
                return this.clone()._divByPoint(t1);
            },
            mult: function(t1) {
                return this.clone()._mult(t1);
            },
            div: function(t1) {
                return this.clone()._div(t1);
            },
            rotate: function(t1) {
                return this.clone()._rotate(t1);
            },
            rotateAround: function(t1, e1) {
                return this.clone()._rotateAround(t1, e1);
            },
            matMult: function(t1) {
                return this.clone()._matMult(t1);
            },
            unit: function() {
                return this.clone()._unit();
            },
            perp: function() {
                return this.clone()._perp();
            },
            round: function() {
                return this.clone()._round();
            },
            mag: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            equals: function(t1) {
                return this.x === t1.x && this.y === t1.y;
            },
            dist: function(t1) {
                return Math.sqrt(this.distSqr(t1));
            },
            distSqr: function(t1) {
                var e1 = t1.x - this.x, r1 = t1.y - this.y;
                return e1 * e1 + r1 * r1;
            },
            angle: function() {
                return Math.atan2(this.y, this.x);
            },
            angleTo: function(t1) {
                return Math.atan2(this.y - t1.y, this.x - t1.x);
            },
            angleWith: function(t1) {
                return this.angleWithSep(t1.x, t1.y);
            },
            angleWithSep: function(t1, e1) {
                return Math.atan2(this.x * e1 - this.y * t1, this.x * t1 + this.y * e1);
            },
            _matMult: function(t1) {
                var e1 = t1[2] * this.x + t1[3] * this.y;
                return this.x = t1[0] * this.x + t1[1] * this.y, this.y = e1, this;
            },
            _add: function(t1) {
                return this.x += t1.x, this.y += t1.y, this;
            },
            _sub: function(t1) {
                return this.x -= t1.x, this.y -= t1.y, this;
            },
            _mult: function(t1) {
                return this.x *= t1, this.y *= t1, this;
            },
            _div: function(t1) {
                return this.x /= t1, this.y /= t1, this;
            },
            _multByPoint: function(t1) {
                return this.x *= t1.x, this.y *= t1.y, this;
            },
            _divByPoint: function(t1) {
                return this.x /= t1.x, this.y /= t1.y, this;
            },
            _unit: function() {
                return this._div(this.mag()), this;
            },
            _perp: function() {
                var t1 = this.y;
                return this.y = this.x, this.x = -t1, this;
            },
            _rotate: function(t1) {
                var e1 = Math.cos(t1), r1 = Math.sin(t1), n1 = r1 * this.x + e1 * this.y;
                return this.x = e1 * this.x - r1 * this.y, this.y = n1, this;
            },
            _rotateAround: function(t1, e1) {
                var r1 = Math.cos(t1), n1 = Math.sin(t1), i2 = e1.y + n1 * (this.x - e1.x) + r1 * (this.y - e1.y);
                return this.x = e1.x + r1 * (this.x - e1.x) - n1 * (this.y - e1.y), this.y = i2, this;
            },
            _round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            }
        }, y1.convert = function(t1) {
            return t1 instanceof y1 ? t1 : Array.isArray(t1) ? new y1(t1[0], t1[1]) : t1;
        };
        const m1 = Math.PI / 180, g1 = 180 / Math.PI;
        function x1(t1) {
            return t1 * m1;
        }
        function v1(t1) {
            return t1 * g1;
        }
        const b1 = [
            [
                0,
                0
            ],
            [
                1,
                0
            ],
            [
                1,
                1
            ],
            [
                0,
                1
            ]
        ];
        function w1(t1) {
            if (t1 <= 0) return 0;
            if (t1 >= 1) return 1;
            const e1 = t1 * t1, r1 = e1 * t1;
            return 4 * (t1 < 0.5 ? r1 : 3 * (t1 - e1) + r1 - 0.75);
        }
        function _1(t1, e1, r1, n1) {
            const i2 = new p2(t1, e1, r1, n1);
            return function(t2) {
                return i2.solve(t2);
            };
        }
        const A1 = _1(0.25, 0.1, 0.25, 1);
        function S1(t1, e1, r1) {
            return Math.min(r1, Math.max(e1, t1));
        }
        function k1(t1, e1, r1) {
            return (r1 = S1((r1 - t1) / (e1 - t1), 0, 1)) * r1 * (3 - 2 * r1);
        }
        function I1(t1, e1, r1) {
            const n1 = r1 - e1, i2 = ((t1 - e1) % n1 + n1) % n1 + e1;
            return i2 === e1 ? r1 : i2;
        }
        function M1(t1, e1, r1) {
            if (!t1.length) return r1(null, []);
            let n1 = t1.length;
            const i2 = new Array(t1.length);
            let s2 = null;
            t1.forEach((t2, a1)=>{
                e1(t2, (t3, e2)=>{
                    t3 && (s2 = t3), i2[a1] = e2, 0 == --n1 && r1(s2, i2);
                });
            });
        }
        function T1(t1) {
            const e1 = [];
            for(const r1 in t1)e1.push(t1[r1]);
            return e1;
        }
        function z1(t1, ...e1) {
            for (const r1 of e1)for(const e2 in r1)t1[e2] = r1[e2];
            return t1;
        }
        let B1 = 1;
        function E() {
            return B1++;
        }
        function C() {
            return (function t1(e1) {
                return e1 ? (e1 ^ Math.random() * (16 >> e1 / 4)).toString(16) : ([
                    10000000
                ] + -[
                    1000
                ] + -4000 + -8000 + -100000000000).replace(/[018]/g, t1);
            })();
        }
        function P(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t1) / Math.LN2));
        }
        function D(t1) {
            return !!t1 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t1);
        }
        function V(t1, e1) {
            t1.forEach((t2)=>{
                e1[t2] && (e1[t2] = e1[t2].bind(e1));
            });
        }
        function L(t1, e1) {
            return -1 !== t1.indexOf(e1, t1.length - e1.length);
        }
        function F(t1, e1, r1) {
            const n1 = {
            };
            for(const i2 in t1)n1[i2] = e1.call(r1 || this, t1[i2], i2, t1);
            return n1;
        }
        function R(t1, e1, r1) {
            const n1 = {
            };
            for(const i2 in t1)e1.call(r1 || this, t1[i2], i2, t1) && (n1[i2] = t1[i2]);
            return n1;
        }
        function j(t1) {
            return Array.isArray(t1) ? t1.map(j) : "object" == typeof t1 && t1 ? F(t1, j) : t1;
        }
        const U = {
        };
        function $(t1) {
            U[t1] || ("undefined" != typeof console && console.warn(t1), U[t1] = !0);
        }
        function O(t1, e1, r1) {
            return (r1.y - t1.y) * (e1.x - t1.x) > (e1.y - t1.y) * (r1.x - t1.x);
        }
        function q(t1) {
            let e1 = 0;
            for(let r1, n1, i2 = 0, s2 = t1.length, a1 = s2 - 1; i2 < s2; a1 = i2++)r1 = t1[i2], n1 = t1[a1], e1 += (n1.x - r1.x) * (r1.y + n1.y);
            return e1;
        }
        function N() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function G(t1) {
            const e1 = {
            };
            if (t1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t2, r1, n1, i2)=>{
                const s2 = n1 || i2;
                return e1[r1] = !s2 || s2.toLowerCase(), "";
            }), e1["max-age"]) {
                const t2 = parseInt(e1["max-age"], 10);
                isNaN(t2) ? delete e1["max-age"] : e1["max-age"] = t2;
            }
            return e1;
        }
        let X = null;
        function Z(t1) {
            if (null == X) {
                const e1 = t1.navigator ? t1.navigator.userAgent : null;
                X = !!t1.safari || !(!e1 || !(/\b(iPad|iPhone|iPod)\b/.test(e1) || e1.match("Safari") && !e1.match("Chrome")));
            }
            return X;
        }
        function K(t1) {
            try {
                const r1 = e2[t1];
                return r1.setItem("_mapbox_test_", 1), r1.removeItem("_mapbox_test_"), !0;
            } catch (t2) {
                return !1;
            }
        }
        function Y(t1, e1) {
            return [
                t1[4 * e1],
                t1[4 * e1 + 1],
                t1[4 * e1 + 2],
                t1[4 * e1 + 3]
            ];
        }
        const H = "mapbox-tiles";
        let W, J, Q = 500, tt = 50;
        function et() {
            try {
                return e2.caches;
            } catch (t1) {
            }
        }
        function rt() {
            et() && !W && (W = e2.caches.open(H));
        }
        function nt(t1) {
            const e1 = t1.indexOf("?");
            if (e1 < 0) return t1;
            const r1 = function(t2) {
                const e2 = t2.indexOf("?");
                return e2 > 0 ? t2.slice(e2 + 1).split("&") : [];
            }(t1), n1 = r1.filter((t2)=>{
                const e2 = t2.split("=");
                return "language" === e2[0] || "worldview" === e2[0];
            });
            return n1.length ? `${t1.slice(0, e1)}?${n1.join("&")}` : t1.slice(0, e1);
        }
        let it = 1 / 0;
        const st = {
            Unknown: "Unknown",
            Style: "Style",
            Source: "Source",
            Tile: "Tile",
            Glyphs: "Glyphs",
            SpriteImage: "SpriteImage",
            SpriteJSON: "SpriteJSON",
            Image: "Image"
        };
        "function" == typeof Object.freeze && Object.freeze(st);
        class at extends Error {
            constructor(t1, e1, r1){
                401 === e1 && gt(r1) && (t1 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t1), this.status = e1, this.url = r1;
            }
            toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
        }
        const ot = N() ? ()=>self.worker && self.worker.referrer
         : ()=>("blob:" === e2.location.protocol ? e2.parent : e2).location.href
        ;
        const lt = function(t2, r2) {
            if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(ot()) && !/^\w+:/.test(n2))) {
                if (e2.fetch && e2.Request && e2.AbortController && e2.Request.prototype.hasOwnProperty("signal")) return (function(t3, r3) {
                    const n2 = new e2.AbortController, i2 = new e2.Request(t3.url, {
                        method: t3.method || "GET",
                        body: t3.body,
                        credentials: t3.credentials,
                        headers: t3.headers,
                        referrer: ot(),
                        signal: n2.signal
                    });
                    let s2 = !1, a1 = !1;
                    const o1 = (l2 = i2.url).indexOf("sku=") > 0 && gt(l2);
                    var l2;
                    "json" === t3.type && i2.headers.set("Accept", "application/json");
                    const u1 = (n3, s3, l3)=>{
                        if (a1) return;
                        if (n3 && "SecurityError" !== n3.message && $(n3), s3 && l3) return c2(s3);
                        const u2 = Date.now();
                        e2.fetch(i2).then((e2)=>{
                            if (e2.ok) {
                                const t4 = o1 ? e2.clone() : null;
                                return c2(e2, t4, u2);
                            }
                            return r3(new at(e2.statusText, e2.status, t3.url));
                        }).catch((t4)=>{
                            20 !== t4.code && r3(new Error(t4.message));
                        });
                    }, c2 = (n3, o2, l3)=>{
                        ("arrayBuffer" === t3.type ? n3.arrayBuffer() : "json" === t3.type ? n3.json() : n3.text()).then((t4)=>{
                            a1 || (o2 && l3 && (function(t5, r4, n4) {
                                if (rt(), !W) return;
                                const i3 = {
                                    status: r4.status,
                                    statusText: r4.statusText,
                                    headers: new e2.Headers
                                };
                                r4.headers.forEach((t6, e2)=>i3.headers.set(e2, t6)
                                );
                                const s3 = G(r4.headers.get("Cache-Control") || "");
                                if (s3["no-store"]) return;
                                s3["max-age"] && i3.headers.set("Expires", new Date(n4 + 1000 * s3["max-age"]).toUTCString());
                                const a2 = i3.headers.get("Expires");
                                a2 && (new Date(a2).getTime() - n4 < 420000 || (function(t6, e2) {
                                    if ((void 0) === J) try {
                                        new Response(new ReadableStream), J = !0;
                                    } catch (t7) {
                                        J = !1;
                                    }
                                    J ? e2(t6.body) : t6.blob().then(e2);
                                })(r4, (r5)=>{
                                    const n5 = new e2.Response(r5, i3);
                                    rt(), W && W.then((e2)=>e2.put(nt(t5.url), n5)
                                    ).catch((t6)=>$(t6.message)
                                    );
                                }));
                            })(i2, o2, l3), s2 = !0, r3(null, t4, n3.headers.get("Cache-Control"), n3.headers.get("Expires")));
                        }).catch((t4)=>{
                            a1 || r3(new Error(t4.message));
                        });
                    };
                    return o1 ? (function(t4, e2) {
                        if (rt(), !W) return e2(null);
                        const r4 = nt(t4.url);
                        W.then((t5)=>{
                            t5.match(r4).then((n3)=>{
                                const i3 = function(t6) {
                                    if (!t6) return !1;
                                    const e3 = new Date(t6.headers.get("Expires") || 0), r5 = G(t6.headers.get("Cache-Control") || "");
                                    return e3 > Date.now() && !r5["no-cache"];
                                }(n3);
                                t5.delete(r4), i3 && t5.put(r4, n3.clone()), e2(null, n3, i3);
                            }).catch(e2);
                        }).catch(e2);
                    })(i2, u1) : u1(null, null), {
                        cancel: ()=>{
                            a1 = !0, s2 || n2.abort();
                        }
                    };
                })(t2, r2);
                if (N() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t2, r2, void 0, !0);
            }
            var n2;
            return (function(t3, r3) {
                const n3 = new e2.XMLHttpRequest;
                n3.open(t3.method || "GET", t3.url, !0), "arrayBuffer" === t3.type && (n3.responseType = "arraybuffer");
                for(const e2 in t3.headers)n3.setRequestHeader(e2, t3.headers[e2]);
                return "json" === t3.type && (n3.responseType = "text", n3.setRequestHeader("Accept", "application/json")), n3.withCredentials = "include" === t3.credentials, n3.onerror = ()=>{
                    r3(new Error(n3.statusText));
                }, n3.onload = ()=>{
                    if ((n3.status >= 200 && n3.status < 300 || 0 === n3.status) && null !== n3.response) {
                        let e3 = n3.response;
                        if ("json" === t3.type) try {
                            e3 = JSON.parse(n3.response);
                        } catch (t4) {
                            return r3(t4);
                        }
                        r3(null, e3, n3.getResponseHeader("Cache-Control"), n3.getResponseHeader("Expires"));
                    } else r3(new at(n3.statusText, n3.status, t3.url));
                }, n3.send(t3.body), {
                    cancel: ()=>n3.abort()
                };
            })(t2, r2);
        }, ut = function(t2, e2) {
            return lt(z1(t2, {
                type: "arrayBuffer"
            }), e2);
        };
        function ct(t2) {
            const r2 = e2.document.createElement("a");
            return r2.href = t2, r2.protocol === e2.document.location.protocol && r2.host === e2.document.location.host;
        }
        const ht = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let pt, ft;
        pt = [], ft = 0;
        const dt = function(t2, r2) {
            if (s3.supported && (t2.headers || (t2.headers = {
            }), t2.headers.accept = "image/webp,*/*"), ft >= i3.MAX_PARALLEL_IMAGE_REQUESTS) {
                const e2 = {
                    requestParameters: t2,
                    callback: r2,
                    cancelled: !1,
                    cancel () {
                        this.cancelled = !0;
                    }
                };
                return pt.push(e2), e2;
            }
            ft++;
            let n2 = !1;
            const a1 = ()=>{
                if (!n2) for(n2 = !0, ft--; pt.length && ft < i3.MAX_PARALLEL_IMAGE_REQUESTS;){
                    const t3 = pt.shift(), { requestParameters: e2 , callback: r3 , cancelled: n3  } = t3;
                    n3 || (t3.cancel = dt(e2, r3).cancel);
                }
            }, o1 = ut(t2, (t3, n3, i2, s2)=>{
                a1(), t3 ? r2(t3) : n3 && (e2.createImageBitmap ? (function(t4, r3) {
                    const n4 = new e2.Blob([
                        new Uint8Array(t4)
                    ], {
                        type: "image/png"
                    });
                    e2.createImageBitmap(n4).then((t5)=>{
                        r3(null, t5);
                    }).catch((t5)=>{
                        r3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                    });
                })(n3, (t4, e2)=>r2(t4, e2, i2, s2)
                ) : (function(t4, r3) {
                    const n4 = new e2.Image, i3 = e2.URL;
                    n4.onload = ()=>{
                        r3(null, n4), i3.revokeObjectURL(n4.src), n4.onload = null, e2.requestAnimationFrame(()=>{
                            n4.src = ht;
                        });
                    }, n4.onerror = ()=>r3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
                    ;
                    const s3 = new e2.Blob([
                        new Uint8Array(t4)
                    ], {
                        type: "image/png"
                    });
                    n4.src = t4.byteLength ? i3.createObjectURL(s3) : ht;
                })(n3, (t4, e2)=>r2(t4, e2, i2, s2)
                ));
            });
            return {
                cancel: ()=>{
                    o1.cancel(), a1();
                }
            };
        }, yt = "NO_ACCESS_TOKEN";
        function mt(t2) {
            return 0 === t2.indexOf("mapbox:");
        }
        function gt(t2) {
            return i3.API_URL_REGEX.test(t2);
        }
        function xt(t2) {
            return i3.API_CDN_URL_REGEX.test(t2);
        }
        function vt(t2) {
            return i3.API_STYLE_REGEX.test(t2) && !bt(t2);
        }
        function bt(t2) {
            return i3.API_SPRITE_REGEX.test(t2);
        }
        const wt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function _t(t2) {
            const e2 = t2.match(wt);
            if (!e2) throw new Error("Unable to parse URL object");
            return {
                protocol: e2[1],
                authority: e2[2],
                path: e2[3] || "/",
                params: e2[4] ? e2[4].split("&") : []
            };
        }
        function At(t2) {
            const e2 = t2.params.length ? `?${t2.params.join("&")}` : "";
            return `${t2.protocol}://${t2.authority}${t2.path}${e2}`;
        }
        function St(t2) {
            if (!t2) return null;
            const r2 = t2.split(".");
            if (!r2 || 3 !== r2.length) return null;
            try {
                return JSON.parse(decodeURIComponent(e2.atob(r2[1]).split("").map((t3)=>"%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)
                ).join("")));
            } catch (t3) {
                return null;
            }
        }
        class kt {
            constructor(t2){
                this.type = t2, this.anonId = null, this.eventData = {
                }, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t) {
                const r2 = St(i3.ACCESS_TOKEN);
                let n2 = "";
                return n2 = r2 && r2.u ? e2.btoa(encodeURIComponent(r2.u).replace(/%([0-9A-F]{2})/g, (t4, e2)=>String.fromCharCode(Number("0x" + e2))
                )) : i3.ACCESS_TOKEN || "", t ? `mapbox.eventData.${t}:${n2}` : `mapbox.eventData:${n2}`;
            }
            fetchEventData() {
                const t4 = K("localStorage"), r2 = this.getStorageKey(), n2 = this.getStorageKey("uuid");
                if (t4) try {
                    const t5 = e2.localStorage.getItem(r2);
                    t5 && (this.eventData = JSON.parse(t5));
                    const i2 = e2.localStorage.getItem(n2);
                    i2 && (this.anonId = i2);
                } catch (t6) {
                    $("Unable to read from LocalStorage");
                }
            }
            saveEventData() {
                const t4 = K("localStorage"), r2 = this.getStorageKey(), n2 = this.getStorageKey("uuid");
                if (t4) try {
                    e2.localStorage.setItem(n2, this.anonId), Object.keys(this.eventData).length >= 1 && e2.localStorage.setItem(r2, JSON.stringify(this.eventData));
                } catch (t5) {
                    $("Unable to write to LocalStorage");
                }
            }
            processRequests(t) {
            }
            postEvent(t, e, r, n) {
                if (!i3.EVENTS_URL) return;
                const s2 = _t(i3.EVENTS_URL);
                s2.params.push(`access_token=${n || i3.ACCESS_TOKEN || ""}`);
                const a1 = {
                    event: this.type,
                    created: new Date(t).toISOString()
                }, o1 = e ? z1(a1, e) : a1, l2 = {
                    url: At(s2),
                    headers: {
                        "Content-Type": "text/plain"
                    },
                    body: JSON.stringify([
                        o1
                    ])
                };
                this.pendingRequest = (function(t4, e3) {
                    return lt(z1(t4, {
                        method: "POST"
                    }), e3);
                })(l2, (t4)=>{
                    this.pendingRequest = null, r(t4), this.saveEventData(), this.processRequests(n);
                });
            }
            queueRequest(t, e) {
                this.queue.push(t), this.processRequests(e);
            }
        }
        const It = new class extends kt {
            constructor(t4){
                super("appUserTurnstile"), this._customAccessToken = t4;
            }
            postTurnstileEvent(t, e) {
                i3.EVENTS_URL && i3.ACCESS_TOKEN && Array.isArray(t) && t.some((t5)=>mt(t5) || gt(t5)
                ) && this.queueRequest(Date.now(), e);
            }
            processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                const e3 = St(i3.ACCESS_TOKEN), n2 = e3 ? e3.u : i3.ACCESS_TOKEN;
                let s2 = n2 !== this.eventData.tokenU;
                D(this.anonId) || (this.anonId = C(), s2 = !0);
                const a1 = this.queue.shift();
                if (this.eventData.lastSuccess) {
                    const t5 = new Date(this.eventData.lastSuccess), e4 = new Date(a1), r3 = (a1 - this.eventData.lastSuccess) / 86400000;
                    s2 = s2 || r3 >= 1 || r3 < -1 || t5.getDate() !== e4.getDate();
                } else s2 = !0;
                s2 ? this.postEvent(a1, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: r2,
                    skuId: h2,
                    "enabled.telemetry": !1,
                    userId: this.anonId
                }, (t5)=>{
                    t5 || (this.eventData.lastSuccess = a1, this.eventData.tokenU = n2);
                }, t) : this.processRequests();
            }
        }, Mt = It.postTurnstileEvent.bind(It), Tt = new class extends kt {
            constructor(){
                super("map.load"), this.success = {
                }, this.skuToken = "";
            }
            postMapLoadEvent(t, e, r, n) {
                this.skuToken = e, this.errorCb = n, i3.EVENTS_URL && (r || i3.ACCESS_TOKEN ? this.queueRequest({
                    id: t,
                    timestamp: Date.now()
                }, r) : this.errorCb(new Error(yt)));
            }
            processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: e3 , timestamp: n2  } = this.queue.shift();
                e3 && this.success[e3] || (this.anonId || this.fetchEventData(), D(this.anonId) || (this.anonId = C()), this.postEvent(n2, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: r2,
                    skuId: h2,
                    skuToken: this.skuToken,
                    userId: this.anonId
                }, (t5)=>{
                    t5 ? this.errorCb(t5) : e3 && (this.success[e3] = !0);
                }, t));
            }
        }, zt = Tt.postMapLoadEvent.bind(Tt), Bt = new class extends kt {
            constructor(){
                super("gljs.performance");
            }
            postPerformanceEvent(t, e) {
                i3.EVENTS_URL && (t || i3.ACCESS_TOKEN) && this.queueRequest({
                    timestamp: Date.now(),
                    performanceData: e
                }, t);
            }
            processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: n2 , performanceData: i2  } = this.queue.shift(), s2 = function(t5) {
                    const n3 = e2.performance.getEntriesByType("resource"), i3 = e2.performance.getEntriesByType("mark"), s3 = function(t6) {
                        const e3 = {
                        };
                        if (t6) for(const r3 in t6)if ("other" !== r3) for (const n4 of t6[r3]){
                            const t7 = `${r3}ResolveRangeMin`, i4 = `${r3}ResolveRangeMax`, s4 = `${r3}RequestCount`, a1 = `${r3}RequestCachedCount`;
                            e3[t7] = Math.min(e3[t7] || 1 / 0, n4.startTime), e3[i4] = Math.max(e3[i4] || -1 / 0, n4.responseEnd);
                            const o1 = (t8)=>{
                                (void 0) === e3[t8] && (e3[t8] = 0), ++e3[t8];
                            };
                            (void 0) !== n4.transferSize && 0 === n4.transferSize && o1(a1), o1(s4);
                        }
                        return e3;
                    }(function(t6, e3) {
                        const r3 = {
                        };
                        if (t6) for (const n4 of t6){
                            const t7 = e3(n4);
                            (void 0) === r3[t7] && (r3[t7] = []), r3[t7].push(n4);
                        }
                        return r3;
                    }(n3, Ft)), a1 = e2.devicePixelRatio, o1 = e2.navigator.connection || e2.navigator.mozConnection || e2.navigator.webkitConnection, l2 = {
                        counters: [],
                        metadata: [],
                        attributes: []
                    }, u1 = (t6, e3, r3)=>{
                        null != r3 && t6.push({
                            name: e3,
                            value: r3.toString()
                        });
                    };
                    for(const t6 in s3)u1(l2.counters, t6, s3[t6]);
                    if (t5.interactionRange[0] !== 1 / 0 && t5.interactionRange[1] !== -1 / 0 && (u1(l2.counters, "interactionRangeMin", t5.interactionRange[0]), u1(l2.counters, "interactionRangeMax", t5.interactionRange[1])), i3) for (const t7 of Object.keys(Vt)){
                        const e3 = Vt[t7], r3 = i3.find((t8)=>t8.name === e3
                        );
                        r3 && u1(l2.counters, e3, r3.startTime);
                    }
                    return u1(l2.counters, "visibilityHidden", t5.visibilityHidden), u1(l2.attributes, "style", function(t8) {
                        if (t8) for (const e3 of t8){
                            const t9 = e3.name.split("?")[0];
                            if (vt(t9)) {
                                const e4 = t9.split("/").slice(-2);
                                if (2 === e4.length) return `mapbox://styles/${e4[0]}/${e4[1]}`;
                            }
                        }
                    }(n3)), u1(l2.attributes, "terrainEnabled", t5.terrainEnabled ? "true" : "false"), u1(l2.attributes, "fogEnabled", t5.fogEnabled ? "true" : "false"), u1(l2.attributes, "projection", t5.projection), u1(l2.attributes, "zoom", t5.zoom), u1(l2.metadata, "devicePixelRatio", a1), u1(l2.metadata, "connectionEffectiveType", o1 ? o1.effectiveType : void 0), u1(l2.metadata, "navigatorUserAgent", e2.navigator.userAgent), u1(l2.metadata, "screenWidth", e2.screen.width), u1(l2.metadata, "screenHeight", e2.screen.height), u1(l2.metadata, "windowWidth", e2.innerWidth), u1(l2.metadata, "windowHeight", e2.innerHeight), u1(l2.metadata, "mapWidth", t5.width / a1), u1(l2.metadata, "mapHeight", t5.height / a1), u1(l2.metadata, "webglRenderer", t5.renderer), u1(l2.metadata, "webglVendor", t5.vendor), u1(l2.metadata, "sdkVersion", r2), u1(l2.metadata, "sdkIdentifier", "mapbox-gl-js"), l2;
                }(i2);
                for (const t5 of s2.metadata);
                for (const t6 of s2.counters);
                for (const t7 of s2.attributes);
                this.postEvent(n2, s2, ()=>{
                }, t);
            }
        }, Et = Bt.postPerformanceEvent.bind(Bt), Ct = new class extends kt {
            constructor(){
                super("map.auth"), this.success = {
                }, this.skuToken = "";
            }
            getSession(t, e, r, n) {
                if (!i3.API_URL || !i3.SESSION_PATH) return;
                const s2 = _t(i3.API_URL + i3.SESSION_PATH);
                s2.params.push(`sku=${e || ""}`), s2.params.push(`access_token=${n || i3.ACCESS_TOKEN || ""}`);
                const a1 = {
                    url: At(s2),
                    headers: {
                        "Content-Type": "text/plain"
                    }
                };
                this.pendingRequest = (function(t5, e3) {
                    return lt(z1(t5, {
                        method: "GET"
                    }), e3);
                })(a1, (t5)=>{
                    this.pendingRequest = null, r(t5), this.saveEventData(), this.processRequests(n);
                });
            }
            getSessionAPI(t, e, r, n) {
                this.skuToken = e, this.errorCb = n, i3.SESSION_PATH && i3.API_URL && (r || i3.ACCESS_TOKEN ? this.queueRequest({
                    id: t,
                    timestamp: Date.now()
                }, r) : this.errorCb(new Error(yt)));
            }
            processRequests(t) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: e3 , timestamp: r3  } = this.queue.shift();
                e3 && this.success[e3] || this.getSession(r3, this.skuToken, (t5)=>{
                    t5 ? this.errorCb(t5) : e3 && (this.success[e3] = !0);
                }, t);
            }
        }, Pt = Ct.getSessionAPI.bind(Ct), Dt = new Set, Vt = {
            create: "create",
            load: "load",
            fullLoad: "fullLoad"
        }, Lt = {
            mark (t) {
                e2.performance.mark(t);
            },
            measure (t, r, n) {
                e2.performance.measure(t, r, n);
            }
        };
        function Ft(t5) {
            const e3 = t5.name.split("?")[0];
            return xt(e3) && e3.includes("mapbox-gl.js") ? "javascript" : xt(e3) && e3.includes("mapbox-gl.css") ? "css" : (function(t6) {
                return i3.API_FONTS_REGEX.test(t6);
            })(e3) ? "fontRange" : bt(e3) ? "sprite" : vt(e3) ? "style" : (function(t6) {
                return i3.API_TILEJSON_REGEX.test(t6);
            })(e3) ? "tilejson" : "other";
        }
        const Rt = e2.performance;
        function jt(t5) {
            const e3 = t5 ? t5.url.toString() : void 0;
            return Rt.getEntriesByName(e3);
        }
        let Ut, $t, Ot, qt;
        const Nt = {
            now: ()=>(void 0) !== Ot ? Ot : e2.performance.now()
            ,
            setNow (t) {
                Ot = t;
            },
            restoreNow () {
                Ot = void 0;
            },
            frame (t) {
                const r3 = e2.requestAnimationFrame(t);
                return {
                    cancel: ()=>e2.cancelAnimationFrame(r3)
                };
            },
            getImageData (t, r = 0) {
                const { width: n2 , height: i2  } = t;
                qt || (qt = e2.document.createElement("canvas"));
                const s2 = qt.getContext("2d", {
                    willReadFrequently: !0
                });
                if (!s2) throw new Error("failed to create canvas 2d context");
                return (n2 > qt.width || i2 > qt.height) && (qt.width = n2, qt.height = i2), s2.clearRect(-r, -r, n2 + 2 * r, i2 + 2 * r), s2.drawImage(t, 0, 0, n2, i2), s2.getImageData(-r, -r, n2 + 2 * r, i2 + 2 * r);
            },
            resolveURL: (t5)=>(Ut || (Ut = e2.document.createElement("a")), Ut.href = t5, Ut.href)
            ,
            get devicePixelRatio () {
                return e2.devicePixelRatio;
            },
            get prefersReducedMotion () {
                return !!e2.matchMedia && (null == $t && ($t = e2.matchMedia("(prefers-reduced-motion: reduce)")), $t.matches);
            }
        };
        function Gt(t5, e3, r3) {
            r3[t5] && -1 !== r3[t5].indexOf(e3) || (r3[t5] = r3[t5] || [], r3[t5].push(e3));
        }
        function Xt(t5, e3, r3) {
            if (r3 && r3[t5]) {
                const n2 = r3[t5].indexOf(e3);
                -1 !== n2 && r3[t5].splice(n2, 1);
            }
        }
        class Zt {
            constructor(t5, e3 = {
            }){
                z1(this, e3), this.type = t5;
            }
        }
        class Kt extends Zt {
            constructor(t6, e4 = {
            }){
                super("error", z1({
                    error: t6
                }, e4));
            }
        }
        class Yt {
            on(t, e) {
                return this._listeners = this._listeners || {
                }, Gt(t, e, this._listeners), this;
            }
            off(t, e) {
                return Xt(t, e, this._listeners), Xt(t, e, this._oneTimeListeners), this;
            }
            once(t, e) {
                return e ? (this._oneTimeListeners = this._oneTimeListeners || {
                }, Gt(t, e, this._oneTimeListeners), this) : new Promise((e5)=>this.once(t, e5)
                );
            }
            fire(t, e) {
                "string" == typeof t && (t = new Zt(t, e || {
                }));
                const r3 = t.type;
                if (this.listens(r3)) {
                    t.target = this;
                    const e5 = this._listeners && this._listeners[r3] ? this._listeners[r3].slice() : [];
                    for (const r4 of e5)r4.call(this, t);
                    const n2 = this._oneTimeListeners && this._oneTimeListeners[r3] ? this._oneTimeListeners[r3].slice() : [];
                    for (const e6 of n2)Xt(r3, e6, this._oneTimeListeners), e6.call(this, t);
                    const i2 = this._eventedParent;
                    i2 && (z1(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t));
                } else t instanceof Kt && console.error(t.error);
                return this;
            }
            listens(t) {
                return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t));
            }
            setEventedParent(t, e) {
                return this._eventedParent = t, this._eventedParentData = e, this;
            }
        }
        var Ht = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function Wt(t7, ...e5) {
            for (const r3 of e5)for(const e6 in r3)t7[e6] = r3[e6];
            return t7;
        }
        function Jt(t7) {
            return t7 instanceof Number || t7 instanceof String || t7 instanceof Boolean ? t7.valueOf() : t7;
        }
        function Qt(t7) {
            if (Array.isArray(t7)) return t7.map(Qt);
            if (t7 instanceof Object && !(t7 instanceof Number || t7 instanceof String || t7 instanceof Boolean)) {
                const e5 = {
                };
                for(const r3 in t7)e5[r3] = Qt(t7[r3]);
                return e5;
            }
            return Jt(t7);
        }
        class te extends Error {
            constructor(t7, e5){
                super(e5), this.message = e5, this.key = t7;
            }
        }
        var ee = te;
        class re {
            constructor(t8, e6 = []){
                this.parent = t8, this.bindings = {
                };
                for (const [t9, r3] of e6)this.bindings[t9] = r3;
            }
            concat(t) {
                return new re(this, t);
            }
            get(t) {
                if (this.bindings[t]) return this.bindings[t];
                if (this.parent) return this.parent.get(t);
                throw new Error(`${t} not found in scope.`);
            }
            has(t) {
                return !!this.bindings[t] || !!this.parent && this.parent.has(t);
            }
        }
        var ne = re;
        const ie = {
            kind: "null"
        }, se = {
            kind: "number"
        }, ae = {
            kind: "string"
        }, oe = {
            kind: "boolean"
        }, le = {
            kind: "color"
        }, ue = {
            kind: "object"
        }, ce = {
            kind: "value"
        }, he = {
            kind: "collator"
        }, pe = {
            kind: "formatted"
        }, fe = {
            kind: "resolvedImage"
        };
        function de(t10, e7) {
            return {
                kind: "array",
                itemType: t10,
                N: e7
            };
        }
        function ye(t10) {
            if ("array" === t10.kind) {
                const e7 = ye(t10.itemType);
                return "number" == typeof t10.N ? `array<${e7}, ${t10.N}>` : "value" === t10.itemType.kind ? "array" : `array<${e7}>`;
            }
            return t10.kind;
        }
        const me = [
            ie,
            se,
            ae,
            oe,
            le,
            pe,
            ue,
            de(ce),
            fe
        ];
        function ge(t10, e7) {
            if ("error" === e7.kind) return null;
            if ("array" === t10.kind) {
                if ("array" === e7.kind && (0 === e7.N && "value" === e7.itemType.kind || !ge(t10.itemType, e7.itemType)) && ("number" != typeof t10.N || t10.N === e7.N)) return null;
            } else {
                if (t10.kind === e7.kind) return null;
                if ("value" === t10.kind) for (const t11 of me)if (!ge(t11, e7)) return null;
            }
            return `Expected ${ye(t10)} but found ${ye(e7)} instead.`;
        }
        function xe(t10, e7) {
            return e7.some((e8)=>e8.kind === t10.kind
            );
        }
        function ve(t10, e7) {
            return e7.some((e8)=>"null" === e8 ? null === t10 : "array" === e8 ? Array.isArray(t10) : "object" === e8 ? t10 && !Array.isArray(t10) && "object" == typeof t10 : e8 === typeof t10
            );
        }
        var be, we = {
            transparent: [
                0,
                0,
                0,
                0
            ],
            aliceblue: [
                240,
                248,
                255,
                1
            ],
            antiquewhite: [
                250,
                235,
                215,
                1
            ],
            aqua: [
                0,
                255,
                255,
                1
            ],
            aquamarine: [
                127,
                255,
                212,
                1
            ],
            azure: [
                240,
                255,
                255,
                1
            ],
            beige: [
                245,
                245,
                220,
                1
            ],
            bisque: [
                255,
                228,
                196,
                1
            ],
            black: [
                0,
                0,
                0,
                1
            ],
            blanchedalmond: [
                255,
                235,
                205,
                1
            ],
            blue: [
                0,
                0,
                255,
                1
            ],
            blueviolet: [
                138,
                43,
                226,
                1
            ],
            brown: [
                165,
                42,
                42,
                1
            ],
            burlywood: [
                222,
                184,
                135,
                1
            ],
            cadetblue: [
                95,
                158,
                160,
                1
            ],
            chartreuse: [
                127,
                255,
                0,
                1
            ],
            chocolate: [
                210,
                105,
                30,
                1
            ],
            coral: [
                255,
                127,
                80,
                1
            ],
            cornflowerblue: [
                100,
                149,
                237,
                1
            ],
            cornsilk: [
                255,
                248,
                220,
                1
            ],
            crimson: [
                220,
                20,
                60,
                1
            ],
            cyan: [
                0,
                255,
                255,
                1
            ],
            darkblue: [
                0,
                0,
                139,
                1
            ],
            darkcyan: [
                0,
                139,
                139,
                1
            ],
            darkgoldenrod: [
                184,
                134,
                11,
                1
            ],
            darkgray: [
                169,
                169,
                169,
                1
            ],
            darkgreen: [
                0,
                100,
                0,
                1
            ],
            darkgrey: [
                169,
                169,
                169,
                1
            ],
            darkkhaki: [
                189,
                183,
                107,
                1
            ],
            darkmagenta: [
                139,
                0,
                139,
                1
            ],
            darkolivegreen: [
                85,
                107,
                47,
                1
            ],
            darkorange: [
                255,
                140,
                0,
                1
            ],
            darkorchid: [
                153,
                50,
                204,
                1
            ],
            darkred: [
                139,
                0,
                0,
                1
            ],
            darksalmon: [
                233,
                150,
                122,
                1
            ],
            darkseagreen: [
                143,
                188,
                143,
                1
            ],
            darkslateblue: [
                72,
                61,
                139,
                1
            ],
            darkslategray: [
                47,
                79,
                79,
                1
            ],
            darkslategrey: [
                47,
                79,
                79,
                1
            ],
            darkturquoise: [
                0,
                206,
                209,
                1
            ],
            darkviolet: [
                148,
                0,
                211,
                1
            ],
            deeppink: [
                255,
                20,
                147,
                1
            ],
            deepskyblue: [
                0,
                191,
                255,
                1
            ],
            dimgray: [
                105,
                105,
                105,
                1
            ],
            dimgrey: [
                105,
                105,
                105,
                1
            ],
            dodgerblue: [
                30,
                144,
                255,
                1
            ],
            firebrick: [
                178,
                34,
                34,
                1
            ],
            floralwhite: [
                255,
                250,
                240,
                1
            ],
            forestgreen: [
                34,
                139,
                34,
                1
            ],
            fuchsia: [
                255,
                0,
                255,
                1
            ],
            gainsboro: [
                220,
                220,
                220,
                1
            ],
            ghostwhite: [
                248,
                248,
                255,
                1
            ],
            gold: [
                255,
                215,
                0,
                1
            ],
            goldenrod: [
                218,
                165,
                32,
                1
            ],
            gray: [
                128,
                128,
                128,
                1
            ],
            green: [
                0,
                128,
                0,
                1
            ],
            greenyellow: [
                173,
                255,
                47,
                1
            ],
            grey: [
                128,
                128,
                128,
                1
            ],
            honeydew: [
                240,
                255,
                240,
                1
            ],
            hotpink: [
                255,
                105,
                180,
                1
            ],
            indianred: [
                205,
                92,
                92,
                1
            ],
            indigo: [
                75,
                0,
                130,
                1
            ],
            ivory: [
                255,
                255,
                240,
                1
            ],
            khaki: [
                240,
                230,
                140,
                1
            ],
            lavender: [
                230,
                230,
                250,
                1
            ],
            lavenderblush: [
                255,
                240,
                245,
                1
            ],
            lawngreen: [
                124,
                252,
                0,
                1
            ],
            lemonchiffon: [
                255,
                250,
                205,
                1
            ],
            lightblue: [
                173,
                216,
                230,
                1
            ],
            lightcoral: [
                240,
                128,
                128,
                1
            ],
            lightcyan: [
                224,
                255,
                255,
                1
            ],
            lightgoldenrodyellow: [
                250,
                250,
                210,
                1
            ],
            lightgray: [
                211,
                211,
                211,
                1
            ],
            lightgreen: [
                144,
                238,
                144,
                1
            ],
            lightgrey: [
                211,
                211,
                211,
                1
            ],
            lightpink: [
                255,
                182,
                193,
                1
            ],
            lightsalmon: [
                255,
                160,
                122,
                1
            ],
            lightseagreen: [
                32,
                178,
                170,
                1
            ],
            lightskyblue: [
                135,
                206,
                250,
                1
            ],
            lightslategray: [
                119,
                136,
                153,
                1
            ],
            lightslategrey: [
                119,
                136,
                153,
                1
            ],
            lightsteelblue: [
                176,
                196,
                222,
                1
            ],
            lightyellow: [
                255,
                255,
                224,
                1
            ],
            lime: [
                0,
                255,
                0,
                1
            ],
            limegreen: [
                50,
                205,
                50,
                1
            ],
            linen: [
                250,
                240,
                230,
                1
            ],
            magenta: [
                255,
                0,
                255,
                1
            ],
            maroon: [
                128,
                0,
                0,
                1
            ],
            mediumaquamarine: [
                102,
                205,
                170,
                1
            ],
            mediumblue: [
                0,
                0,
                205,
                1
            ],
            mediumorchid: [
                186,
                85,
                211,
                1
            ],
            mediumpurple: [
                147,
                112,
                219,
                1
            ],
            mediumseagreen: [
                60,
                179,
                113,
                1
            ],
            mediumslateblue: [
                123,
                104,
                238,
                1
            ],
            mediumspringgreen: [
                0,
                250,
                154,
                1
            ],
            mediumturquoise: [
                72,
                209,
                204,
                1
            ],
            mediumvioletred: [
                199,
                21,
                133,
                1
            ],
            midnightblue: [
                25,
                25,
                112,
                1
            ],
            mintcream: [
                245,
                255,
                250,
                1
            ],
            mistyrose: [
                255,
                228,
                225,
                1
            ],
            moccasin: [
                255,
                228,
                181,
                1
            ],
            navajowhite: [
                255,
                222,
                173,
                1
            ],
            navy: [
                0,
                0,
                128,
                1
            ],
            oldlace: [
                253,
                245,
                230,
                1
            ],
            olive: [
                128,
                128,
                0,
                1
            ],
            olivedrab: [
                107,
                142,
                35,
                1
            ],
            orange: [
                255,
                165,
                0,
                1
            ],
            orangered: [
                255,
                69,
                0,
                1
            ],
            orchid: [
                218,
                112,
                214,
                1
            ],
            palegoldenrod: [
                238,
                232,
                170,
                1
            ],
            palegreen: [
                152,
                251,
                152,
                1
            ],
            paleturquoise: [
                175,
                238,
                238,
                1
            ],
            palevioletred: [
                219,
                112,
                147,
                1
            ],
            papayawhip: [
                255,
                239,
                213,
                1
            ],
            peachpuff: [
                255,
                218,
                185,
                1
            ],
            peru: [
                205,
                133,
                63,
                1
            ],
            pink: [
                255,
                192,
                203,
                1
            ],
            plum: [
                221,
                160,
                221,
                1
            ],
            powderblue: [
                176,
                224,
                230,
                1
            ],
            purple: [
                128,
                0,
                128,
                1
            ],
            rebeccapurple: [
                102,
                51,
                153,
                1
            ],
            red: [
                255,
                0,
                0,
                1
            ],
            rosybrown: [
                188,
                143,
                143,
                1
            ],
            royalblue: [
                65,
                105,
                225,
                1
            ],
            saddlebrown: [
                139,
                69,
                19,
                1
            ],
            salmon: [
                250,
                128,
                114,
                1
            ],
            sandybrown: [
                244,
                164,
                96,
                1
            ],
            seagreen: [
                46,
                139,
                87,
                1
            ],
            seashell: [
                255,
                245,
                238,
                1
            ],
            sienna: [
                160,
                82,
                45,
                1
            ],
            silver: [
                192,
                192,
                192,
                1
            ],
            skyblue: [
                135,
                206,
                235,
                1
            ],
            slateblue: [
                106,
                90,
                205,
                1
            ],
            slategray: [
                112,
                128,
                144,
                1
            ],
            slategrey: [
                112,
                128,
                144,
                1
            ],
            snow: [
                255,
                250,
                250,
                1
            ],
            springgreen: [
                0,
                255,
                127,
                1
            ],
            steelblue: [
                70,
                130,
                180,
                1
            ],
            tan: [
                210,
                180,
                140,
                1
            ],
            teal: [
                0,
                128,
                128,
                1
            ],
            thistle: [
                216,
                191,
                216,
                1
            ],
            tomato: [
                255,
                99,
                71,
                1
            ],
            turquoise: [
                64,
                224,
                208,
                1
            ],
            violet: [
                238,
                130,
                238,
                1
            ],
            wheat: [
                245,
                222,
                179,
                1
            ],
            white: [
                255,
                255,
                255,
                1
            ],
            whitesmoke: [
                245,
                245,
                245,
                1
            ],
            yellow: [
                255,
                255,
                0,
                1
            ],
            yellowgreen: [
                154,
                205,
                50,
                1
            ]
        };
        function _e(t10) {
            return (t10 = Math.round(t10)) < 0 ? 0 : t10 > 255 ? 255 : t10;
        }
        function Ae(t10) {
            return _e("%" === t10[t10.length - 1] ? parseFloat(t10) / 100 * 255 : parseInt(t10));
        }
        function Se(t10) {
            var e7;
            return (e7 = "%" === t10[t10.length - 1] ? parseFloat(t10) / 100 : parseFloat(t10)) < 0 ? 0 : e7 > 1 ? 1 : e7;
        }
        function ke(t10, e7, r4) {
            return r4 < 0 ? r4 += 1 : r4 > 1 && (r4 -= 1), 6 * r4 < 1 ? t10 + (e7 - t10) * r4 * 6 : 2 * r4 < 1 ? e7 : 3 * r4 < 2 ? t10 + (e7 - t10) * (2 / 3 - r4) * 6 : t10;
        }
        try {
            be = ({
            }).parseCSSColor = function(t10) {
                var e7, r4 = t10.replace(/ /g, "").toLowerCase();
                if (r4 in we) return we[r4].slice();
                if ("#" === r4[0]) return 4 === r4.length ? (e7 = parseInt(r4.substr(1), 16)) >= 0 && e7 <= 4095 ? [
                    (3840 & e7) >> 4 | (3840 & e7) >> 8,
                    240 & e7 | (240 & e7) >> 4,
                    15 & e7 | (15 & e7) << 4,
                    1
                ] : null : 7 === r4.length && (e7 = parseInt(r4.substr(1), 16)) >= 0 && e7 <= 16777215 ? [
                    (16711680 & e7) >> 16,
                    (65280 & e7) >> 8,
                    255 & e7,
                    1
                ] : null;
                var n2 = r4.indexOf("("), i2 = r4.indexOf(")");
                if (-1 !== n2 && i2 + 1 === r4.length) {
                    var s2 = r4.substr(0, n2), a1 = r4.substr(n2 + 1, i2 - (n2 + 1)).split(","), o1 = 1;
                    switch(s2){
                        case "rgba":
                            if (4 !== a1.length) return null;
                            o1 = Se(a1.pop());
                        case "rgb":
                            return 3 !== a1.length ? null : [
                                Ae(a1[0]),
                                Ae(a1[1]),
                                Ae(a1[2]),
                                o1
                            ];
                        case "hsla":
                            if (4 !== a1.length) return null;
                            o1 = Se(a1.pop());
                        case "hsl":
                            if (3 !== a1.length) return null;
                            var l2 = (parseFloat(a1[0]) % 360 + 360) % 360 / 360, u1 = Se(a1[1]), c2 = Se(a1[2]), h1 = c2 <= 0.5 ? c2 * (u1 + 1) : c2 + u1 - c2 * u1, p1 = 2 * c2 - h1;
                            return [
                                _e(255 * ke(p1, h1, l2 + 1 / 3)),
                                _e(255 * ke(p1, h1, l2)),
                                _e(255 * ke(p1, h1, l2 - 1 / 3)),
                                o1
                            ];
                        default:
                            return null;
                    }
                }
                return null;
            };
        } catch (t10) {
        }
        class Ie {
            constructor(t10, e7, r4, n2 = 1){
                this.r = t10, this.g = e7, this.b = r4, this.a = n2;
            }
            static parse(t) {
                if (!t) return;
                if (t instanceof Ie) return t;
                if ("string" != typeof t) return;
                const e8 = be(t);
                return e8 ? new Ie(e8[0] / 255 * e8[3], e8[1] / 255 * e8[3], e8[2] / 255 * e8[3], e8[3]) : void 0;
            }
            toString() {
                const [t11, e8, r5, n3] = this.toArray();
                return `rgba(${Math.round(t11)},${Math.round(e8)},${Math.round(r5)},${n3})`;
            }
            toArray() {
                const { r: t11 , g: e8 , b: r5 , a: n3  } = this;
                return 0 === n3 ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    255 * t11 / n3,
                    255 * e8 / n3,
                    255 * r5 / n3,
                    n3
                ];
            }
            toArray01() {
                const { r: t11 , g: e8 , b: r5 , a: n3  } = this;
                return 0 === n3 ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    t11 / n3,
                    e8 / n3,
                    r5 / n3,
                    n3
                ];
            }
            toArray01PremultipliedAlpha() {
                const { r: t11 , g: e8 , b: r5 , a: n3  } = this;
                return [
                    t11,
                    e8,
                    r5,
                    n3
                ];
            }
        }
        Ie.black = new Ie(0, 0, 0, 1), Ie.white = new Ie(1, 1, 1, 1), Ie.transparent = new Ie(0, 0, 0, 0), Ie.red = new Ie(1, 0, 0, 1), Ie.blue = new Ie(0, 0, 1, 1);
        var Me = Ie;
        class Te {
            constructor(t11, e8, r5){
                this.sensitivity = t11 ? e8 ? "variant" : "case" : e8 ? "accent" : "base", this.locale = r5, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                    sensitivity: this.sensitivity,
                    usage: "search"
                });
            }
            compare(t, e) {
                return this.collator.compare(t, e);
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
        }
        class ze {
            constructor(t12, e9, r6, n3, i2){
                this.text = t12.normalize ? t12.normalize() : t12, this.image = e9, this.scale = r6, this.fontStack = n3, this.textColor = i2;
            }
        }
        class Be {
            constructor(t13){
                this.sections = t13;
            }
            static fromString(t) {
                return new Be([
                    new ze(t, null, null, null, null)
                ]);
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some((t14)=>0 !== t14.text.length || t14.image && 0 !== t14.image.name.length
                );
            }
            static factory(t) {
                return t instanceof Be ? t : Be.fromString(t);
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map((t14)=>t14.text
                ).join("");
            }
            serialize() {
                const t14 = [
                    "format"
                ];
                for (const e10 of this.sections){
                    if (e10.image) {
                        t14.push([
                            "image",
                            e10.image.name
                        ]);
                        continue;
                    }
                    t14.push(e10.text);
                    const r7 = {
                    };
                    e10.fontStack && (r7["text-font"] = [
                        "literal",
                        e10.fontStack.split(",")
                    ]), e10.scale && (r7["font-scale"] = e10.scale), e10.textColor && (r7["text-color"] = [
                        "rgba"
                    ].concat(e10.textColor.toArray())), t14.push(r7);
                }
                return t14;
            }
        }
        class Ee {
            constructor(t14){
                this.name = t14.name, this.available = t14.available;
            }
            toString() {
                return this.name;
            }
            static fromString(t) {
                return t ? new Ee({
                    name: t,
                    available: !1
                }) : null;
            }
            serialize() {
                return [
                    "image",
                    this.name
                ];
            }
        }
        function Ce(t15, e10, r7, n4) {
            return "number" == typeof t15 && t15 >= 0 && t15 <= 255 && "number" == typeof e10 && e10 >= 0 && e10 <= 255 && "number" == typeof r7 && r7 >= 0 && r7 <= 255 ? (void 0) === n4 || "number" == typeof n4 && n4 >= 0 && n4 <= 1 ? null : `Invalid rgba value [${[
                t15,
                e10,
                r7,
                n4
            ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n4 ? [
                t15,
                e10,
                r7,
                n4
            ] : [
                t15,
                e10,
                r7
            ]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Pe(t15) {
            if (null === t15) return !0;
            if ("string" == typeof t15) return !0;
            if ("boolean" == typeof t15) return !0;
            if ("number" == typeof t15) return !0;
            if (t15 instanceof Me) return !0;
            if (t15 instanceof Te) return !0;
            if (t15 instanceof Be) return !0;
            if (t15 instanceof Ee) return !0;
            if (Array.isArray(t15)) {
                for (const e10 of t15)if (!Pe(e10)) return !1;
                return !0;
            }
            if ("object" == typeof t15) {
                for(const e10 in t15)if (!Pe(t15[e10])) return !1;
                return !0;
            }
            return !1;
        }
        function De(t15) {
            if (null === t15) return ie;
            if ("string" == typeof t15) return ae;
            if ("boolean" == typeof t15) return oe;
            if ("number" == typeof t15) return se;
            if (t15 instanceof Me) return le;
            if (t15 instanceof Te) return he;
            if (t15 instanceof Be) return pe;
            if (t15 instanceof Ee) return fe;
            if (Array.isArray(t15)) {
                const e10 = t15.length;
                let r7;
                for (const e11 of t15){
                    const t16 = De(e11);
                    if (r7) {
                        if (r7 === t16) continue;
                        r7 = ce;
                        break;
                    }
                    r7 = t16;
                }
                return de(r7 || ce, e10);
            }
            return ue;
        }
        function Ve(t15) {
            const e10 = typeof t15;
            return null === t15 ? "" : "string" === e10 || "number" === e10 || "boolean" === e10 ? String(t15) : t15 instanceof Me || t15 instanceof Be || t15 instanceof Ee ? t15.toString() : JSON.stringify(t15);
        }
        class Le {
            constructor(t15, e10){
                this.type = t15, this.value = e10;
            }
            static parse(t, e) {
                if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                if (!Pe(t[1])) return e.error("invalid value");
                const r7 = t[1];
                let n4 = De(r7);
                const i3 = e.expectedType;
                return "array" !== n4.kind || 0 !== n4.N || !i3 || "array" !== i3.kind || "number" == typeof i3.N && 0 !== i3.N || (n4 = i3), new Le(n4, r7);
            }
            evaluate() {
                return this.value;
            }
            eachChild() {
            }
            outputDefined() {
                return !0;
            }
            serialize() {
                return "array" === this.type.kind || "object" === this.type.kind ? [
                    "literal",
                    this.value
                ] : this.value instanceof Me ? [
                    "rgba"
                ].concat(this.value.toArray()) : this.value instanceof Be ? this.value.serialize() : this.value;
            }
        }
        var Fe = Le, Re = class {
            constructor(t16){
                this.name = "ExpressionEvaluationError", this.message = t16;
            }
            toJSON() {
                return this.message;
            }
        };
        const je = {
            string: ae,
            number: se,
            boolean: oe,
            object: ue
        };
        class Ue {
            constructor(t17, e11){
                this.type = t17, this.args = e11;
            }
            static parse(t, e) {
                if (t.length < 2) return e.error("Expected at least one argument.");
                let r7, n4 = 1;
                const i3 = t[0];
                if ("array" === i3) {
                    let i4, s3;
                    if (t.length > 2) {
                        const r8 = t[1];
                        if ("string" != typeof r8 || !(r8 in je) || "object" === r8) return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        i4 = je[r8], n4++;
                    } else i4 = ce;
                    if (t.length > 3) {
                        if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2);
                        s3 = t[2], n4++;
                    }
                    r7 = de(i4, s3);
                } else r7 = je[i3];
                const s3 = [];
                for(; n4 < t.length; n4++){
                    const r8 = e.parse(t[n4], n4, ce);
                    if (!r8) return null;
                    s3.push(r8);
                }
                return new Ue(r7, s3);
            }
            evaluate(t) {
                for(let e12 = 0; e12 < this.args.length; e12++){
                    const r7 = this.args[e12].evaluate(t);
                    if (!ge(this.type, De(r7))) return r7;
                    if (e12 === this.args.length - 1) throw new Re(`Expected value to be of type ${ye(this.type)}, but found ${ye(De(r7))} instead.`);
                }
                return null;
            }
            eachChild(t) {
                this.args.forEach(t);
            }
            outputDefined() {
                return this.args.every((t18)=>t18.outputDefined()
                );
            }
            serialize() {
                const t18 = this.type, e12 = [
                    t18.kind
                ];
                if ("array" === t18.kind) {
                    const r7 = t18.itemType;
                    if ("string" === r7.kind || "number" === r7.kind || "boolean" === r7.kind) {
                        e12.push(r7.kind);
                        const n4 = t18.N;
                        ("number" == typeof n4 || this.args.length > 1) && e12.push(n4);
                    }
                }
                return e12.concat(this.args.map((t19)=>t19.serialize()
                ));
            }
        }
        var $e = Ue;
        class Oe {
            constructor(t18){
                this.type = pe, this.sections = t18;
            }
            static parse(t, e) {
                if (t.length < 2) return e.error("Expected at least one argument.");
                const r7 = t[1];
                if (!Array.isArray(r7) && "object" == typeof r7) return e.error("First argument must be an image or text section.");
                const n4 = [];
                let i3 = !1;
                for(let r8 = 1; r8 <= t.length - 1; ++r8){
                    const s3 = t[r8];
                    if (i3 && "object" == typeof s3 && !Array.isArray(s3)) {
                        i3 = !1;
                        let t19 = null;
                        if (s3["font-scale"] && (t19 = e.parse(s3["font-scale"], 1, se), !t19)) return null;
                        let r9 = null;
                        if (s3["text-font"] && (r9 = e.parse(s3["text-font"], 1, de(ae)), !r9)) return null;
                        let a2 = null;
                        if (s3["text-color"] && (a2 = e.parse(s3["text-color"], 1, le), !a2)) return null;
                        const o2 = n4[n4.length - 1];
                        o2.scale = t19, o2.font = r9, o2.textColor = a2;
                    } else {
                        const s4 = e.parse(t[r8], 1, ce);
                        if (!s4) return null;
                        const a2 = s4.type.kind;
                        if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        i3 = !0, n4.push({
                            content: s4,
                            scale: null,
                            font: null,
                            textColor: null
                        });
                    }
                }
                return new Oe(n4);
            }
            evaluate(t) {
                return new Be(this.sections.map((e12)=>{
                    const r7 = e12.content.evaluate(t);
                    return De(r7) === fe ? new ze("", r7, null, null, null) : new ze(Ve(r7), null, e12.scale ? e12.scale.evaluate(t) : null, e12.font ? e12.font.evaluate(t).join(",") : null, e12.textColor ? e12.textColor.evaluate(t) : null);
                }));
            }
            eachChild(t) {
                for (const e12 of this.sections)t(e12.content), e12.scale && t(e12.scale), e12.font && t(e12.font), e12.textColor && t(e12.textColor);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t19 = [
                    "format"
                ];
                for (const e12 of this.sections){
                    t19.push(e12.content.serialize());
                    const r7 = {
                    };
                    e12.scale && (r7["font-scale"] = e12.scale.serialize()), e12.font && (r7["text-font"] = e12.font.serialize()), e12.textColor && (r7["text-color"] = e12.textColor.serialize()), t19.push(r7);
                }
                return t19;
            }
        }
        class qe {
            constructor(t19){
                this.type = fe, this.input = t19;
            }
            static parse(t, e) {
                if (2 !== t.length) return e.error("Expected two arguments.");
                const r7 = e.parse(t[1], 1, ae);
                return r7 ? new qe(r7) : e.error("No image name provided.");
            }
            evaluate(t) {
                const e12 = this.input.evaluate(t), r7 = Ee.fromString(e12);
                return r7 && t.availableImages && (r7.available = t.availableImages.indexOf(e12) > -1), r7;
            }
            eachChild(t) {
                t(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "image",
                    this.input.serialize()
                ];
            }
        }
        const Ne = {
            "to-boolean": oe,
            "to-color": le,
            "to-number": se,
            "to-string": ae
        };
        class Ge {
            constructor(t20, e12){
                this.type = t20, this.args = e12;
            }
            static parse(t, e) {
                if (t.length < 2) return e.error("Expected at least one argument.");
                const r7 = t[0];
                if (("to-boolean" === r7 || "to-string" === r7) && 2 !== t.length) return e.error("Expected one argument.");
                const n4 = Ne[r7], i3 = [];
                for(let r8 = 1; r8 < t.length; r8++){
                    const n5 = e.parse(t[r8], r8, ce);
                    if (!n5) return null;
                    i3.push(n5);
                }
                return new Ge(n4, i3);
            }
            evaluate(t) {
                if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t));
                if ("color" === this.type.kind) {
                    let e13, r7;
                    for (const n4 of this.args){
                        if (e13 = n4.evaluate(t), r7 = null, e13 instanceof Me) return e13;
                        if ("string" == typeof e13) {
                            const r8 = t.parseColor(e13);
                            if (r8) return r8;
                        } else if (Array.isArray(e13) && (r7 = e13.length < 3 || e13.length > 4 ? `Invalid rbga value ${JSON.stringify(e13)}: expected an array containing either three or four numeric values.` : Ce(e13[0], e13[1], e13[2], e13[3]), !r7)) return new Me(e13[0] / 255, e13[1] / 255, e13[2] / 255, e13[3]);
                    }
                    throw new Re(r7 || `Could not parse color from value '${"string" == typeof e13 ? e13 : String(JSON.stringify(e13))}'`);
                }
                if ("number" === this.type.kind) {
                    let e13 = null;
                    for (const r7 of this.args){
                        if (e13 = r7.evaluate(t), null === e13) return 0;
                        const n4 = Number(e13);
                        if (!isNaN(n4)) return n4;
                    }
                    throw new Re(`Could not convert ${JSON.stringify(e13)} to number.`);
                }
                return "formatted" === this.type.kind ? Be.fromString(Ve(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? Ee.fromString(Ve(this.args[0].evaluate(t))) : Ve(this.args[0].evaluate(t));
            }
            eachChild(t) {
                this.args.forEach(t);
            }
            outputDefined() {
                return this.args.every((t21)=>t21.outputDefined()
                );
            }
            serialize() {
                if ("formatted" === this.type.kind) return new Oe([
                    {
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }
                ]).serialize();
                if ("resolvedImage" === this.type.kind) return new qe(this.args[0]).serialize();
                const t21 = [
                    `to-${this.type.kind}`
                ];
                return this.eachChild((e13)=>{
                    t21.push(e13.serialize());
                }), t21;
            }
        }
        var Xe = Ge;
        const Ze = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ];
        var Ke = class {
            constructor(){
                this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {
                }, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
            }
            id() {
                return this.feature && (void 0) !== this.feature.id ? this.feature.id : null;
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? Ze[this.feature.type] : this.feature.type : null;
            }
            geometry() {
                return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
                return this.canonical;
            }
            properties() {
                return this.feature && this.feature.properties || {
                };
            }
            distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                    const t21 = this.featureDistanceData.center, e13 = this.featureDistanceData.scale, { x: r7 , y: n4  } = this.featureTileCoord;
                    return this.featureDistanceData.bearing[0] * (r7 * e13 - t21[0]) + this.featureDistanceData.bearing[1] * (n4 * e13 - t21[1]);
                }
                return 0;
            }
            parseColor(t) {
                let e13 = this._parseColorCache[t];
                return e13 || (e13 = this._parseColorCache[t] = Me.parse(t)), e13;
            }
        };
        class Ye {
            constructor(t21, e13, r7, n4){
                this.name = t21, this.type = e13, this._evaluate = r7, this.args = n4;
            }
            evaluate(t) {
                return this._evaluate(t, this.args);
            }
            eachChild(t) {
                this.args.forEach(t);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    this.name
                ].concat(this.args.map((t22)=>t22.serialize()
                ));
            }
            static parse(t, e) {
                const r8 = t[0], n5 = Ye.definitions[r8];
                if (!n5) return e.error(`Unknown expression "${r8}". If you wanted a literal array, use ["literal", [...]].`, 0);
                const i3 = Array.isArray(n5) ? n5[0] : n5.type, s3 = Array.isArray(n5) ? [
                    [
                        n5[1],
                        n5[2]
                    ]
                ] : n5.overloads, a2 = s3.filter(([e14])=>!Array.isArray(e14) || e14.length === t.length - 1
                );
                let o2 = null;
                for (const [n6, s4] of a2){
                    o2 = new _r(e.registry, e.path, null, e.scope);
                    const a3 = [];
                    let l3 = !1;
                    for(let e14 = 1; e14 < t.length; e14++){
                        const r9 = t[e14], i4 = Array.isArray(n6) ? n6[e14 - 1] : n6.type, s5 = o2.parse(r9, 1 + a3.length, i4);
                        if (!s5) {
                            l3 = !0;
                            break;
                        }
                        a3.push(s5);
                    }
                    if (!l3) {
                        if (Array.isArray(n6) && n6.length !== a3.length) o2.error(`Expected ${n6.length} arguments, but found ${a3.length} instead.`);
                        else {
                            for(let t22 = 0; t22 < a3.length; t22++){
                                const e15 = Array.isArray(n6) ? n6[t22] : n6.type, r9 = a3[t22];
                                o2.concat(t22 + 1).checkSubtype(e15, r9.type);
                            }
                            if (0 === o2.errors.length) return new Ye(r8, i3, s4, a3);
                        }
                    }
                }
                if (1 === a2.length) e.errors.push(...o2.errors);
                else {
                    const r9 = (a2.length ? a2 : s3).map(([t22])=>{
                        var e14;
                        return e14 = t22, Array.isArray(e14) ? `(${e14.map(ye).join(", ")})` : `(${ye(e14.type)}...)`;
                    }).join(" | "), n7 = [];
                    for(let r10 = 1; r10 < t.length; r10++){
                        const i4 = e.parse(t[r10], 1 + n7.length);
                        if (!i4) return null;
                        n7.push(ye(i4.type));
                    }
                    e.error(`Expected arguments of type ${r9}, but found (${n7.join(", ")}) instead.`);
                }
                return null;
            }
            static register(t, e) {
                Ye.definitions = e;
                for(const r8 in e)t[r8] = Ye;
            }
        }
        var He = Ye;
        class We {
            constructor(t22, e15, r8){
                this.type = he, this.locale = r8, this.caseSensitive = t22, this.diacriticSensitive = e15;
            }
            static parse(t, e) {
                if (2 !== t.length) return e.error("Expected one argument.");
                const r9 = t[1];
                if ("object" != typeof r9 || Array.isArray(r9)) return e.error("Collator options argument must be an object.");
                const n5 = e.parse((void 0) !== r9["case-sensitive"] && r9["case-sensitive"], 1, oe);
                if (!n5) return null;
                const i3 = e.parse((void 0) !== r9["diacritic-sensitive"] && r9["diacritic-sensitive"], 1, oe);
                if (!i3) return null;
                let s3 = null;
                return r9.locale && (s3 = e.parse(r9.locale, 1, ae), !s3) ? null : new We(n5, i3, s3);
            }
            evaluate(t) {
                return new Te(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
            }
            eachChild(t) {
                t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t23 = {
                };
                return t23["case-sensitive"] = this.caseSensitive.serialize(), t23["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t23.locale = this.locale.serialize()), [
                    "collator",
                    t23
                ];
            }
        }
        const Je = 8192;
        function Qe(t23, e16) {
            t23[0] = Math.min(t23[0], e16[0]), t23[1] = Math.min(t23[1], e16[1]), t23[2] = Math.max(t23[2], e16[0]), t23[3] = Math.max(t23[3], e16[1]);
        }
        function tr(t23, e16) {
            return !(t23[0] <= e16[0] || t23[2] >= e16[2] || t23[1] <= e16[1] || t23[3] >= e16[3]);
        }
        function er(t23, e16) {
            const r9 = (180 + t23[0]) / 360, n5 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t23[1] * Math.PI / 360))) / 360, i3 = Math.pow(2, e16.z);
            return [
                Math.round(r9 * i3 * Je),
                Math.round(n5 * i3 * Je)
            ];
        }
        function rr(t23, e16, r9) {
            const n5 = t23[0] - e16[0], i3 = t23[1] - e16[1], s3 = t23[0] - r9[0], a2 = t23[1] - r9[1];
            return n5 * a2 - s3 * i3 == 0 && n5 * s3 <= 0 && i3 * a2 <= 0;
        }
        function nr(t23, e16) {
            let r9 = !1;
            for(let a2 = 0, o2 = e16.length; a2 < o2; a2++){
                const o2 = e16[a2];
                for(let e17 = 0, a3 = o2.length; e17 < a3 - 1; e17++){
                    if (rr(t23, o2[e17], o2[e17 + 1])) return !1;
                    (i4 = o2[e17])[1] > (n5 = t23)[1] != (s4 = o2[e17 + 1])[1] > n5[1] && n5[0] < (s4[0] - i4[0]) * (n5[1] - i4[1]) / (s4[1] - i4[1]) + i4[0] && (r9 = !r9);
                }
            }
            var n5, i4, s4;
            return r9;
        }
        function ir(t23, e16) {
            for(let r9 = 0; r9 < e16.length; r9++)if (nr(t23, e16[r9])) return !0;
            return !1;
        }
        function sr(t23, e16, r9, n5) {
            const i4 = n5[0] - r9[0], s4 = n5[1] - r9[1], a2 = (t23[0] - r9[0]) * s4 - i4 * (t23[1] - r9[1]), o2 = (e16[0] - r9[0]) * s4 - i4 * (e16[1] - r9[1]);
            return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
        }
        function ar(t23, e16, r9) {
            for (const u2 of r9)for(let r10 = 0; r10 < u2.length - 1; ++r10)if (0 != (o3 = [
                (a3 = u2[r10 + 1])[0] - (s4 = u2[r10])[0],
                a3[1] - s4[1]
            ])[0] * (l3 = [
                (i4 = e16)[0] - (n5 = t23)[0],
                i4[1] - n5[1]
            ])[1] - o3[1] * l3[0] && sr(n5, i4, s4, a3) && sr(s4, a3, n5, i4)) return !0;
            var n5, i4, s4, a3, o3, l3;
            return !1;
        }
        function or(t23, e16) {
            for(let r9 = 0; r9 < t23.length; ++r9)if (!nr(t23[r9], e16)) return !1;
            for(let r10 = 0; r10 < t23.length - 1; ++r10)if (ar(t23[r10], t23[r10 + 1], e16)) return !1;
            return !0;
        }
        function lr(t23, e16) {
            for(let r9 = 0; r9 < e16.length; r9++)if (or(t23, e16[r9])) return !0;
            return !1;
        }
        function ur(t23, e16, r9) {
            const n5 = [];
            for(let i4 = 0; i4 < t23.length; i4++){
                const s4 = [];
                for(let n6 = 0; n6 < t23[i4].length; n6++){
                    const a3 = er(t23[i4][n6], r9);
                    Qe(e16, a3), s4.push(a3);
                }
                n5.push(s4);
            }
            return n5;
        }
        function cr(t23, e16, r9) {
            const n5 = [];
            for(let i4 = 0; i4 < t23.length; i4++){
                const s4 = ur(t23[i4], e16, r9);
                n5.push(s4);
            }
            return n5;
        }
        function hr(t23, e16, r9, n5) {
            if (t23[0] < r9[0] || t23[0] > r9[2]) {
                const e17 = 0.5 * n5;
                let i4 = t23[0] - r9[0] > e17 ? -n5 : r9[0] - t23[0] > e17 ? n5 : 0;
                0 === i4 && (i4 = t23[0] - r9[2] > e17 ? -n5 : r9[2] - t23[0] > e17 ? n5 : 0), t23[0] += i4;
            }
            Qe(e16, t23);
        }
        function pr(t23, e16, r9, n5) {
            const i4 = Math.pow(2, n5.z) * Je, s4 = [
                n5.x * Je,
                n5.y * Je
            ], a3 = [];
            if (!t23) return a3;
            for (const n6 of t23)for (const t24 of n6){
                const n7 = [
                    t24.x + s4[0],
                    t24.y + s4[1]
                ];
                hr(n7, e16, r9, i4), a3.push(n7);
            }
            return a3;
        }
        function fr(t23, e16, r9, n5) {
            const i4 = Math.pow(2, n5.z) * Je, s4 = [
                n5.x * Je,
                n5.y * Je
            ], a3 = [];
            if (!t23) return a3;
            for (const r10 of t23){
                const t24 = [];
                for (const n6 of r10){
                    const r11 = [
                        n6.x + s4[0],
                        n6.y + s4[1]
                    ];
                    Qe(e16, r11), t24.push(r11);
                }
                a3.push(t24);
            }
            if (e16[2] - e16[0] <= i4 / 2) {
                (o3 = e16)[0] = o3[1] = 1 / 0, o3[2] = o3[3] = -1 / 0;
                for (const t24 of a3)for (const n6 of t24)hr(n6, e16, r9, i4);
            }
            var o3;
            return a3;
        }
        class dr {
            constructor(t23, e16){
                this.type = oe, this.geojson = t23, this.geometries = e16;
            }
            static parse(t, e) {
                if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                if (Pe(t[1])) {
                    const e17 = t[1];
                    if ("FeatureCollection" === e17.type) for(let t24 = 0; t24 < e17.features.length; ++t24){
                        const r9 = e17.features[t24].geometry.type;
                        if ("Polygon" === r9 || "MultiPolygon" === r9) return new dr(e17, e17.features[t24].geometry);
                    }
                    else if ("Feature" === e17.type) {
                        const t25 = e17.geometry.type;
                        if ("Polygon" === t25 || "MultiPolygon" === t25) return new dr(e17, e17.geometry);
                    } else if ("Polygon" === e17.type || "MultiPolygon" === e17.type) return new dr(e17, e17);
                }
                return e.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t) {
                if (null != t.geometry() && null != t.canonicalID()) {
                    if ("Point" === t.geometryType()) return (function(t24, e17) {
                        const r9 = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n5 = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i4 = t24.canonicalID();
                        if (!i4) return !1;
                        if ("Polygon" === e17.type) {
                            const s4 = ur(e17.coordinates, n5, i4), a3 = pr(t24.geometry(), r9, n5, i4);
                            if (!tr(r9, n5)) return !1;
                            for (const t25 of a3)if (!nr(t25, s4)) return !1;
                        }
                        if ("MultiPolygon" === e17.type) {
                            const s4 = cr(e17.coordinates, n5, i4), a3 = pr(t24.geometry(), r9, n5, i4);
                            if (!tr(r9, n5)) return !1;
                            for (const t25 of a3)if (!ir(t25, s4)) return !1;
                        }
                        return !0;
                    })(t, this.geometries);
                    if ("LineString" === t.geometryType()) return (function(t24, e17) {
                        const r9 = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n5 = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i4 = t24.canonicalID();
                        if (!i4) return !1;
                        if ("Polygon" === e17.type) {
                            const s4 = ur(e17.coordinates, n5, i4), a3 = fr(t24.geometry(), r9, n5, i4);
                            if (!tr(r9, n5)) return !1;
                            for (const t25 of a3)if (!or(t25, s4)) return !1;
                        }
                        if ("MultiPolygon" === e17.type) {
                            const s4 = cr(e17.coordinates, n5, i4), a3 = fr(t24.geometry(), r9, n5, i4);
                            if (!tr(r9, n5)) return !1;
                            for (const t25 of a3)if (!lr(t25, s4)) return !1;
                        }
                        return !0;
                    })(t, this.geometries);
                }
                return !1;
            }
            eachChild() {
            }
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "within",
                    this.geojson
                ];
            }
        }
        var yr = dr;
        function mr(t24) {
            if (t24 instanceof He) {
                if ("get" === t24.name && 1 === t24.args.length) return !1;
                if ("feature-state" === t24.name) return !1;
                if ("has" === t24.name && 1 === t24.args.length) return !1;
                if ("properties" === t24.name || "geometry-type" === t24.name || "id" === t24.name) return !1;
                if (/^filter-/.test(t24.name)) return !1;
            }
            if (t24 instanceof yr) return !1;
            let e17 = !0;
            return t24.eachChild((t25)=>{
                e17 && !mr(t25) && (e17 = !1);
            }), e17;
        }
        function gr(t24) {
            if (t24 instanceof He && "feature-state" === t24.name) return !1;
            let e17 = !0;
            return t24.eachChild((t25)=>{
                e17 && !gr(t25) && (e17 = !1);
            }), e17;
        }
        function xr(t24, e17) {
            if (t24 instanceof He && e17.indexOf(t24.name) >= 0) return !1;
            let r9 = !0;
            return t24.eachChild((t25)=>{
                r9 && !xr(t25, e17) && (r9 = !1);
            }), r9;
        }
        class vr {
            constructor(t24, e17){
                this.type = e17.type, this.name = t24, this.boundExpression = e17;
            }
            static parse(t, e) {
                if (2 !== t.length || "string" != typeof t[1]) return e.error("'var' expression requires exactly one string literal argument.");
                const r9 = t[1];
                return e.scope.has(r9) ? new vr(r9, e.scope.get(r9)) : e.error(`Unknown variable "${r9}". Make sure "${r9}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t) {
                return this.boundExpression.evaluate(t);
            }
            eachChild() {
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "var",
                    this.name
                ];
            }
        }
        var br = vr;
        class wr {
            constructor(t25, e18 = [], r9, n5 = new ne, i4 = []){
                this.registry = t25, this.path = e18, this.key = e18.map((t26)=>`[${t26}]`
                ).join(""), this.scope = n5, this.errors = i4, this.expectedType = r9;
            }
            parse(t, e, r, n, i = {
            }) {
                return e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);
            }
            _parse(t, e) {
                function r10(t26, e19, r11) {
                    return "assert" === r11 ? new $e(e19, [
                        t26
                    ]) : "coerce" === r11 ? new Xe(e19, [
                        t26
                    ]) : t26;
                }
                if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = [
                    "literal",
                    t
                ]), Array.isArray(t)) {
                    if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    const n6 = t[0];
                    if ("string" != typeof n6) return this.error(`Expression name must be a string, but found ${typeof n6} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                    const i5 = this.registry[n6];
                    if (i5) {
                        let n7 = i5.parse(t, this);
                        if (!n7) return null;
                        if (this.expectedType) {
                            const t26 = this.expectedType, i6 = n7.type;
                            if ("string" !== t26.kind && "number" !== t26.kind && "boolean" !== t26.kind && "object" !== t26.kind && "array" !== t26.kind || "value" !== i6.kind) {
                                if ("color" !== t26.kind && "formatted" !== t26.kind && "resolvedImage" !== t26.kind || "value" !== i6.kind && "string" !== i6.kind) {
                                    if (this.checkSubtype(t26, i6)) return null;
                                } else n7 = r10(n7, t26, e.typeAnnotation || "coerce");
                            } else n7 = r10(n7, t26, e.typeAnnotation || "assert");
                        }
                        if (!(n7 instanceof Fe) && "resolvedImage" !== n7.type.kind && Ar(n7)) {
                            const t26 = new Ke;
                            try {
                                n7 = new Fe(n7.type, n7.evaluate(t26));
                            } catch (t27) {
                                return this.error(t27.message), null;
                            }
                        }
                        return n7;
                    }
                    return this.error(`Unknown expression "${n6}". If you wanted a literal array, use ["literal", [...]].`, 0);
                }
                return this.error((void 0) === t ? "'undefined' value invalid. Use null instead." : "object" == typeof t ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
            }
            concat(t, e, r) {
                const n6 = "number" == typeof t ? this.path.concat(t) : this.path, i5 = r ? this.scope.concat(r) : this.scope;
                return new wr(this.registry, n6, e || null, i5, this.errors);
            }
            error(t, ...e) {
                const r10 = `${this.key}${e.map((t26)=>`[${t26}]`
                ).join("")}`;
                this.errors.push(new ee(r10, t));
            }
            checkSubtype(t, e) {
                const r10 = ge(t, e);
                return r10 && this.error(r10), r10;
            }
        }
        var _r = wr;
        function Ar(t26) {
            if (t26 instanceof br) return Ar(t26.boundExpression);
            if (t26 instanceof He && "error" === t26.name) return !1;
            if (t26 instanceof We) return !1;
            if (t26 instanceof yr) return !1;
            const e19 = t26 instanceof Xe || t26 instanceof $e;
            let r10 = !0;
            return t26.eachChild((t27)=>{
                r10 = e19 ? r10 && Ar(t27) : r10 && t27 instanceof Fe;
            }), !!r10 && mr(t26) && xr(t26, [
                "zoom",
                "heatmap-density",
                "line-progress",
                "sky-radial-progress",
                "accumulated",
                "is-supported-script",
                "pitch",
                "distance-from-center"
            ]);
        }
        function Sr(t26, e19) {
            const r10 = t26.length - 1;
            let n6, i5, s4 = 0, a3 = r10, o3 = 0;
            for(; s4 <= a3;)if (o3 = Math.floor((s4 + a3) / 2), n6 = t26[o3], i5 = t26[o3 + 1], n6 <= e19) {
                if (o3 === r10 || e19 < i5) return o3;
                s4 = o3 + 1;
            } else {
                if (!(n6 > e19)) throw new Re("Input is not a number.");
                a3 = o3 - 1;
            }
            return 0;
        }
        class kr {
            constructor(t26, e19, r10){
                this.type = t26, this.input = e19, this.labels = [], this.outputs = [];
                for (const [t27, e20] of r10)this.labels.push(t27), this.outputs.push(e20);
            }
            static parse(t, e) {
                if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
                const r11 = e.parse(t[1], 1, se);
                if (!r11) return null;
                const n6 = [];
                let i5 = null;
                e.expectedType && "value" !== e.expectedType.kind && (i5 = e.expectedType);
                for(let r12 = 1; r12 < t.length; r12 += 2){
                    const s4 = 1 === r12 ? -1 / 0 : t[r12], a3 = t[r12 + 1], o3 = r12, l3 = r12 + 1;
                    if ("number" != typeof s4) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o3);
                    if (n6.length && n6[n6.length - 1][0] >= s4) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o3);
                    const u2 = e.parse(a3, l3, i5);
                    if (!u2) return null;
                    i5 = i5 || u2.type, n6.push([
                        s4,
                        u2
                    ]);
                }
                return new kr(i5, r11, n6);
            }
            evaluate(t) {
                const e21 = this.labels, r11 = this.outputs;
                if (1 === e21.length) return r11[0].evaluate(t);
                const n6 = this.input.evaluate(t);
                if (n6 <= e21[0]) return r11[0].evaluate(t);
                const i5 = e21.length;
                return n6 >= e21[i5 - 1] ? r11[i5 - 1].evaluate(t) : r11[Sr(e21, n6)].evaluate(t);
            }
            eachChild(t) {
                t(this.input);
                for (const e21 of this.outputs)t(e21);
            }
            outputDefined() {
                return this.outputs.every((t28)=>t28.outputDefined()
                );
            }
            serialize() {
                const t28 = [
                    "step",
                    this.input.serialize()
                ];
                for(let e21 = 0; e21 < this.labels.length; e21++)e21 > 0 && t28.push(this.labels[e21]), t28.push(this.outputs[e21].serialize());
                return t28;
            }
        }
        var Ir = kr;
        function Mr(t28, e21, r11) {
            return t28 * (1 - r11) + e21 * r11;
        }
        var Tr = Object.freeze({
            __proto__: null,
            number: Mr,
            color: function(t28, e21, r11) {
                return new Me(Mr(t28.r, e21.r, r11), Mr(t28.g, e21.g, r11), Mr(t28.b, e21.b, r11), Mr(t28.a, e21.a, r11));
            },
            array: function(t28, e21, r11) {
                return t28.map((t29, n6)=>Mr(t29, e21[n6], r11)
                );
            }
        });
        const zr = 0.95047, Br = 1.08883, Er = 4 / 29, Cr = 6 / 29, Pr = 3 * Cr * Cr, Dr = Math.PI / 180, Vr = 180 / Math.PI;
        function Lr(t28) {
            return t28 > 0.008856451679035631 ? Math.pow(t28, 1 / 3) : t28 / Pr + Er;
        }
        function Fr(t28) {
            return t28 > Cr ? t28 * t28 * t28 : Pr * (t28 - Er);
        }
        function Rr(t28) {
            return 255 * (t28 <= 0.0031308 ? 12.92 * t28 : 1.055 * Math.pow(t28, 1 / 2.4) - 0.055);
        }
        function jr(t28) {
            return (t28 /= 255) <= 0.04045 ? t28 / 12.92 : Math.pow((t28 + 0.055) / 1.055, 2.4);
        }
        function Ur(t28) {
            const e21 = jr(t28.r), r11 = jr(t28.g), n6 = jr(t28.b), i5 = Lr((0.4124564 * e21 + 0.3575761 * r11 + 0.1804375 * n6) / zr), s4 = Lr((0.2126729 * e21 + 0.7151522 * r11 + 0.072175 * n6) / 1);
            return {
                l: 116 * s4 - 16,
                a: 500 * (i5 - s4),
                b: 200 * (s4 - Lr((0.0193339 * e21 + 0.119192 * r11 + 0.9503041 * n6) / Br)),
                alpha: t28.a
            };
        }
        function $r(t28) {
            let e21 = (t28.l + 16) / 116, r11 = isNaN(t28.a) ? e21 : e21 + t28.a / 500, n6 = isNaN(t28.b) ? e21 : e21 - t28.b / 200;
            return e21 = 1 * Fr(e21), r11 = zr * Fr(r11), n6 = Br * Fr(n6), new Me(Rr(3.2404542 * r11 - 1.5371385 * e21 - 0.4985314 * n6), Rr(-0.969266 * r11 + 1.8760108 * e21 + 0.041556 * n6), Rr(0.0556434 * r11 - 0.2040259 * e21 + 1.0572252 * n6), t28.alpha);
        }
        function Or(t28, e21, r11) {
            const n6 = e21 - t28;
            return t28 + r11 * (n6 > 180 || n6 < -180 ? n6 - 360 * Math.round(n6 / 360) : n6);
        }
        const qr = {
            forward: Ur,
            reverse: $r,
            interpolate: function(t28, e21, r11) {
                return {
                    l: Mr(t28.l, e21.l, r11),
                    a: Mr(t28.a, e21.a, r11),
                    b: Mr(t28.b, e21.b, r11),
                    alpha: Mr(t28.alpha, e21.alpha, r11)
                };
            }
        }, Nr = {
            forward: function(t28) {
                const { l: e21 , a: r11 , b: n6  } = Ur(t28), i5 = Math.atan2(n6, r11) * Vr;
                return {
                    h: i5 < 0 ? i5 + 360 : i5,
                    c: Math.sqrt(r11 * r11 + n6 * n6),
                    l: e21,
                    alpha: t28.a
                };
            },
            reverse: function(t28) {
                const e21 = t28.h * Dr, r11 = t28.c;
                return $r({
                    l: t28.l,
                    a: Math.cos(e21) * r11,
                    b: Math.sin(e21) * r11,
                    alpha: t28.alpha
                });
            },
            interpolate: function(t28, e21, r11) {
                return {
                    h: Or(t28.h, e21.h, r11),
                    c: Mr(t28.c, e21.c, r11),
                    l: Mr(t28.l, e21.l, r11),
                    alpha: Mr(t28.alpha, e21.alpha, r11)
                };
            }
        };
        var Gr = Object.freeze({
            __proto__: null,
            lab: qr,
            hcl: Nr
        });
        class Xr {
            constructor(t28, e21, r11, n6, i5){
                this.type = t28, this.operator = e21, this.interpolation = r11, this.input = n6, this.labels = [], this.outputs = [];
                for (const [t29, e22] of i5)this.labels.push(t29), this.outputs.push(e22);
            }
            static interpolationFactor(t, e, r, n) {
                let i6 = 0;
                if ("exponential" === t.name) i6 = Zr(e, t.base, r, n);
                else if ("linear" === t.name) i6 = Zr(e, 1, r, n);
                else if ("cubic-bezier" === t.name) {
                    const s4 = t.controlPoints;
                    i6 = new p2(s4[0], s4[1], s4[2], s4[3]).solve(Zr(e, 1, r, n));
                }
                return i6;
            }
            static parse(t, e) {
                let [r12, n7, i6, ...s4] = t;
                if (!Array.isArray(n7) || 0 === n7.length) return e.error("Expected an interpolation type expression.", 1);
                if ("linear" === n7[0]) n7 = {
                    name: "linear"
                };
                else if ("exponential" === n7[0]) {
                    const t30 = n7[1];
                    if ("number" != typeof t30) return e.error("Exponential interpolation requires a numeric base.", 1, 1);
                    n7 = {
                        name: "exponential",
                        base: t30
                    };
                } else {
                    if ("cubic-bezier" !== n7[0]) return e.error(`Unknown interpolation type ${String(n7[0])}`, 1, 0);
                    {
                        const t30 = n7.slice(1);
                        if (4 !== t30.length || t30.some((t31)=>"number" != typeof t31 || t31 < 0 || t31 > 1
                        )) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        n7 = {
                            name: "cubic-bezier",
                            controlPoints: t30
                        };
                    }
                }
                if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
                if (i6 = e.parse(i6, 2, se), !i6) return null;
                const a3 = [];
                let o3 = null;
                "interpolate-hcl" === r12 || "interpolate-lab" === r12 ? o3 = le : e.expectedType && "value" !== e.expectedType.kind && (o3 = e.expectedType);
                for(let t30 = 0; t30 < s4.length; t30 += 2){
                    const r13 = s4[t30], n8 = s4[t30 + 1], i7 = t30 + 3, l3 = t30 + 4;
                    if ("number" != typeof r13) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i7);
                    if (a3.length && a3[a3.length - 1][0] >= r13) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i7);
                    const u2 = e.parse(n8, l3, o3);
                    if (!u2) return null;
                    o3 = o3 || u2.type, a3.push([
                        r13,
                        u2
                    ]);
                }
                return "number" === o3.kind || "color" === o3.kind || "array" === o3.kind && "number" === o3.itemType.kind && "number" == typeof o3.N ? new Xr(o3, r12, n7, i6, a3) : e.error(`Type ${ye(o3)} is not interpolatable.`);
            }
            evaluate(t) {
                const e23 = this.labels, r12 = this.outputs;
                if (1 === e23.length) return r12[0].evaluate(t);
                const n7 = this.input.evaluate(t);
                if (n7 <= e23[0]) return r12[0].evaluate(t);
                const i6 = e23.length;
                if (n7 >= e23[i6 - 1]) return r12[i6 - 1].evaluate(t);
                const s4 = Sr(e23, n7), a3 = Xr.interpolationFactor(this.interpolation, n7, e23[s4], e23[s4 + 1]), o3 = r12[s4].evaluate(t), l3 = r12[s4 + 1].evaluate(t);
                return "interpolate" === this.operator ? Tr[this.type.kind.toLowerCase()](o3, l3, a3) : "interpolate-hcl" === this.operator ? Nr.reverse(Nr.interpolate(Nr.forward(o3), Nr.forward(l3), a3)) : qr.reverse(qr.interpolate(qr.forward(o3), qr.forward(l3), a3));
            }
            eachChild(t) {
                t(this.input);
                for (const e23 of this.outputs)t(e23);
            }
            outputDefined() {
                return this.outputs.every((t30)=>t30.outputDefined()
                );
            }
            serialize() {
                let t30;
                t30 = "linear" === this.interpolation.name ? [
                    "linear"
                ] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? [
                    "linear"
                ] : [
                    "exponential",
                    this.interpolation.base
                ] : [
                    "cubic-bezier"
                ].concat(this.interpolation.controlPoints);
                const e23 = [
                    this.operator,
                    t30,
                    this.input.serialize()
                ];
                for(let t31 = 0; t31 < this.labels.length; t31++)e23.push(this.labels[t31], this.outputs[t31].serialize());
                return e23;
            }
        }
        function Zr(t30, e23, r12, n7) {
            const i6 = n7 - r12, s4 = t30 - r12;
            return 0 === i6 ? 0 : 1 === e23 ? s4 / i6 : (Math.pow(e23, s4) - 1) / (Math.pow(e23, i6) - 1);
        }
        var Kr = Xr;
        class Yr {
            constructor(t30, e23){
                this.type = t30, this.args = e23;
            }
            static parse(t, e) {
                if (t.length < 2) return e.error("Expectected at least one argument.");
                let r12 = null;
                const n7 = e.expectedType;
                n7 && "value" !== n7.kind && (r12 = n7);
                const i6 = [];
                for (const n8 of t.slice(1)){
                    const t31 = e.parse(n8, 1 + i6.length, r12, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!t31) return null;
                    r12 = r12 || t31.type, i6.push(t31);
                }
                const s4 = n7 && i6.some((t31)=>ge(n7, t31.type)
                );
                return new Yr(s4 ? ce : r12, i6);
            }
            evaluate(t) {
                let e24, r12 = null, n7 = 0;
                for (const i6 of this.args){
                    if (n7++, r12 = i6.evaluate(t), r12 && r12 instanceof Ee && !r12.available && (e24 || (e24 = r12), r12 = null, n7 === this.args.length)) return e24;
                    if (null !== r12) break;
                }
                return r12;
            }
            eachChild(t) {
                this.args.forEach(t);
            }
            outputDefined() {
                return this.args.every((t31)=>t31.outputDefined()
                );
            }
            serialize() {
                const t31 = [
                    "coalesce"
                ];
                return this.eachChild((e24)=>{
                    t31.push(e24.serialize());
                }), t31;
            }
        }
        var Hr = Yr;
        class Wr {
            constructor(t31, e24){
                this.type = e24.type, this.bindings = [].concat(t31), this.result = e24;
            }
            evaluate(t) {
                return this.result.evaluate(t);
            }
            eachChild(t) {
                for (const e25 of this.bindings)t(e25[1]);
                t(this.result);
            }
            static parse(t, e) {
                if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
                const r12 = [];
                for(let n7 = 1; n7 < t.length - 1; n7 += 2){
                    const i6 = t[n7];
                    if ("string" != typeof i6) return e.error(`Expected string, but found ${typeof i6} instead.`, n7);
                    if (/[^a-zA-Z0-9_]/.test(i6)) return e.error("Variable names must contain only alphanumeric characters or '_'.", n7);
                    const s4 = e.parse(t[n7 + 1], n7 + 1);
                    if (!s4) return null;
                    r12.push([
                        i6,
                        s4
                    ]);
                }
                const n8 = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r12);
                return n8 ? new Wr(r12, n8) : null;
            }
            outputDefined() {
                return this.result.outputDefined();
            }
            serialize() {
                const t32 = [
                    "let"
                ];
                for (const [e25, r12] of this.bindings)t32.push(e25, r12.serialize());
                return t32.push(this.result.serialize()), t32;
            }
        }
        var Jr = Wr;
        class Qr {
            constructor(t32, e25, r12){
                this.type = t32, this.index = e25, this.input = r12;
            }
            static parse(t, e) {
                if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                const r13 = e.parse(t[1], 1, se), n7 = e.parse(t[2], 2, de(e.expectedType || ce));
                return r13 && n7 ? new Qr(n7.type.itemType, r13, n7) : null;
            }
            evaluate(t) {
                const e26 = this.index.evaluate(t), r13 = this.input.evaluate(t);
                if (e26 < 0) throw new Re(`Array index out of bounds: ${e26} < 0.`);
                if (e26 >= r13.length) throw new Re(`Array index out of bounds: ${e26} > ${r13.length - 1}.`);
                if (e26 !== Math.floor(e26)) throw new Re(`Array index must be an integer, but found ${e26} instead.`);
                return r13[e26];
            }
            eachChild(t) {
                t(this.index), t(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "at",
                    this.index.serialize(),
                    this.input.serialize()
                ];
            }
        }
        var tn = Qr;
        class en {
            constructor(t33, e26){
                this.type = oe, this.needle = t33, this.haystack = e26;
            }
            static parse(t, e) {
                if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                const r13 = e.parse(t[1], 1, ce), n7 = e.parse(t[2], 2, ce);
                return r13 && n7 ? xe(r13.type, [
                    oe,
                    ae,
                    se,
                    ie,
                    ce
                ]) ? new en(r13, n7) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r13.type)} instead`) : null;
            }
            evaluate(t) {
                const e27 = this.needle.evaluate(t), r13 = this.haystack.evaluate(t);
                if (null == r13) return !1;
                if (!ve(e27, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e27))} instead.`);
                if (!ve(r13, [
                    "string",
                    "array"
                ])) throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r13))} instead.`);
                return r13.indexOf(e27) >= 0;
            }
            eachChild(t) {
                t(this.needle), t(this.haystack);
            }
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "in",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        var rn = en;
        class nn {
            constructor(t34, e27, r13){
                this.type = se, this.needle = t34, this.haystack = e27, this.fromIndex = r13;
            }
            static parse(t, e) {
                if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                const r14 = e.parse(t[1], 1, ce), n7 = e.parse(t[2], 2, ce);
                if (!r14 || !n7) return null;
                if (!xe(r14.type, [
                    oe,
                    ae,
                    se,
                    ie,
                    ce
                ])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ye(r14.type)} instead`);
                if (4 === t.length) {
                    const i6 = e.parse(t[3], 3, se);
                    return i6 ? new nn(r14, n7, i6) : null;
                }
                return new nn(r14, n7);
            }
            evaluate(t) {
                const e28 = this.needle.evaluate(t), r14 = this.haystack.evaluate(t);
                if (!ve(e28, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new Re(`Expected first argument to be of type boolean, string, number or null, but found ${ye(De(e28))} instead.`);
                if (!ve(r14, [
                    "string",
                    "array"
                ])) throw new Re(`Expected second argument to be of type array or string, but found ${ye(De(r14))} instead.`);
                if (this.fromIndex) {
                    const n7 = this.fromIndex.evaluate(t);
                    return r14.indexOf(e28, n7);
                }
                return r14.indexOf(e28);
            }
            eachChild(t) {
                t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.fromIndex && (void 0) !== this.fromIndex) {
                    const t35 = this.fromIndex.serialize();
                    return [
                        "index-of",
                        this.needle.serialize(),
                        this.haystack.serialize(),
                        t35
                    ];
                }
                return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        var sn = nn;
        class an {
            constructor(t35, e28, r14, n7, i6, s4){
                this.inputType = t35, this.type = e28, this.input = r14, this.cases = n7, this.outputs = i6, this.otherwise = s4;
            }
            static parse(t, e) {
                if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                if (t.length % 2 != 1) return e.error("Expected an even number of arguments.");
                let r15, n8;
                e.expectedType && "value" !== e.expectedType.kind && (n8 = e.expectedType);
                const i7 = {
                }, s5 = [];
                for(let a3 = 2; a3 < t.length - 1; a3 += 2){
                    let o3 = t[a3];
                    const l3 = t[a3 + 1];
                    Array.isArray(o3) || (o3 = [
                        o3
                    ]);
                    const u2 = e.concat(a3);
                    if (0 === o3.length) return u2.error("Expected at least one branch label.");
                    for (const t36 of o3){
                        if ("number" != typeof t36 && "string" != typeof t36) return u2.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof t36 && Math.abs(t36) > Number.MAX_SAFE_INTEGER) return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof t36 && Math.floor(t36) !== t36) return u2.error("Numeric branch labels must be integer values.");
                        if (r15) {
                            if (u2.checkSubtype(r15, De(t36))) return null;
                        } else r15 = De(t36);
                        if ((void 0) !== i7[String(t36)]) return u2.error("Branch labels must be unique.");
                        i7[String(t36)] = s5.length;
                    }
                    const c3 = e.parse(l3, a3, n8);
                    if (!c3) return null;
                    n8 = n8 || c3.type, s5.push(c3);
                }
                const a4 = e.parse(t[1], 1, ce);
                if (!a4) return null;
                const o3 = e.parse(t[t.length - 1], t.length - 1, n8);
                return o3 ? "value" !== a4.type.kind && e.concat(1).checkSubtype(r15, a4.type) ? null : new an(r15, n8, a4, i7, s5, o3) : null;
            }
            evaluate(t) {
                const e29 = this.input.evaluate(t);
                return (De(e29) === this.inputType && this.outputs[this.cases[e29]] || this.otherwise).evaluate(t);
            }
            eachChild(t) {
                t(this.input), this.outputs.forEach(t), t(this.otherwise);
            }
            outputDefined() {
                return this.outputs.every((t36)=>t36.outputDefined()
                ) && this.otherwise.outputDefined();
            }
            serialize() {
                const t36 = [
                    "match",
                    this.input.serialize()
                ], e29 = Object.keys(this.cases).sort(), r15 = [], n8 = {
                };
                for (const t37 of e29){
                    const e30 = n8[this.cases[t37]];
                    (void 0) === e30 ? (n8[this.cases[t37]] = r15.length, r15.push([
                        this.cases[t37],
                        [
                            t37
                        ]
                    ])) : r15[e30][1].push(t37);
                }
                const i7 = (t38)=>"number" === this.inputType.kind ? Number(t38) : t38
                ;
                for (const [e30, n9] of r15)t36.push(1 === n9.length ? i7(n9[0]) : n9.map(i7)), t36.push(this.outputs[e30].serialize());
                return t36.push(this.otherwise.serialize()), t36;
            }
        }
        var on = an;
        class ln {
            constructor(t36, e29, r15){
                this.type = t36, this.branches = e29, this.otherwise = r15;
            }
            static parse(t, e) {
                if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
                if (t.length % 2 != 0) return e.error("Expected an odd number of arguments.");
                let r16;
                e.expectedType && "value" !== e.expectedType.kind && (r16 = e.expectedType);
                const n8 = [];
                for(let i7 = 1; i7 < t.length - 1; i7 += 2){
                    const s5 = e.parse(t[i7], i7, oe);
                    if (!s5) return null;
                    const a3 = e.parse(t[i7 + 1], i7 + 1, r16);
                    if (!a3) return null;
                    n8.push([
                        s5,
                        a3
                    ]), r16 = r16 || a3.type;
                }
                const i8 = e.parse(t[t.length - 1], t.length - 1, r16);
                return i8 ? new ln(r16, n8, i8) : null;
            }
            evaluate(t) {
                for (const [e30, r16] of this.branches)if (e30.evaluate(t)) return r16.evaluate(t);
                return this.otherwise.evaluate(t);
            }
            eachChild(t) {
                for (const [e30, r16] of this.branches)t(e30), t(r16);
                t(this.otherwise);
            }
            outputDefined() {
                return this.branches.every(([t37, e30])=>e30.outputDefined()
                ) && this.otherwise.outputDefined();
            }
            serialize() {
                const t37 = [
                    "case"
                ];
                return this.eachChild((e30)=>{
                    t37.push(e30.serialize());
                }), t37;
            }
        }
        var un = ln;
        class cn {
            constructor(t37, e30, r16, n8){
                this.type = t37, this.input = e30, this.beginIndex = r16, this.endIndex = n8;
            }
            static parse(t, e) {
                if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                const r17 = e.parse(t[1], 1, ce), n9 = e.parse(t[2], 2, se);
                if (!r17 || !n9) return null;
                if (!xe(r17.type, [
                    de(ce),
                    ae,
                    ce
                ])) return e.error(`Expected first argument to be of type array or string, but found ${ye(r17.type)} instead`);
                if (4 === t.length) {
                    const i7 = e.parse(t[3], 3, se);
                    return i7 ? new cn(r17.type, r17, n9, i7) : null;
                }
                return new cn(r17.type, r17, n9);
            }
            evaluate(t) {
                const e31 = this.input.evaluate(t), r17 = this.beginIndex.evaluate(t);
                if (!ve(e31, [
                    "string",
                    "array"
                ])) throw new Re(`Expected first argument to be of type array or string, but found ${ye(De(e31))} instead.`);
                if (this.endIndex) {
                    const n9 = this.endIndex.evaluate(t);
                    return e31.slice(r17, n9);
                }
                return e31.slice(r17);
            }
            eachChild(t) {
                t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.endIndex && (void 0) !== this.endIndex) {
                    const t38 = this.endIndex.serialize();
                    return [
                        "slice",
                        this.input.serialize(),
                        this.beginIndex.serialize(),
                        t38
                    ];
                }
                return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize()
                ];
            }
        }
        var hn = cn;
        function pn(t38, e31) {
            return "==" === t38 || "!=" === t38 ? "boolean" === e31.kind || "string" === e31.kind || "number" === e31.kind || "null" === e31.kind || "value" === e31.kind : "string" === e31.kind || "number" === e31.kind || "value" === e31.kind;
        }
        function fn(t38, e31, r17, n9) {
            return 0 === n9.compare(e31, r17);
        }
        function dn(t38, e31, r17) {
            const n9 = "==" !== t38 && "!=" !== t38;
            return class i7 {
                constructor(t39, e32, r18){
                    this.type = oe, this.lhs = t39, this.rhs = e32, this.collator = r18, this.hasUntypedArgument = "value" === t39.type.kind || "value" === e32.type.kind;
                }
                static parse(t, e) {
                    if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments.");
                    const r19 = t[0];
                    let s5 = e.parse(t[1], 1, ce);
                    if (!s5) return null;
                    if (!pn(r19, s5.type)) return e.concat(1).error(`"${r19}" comparisons are not supported for type '${ye(s5.type)}'.`);
                    let a3 = e.parse(t[2], 2, ce);
                    if (!a3) return null;
                    if (!pn(r19, a3.type)) return e.concat(2).error(`"${r19}" comparisons are not supported for type '${ye(a3.type)}'.`);
                    if (s5.type.kind !== a3.type.kind && "value" !== s5.type.kind && "value" !== a3.type.kind) return e.error(`Cannot compare types '${ye(s5.type)}' and '${ye(a3.type)}'.`);
                    n9 && ("value" === s5.type.kind && "value" !== a3.type.kind ? s5 = new $e(a3.type, [
                        s5
                    ]) : "value" !== s5.type.kind && "value" === a3.type.kind && (a3 = new $e(s5.type, [
                        a3
                    ])));
                    let o3 = null;
                    if (4 === t.length) {
                        if ("string" !== s5.type.kind && "string" !== a3.type.kind && "value" !== s5.type.kind && "value" !== a3.type.kind) return e.error("Cannot use collator to compare non-string types.");
                        if (o3 = e.parse(t[3], 3, he), !o3) return null;
                    }
                    return new i7(s5, a3, o3);
                }
                evaluate(i) {
                    const s5 = this.lhs.evaluate(i), a3 = this.rhs.evaluate(i);
                    if (n9 && this.hasUntypedArgument) {
                        const e33 = De(s5), r19 = De(a3);
                        if (e33.kind !== r19.kind || "string" !== e33.kind && "number" !== e33.kind) throw new Re(`Expected arguments for "${t38}" to be (string, string) or (number, number), but found (${e33.kind}, ${r19.kind}) instead.`);
                    }
                    if (this.collator && !n9 && this.hasUntypedArgument) {
                        const t40 = De(s5), r19 = De(a3);
                        if ("string" !== t40.kind || "string" !== r19.kind) return e31(i, s5, a3);
                    }
                    return this.collator ? r17(i, s5, a3, this.collator.evaluate(i)) : e31(i, s5, a3);
                }
                eachChild(t) {
                    t(this.lhs), t(this.rhs), this.collator && t(this.collator);
                }
                outputDefined() {
                    return !0;
                }
                serialize() {
                    const e33 = [
                        t38
                    ];
                    return this.eachChild((t40)=>{
                        e33.push(t40.serialize());
                    }), e33;
                }
            };
        }
        const yn = dn("==", function(t38, e31, r17) {
            return e31 === r17;
        }, fn), mn = dn("!=", function(t38, e31, r17) {
            return e31 !== r17;
        }, function(t38, e31, r17, n9) {
            return !fn(0, e31, r17, n9);
        }), gn = dn("<", function(t38, e31, r17) {
            return e31 < r17;
        }, function(t38, e31, r17, n9) {
            return n9.compare(e31, r17) < 0;
        }), xn = dn(">", function(t38, e31, r17) {
            return e31 > r17;
        }, function(t38, e31, r17, n9) {
            return n9.compare(e31, r17) > 0;
        }), vn = dn("<=", function(t38, e31, r17) {
            return e31 <= r17;
        }, function(t38, e31, r17, n9) {
            return n9.compare(e31, r17) <= 0;
        }), bn = dn(">=", function(t38, e31, r17) {
            return e31 >= r17;
        }, function(t38, e31, r17, n9) {
            return n9.compare(e31, r17) >= 0;
        });
        class wn {
            constructor(t38, e31, r17, n9, i7, s5){
                this.type = ae, this.number = t38, this.locale = e31, this.currency = r17, this.unit = n9, this.minFractionDigits = i7, this.maxFractionDigits = s5;
            }
            static parse(t, e) {
                if (3 !== t.length) return e.error("Expected two arguments.");
                const r18 = e.parse(t[1], 1, se);
                if (!r18) return null;
                const n10 = t[2];
                if ("object" != typeof n10 || Array.isArray(n10)) return e.error("NumberFormat options argument must be an object.");
                let i8 = null;
                if (n10.locale && (i8 = e.parse(n10.locale, 1, ae), !i8)) return null;
                let s6 = null;
                if (n10.currency && (s6 = e.parse(n10.currency, 1, ae), !s6)) return null;
                let a3 = null;
                if (n10.unit && (a3 = e.parse(n10.unit, 1, ae), !a3)) return null;
                let o3 = null;
                if (n10["min-fraction-digits"] && (o3 = e.parse(n10["min-fraction-digits"], 1, se), !o3)) return null;
                let l3 = null;
                return n10["max-fraction-digits"] && (l3 = e.parse(n10["max-fraction-digits"], 1, se), !l3) ? null : new wn(r18, i8, s6, a3, o3, l3);
            }
            evaluate(t) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
                    style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                    currency: this.currency ? this.currency.evaluate(t) : void 0,
                    unit: this.unit ? this.unit.evaluate(t) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
                }).format(this.number.evaluate(t));
            }
            eachChild(t) {
                t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.unit && t(this.unit), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t39 = {
                };
                return this.locale && (t39.locale = this.locale.serialize()), this.currency && (t39.currency = this.currency.serialize()), this.unit && (t39.unit = this.unit.serialize()), this.minFractionDigits && (t39["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t39["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
                    "number-format",
                    this.number.serialize(),
                    t39
                ];
            }
        }
        class _n {
            constructor(t39){
                this.type = se, this.input = t39;
            }
            static parse(t, e) {
                if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                const r18 = e.parse(t[1], 1);
                return r18 ? "array" !== r18.type.kind && "string" !== r18.type.kind && "value" !== r18.type.kind ? e.error(`Expected argument of type string or array, but found ${ye(r18.type)} instead.`) : new _n(r18) : null;
            }
            evaluate(t) {
                const e32 = this.input.evaluate(t);
                if ("string" == typeof e32) return e32.length;
                if (Array.isArray(e32)) return e32.length;
                throw new Re(`Expected value to be of type string or array, but found ${ye(De(e32))} instead.`);
            }
            eachChild(t) {
                t(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t40 = [
                    "length"
                ];
                return this.eachChild((e32)=>{
                    t40.push(e32.serialize());
                }), t40;
            }
        }
        const An = {
            "==": yn,
            "!=": mn,
            ">": xn,
            "<": gn,
            ">=": bn,
            "<=": vn,
            array: $e,
            at: tn,
            boolean: $e,
            case: un,
            coalesce: Hr,
            collator: We,
            format: Oe,
            image: qe,
            in: rn,
            "index-of": sn,
            interpolate: Kr,
            "interpolate-hcl": Kr,
            "interpolate-lab": Kr,
            length: _n,
            let: Jr,
            literal: Fe,
            match: on,
            number: $e,
            "number-format": wn,
            object: $e,
            slice: hn,
            step: Ir,
            string: $e,
            "to-boolean": Xe,
            "to-color": Xe,
            "to-number": Xe,
            "to-string": Xe,
            var: br,
            within: yr
        };
        function Sn(t40, [e32, r18, n10, i8]) {
            e32 = e32.evaluate(t40), r18 = r18.evaluate(t40), n10 = n10.evaluate(t40);
            const s6 = i8 ? i8.evaluate(t40) : 1, a3 = Ce(e32, r18, n10, s6);
            if (a3) throw new Re(a3);
            return new Me(e32 / 255 * s6, r18 / 255 * s6, n10 / 255 * s6, s6);
        }
        function kn(t40, e32) {
            return t40 in e32;
        }
        function In(t40, e32) {
            const r18 = e32[t40];
            return (void 0) === r18 ? null : r18;
        }
        function Mn(t40) {
            return {
                type: t40
            };
        }
        He.register(An, {
            error: [
                {
                    kind: "error"
                },
                [
                    ae
                ],
                (t40, [e32])=>{
                    throw new Re(e32.evaluate(t40));
                }
            ],
            typeof: [
                ae,
                [
                    ce
                ],
                (t40, [e32])=>ye(De(e32.evaluate(t40)))
            ],
            "to-rgba": [
                de(se, 4),
                [
                    le
                ],
                (t40, [e32])=>e32.evaluate(t40).toArray()
            ],
            rgb: [
                le,
                [
                    se,
                    se,
                    se
                ],
                Sn
            ],
            rgba: [
                le,
                [
                    se,
                    se,
                    se,
                    se
                ],
                Sn
            ],
            has: {
                type: oe,
                overloads: [
                    [
                        [
                            ae
                        ],
                        (t40, [e32])=>kn(e32.evaluate(t40), t40.properties())
                    ],
                    [
                        [
                            ae,
                            ue
                        ],
                        (t40, [e32, r18])=>kn(e32.evaluate(t40), r18.evaluate(t40))
                    ]
                ]
            },
            get: {
                type: ce,
                overloads: [
                    [
                        [
                            ae
                        ],
                        (t40, [e32])=>In(e32.evaluate(t40), t40.properties())
                    ],
                    [
                        [
                            ae,
                            ue
                        ],
                        (t40, [e32, r18])=>In(e32.evaluate(t40), r18.evaluate(t40))
                    ]
                ]
            },
            "feature-state": [
                ce,
                [
                    ae
                ],
                (t40, [e32])=>In(e32.evaluate(t40), t40.featureState || {
                    })
            ],
            properties: [
                ue,
                [],
                (t40)=>t40.properties()
            ],
            "geometry-type": [
                ae,
                [],
                (t40)=>t40.geometryType()
            ],
            id: [
                ce,
                [],
                (t40)=>t40.id()
            ],
            zoom: [
                se,
                [],
                (t40)=>t40.globals.zoom
            ],
            pitch: [
                se,
                [],
                (t40)=>t40.globals.pitch || 0
            ],
            "distance-from-center": [
                se,
                [],
                (t40)=>t40.distanceFromCenter()
            ],
            "heatmap-density": [
                se,
                [],
                (t40)=>t40.globals.heatmapDensity || 0
            ],
            "line-progress": [
                se,
                [],
                (t40)=>t40.globals.lineProgress || 0
            ],
            "sky-radial-progress": [
                se,
                [],
                (t40)=>t40.globals.skyRadialProgress || 0
            ],
            accumulated: [
                ce,
                [],
                (t40)=>(void 0) === t40.globals.accumulated ? null : t40.globals.accumulated
            ],
            "+": [
                se,
                Mn(se),
                (t40, e32)=>{
                    let r18 = 0;
                    for (const n10 of e32)r18 += n10.evaluate(t40);
                    return r18;
                }
            ],
            "*": [
                se,
                Mn(se),
                (t40, e32)=>{
                    let r18 = 1;
                    for (const n10 of e32)r18 *= n10.evaluate(t40);
                    return r18;
                }
            ],
            "-": {
                type: se,
                overloads: [
                    [
                        [
                            se,
                            se
                        ],
                        (t40, [e32, r18])=>e32.evaluate(t40) - r18.evaluate(t40)
                    ],
                    [
                        [
                            se
                        ],
                        (t40, [e32])=>-e32.evaluate(t40)
                    ]
                ]
            },
            "/": [
                se,
                [
                    se,
                    se
                ],
                (t40, [e32, r18])=>e32.evaluate(t40) / r18.evaluate(t40)
            ],
            "%": [
                se,
                [
                    se,
                    se
                ],
                (t40, [e32, r18])=>e32.evaluate(t40) % r18.evaluate(t40)
            ],
            ln2: [
                se,
                [],
                ()=>Math.LN2
            ],
            pi: [
                se,
                [],
                ()=>Math.PI
            ],
            e: [
                se,
                [],
                ()=>Math.E
            ],
            "^": [
                se,
                [
                    se,
                    se
                ],
                (t40, [e32, r18])=>Math.pow(e32.evaluate(t40), r18.evaluate(t40))
            ],
            sqrt: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.sqrt(e32.evaluate(t40))
            ],
            log10: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.log(e32.evaluate(t40)) / Math.LN10
            ],
            ln: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.log(e32.evaluate(t40))
            ],
            log2: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.log(e32.evaluate(t40)) / Math.LN2
            ],
            sin: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.sin(e32.evaluate(t40))
            ],
            cos: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.cos(e32.evaluate(t40))
            ],
            tan: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.tan(e32.evaluate(t40))
            ],
            asin: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.asin(e32.evaluate(t40))
            ],
            acos: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.acos(e32.evaluate(t40))
            ],
            atan: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.atan(e32.evaluate(t40))
            ],
            min: [
                se,
                Mn(se),
                (t40, e32)=>Math.min(...e32.map((e33)=>e33.evaluate(t40)
                    ))
            ],
            max: [
                se,
                Mn(se),
                (t40, e32)=>Math.max(...e32.map((e33)=>e33.evaluate(t40)
                    ))
            ],
            abs: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.abs(e32.evaluate(t40))
            ],
            round: [
                se,
                [
                    se
                ],
                (t40, [e32])=>{
                    const r18 = e32.evaluate(t40);
                    return r18 < 0 ? -Math.round(-r18) : Math.round(r18);
                }
            ],
            floor: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.floor(e32.evaluate(t40))
            ],
            ceil: [
                se,
                [
                    se
                ],
                (t40, [e32])=>Math.ceil(e32.evaluate(t40))
            ],
            "filter-==": [
                oe,
                [
                    ae,
                    ce
                ],
                (t40, [e32, r18])=>t40.properties()[e32.value] === r18.value
            ],
            "filter-id-==": [
                oe,
                [
                    ce
                ],
                (t40, [e32])=>t40.id() === e32.value
            ],
            "filter-type-==": [
                oe,
                [
                    ae
                ],
                (t40, [e32])=>t40.geometryType() === e32.value
            ],
            "filter-<": [
                oe,
                [
                    ae,
                    ce
                ],
                (t40, [e32, r18])=>{
                    const n10 = t40.properties()[e32.value], i8 = r18.value;
                    return typeof n10 == typeof i8 && n10 < i8;
                }
            ],
            "filter-id-<": [
                oe,
                [
                    ce
                ],
                (t40, [e32])=>{
                    const r18 = t40.id(), n10 = e32.value;
                    return typeof r18 == typeof n10 && r18 < n10;
                }
            ],
            "filter->": [
                oe,
                [
                    ae,
                    ce
                ],
                (t40, [e32, r18])=>{
                    const n10 = t40.properties()[e32.value], i8 = r18.value;
                    return typeof n10 == typeof i8 && n10 > i8;
                }
            ],
            "filter-id->": [
                oe,
                [
                    ce
                ],
                (t40, [e32])=>{
                    const r18 = t40.id(), n10 = e32.value;
                    return typeof r18 == typeof n10 && r18 > n10;
                }
            ],
            "filter-<=": [
                oe,
                [
                    ae,
                    ce
                ],
                (t40, [e32, r18])=>{
                    const n10 = t40.properties()[e32.value], i8 = r18.value;
                    return typeof n10 == typeof i8 && n10 <= i8;
                }
            ],
            "filter-id-<=": [
                oe,
                [
                    ce
                ],
                (t40, [e32])=>{
                    const r18 = t40.id(), n10 = e32.value;
                    return typeof r18 == typeof n10 && r18 <= n10;
                }
            ],
            "filter->=": [
                oe,
                [
                    ae,
                    ce
                ],
                (t40, [e32, r18])=>{
                    const n10 = t40.properties()[e32.value], i8 = r18.value;
                    return typeof n10 == typeof i8 && n10 >= i8;
                }
            ],
            "filter-id->=": [
                oe,
                [
                    ce
                ],
                (t40, [e32])=>{
                    const r18 = t40.id(), n10 = e32.value;
                    return typeof r18 == typeof n10 && r18 >= n10;
                }
            ],
            "filter-has": [
                oe,
                [
                    ce
                ],
                (t40, [e32])=>e32.value in t40.properties()
            ],
            "filter-has-id": [
                oe,
                [],
                (t40)=>null !== t40.id() && (void 0) !== t40.id()
            ],
            "filter-type-in": [
                oe,
                [
                    de(ae)
                ],
                (t40, [e32])=>e32.value.indexOf(t40.geometryType()) >= 0
            ],
            "filter-id-in": [
                oe,
                [
                    de(ce)
                ],
                (t40, [e32])=>e32.value.indexOf(t40.id()) >= 0
            ],
            "filter-in-small": [
                oe,
                [
                    ae,
                    de(ce)
                ],
                (t40, [e32, r18])=>r18.value.indexOf(t40.properties()[e32.value]) >= 0
            ],
            "filter-in-large": [
                oe,
                [
                    ae,
                    de(ce)
                ],
                (t40, [e32, r18])=>(function(t41, e33, r19, n10) {
                        for(; r19 <= n10;){
                            const i8 = r19 + n10 >> 1;
                            if (e33[i8] === t41) return !0;
                            e33[i8] > t41 ? n10 = i8 - 1 : r19 = i8 + 1;
                        }
                        return !1;
                    })(t40.properties()[e32.value], r18.value, 0, r18.value.length - 1)
            ],
            all: {
                type: oe,
                overloads: [
                    [
                        [
                            oe,
                            oe
                        ],
                        (t40, [e32, r18])=>e32.evaluate(t40) && r18.evaluate(t40)
                    ],
                    [
                        Mn(oe),
                        (t40, e32)=>{
                            for (const r18 of e32)if (!r18.evaluate(t40)) return !1;
                            return !0;
                        }
                    ]
                ]
            },
            any: {
                type: oe,
                overloads: [
                    [
                        [
                            oe,
                            oe
                        ],
                        (t40, [e32, r18])=>e32.evaluate(t40) || r18.evaluate(t40)
                    ],
                    [
                        Mn(oe),
                        (t40, e32)=>{
                            for (const r18 of e32)if (r18.evaluate(t40)) return !0;
                            return !1;
                        }
                    ]
                ]
            },
            "!": [
                oe,
                [
                    oe
                ],
                (t40, [e32])=>!e32.evaluate(t40)
            ],
            "is-supported-script": [
                oe,
                [
                    ae
                ],
                (t40, [e32])=>{
                    const r18 = t40.globals && t40.globals.isSupportedScript;
                    return !r18 || r18(e32.evaluate(t40));
                }
            ],
            upcase: [
                ae,
                [
                    ae
                ],
                (t40, [e32])=>e32.evaluate(t40).toUpperCase()
            ],
            downcase: [
                ae,
                [
                    ae
                ],
                (t40, [e32])=>e32.evaluate(t40).toLowerCase()
            ],
            concat: [
                ae,
                Mn(ce),
                (t40, e32)=>e32.map((e33)=>Ve(e33.evaluate(t40))
                    ).join("")
            ],
            "resolved-locale": [
                ae,
                [
                    he
                ],
                (t40, [e32])=>e32.evaluate(t40).resolvedLocale()
            ]
        });
        var Tn = An;
        function zn(t40) {
            return {
                result: "success",
                value: t40
            };
        }
        function Bn(t40) {
            return {
                result: "error",
                value: t40
            };
        }
        function En(t40) {
            return "data-driven" === t40["property-type"];
        }
        function Cn(t40) {
            return !!t40.expression && t40.expression.parameters.indexOf("zoom") > -1;
        }
        function Pn(t40) {
            return !!t40.expression && t40.expression.interpolated;
        }
        function Dn(t40) {
            return t40 instanceof Number ? "number" : t40 instanceof String ? "string" : t40 instanceof Boolean ? "boolean" : Array.isArray(t40) ? "array" : null === t40 ? "null" : typeof t40;
        }
        function Vn(t40) {
            return "object" == typeof t40 && null !== t40 && !Array.isArray(t40);
        }
        function Ln(t40) {
            return t40;
        }
        function Fn(t40, e32) {
            const r18 = "color" === e32.type, n10 = t40.stops && "object" == typeof t40.stops[0][0], i8 = n10 || !(n10 || (void 0) !== t40.property), s6 = t40.type || (Pn(e32) ? "exponential" : "interval");
            if (r18 && ((t40 = Wt({
            }, t40)).stops && (t40.stops = t40.stops.map((t41)=>[
                    t41[0],
                    Me.parse(t41[1])
                ]
            )), t40.default = Me.parse(t40.default ? t40.default : e32.default)), t40.colorSpace && "rgb" !== t40.colorSpace && !Gr[t40.colorSpace]) throw new Error(`Unknown color space: ${t40.colorSpace}`);
            let a3, o3, l3;
            if ("exponential" === s6) a3 = $n;
            else if ("interval" === s6) a3 = Un;
            else if ("categorical" === s6) {
                a3 = jn, o3 = Object.create(null);
                for (const e33 of t40.stops)o3[e33[0]] = e33[1];
                l3 = typeof t40.stops[0][0];
            } else {
                if ("identity" !== s6) throw new Error(`Unknown function type "${s6}"`);
                a3 = On;
            }
            if (n10) {
                const r19 = {
                }, n11 = [];
                for(let e33 = 0; e33 < t40.stops.length; e33++){
                    const i9 = t40.stops[e33], s7 = i9[0].zoom;
                    (void 0) === r19[s7] && (r19[s7] = {
                        zoom: s7,
                        type: t40.type,
                        property: t40.property,
                        default: t40.default,
                        stops: []
                    }, n11.push(s7)), r19[s7].stops.push([
                        i9[0].value,
                        i9[1]
                    ]);
                }
                const i9 = [];
                for (const t41 of n11)i9.push([
                    r19[t41].zoom,
                    Fn(r19[t41], e32)
                ]);
                const s7 = {
                    name: "linear"
                };
                return {
                    kind: "composite",
                    interpolationType: s7,
                    interpolationFactor: Kr.interpolationFactor.bind(void 0, s7),
                    zoomStops: i9.map((t42)=>t42[0]
                    ),
                    evaluate: ({ zoom: r20  }, n12)=>$n({
                            stops: i9,
                            base: t40.base
                        }, e32, r20).evaluate(r20, n12)
                };
            }
            if (i8) {
                const r19 = "exponential" === s6 ? {
                    name: "exponential",
                    base: (void 0) !== t40.base ? t40.base : 1
                } : null;
                return {
                    kind: "camera",
                    interpolationType: r19,
                    interpolationFactor: Kr.interpolationFactor.bind(void 0, r19),
                    zoomStops: t40.stops.map((t41)=>t41[0]
                    ),
                    evaluate: ({ zoom: r20  })=>a3(t40, e32, r20, o3, l3)
                };
            }
            return {
                kind: "source",
                evaluate (r, n) {
                    const i9 = n && n.properties ? n.properties[t40.property] : void 0;
                    return (void 0) === i9 ? Rn(t40.default, e32.default) : a3(t40, e32, i9, o3, l3);
                }
            };
        }
        function Rn(t40, e32, r18) {
            return (void 0) !== t40 ? t40 : (void 0) !== e32 ? e32 : (void 0) !== r18 ? r18 : void 0;
        }
        function jn(t40, e32, r18, n10, i8) {
            return Rn(typeof r18 === i8 ? n10[r18] : void 0, t40.default, e32.default);
        }
        function Un(t40, e32, r18) {
            if ("number" !== Dn(r18)) return Rn(t40.default, e32.default);
            const n10 = t40.stops.length;
            if (1 === n10) return t40.stops[0][1];
            if (r18 <= t40.stops[0][0]) return t40.stops[0][1];
            if (r18 >= t40.stops[n10 - 1][0]) return t40.stops[n10 - 1][1];
            const i8 = Sr(t40.stops.map((t41)=>t41[0]
            ), r18);
            return t40.stops[i8][1];
        }
        function $n(t40, e32, r18) {
            const n10 = (void 0) !== t40.base ? t40.base : 1;
            if ("number" !== Dn(r18)) return Rn(t40.default, e32.default);
            const i8 = t40.stops.length;
            if (1 === i8) return t40.stops[0][1];
            if (r18 <= t40.stops[0][0]) return t40.stops[0][1];
            if (r18 >= t40.stops[i8 - 1][0]) return t40.stops[i8 - 1][1];
            const s6 = Sr(t40.stops.map((t41)=>t41[0]
            ), r18), a3 = function(t41, e33, r19, n11) {
                const i9 = n11 - r19, s7 = t41 - r19;
                return 0 === i9 ? 0 : 1 === e33 ? s7 / i9 : (Math.pow(e33, s7) - 1) / (Math.pow(e33, i9) - 1);
            }(r18, n10, t40.stops[s6][0], t40.stops[s6 + 1][0]), o3 = t40.stops[s6][1], l3 = t40.stops[s6 + 1][1];
            let u2 = Tr[e32.type] || Ln;
            if (t40.colorSpace && "rgb" !== t40.colorSpace) {
                const e33 = Gr[t40.colorSpace];
                u2 = (t41, r19)=>e33.reverse(e33.interpolate(e33.forward(t41), e33.forward(r19), a3))
                ;
            }
            return "function" == typeof o3.evaluate ? {
                evaluate (...t) {
                    const e33 = o3.evaluate.apply(void 0, t), r19 = l3.evaluate.apply(void 0, t);
                    if ((void 0) !== e33 && (void 0) !== r19) return u2(e33, r19, a3);
                }
            } : u2(o3, l3, a3);
        }
        function On(t40, e32, r18) {
            return "color" === e32.type ? r18 = Me.parse(r18) : "formatted" === e32.type ? r18 = Be.fromString(r18.toString()) : "resolvedImage" === e32.type ? r18 = Ee.fromString(r18.toString()) : Dn(r18) === e32.type || "enum" === e32.type && e32.values[r18] || (r18 = void 0), Rn(r18, t40.default, e32.default);
        }
        class qn {
            constructor(t40, e32){
                this.expression = t40, this._warningHistory = {
                }, this._evaluator = new Ke, this._defaultValue = e32 ? (function(t41) {
                    return "color" === t41.type && (Vn(t41.default) || Array.isArray(t41.default)) ? new Me(0, 0, 0, 0) : "color" === t41.type ? Me.parse(t41.default) || null : (void 0) === t41.default ? null : t41.default;
                })(e32) : null, this._enumValues = e32 && "enum" === e32.type ? e32.values : null;
            }
            evaluateWithoutErrorHandling(t, e, r, n, i, s, a, o) {
                return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);
            }
            evaluate(t, e, r, n, i, s, a, o) {
                this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null;
                try {
                    const t41 = this.expression.evaluate(this._evaluator);
                    if (null == t41 || "number" == typeof t41 && t41 != t41) return this._defaultValue;
                    if (this._enumValues && !(t41 in this._enumValues)) throw new Re(`Expected value to be one of ${Object.keys(this._enumValues).map((t42)=>JSON.stringify(t42)
                    ).join(", ")}, but found ${JSON.stringify(t41)} instead.`);
                    return t41;
                } catch (t42) {
                    return this._warningHistory[t42.message] || (this._warningHistory[t42.message] = !0, "undefined" != typeof console && console.warn(t42.message)), this._defaultValue;
                }
            }
        }
        function Nn(t41) {
            return Array.isArray(t41) && t41.length > 0 && "string" == typeof t41[0] && t41[0] in Tn;
        }
        function Gn(t41, e33) {
            const r18 = new _r(Tn, [], e33 ? function(t42) {
                const e34 = {
                    color: le,
                    string: ae,
                    number: se,
                    enum: ae,
                    boolean: oe,
                    formatted: pe,
                    resolvedImage: fe
                };
                return "array" === t42.type ? de(e34[t42.value] || ce, t42.length) : e34[t42.type];
            }(e33) : void 0), n10 = r18.parse(t41, void 0, void 0, void 0, e33 && "string" === e33.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return n10 ? zn(new qn(n10, e33)) : Bn(r18.errors);
        }
        class Xn {
            constructor(t41, e33){
                this.kind = t41, this._styleExpression = e33, this.isStateDependent = "constant" !== t41 && !gr(e33.expression);
            }
            evaluateWithoutErrorHandling(t, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);
            }
            evaluate(t, e, r, n, i, s) {
                return this._styleExpression.evaluate(t, e, r, n, i, s);
            }
        }
        class Zn {
            constructor(t42, e34, r18, n10){
                this.kind = t42, this.zoomStops = r18, this._styleExpression = e34, this.isStateDependent = "camera" !== t42 && !gr(e34.expression), this.interpolationType = n10;
            }
            evaluateWithoutErrorHandling(t, e, r, n, i, s) {
                return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);
            }
            evaluate(t, e, r, n, i, s) {
                return this._styleExpression.evaluate(t, e, r, n, i, s);
            }
            interpolationFactor(t, e, r) {
                return this.interpolationType ? Kr.interpolationFactor(this.interpolationType, t, e, r) : 0;
            }
        }
        function Kn(t43, e35) {
            if ("error" === (t43 = Gn(t43, e35)).result) return t43;
            const r19 = t43.value.expression, n11 = mr(r19);
            if (!n11 && !En(e35)) return Bn([
                new ee("", "data expressions not supported")
            ]);
            const i8 = xr(r19, [
                "zoom",
                "pitch",
                "distance-from-center"
            ]);
            if (!i8 && !Cn(e35)) return Bn([
                new ee("", "zoom expressions not supported")
            ]);
            const s6 = Hn(r19);
            return s6 || i8 ? s6 instanceof ee ? Bn([
                s6
            ]) : s6 instanceof Kr && !Pn(e35) ? Bn([
                new ee("", '"interpolate" expressions cannot be used with this property')
            ]) : zn(s6 ? new Zn(n11 ? "camera" : "composite", t43.value, s6.labels, s6 instanceof Kr ? s6.interpolation : void 0) : new Xn(n11 ? "constant" : "source", t43.value)) : Bn([
                new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')
            ]);
        }
        class Yn {
            constructor(t43, e35){
                this._parameters = t43, this._specification = e35, Wt(this, Fn(this._parameters, this._specification));
            }
            static deserialize(t) {
                return new Yn(t._parameters, t._specification);
            }
            static serialize(t) {
                return {
                    _parameters: t._parameters,
                    _specification: t._specification
                };
            }
        }
        function Hn(t44) {
            let e36 = null;
            if (t44 instanceof Jr) e36 = Hn(t44.result);
            else if (t44 instanceof Hr) {
                for (const r19 of t44.args)if (e36 = Hn(r19), e36) break;
            } else (t44 instanceof Ir || t44 instanceof Kr) && t44.input instanceof He && "zoom" === t44.input.name && (e36 = t44);
            return e36 instanceof ee || t44.eachChild((t45)=>{
                const r19 = Hn(t45);
                r19 instanceof ee ? e36 = r19 : !e36 && r19 ? e36 = new ee("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e36 && r19 && e36 !== r19 && (e36 = new ee("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e36;
        }
        class Wn {
            constructor(t44, e36, r19, n11){
                this.message = (t44 ? `${t44}: ` : "") + r19, n11 && (this.identifier = n11), null != e36 && e36.__line__ && (this.line = e36.__line__);
            }
        }
        function Jn(t45) {
            const e37 = t45.key, r20 = t45.value, n12 = t45.valueSpec || {
            }, i8 = t45.objectElementValidators || {
            }, s6 = t45.style, a3 = t45.styleSpec;
            let o3 = [];
            const l3 = Dn(r20);
            if ("object" !== l3) return [
                new Wn(e37, r20, `object expected, ${l3} found`)
            ];
            for(const t46 in r20){
                const l4 = t46.split(".")[0], u2 = n12[l4] || n12["*"];
                let c3;
                i8[l4] ? c3 = i8[l4] : n12[l4] ? c3 = Ci : i8["*"] ? c3 = i8["*"] : n12["*"] && (c3 = Ci), c3 ? o3 = o3.concat(c3({
                    key: (e37 ? `${e37}.` : e37) + t46,
                    value: r20[t46],
                    valueSpec: u2,
                    style: s6,
                    styleSpec: a3,
                    object: r20,
                    objectKey: t46
                }, r20)) : o3.push(new Wn(e37, r20[t46], `unknown property "${t46}"`));
            }
            for(const t47 in n12)i8[t47] || n12[t47].required && (void 0) === n12[t47].default && (void 0) === r20[t47] && o3.push(new Wn(e37, r20, `missing required property "${t47}"`));
            return o3;
        }
        function Qn(t45) {
            const e37 = t45.value, r20 = t45.valueSpec, n12 = t45.style, i8 = t45.styleSpec, s6 = t45.key, a3 = t45.arrayElementValidator || Ci;
            if ("array" !== Dn(e37)) return [
                new Wn(s6, e37, `array expected, ${Dn(e37)} found`)
            ];
            if (r20.length && e37.length !== r20.length) return [
                new Wn(s6, e37, `array length ${r20.length} expected, length ${e37.length} found`)
            ];
            if (r20["min-length"] && e37.length < r20["min-length"]) return [
                new Wn(s6, e37, `array length at least ${r20["min-length"]} expected, length ${e37.length} found`)
            ];
            let o3 = {
                type: r20.value,
                values: r20.values,
                minimum: r20.minimum,
                maximum: r20.maximum,
                function: void 0
            };
            i8.$version < 7 && (o3.function = r20.function), "object" === Dn(r20.value) && (o3 = r20.value);
            let l3 = [];
            for(let t46 = 0; t46 < e37.length; t46++)l3 = l3.concat(a3({
                array: e37,
                arrayIndex: t46,
                value: e37[t46],
                valueSpec: o3,
                style: n12,
                styleSpec: i8,
                key: `${s6}[${t46}]`
            }));
            return l3;
        }
        function ti(t45) {
            const e37 = t45.key, r20 = t45.value, n12 = t45.valueSpec;
            let i8 = Dn(r20);
            if ("number" === i8 && r20 != r20 && (i8 = "NaN"), "number" !== i8) return [
                new Wn(e37, r20, `number expected, ${i8} found`)
            ];
            if ("minimum" in n12) {
                let i9 = n12.minimum;
                if ("array" === Dn(n12.minimum) && (i9 = n12.minimum[t45.arrayIndex]), r20 < i9) return [
                    new Wn(e37, r20, `${r20} is less than the minimum value ${i9}`)
                ];
            }
            if ("maximum" in n12) {
                let i9 = n12.maximum;
                if ("array" === Dn(n12.maximum) && (i9 = n12.maximum[t45.arrayIndex]), r20 > i9) return [
                    new Wn(e37, r20, `${r20} is greater than the maximum value ${i9}`)
                ];
            }
            return [];
        }
        function ei(t45) {
            const e37 = t45.valueSpec, r20 = Jt(t45.value.type);
            let n12, i8, s6, a3 = {
            };
            const o3 = "categorical" !== r20 && (void 0) === t45.value.property, l3 = !o3, u2 = "array" === Dn(t45.value.stops) && "array" === Dn(t45.value.stops[0]) && "object" === Dn(t45.value.stops[0][0]), c3 = Jn({
                key: t45.key,
                value: t45.value,
                valueSpec: t45.styleSpec.function,
                style: t45.style,
                styleSpec: t45.styleSpec,
                objectElementValidators: {
                    stops: function(t46) {
                        if ("identity" === r20) return [
                            new Wn(t46.key, t46.value, 'identity function may not have a "stops" property')
                        ];
                        let e38 = [];
                        const n13 = t46.value;
                        return e38 = e38.concat(Qn({
                            key: t46.key,
                            value: n13,
                            valueSpec: t46.valueSpec,
                            style: t46.style,
                            styleSpec: t46.styleSpec,
                            arrayElementValidator: h3
                        })), "array" === Dn(n13) && 0 === n13.length && e38.push(new Wn(t46.key, n13, "array must have at least one stop")), e38;
                    },
                    default: function(t46) {
                        return Ci({
                            key: t46.key,
                            value: t46.value,
                            valueSpec: e37,
                            style: t46.style,
                            styleSpec: t46.styleSpec
                        });
                    }
                }
            });
            function h3(t46) {
                let r21 = [];
                const n13 = t46.value, o4 = t46.key;
                if ("array" !== Dn(n13)) return [
                    new Wn(o4, n13, `array expected, ${Dn(n13)} found`)
                ];
                if (2 !== n13.length) return [
                    new Wn(o4, n13, `array length 2 expected, length ${n13.length} found`)
                ];
                if (u2) {
                    if ("object" !== Dn(n13[0])) return [
                        new Wn(o4, n13, `object expected, ${Dn(n13[0])} found`)
                    ];
                    if ((void 0) === n13[0].zoom) return [
                        new Wn(o4, n13, "object stop key must have zoom")
                    ];
                    if ((void 0) === n13[0].value) return [
                        new Wn(o4, n13, "object stop key must have value")
                    ];
                    const e38 = Jt(n13[0].zoom);
                    if ("number" != typeof e38) return [
                        new Wn(o4, n13[0].zoom, "stop zoom values must be numbers")
                    ];
                    if (s6 && s6 > e38) return [
                        new Wn(o4, n13[0].zoom, "stop zoom values must appear in ascending order")
                    ];
                    e38 !== s6 && (s6 = e38, i8 = void 0, a3 = {
                    }), r21 = r21.concat(Jn({
                        key: `${o4}[0]`,
                        value: n13[0],
                        valueSpec: {
                            zoom: {
                            }
                        },
                        style: t46.style,
                        styleSpec: t46.styleSpec,
                        objectElementValidators: {
                            zoom: ti,
                            value: p3
                        }
                    }));
                } else r21 = r21.concat(p3({
                    key: `${o4}[0]`,
                    value: n13[0],
                    valueSpec: {
                    },
                    style: t46.style,
                    styleSpec: t46.styleSpec
                }, n13));
                return Nn(Qt(n13[1])) ? r21.concat([
                    new Wn(`${o4}[1]`, n13[1], "expressions are not allowed in function stops.")
                ]) : r21.concat(Ci({
                    key: `${o4}[1]`,
                    value: n13[1],
                    valueSpec: e37,
                    style: t46.style,
                    styleSpec: t46.styleSpec
                }));
            }
            function p3(t46, s7) {
                const o4 = Dn(t46.value), l4 = Jt(t46.value), u3 = null !== t46.value ? t46.value : s7;
                if (n12) {
                    if (o4 !== n12) return [
                        new Wn(t46.key, u3, `${o4} stop domain type must match previous stop domain type ${n12}`)
                    ];
                } else n12 = o4;
                if ("number" !== o4 && "string" !== o4 && "boolean" !== o4 && "number" != typeof l4 && "string" != typeof l4 && "boolean" != typeof l4) return [
                    new Wn(t46.key, u3, "stop domain value must be a number, string, or boolean")
                ];
                if ("number" !== o4 && "categorical" !== r20) {
                    let n13 = `number expected, ${o4} found`;
                    return En(e37) && (void 0) === r20 && (n13 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [
                        new Wn(t46.key, u3, n13)
                    ];
                }
                return "categorical" !== r20 || "number" !== o4 || "number" == typeof l4 && isFinite(l4) && Math.floor(l4) === l4 ? "categorical" !== r20 && "number" === o4 && "number" == typeof l4 && "number" == typeof i8 && (void 0) !== i8 && l4 < i8 ? [
                    new Wn(t46.key, u3, "stop domain values must appear in ascending order")
                ] : (i8 = l4, "categorical" === r20 && l4 in a3 ? [
                    new Wn(t46.key, u3, "stop domain values must be unique")
                ] : (a3[l4] = !0, [])) : [
                    new Wn(t46.key, u3, `integer expected, found ${String(l4)}`)
                ];
            }
            return "identity" === r20 && o3 && c3.push(new Wn(t45.key, t45.value, 'missing required property "property"')), "identity" === r20 || t45.value.stops || c3.push(new Wn(t45.key, t45.value, 'missing required property "stops"')), "exponential" === r20 && t45.valueSpec.expression && !Pn(t45.valueSpec) && c3.push(new Wn(t45.key, t45.value, "exponential functions not supported")), t45.styleSpec.$version >= 8 && (l3 && !En(t45.valueSpec) ? c3.push(new Wn(t45.key, t45.value, "property functions not supported")) : o3 && !Cn(t45.valueSpec) && c3.push(new Wn(t45.key, t45.value, "zoom functions not supported"))), "categorical" !== r20 && !u2 || (void 0) !== t45.value.property || c3.push(new Wn(t45.key, t45.value, '"property" property is required')), c3;
        }
        function ri(t45) {
            const e37 = ("property" === t45.expressionContext ? Kn : Gn)(Qt(t45.value), t45.valueSpec);
            if ("error" === e37.result) return e37.value.map((e38)=>new Wn(`${t45.key}${e38.key}`, t45.value, e38.message)
            );
            const r20 = e37.value.expression || e37.value._styleExpression.expression;
            if ("property" === t45.expressionContext && "text-font" === t45.propertyKey && !r20.outputDefined()) return [
                new Wn(t45.key, t45.value, `Invalid data expression for "${t45.propertyKey}". Output values must be contained as literals within the expression.`)
            ];
            if ("property" === t45.expressionContext && "layout" === t45.propertyType && !gr(r20)) return [
                new Wn(t45.key, t45.value, '"feature-state" data expressions are not supported with layout properties.')
            ];
            if ("filter" === t45.expressionContext) return ni(r20, t45);
            if (t45.expressionContext && 0 === t45.expressionContext.indexOf("cluster")) {
                if (!xr(r20, [
                    "zoom",
                    "feature-state"
                ])) return [
                    new Wn(t45.key, t45.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')
                ];
                if ("cluster-initial" === t45.expressionContext && !mr(r20)) return [
                    new Wn(t45.key, t45.value, "Feature data expressions are not supported with initial expression part of cluster properties.")
                ];
            }
            return [];
        }
        function ni(t45, e37) {
            const r20 = new Set([
                "zoom",
                "feature-state",
                "pitch",
                "distance-from-center"
            ]);
            if (e37.valueSpec && e37.valueSpec.expression) for (const t46 of e37.valueSpec.expression.parameters)r20.delete(t46);
            if (0 === r20.size) return [];
            const n12 = [];
            return t45 instanceof He && r20.has(t45.name) ? [
                new Wn(e37.key, e37.value, `["${t45.name}"] expression is not supported in a filter for a ${e37.object.type} layer with id: ${e37.object.id}`)
            ] : (t45.eachChild((t47)=>{
                n12.push(...ni(t47, e37));
            }), n12);
        }
        function ii(t45) {
            const e37 = t45.key, r20 = t45.value, n12 = t45.valueSpec, i8 = [];
            return Array.isArray(n12.values) ? -1 === n12.values.indexOf(Jt(r20)) && i8.push(new Wn(e37, r20, `expected one of [${n12.values.join(", ")}], ${JSON.stringify(r20)} found`)) : -1 === Object.keys(n12.values).indexOf(Jt(r20)) && i8.push(new Wn(e37, r20, `expected one of [${Object.keys(n12.values).join(", ")}], ${JSON.stringify(r20)} found`)), i8;
        }
        function si(t45) {
            if (!0 === t45 || !1 === t45) return !0;
            if (!Array.isArray(t45) || 0 === t45.length) return !1;
            switch(t45[0]){
                case "has":
                    return t45.length >= 2 && "$id" !== t45[1] && "$type" !== t45[1];
                case "in":
                    return t45.length >= 3 && ("string" != typeof t45[1] || Array.isArray(t45[2]));
                case "!in":
                case "!has":
                case "none":
                    return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                    return 3 !== t45.length || Array.isArray(t45[1]) || Array.isArray(t45[2]);
                case "any":
                case "all":
                    for (const e37 of t45.slice(1))if (!si(e37) && "boolean" != typeof e37) return !1;
                    return !0;
                default:
                    return !0;
            }
        }
        function ai(t45, e37 = "fill") {
            if (null == t45) return {
                filter: ()=>!0
                ,
                needGeometry: !1,
                needFeature: !1
            };
            si(t45) || (t45 = fi(t45));
            const r20 = t45;
            let n12 = !0;
            try {
                n12 = (function(t46) {
                    if (!ui(t46)) return t46;
                    let e38 = Qt(t46);
                    return li(e38), e38 = oi(e38), e38;
                })(r20);
            } catch (t46) {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r20, null, 2)}\n        `);
            }
            const i8 = Ht[`filter_${e37}`], s6 = Gn(n12, i8);
            let a3 = null;
            if ("error" === s6.result) throw new Error(s6.value.map((t46)=>`${t46.key}: ${t46.message}`
            ).join(", "));
            a3 = (t46, e38, r21)=>s6.value.evaluate(t46, e38, {
                }, r21)
            ;
            let o3 = null, l3 = null;
            if (n12 !== r20) {
                const t46 = Gn(r20, i8);
                if ("error" === t46.result) throw new Error(t46.value.map((t47)=>`${t47.key}: ${t47.message}`
                ).join(", "));
                o3 = (e38, r21, n13, i9, s7)=>t46.value.evaluate(e38, r21, {
                    }, n13, void 0, void 0, i9, s7)
                , l3 = !mr(t46.value.expression);
            }
            return {
                filter: a3,
                dynamicFilter: o3 || void 0,
                needGeometry: pi(n12),
                needFeature: !!l3
            };
        }
        function oi(t45) {
            if (!Array.isArray(t45)) return t45;
            const e37 = function(t46) {
                if (ci.has(t46[0])) for(let e38 = 1; e38 < t46.length; e38++)if (ui(t46[e38])) return !0;
                return t46;
            }(t45);
            return !0 === e37 ? e37 : e37.map((t46)=>oi(t46)
            );
        }
        function li(t45) {
            let e37 = !1;
            const r20 = [];
            if ("case" === t45[0]) {
                for(let n12 = 1; n12 < t45.length - 1; n12 += 2)e37 = e37 || ui(t45[n12]), r20.push(t45[n12 + 1]);
                r20.push(t45[t45.length - 1]);
            } else if ("match" === t45[0]) {
                e37 = e37 || ui(t45[1]);
                for(let e38 = 2; e38 < t45.length - 1; e38 += 2)r20.push(t45[e38 + 1]);
                r20.push(t45[t45.length - 1]);
            } else if ("step" === t45[0]) {
                e37 = e37 || ui(t45[1]);
                for(let e38 = 1; e38 < t45.length - 1; e38 += 2)r20.push(t45[e38 + 1]);
            }
            e37 && (t45.length = 0, t45.push("any", ...r20));
            for(let e38 = 1; e38 < t45.length; e38++)li(t45[e38]);
        }
        function ui(t45) {
            if (!Array.isArray(t45)) return !1;
            if ("pitch" === (e37 = t45[0]) || "distance-from-center" === e37) return !0;
            var e37;
            for(let e38 = 1; e38 < t45.length; e38++)if (ui(t45[e38])) return !0;
            return !1;
        }
        const ci = new Set([
            "in",
            "==",
            "!=",
            ">",
            ">=",
            "<",
            "<=",
            "to-boolean"
        ]);
        function hi(t45, e37) {
            return t45 < e37 ? -1 : t45 > e37 ? 1 : 0;
        }
        function pi(t45) {
            if (!Array.isArray(t45)) return !1;
            if ("within" === t45[0]) return !0;
            for(let e37 = 1; e37 < t45.length; e37++)if (pi(t45[e37])) return !0;
            return !1;
        }
        function fi(t45) {
            if (!t45) return !0;
            const e37 = t45[0];
            var r20;
            return t45.length <= 1 ? "any" !== e37 : "==" === e37 ? di(t45[1], t45[2], "==") : "!=" === e37 ? gi(di(t45[1], t45[2], "==")) : "<" === e37 || ">" === e37 || "<=" === e37 || ">=" === e37 ? di(t45[1], t45[2], e37) : "any" === e37 ? (r20 = t45.slice(1), [
                "any"
            ].concat(r20.map(fi))) : "all" === e37 ? [
                "all"
            ].concat(t45.slice(1).map(fi)) : "none" === e37 ? [
                "all"
            ].concat(t45.slice(1).map(fi).map(gi)) : "in" === e37 ? yi(t45[1], t45.slice(2)) : "!in" === e37 ? gi(yi(t45[1], t45.slice(2))) : "has" === e37 ? mi(t45[1]) : "!has" === e37 ? gi(mi(t45[1])) : "within" !== e37 || t45;
        }
        function di(t45, e37, r20) {
            switch(t45){
                case "$type":
                    return [
                        `filter-type-${r20}`,
                        e37
                    ];
                case "$id":
                    return [
                        `filter-id-${r20}`,
                        e37
                    ];
                default:
                    return [
                        `filter-${r20}`,
                        t45,
                        e37
                    ];
            }
        }
        function yi(t45, e37) {
            if (0 === e37.length) return !1;
            switch(t45){
                case "$type":
                    return [
                        "filter-type-in",
                        [
                            "literal",
                            e37
                        ]
                    ];
                case "$id":
                    return [
                        "filter-id-in",
                        [
                            "literal",
                            e37
                        ]
                    ];
                default:
                    return e37.length > 200 && !e37.some((t46)=>typeof t46 != typeof e37[0]
                    ) ? [
                        "filter-in-large",
                        t45,
                        [
                            "literal",
                            e37.sort(hi)
                        ]
                    ] : [
                        "filter-in-small",
                        t45,
                        [
                            "literal",
                            e37
                        ]
                    ];
            }
        }
        function mi(t45) {
            switch(t45){
                case "$type":
                    return !0;
                case "$id":
                    return [
                        "filter-has-id"
                    ];
                default:
                    return [
                        "filter-has",
                        t45
                    ];
            }
        }
        function gi(t45) {
            return [
                "!",
                t45
            ];
        }
        function xi(t45) {
            return si(Qt(t45.value)) ? ri(Wt({
            }, t45, {
                expressionContext: "filter",
                valueSpec: t45.styleSpec[`filter_${t45.layerType || "fill"}`]
            })) : vi(t45);
        }
        function vi(t45) {
            const e37 = t45.value, r20 = t45.key;
            if ("array" !== Dn(e37)) return [
                new Wn(r20, e37, `array expected, ${Dn(e37)} found`)
            ];
            const n12 = t45.styleSpec;
            let i8, s6 = [];
            if (e37.length < 1) return [
                new Wn(r20, e37, "filter array must have at least 1 element")
            ];
            switch(s6 = s6.concat(ii({
                key: `${r20}[0]`,
                value: e37[0],
                valueSpec: n12.filter_operator,
                style: t45.style,
                styleSpec: t45.styleSpec
            })), Jt(e37[0])){
                case "<":
                case "<=":
                case ">":
                case ">=":
                    e37.length >= 2 && "$type" === Jt(e37[1]) && s6.push(new Wn(r20, e37, `"$type" cannot be use with operator "${e37[0]}"`));
                case "==":
                case "!=":
                    3 !== e37.length && s6.push(new Wn(r20, e37, `filter array for operator "${e37[0]}" must have 3 elements`));
                case "in":
                case "!in":
                    e37.length >= 2 && (i8 = Dn(e37[1]), "string" !== i8 && s6.push(new Wn(`${r20}[1]`, e37[1], `string expected, ${i8} found`)));
                    for(let a3 = 2; a3 < e37.length; a3++)i8 = Dn(e37[a3]), "$type" === Jt(e37[1]) ? s6 = s6.concat(ii({
                        key: `${r20}[${a3}]`,
                        value: e37[a3],
                        valueSpec: n12.geometry_type,
                        style: t45.style,
                        styleSpec: t45.styleSpec
                    })) : "string" !== i8 && "number" !== i8 && "boolean" !== i8 && s6.push(new Wn(`${r20}[${a3}]`, e37[a3], `string, number, or boolean expected, ${i8} found`));
                    break;
                case "any":
                case "all":
                case "none":
                    for(let n13 = 1; n13 < e37.length; n13++)s6 = s6.concat(vi({
                        key: `${r20}[${n13}]`,
                        value: e37[n13],
                        style: t45.style,
                        styleSpec: t45.styleSpec
                    }));
                    break;
                case "has":
                case "!has":
                    i8 = Dn(e37[1]), 2 !== e37.length ? s6.push(new Wn(r20, e37, `filter array for "${e37[0]}" operator must have 2 elements`)) : "string" !== i8 && s6.push(new Wn(`${r20}[1]`, e37[1], `string expected, ${i8} found`));
                    break;
                case "within":
                    i8 = Dn(e37[1]), 2 !== e37.length ? s6.push(new Wn(r20, e37, `filter array for "${e37[0]}" operator must have 2 elements`)) : "object" !== i8 && s6.push(new Wn(`${r20}[1]`, e37[1], `object expected, ${i8} found`));
            }
            return s6;
        }
        function bi(t45, e37) {
            const r20 = t45.key, n12 = t45.style, i8 = t45.styleSpec, s6 = t45.value, a3 = t45.objectKey, o3 = i8[`${e37}_${t45.layerType}`];
            if (!o3) return [];
            const l3 = a3.match(/^(.*)-transition$/);
            if ("paint" === e37 && l3 && o3[l3[1]] && o3[l3[1]].transition) return Ci({
                key: r20,
                value: s6,
                valueSpec: i8.transition,
                style: n12,
                styleSpec: i8
            });
            const u2 = t45.valueSpec || o3[a3];
            if (!u2) return [
                new Wn(r20, s6, `unknown property "${a3}"`)
            ];
            let c3;
            if ("string" === Dn(s6) && En(u2) && !u2.tokens && (c3 = /^{([^}]+)}$/.exec(s6))) return [
                new Wn(r20, s6, `"${a3}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c3[1])} }\`.`)
            ];
            const h3 = [];
            return "symbol" === t45.layerType && ("text-field" === a3 && n12 && !n12.glyphs && h3.push(new Wn(r20, s6, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a3 && Vn(Qt(s6)) && "identity" === Jt(s6.type) && h3.push(new Wn(r20, s6, '"text-font" does not support identity functions'))), h3.concat(Ci({
                key: t45.key,
                value: s6,
                valueSpec: u2,
                style: n12,
                styleSpec: i8,
                expressionContext: "property",
                propertyType: e37,
                propertyKey: a3
            }));
        }
        function wi(t45) {
            return bi(t45, "paint");
        }
        function _i(t45) {
            return bi(t45, "layout");
        }
        function Ai(t45) {
            let e37 = [];
            const r20 = t45.value, n12 = t45.key, i8 = t45.style, s6 = t45.styleSpec;
            r20.type || r20.ref || e37.push(new Wn(n12, r20, 'either "type" or "ref" is required'));
            let a3 = Jt(r20.type);
            const o3 = Jt(r20.ref);
            if (r20.id) {
                const s7 = Jt(r20.id);
                for(let a4 = 0; a4 < t45.arrayIndex; a4++){
                    const t46 = i8.layers[a4];
                    Jt(t46.id) === s7 && e37.push(new Wn(n12, r20.id, `duplicate layer id "${r20.id}", previously used at line ${t46.id.__line__}`));
                }
            }
            if ("ref" in r20) {
                let t46;
                [
                    "type",
                    "source",
                    "source-layer",
                    "filter",
                    "layout"
                ].forEach((t47)=>{
                    t47 in r20 && e37.push(new Wn(n12, r20[t47], `"${t47}" is prohibited for ref layers`));
                }), i8.layers.forEach((e38)=>{
                    Jt(e38.id) === o3 && (t46 = e38);
                }), t46 ? t46.ref ? e37.push(new Wn(n12, r20.ref, "ref cannot reference another ref layer")) : a3 = Jt(t46.type) : "string" == typeof o3 && e37.push(new Wn(n12, r20.ref, `ref layer "${o3}" not found`));
            } else if ("background" !== a3 && "sky" !== a3) {
                if (r20.source) {
                    const t46 = i8.sources && i8.sources[r20.source], s7 = t46 && Jt(t46.type);
                    t46 ? "vector" === s7 && "raster" === a3 ? e37.push(new Wn(n12, r20.source, `layer "${r20.id}" requires a raster source`)) : "raster" === s7 && "raster" !== a3 ? e37.push(new Wn(n12, r20.source, `layer "${r20.id}" requires a vector source`)) : "vector" !== s7 || r20["source-layer"] ? "raster-dem" === s7 && "hillshade" !== a3 ? e37.push(new Wn(n12, r20.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a3 || !r20.paint || !r20.paint["line-gradient"] && !r20.paint["line-trim-offset"] || "geojson" === s7 && t46.lineMetrics || e37.push(new Wn(n12, r20, `layer "${r20.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e37.push(new Wn(n12, r20, `layer "${r20.id}" must specify a "source-layer"`)) : e37.push(new Wn(n12, r20.source, `source "${r20.source}" not found`));
                } else e37.push(new Wn(n12, r20, 'missing required property "source"'));
            }
            return e37 = e37.concat(Jn({
                key: n12,
                value: r20,
                valueSpec: s6.layer,
                style: t45.style,
                styleSpec: t45.styleSpec,
                objectElementValidators: {
                    "*": ()=>[]
                    ,
                    type: ()=>Ci({
                            key: `${n12}.type`,
                            value: r20.type,
                            valueSpec: s6.layer.type,
                            style: t45.style,
                            styleSpec: t45.styleSpec,
                            object: r20,
                            objectKey: "type"
                        })
                    ,
                    filter: (t46)=>xi(Wt({
                            layerType: a3
                        }, t46))
                    ,
                    layout: (t46)=>Jn({
                            layer: r20,
                            key: t46.key,
                            value: t46.value,
                            valueSpec: {
                            },
                            style: t46.style,
                            styleSpec: t46.styleSpec,
                            objectElementValidators: {
                                "*": (t47)=>_i(Wt({
                                        layerType: a3
                                    }, t47))
                            }
                        })
                    ,
                    paint: (t46)=>Jn({
                            layer: r20,
                            key: t46.key,
                            value: t46.value,
                            valueSpec: {
                            },
                            style: t46.style,
                            styleSpec: t46.styleSpec,
                            objectElementValidators: {
                                "*": (t47)=>wi(Wt({
                                        layerType: a3
                                    }, t47))
                            }
                        })
                }
            })), e37;
        }
        function Si(t45) {
            const e37 = t45.value, r20 = t45.key, n12 = Dn(e37);
            return "string" !== n12 ? [
                new Wn(r20, e37, `string expected, ${n12} found`)
            ] : [];
        }
        const ki = {
            promoteId: function({ key: t45 , value: e37  }) {
                if ("string" === Dn(e37)) return Si({
                    key: t45,
                    value: e37
                });
                {
                    const r20 = [];
                    for(const n12 in e37)r20.push(...Si({
                        key: `${t45}.${n12}`,
                        value: e37[n12]
                    }));
                    return r20;
                }
            }
        };
        function Ii(t45) {
            const e37 = t45.value, r20 = t45.key, n12 = t45.styleSpec, i8 = t45.style;
            if (!e37.type) return [
                new Wn(r20, e37, '"type" is required')
            ];
            const s6 = Jt(e37.type);
            let a3;
            switch(s6){
                case "vector":
                case "raster":
                case "raster-dem":
                    return a3 = Jn({
                        key: r20,
                        value: e37,
                        valueSpec: n12[`source_${s6.replace("-", "_")}`],
                        style: t45.style,
                        styleSpec: n12,
                        objectElementValidators: ki
                    }), a3;
                case "geojson":
                    if (a3 = Jn({
                        key: r20,
                        value: e37,
                        valueSpec: n12.source_geojson,
                        style: i8,
                        styleSpec: n12,
                        objectElementValidators: ki
                    }), e37.cluster) for(const t46 in e37.clusterProperties){
                        const [n13, i9] = e37.clusterProperties[t46], s7 = "string" == typeof n13 ? [
                            n13,
                            [
                                "accumulated"
                            ],
                            [
                                "get",
                                t46
                            ]
                        ] : n13;
                        a3.push(...ri({
                            key: `${r20}.${t46}.map`,
                            value: i9,
                            expressionContext: "cluster-map"
                        })), a3.push(...ri({
                            key: `${r20}.${t46}.reduce`,
                            value: s7,
                            expressionContext: "cluster-reduce"
                        }));
                    }
                    return a3;
                case "video":
                    return Jn({
                        key: r20,
                        value: e37,
                        valueSpec: n12.source_video,
                        style: i8,
                        styleSpec: n12
                    });
                case "image":
                    return Jn({
                        key: r20,
                        value: e37,
                        valueSpec: n12.source_image,
                        style: i8,
                        styleSpec: n12
                    });
                case "canvas":
                    return [
                        new Wn(r20, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")
                    ];
                default:
                    return ii({
                        key: `${r20}.type`,
                        value: e37.type,
                        valueSpec: {
                            values: Mi(n12)
                        },
                        style: i8,
                        styleSpec: n12
                    });
            }
        }
        function Mi(t45) {
            return t45.source.reduce((e37, r20)=>{
                const n12 = t45[r20];
                return "enum" === n12.type.type && (e37 = e37.concat(Object.keys(n12.type.values))), e37;
            }, []);
        }
        function Ti(t45) {
            const e37 = t45.value, r20 = t45.styleSpec, n12 = r20.light, i8 = t45.style;
            let s6 = [];
            const a3 = Dn(e37);
            if ((void 0) === e37) return s6;
            if ("object" !== a3) return s6 = s6.concat([
                new Wn("light", e37, `object expected, ${a3} found`)
            ]), s6;
            for(const t46 in e37){
                const a4 = t46.match(/^(.*)-transition$/);
                s6 = s6.concat(a4 && n12[a4[1]] && n12[a4[1]].transition ? Ci({
                    key: t46,
                    value: e37[t46],
                    valueSpec: r20.transition,
                    style: i8,
                    styleSpec: r20
                }) : n12[t46] ? Ci({
                    key: t46,
                    value: e37[t46],
                    valueSpec: n12[t46],
                    style: i8,
                    styleSpec: r20
                }) : [
                    new Wn(t46, e37[t46], `unknown property "${t46}"`)
                ]);
            }
            return s6;
        }
        function zi(t45) {
            const e37 = t45.value, r20 = t45.key, n12 = t45.style, i8 = t45.styleSpec, s6 = i8.terrain;
            let a3 = [];
            const o3 = Dn(e37);
            if ((void 0) === e37) return a3;
            if ("object" !== o3) return a3 = a3.concat([
                new Wn("terrain", e37, `object expected, ${o3} found`)
            ]), a3;
            for(const t46 in e37){
                const r21 = t46.match(/^(.*)-transition$/);
                a3 = a3.concat(r21 && s6[r21[1]] && s6[r21[1]].transition ? Ci({
                    key: t46,
                    value: e37[t46],
                    valueSpec: i8.transition,
                    style: n12,
                    styleSpec: i8
                }) : s6[t46] ? Ci({
                    key: t46,
                    value: e37[t46],
                    valueSpec: s6[t46],
                    style: n12,
                    styleSpec: i8
                }) : [
                    new Wn(t46, e37[t46], `unknown property "${t46}"`)
                ]);
            }
            if (e37.source) {
                const t47 = n12.sources && n12.sources[e37.source], i9 = t47 && Jt(t47.type);
                t47 ? "raster-dem" !== i9 && a3.push(new Wn(r20, e37.source, `terrain cannot be used with a source of type ${String(i9)}, it only be used with a "raster-dem" source type`)) : a3.push(new Wn(r20, e37.source, `source "${e37.source}" not found`));
            } else a3.push(new Wn(r20, e37, 'terrain is missing required property "source"'));
            return a3;
        }
        function Bi(t45) {
            const e37 = t45.value, r20 = t45.style, n12 = t45.styleSpec, i8 = n12.fog;
            let s6 = [];
            const a3 = Dn(e37);
            if ((void 0) === e37) return s6;
            if ("object" !== a3) return s6 = s6.concat([
                new Wn("fog", e37, `object expected, ${a3} found`)
            ]), s6;
            for(const t46 in e37){
                const a4 = t46.match(/^(.*)-transition$/);
                s6 = s6.concat(a4 && i8[a4[1]] && i8[a4[1]].transition ? Ci({
                    key: t46,
                    value: e37[t46],
                    valueSpec: n12.transition,
                    style: r20,
                    styleSpec: n12
                }) : i8[t46] ? Ci({
                    key: t46,
                    value: e37[t46],
                    valueSpec: i8[t46],
                    style: r20,
                    styleSpec: n12
                }) : [
                    new Wn(t46, e37[t46], `unknown property "${t46}"`)
                ]);
            }
            return s6;
        }
        const Ei = {
            "*": ()=>[]
            ,
            array: Qn,
            boolean: function(t45) {
                const e37 = t45.value, r20 = t45.key, n12 = Dn(e37);
                return "boolean" !== n12 ? [
                    new Wn(r20, e37, `boolean expected, ${n12} found`)
                ] : [];
            },
            number: ti,
            color: function(t45) {
                const e37 = t45.key, r20 = t45.value, n12 = Dn(r20);
                return "string" !== n12 ? [
                    new Wn(e37, r20, `color expected, ${n12} found`)
                ] : null === be(r20) ? [
                    new Wn(e37, r20, `color expected, "${r20}" found`)
                ] : [];
            },
            enum: ii,
            filter: xi,
            function: ei,
            layer: Ai,
            object: Jn,
            source: Ii,
            light: Ti,
            terrain: zi,
            fog: Bi,
            string: Si,
            formatted: function(t45) {
                return 0 === Si(t45).length ? [] : ri(t45);
            },
            resolvedImage: function(t45) {
                return 0 === Si(t45).length ? [] : ri(t45);
            },
            projection: function(t45) {
                const e37 = t45.value, r20 = t45.styleSpec, n12 = r20.projection, i8 = t45.style;
                let s6 = [];
                const a3 = Dn(e37);
                if ("object" === a3) for(const t46 in e37)s6 = s6.concat(Ci({
                    key: t46,
                    value: e37[t46],
                    valueSpec: n12[t46],
                    style: i8,
                    styleSpec: r20
                }));
                else "string" !== a3 && (s6 = s6.concat([
                    new Wn("projection", e37, `object or string expected, ${a3} found`)
                ]));
                return s6;
            }
        };
        function Ci(t45) {
            const e37 = t45.value, r20 = t45.valueSpec, n12 = t45.styleSpec;
            return r20.expression && Vn(Jt(e37)) ? ei(t45) : r20.expression && Nn(Qt(e37)) ? ri(t45) : r20.type && Ei[r20.type] ? Ei[r20.type](t45) : Jn(Wt({
            }, t45, {
                valueSpec: r20.type ? n12[r20.type] : r20
            }));
        }
        function Pi(t45) {
            const e37 = t45.value, r20 = t45.key, n12 = Si(t45);
            return n12.length || (-1 === e37.indexOf("{fontstack}") && n12.push(new Wn(r20, e37, '"glyphs" url must include a "{fontstack}" token')), -1 === e37.indexOf("{range}") && n12.push(new Wn(r20, e37, '"glyphs" url must include a "{range}" token'))), n12;
        }
        function Di(t45, e37 = Ht) {
            return Fi(Ci({
                key: "",
                value: t45,
                valueSpec: e37.$root,
                styleSpec: e37,
                style: t45,
                objectElementValidators: {
                    glyphs: Pi,
                    "*": ()=>[]
                }
            }));
        }
        const Vi = (t45)=>Fi(wi(t45))
        , Li = (t45)=>Fi(_i(t45))
        ;
        function Fi(t45) {
            return t45.slice().sort((t46, e37)=>t46.line && e37.line ? t46.line - e37.line : 0
            );
        }
        function Ri(t45, e37) {
            let r20 = !1;
            if (e37 && e37.length) for (const n12 of e37)t45.fire(new Kt(new Error(n12.message))), r20 = !0;
            return r20;
        }
        var ji = Ui;
        function Ui(t45, e37, r20) {
            var n12 = this.cells = [];
            if (t45 instanceof ArrayBuffer) {
                this.arrayBuffer = t45;
                var i8 = new Int32Array(this.arrayBuffer);
                t45 = i8[0], this.d = (e37 = i8[1]) + 2 * (r20 = i8[2]);
                for(var s6 = 0; s6 < this.d * this.d; s6++){
                    var a3 = i8[3 + s6], o3 = i8[3 + s6 + 1];
                    n12.push(a3 === o3 ? null : i8.subarray(a3, o3));
                }
                var l3 = i8[3 + n12.length + 1];
                this.keys = i8.subarray(i8[3 + n12.length], l3), this.bboxes = i8.subarray(l3), this.insert = this._insertReadonly;
            } else {
                this.d = e37 + 2 * r20;
                for(var u2 = 0; u2 < this.d * this.d; u2++)n12.push([]);
                this.keys = [], this.bboxes = [];
            }
            this.n = e37, this.extent = t45, this.padding = r20, this.scale = e37 / t45, this.uid = 0;
            var c3 = r20 / e37 * t45;
            this.min = -c3, this.max = t45 + c3;
        }
        Ui.prototype.insert = function(t45, e37, r20, n12, i9) {
            this._forEachCell(e37, r20, n12, i9, this._insertCell, this.uid++), this.keys.push(t45), this.bboxes.push(e37), this.bboxes.push(r20), this.bboxes.push(n12), this.bboxes.push(i9);
        }, Ui.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, Ui.prototype._insertCell = function(t45, e37, r20, n12, i9, s7) {
            this.cells[i9].push(s7);
        }, Ui.prototype.query = function(t45, e37, r20, n12, i9) {
            var s7 = this.min, a4 = this.max;
            if (t45 <= s7 && e37 <= s7 && a4 <= r20 && a4 <= n12 && !i9) return Array.prototype.slice.call(this.keys);
            var o4 = [];
            return this._forEachCell(t45, e37, r20, n12, this._queryCell, o4, {
            }, i9), o4;
        }, Ui.prototype._queryCell = function(t45, e37, r20, n12, i9, s7, a4, o4) {
            var l4 = this.cells[i9];
            if (null !== l4) for(var u3 = this.keys, c3 = this.bboxes, h3 = 0; h3 < l4.length; h3++){
                var p3 = l4[h3];
                if ((void 0) === a4[p3]) {
                    var f1 = 4 * p3;
                    (o4 ? o4(c3[f1 + 0], c3[f1 + 1], c3[f1 + 2], c3[f1 + 3]) : t45 <= c3[f1 + 2] && e37 <= c3[f1 + 3] && r20 >= c3[f1 + 0] && n12 >= c3[f1 + 1]) ? (a4[p3] = !0, s7.push(u3[p3])) : a4[p3] = !1;
                }
            }
        }, Ui.prototype._forEachCell = function(t45, e37, r20, n12, i9, s7, a4, o4) {
            for(var l4 = this._convertToCellCoord(t45), u3 = this._convertToCellCoord(e37), c3 = this._convertToCellCoord(r20), h3 = this._convertToCellCoord(n12), p4 = l4; p4 <= c3; p4++)for(var f2 = u3; f2 <= h3; f2++){
                var d1 = this.d * f2 + p4;
                if ((!o4 || o4(this._convertFromCellCoord(p4), this._convertFromCellCoord(f2), this._convertFromCellCoord(p4 + 1), this._convertFromCellCoord(f2 + 1))) && i9.call(this, t45, e37, r20, n12, d1, s7, a4, o4)) return;
            }
        }, Ui.prototype._convertFromCellCoord = function(t45) {
            return (t45 - this.padding) / this.scale;
        }, Ui.prototype._convertToCellCoord = function(t45) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t45 * this.scale) + this.padding));
        }, Ui.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer) return this.arrayBuffer;
            for(var t45 = this.cells, e37 = 3 + this.cells.length + 1 + 1, r20 = 0, n12 = 0; n12 < this.cells.length; n12++)r20 += this.cells[n12].length;
            var i9 = new Int32Array(e37 + r20 + this.keys.length + this.bboxes.length);
            i9[0] = this.extent, i9[1] = this.n, i9[2] = this.padding;
            for(var s7 = e37, a4 = 0; a4 < t45.length; a4++){
                var o4 = t45[a4];
                i9[3 + a4] = s7, i9.set(o4, s7), s7 += o4.length;
            }
            return i9[3 + t45.length] = s7, i9.set(this.keys, s7), i9[3 + t45.length + 1] = s7 += this.keys.length, i9.set(this.bboxes, s7), s7 += this.bboxes.length, i9.buffer;
        };
        const $i = {
        };
        function Oi(t45, e37, r20 = {
        }) {
            Object.defineProperty(t45, "_classRegistryKey", {
                value: e37,
                writeable: !1
            }), $i[e37] = {
                klass: t45,
                omit: r20.omit || []
            };
        }
        Oi(Object, "Object"), ji.serialize = function(t45, e37) {
            const r20 = t45.toArrayBuffer();
            return e37 && e37.push(r20), {
                buffer: r20
            };
        }, ji.deserialize = function(t45) {
            return new ji(t45.buffer);
        }, Object.defineProperty(ji, "name", {
            value: "Grid"
        }), Oi(ji, "Grid"), Oi(Me, "Color"), Oi(Error, "Error"), Oi(at, "AJAXError"), Oi(Ee, "ResolvedImage"), Oi(Yn, "StylePropertyFunction"), Oi(qn, "StyleExpression", {
            omit: [
                "_evaluator"
            ]
        }), Oi(Zn, "ZoomDependentExpression"), Oi(Xn, "ZoomConstantExpression"), Oi(He, "CompoundExpression", {
            omit: [
                "_evaluate"
            ]
        });
        for(const t45 in Tn)$i[Tn[t45]._classRegistryKey] || Oi(Tn[t45], `Expression${t45}`);
        function qi(t46) {
            return t46 && "undefined" != typeof ArrayBuffer && (t46 instanceof ArrayBuffer || t46.constructor && "ArrayBuffer" === t46.constructor.name);
        }
        function Ni(t46) {
            return e2.ImageBitmap && t46 instanceof e2.ImageBitmap;
        }
        function Gi(t46, r20) {
            if (null == t46 || "boolean" == typeof t46 || "number" == typeof t46 || "string" == typeof t46 || t46 instanceof Boolean || t46 instanceof Number || t46 instanceof String || t46 instanceof Date || t46 instanceof RegExp) return t46;
            if (qi(t46) || Ni(t46)) return r20 && r20.push(t46), t46;
            if (ArrayBuffer.isView(t46)) {
                const e37 = t46;
                return r20 && r20.push(e37.buffer), e37;
            }
            if (t46 instanceof e2.ImageData) return r20 && r20.push(t46.data.buffer), t46;
            if (Array.isArray(t46)) {
                const e37 = [];
                for (const n12 of t46)e37.push(Gi(n12, r20));
                return e37;
            }
            if ("object" == typeof t46) {
                const e37 = t46.constructor, n12 = e37._classRegistryKey;
                if (!n12) throw new Error(`can't serialize object of unregistered class ${n12}`);
                const i9 = e37.serialize ? e37.serialize(t46, r20) : {
                };
                if (!e37.serialize) {
                    for(const e38 in t46)t46.hasOwnProperty(e38) && ($i[n12].omit.indexOf(e38) >= 0 || (i9[e38] = Gi(t46[e38], r20)));
                    t46 instanceof Error && (i9.message = t46.message);
                }
                if (i9.$name) throw new Error("$name property is reserved for worker serialization logic.");
                return "Object" !== n12 && (i9.$name = n12), i9;
            }
            throw new Error("can't serialize object of type " + typeof t46);
        }
        function Xi(t46) {
            if (null == t46 || "boolean" == typeof t46 || "number" == typeof t46 || "string" == typeof t46 || t46 instanceof Boolean || t46 instanceof Number || t46 instanceof String || t46 instanceof Date || t46 instanceof RegExp || qi(t46) || Ni(t46) || ArrayBuffer.isView(t46) || t46 instanceof e2.ImageData) return t46;
            if (Array.isArray(t46)) return t46.map(Xi);
            if ("object" == typeof t46) {
                const e37 = t46.$name || "Object", { klass: r20  } = $i[e37];
                if (!r20) throw new Error(`can't deserialize unregistered class ${e37}`);
                if (r20.deserialize) return r20.deserialize(t46);
                const n12 = Object.create(r20.prototype);
                for (const e38 of Object.keys(t46))"$name" !== e38 && (n12[e38] = Xi(t46[e38]));
                return n12;
            }
            throw new Error("can't deserialize object of type " + typeof t46);
        }
        const Zi = (t46)=>t46 >= 1536 && t46 <= 1791
        , Ki = (t46)=>t46 >= 1872 && t46 <= 1919
        , Yi = (t46)=>t46 >= 2208 && t46 <= 2303
        , Hi = (t46)=>t46 >= 11904 && t46 <= 12031
        , Wi = (t46)=>t46 >= 12032 && t46 <= 12255
        , Ji = (t46)=>t46 >= 12272 && t46 <= 12287
        , Qi = (t46)=>t46 >= 12288 && t46 <= 12351
        , ts = (t46)=>t46 >= 12352 && t46 <= 12447
        , es = (t46)=>t46 >= 12448 && t46 <= 12543
        , rs = (t46)=>t46 >= 12544 && t46 <= 12591
        , ns = (t46)=>t46 >= 12704 && t46 <= 12735
        , is = (t46)=>t46 >= 12736 && t46 <= 12783
        , ss = (t46)=>t46 >= 12784 && t46 <= 12799
        , as = (t46)=>t46 >= 12800 && t46 <= 13055
        , os = (t46)=>t46 >= 13056 && t46 <= 13311
        , ls = (t46)=>t46 >= 13312 && t46 <= 19903
        , us = (t46)=>t46 >= 19968 && t46 <= 40959
        , cs = (t46)=>t46 >= 40960 && t46 <= 42127
        , hs = (t46)=>t46 >= 42128 && t46 <= 42191
        , ps = (t46)=>t46 >= 44032 && t46 <= 55215
        , fs = (t46)=>t46 >= 63744 && t46 <= 64255
        , ds = (t46)=>t46 >= 64336 && t46 <= 65023
        , ys = (t46)=>t46 >= 65040 && t46 <= 65055
        , ms = (t46)=>t46 >= 65072 && t46 <= 65103
        , gs = (t46)=>t46 >= 65104 && t46 <= 65135
        , xs = (t46)=>t46 >= 65136 && t46 <= 65279
        , vs = (t46)=>t46 >= 65280 && t46 <= 65519
        ;
        function bs(t46) {
            for (const e37 of t46)if (As(e37.charCodeAt(0))) return !0;
            return !1;
        }
        function ws(t46) {
            for (const e37 of t46)if (!_s(e37.charCodeAt(0))) return !1;
            return !0;
        }
        function _s(t46) {
            return !(Zi(t46) || Ki(t46) || Yi(t46) || ds(t46) || xs(t46));
        }
        function As(t46) {
            return !(746 !== t46 && 747 !== t46 && (t46 < 4352 || !(ns(t46) || rs(t46) || ms(t46) && !(t46 >= 65097 && t46 <= 65103) || fs(t46) || os(t46) || Hi(t46) || is(t46) || !(!Qi(t46) || t46 >= 12296 && t46 <= 12305 || t46 >= 12308 && t46 <= 12319 || 12336 === t46) || ls(t46) || us(t46) || as(t46) || ((t47)=>t47 >= 12592 && t47 <= 12687
            )(t46) || ((t47)=>t47 >= 43360 && t47 <= 43391
            )(t46) || ((t47)=>t47 >= 55216 && t47 <= 55295
            )(t46) || ((t47)=>t47 >= 4352 && t47 <= 4607
            )(t46) || ps(t46) || ts(t46) || Ji(t46) || ((t47)=>t47 >= 12688 && t47 <= 12703
            )(t46) || Wi(t46) || ss(t46) || es(t46) && 12540 !== t46 || !(!vs(t46) || 65288 === t46 || 65289 === t46 || 65293 === t46 || t46 >= 65306 && t46 <= 65310 || 65339 === t46 || 65341 === t46 || 65343 === t46 || t46 >= 65371 && t46 <= 65503 || 65507 === t46 || t46 >= 65512 && t46 <= 65519) || !(!gs(t46) || t46 >= 65112 && t46 <= 65118 || t46 >= 65123 && t46 <= 65126) || ((t47)=>t47 >= 5120 && t47 <= 5759
            )(t46) || ((t47)=>t47 >= 6320 && t47 <= 6399
            )(t46) || ys(t46) || ((t47)=>t47 >= 19904 && t47 <= 19967
            )(t46) || cs(t46) || hs(t46))));
        }
        function Ss(t46) {
            return !(As(t46) || function(t47) {
                return !!(((t48)=>t48 >= 128 && t48 <= 255
                )(t47) && (167 === t47 || 169 === t47 || 174 === t47 || 177 === t47 || 188 === t47 || 189 === t47 || 190 === t47 || 215 === t47 || 247 === t47) || ((t48)=>t48 >= 8192 && t48 <= 8303
                )(t47) && (8214 === t47 || 8224 === t47 || 8225 === t47 || 8240 === t47 || 8241 === t47 || 8251 === t47 || 8252 === t47 || 8258 === t47 || 8263 === t47 || 8264 === t47 || 8265 === t47 || 8273 === t47) || ((t48)=>t48 >= 8448 && t48 <= 8527
                )(t47) || ((t48)=>t48 >= 8528 && t48 <= 8591
                )(t47) || ((t48)=>t48 >= 8960 && t48 <= 9215
                )(t47) && (t47 >= 8960 && t47 <= 8967 || t47 >= 8972 && t47 <= 8991 || t47 >= 8996 && t47 <= 9000 || 9003 === t47 || t47 >= 9085 && t47 <= 9114 || t47 >= 9150 && t47 <= 9165 || 9167 === t47 || t47 >= 9169 && t47 <= 9179 || t47 >= 9186 && t47 <= 9215) || ((t48)=>t48 >= 9216 && t48 <= 9279
                )(t47) && 9251 !== t47 || ((t48)=>t48 >= 9280 && t48 <= 9311
                )(t47) || ((t48)=>t48 >= 9312 && t48 <= 9471
                )(t47) || ((t48)=>t48 >= 9632 && t48 <= 9727
                )(t47) || ((t48)=>t48 >= 9728 && t48 <= 9983
                )(t47) && !(t47 >= 9754 && t47 <= 9759) || ((t48)=>t48 >= 11008 && t48 <= 11263
                )(t47) && (t47 >= 11026 && t47 <= 11055 || t47 >= 11088 && t47 <= 11097 || t47 >= 11192 && t47 <= 11243) || Qi(t47) || es(t47) || ((t48)=>t48 >= 57344 && t48 <= 63743
                )(t47) || ms(t47) || gs(t47) || vs(t47) || 8734 === t47 || 8756 === t47 || 8757 === t47 || t47 >= 9984 && t47 <= 10087 || t47 >= 10102 && t47 <= 10131 || 65532 === t47 || 65533 === t47);
            }(t46));
        }
        function ks(t46) {
            return t46 >= 1424 && t46 <= 2303 || ds(t46) || xs(t46);
        }
        function Is(t46, e37) {
            return !(!e37 && ks(t46) || t46 >= 2304 && t46 <= 3583 || t46 >= 3840 && t46 <= 4255 || ((t47)=>t47 >= 6016 && t47 <= 6143
            )(t46));
        }
        function Ms(t46) {
            for (const e37 of t46)if (ks(e37.charCodeAt(0))) return !0;
            return !1;
        }
        const Ts = "deferred", zs = "loading", Bs = "loaded";
        let Es = null, Cs = "unavailable", Ps = null;
        const Ds = function(t46) {
            t46 && "string" == typeof t46 && t46.indexOf("NetworkError") > -1 && (Cs = "error"), Es && Es(t46);
        };
        function Vs() {
            Ls.fire(new Zt("pluginStateChange", {
                pluginStatus: Cs,
                pluginURL: Ps
            }));
        }
        const Ls = new Yt, Fs = function() {
            return Cs;
        }, Rs = function() {
            if (Cs !== Ts || !Ps) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Cs = zs, Vs(), Ps && ut({
                url: Ps
            }, (t46)=>{
                t46 ? Ds(t46) : (Cs = Bs, Vs());
            });
        }, js = {
            applyArabicShaping: null,
            processBidirectionalText: null,
            processStyledBidirectionalText: null,
            isLoaded: ()=>Cs === Bs || null != js.applyArabicShaping
            ,
            isLoading: ()=>Cs === zs
            ,
            setState (t) {
                Cs = t.pluginStatus, Ps = t.pluginURL;
            },
            isParsed: ()=>null != js.applyArabicShaping && null != js.processBidirectionalText && null != js.processStyledBidirectionalText
            ,
            getPluginURL: ()=>Ps
        };
        class Us {
            constructor(t46, e37){
                this.zoom = t46, e37 ? (this.now = e37.now, this.fadeDuration = e37.fadeDuration, this.transition = e37.transition, this.pitch = e37.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {
                }, this.pitch = 0);
            }
            isSupportedScript(t) {
                return (function(t47, e38) {
                    for (const r20 of t47)if (!Is(r20.charCodeAt(0), e38)) return !1;
                    return !0;
                })(t, js.isLoaded());
            }
        }
        class $s {
            constructor(t47, e38){
                this.property = t47, this.value = e38, this.expression = (function(t48, e39) {
                    if (Vn(t48)) return new Yn(t48, e39);
                    if (Nn(t48)) {
                        const r20 = Kn(t48, e39);
                        if ("error" === r20.result) throw new Error(r20.value.map((t49)=>`${t49.key}: ${t49.message}`
                        ).join(", "));
                        return r20.value;
                    }
                    {
                        let r20 = t48;
                        return "string" == typeof t48 && "color" === e39.type && (r20 = Me.parse(t48)), {
                            kind: "constant",
                            evaluate: ()=>r20
                        };
                    }
                })((void 0) === e38 ? t47.specification.default : e38, t47.specification);
            }
            isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t, e, r) {
                return this.property.possiblyEvaluate(this, t, e, r);
            }
        }
        class Os {
            constructor(t48){
                this.property = t48, this.value = new $s(t48, void 0);
            }
            transitioned(t, e) {
                return new Ns(this.property, this.value, e, z1({
                }, t.transition, this.transition), t.now);
            }
            untransitioned() {
                return new Ns(this.property, this.value, null, {
                }, 0);
            }
        }
        class qs {
            constructor(t49){
                this._properties = t49, this._values = Object.create(t49.defaultTransitionablePropertyValues);
            }
            getValue(t) {
                return j(this._values[t].value.value);
            }
            setValue(t, e) {
                this._values.hasOwnProperty(t) || (this._values[t] = new Os(this._values[t].property)), this._values[t].value = new $s(this._values[t].property, null === e ? void 0 : j(e));
            }
            getTransition(t) {
                return j(this._values[t].transition);
            }
            setTransition(t, e) {
                this._values.hasOwnProperty(t) || (this._values[t] = new Os(this._values[t].property)), this._values[t].transition = j(e) || void 0;
            }
            serialize() {
                const t50 = {
                };
                for (const e39 of Object.keys(this._values)){
                    const r20 = this.getValue(e39);
                    (void 0) !== r20 && (t50[e39] = r20);
                    const n12 = this.getTransition(e39);
                    (void 0) !== n12 && (t50[`${e39}-transition`] = n12);
                }
                return t50;
            }
            transitioned(t, e) {
                const r20 = new Gs(this._properties);
                for (const n12 of Object.keys(this._values))r20._values[n12] = this._values[n12].transitioned(t, e._values[n12]);
                return r20;
            }
            untransitioned() {
                const t50 = new Gs(this._properties);
                for (const e39 of Object.keys(this._values))t50._values[e39] = this._values[e39].untransitioned();
                return t50;
            }
        }
        class Ns {
            constructor(t50, e39, r20, n12, i9){
                const s7 = n12.delay || 0, a4 = n12.duration || 0;
                i9 = i9 || 0, this.property = t50, this.value = e39, this.begin = i9 + s7, this.end = this.begin + a4, t50.specification.transition && (n12.delay || n12.duration) && (this.prior = r20);
            }
            possiblyEvaluate(t, e, r) {
                const n13 = t.now || 0, i10 = this.value.possiblyEvaluate(t, e, r), s8 = this.prior;
                if (s8) {
                    if (n13 > this.end) return this.prior = null, i10;
                    if (this.value.isDataDriven()) return this.prior = null, i10;
                    if (n13 < this.begin) return s8.possiblyEvaluate(t, e, r);
                    {
                        const a5 = (n13 - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(s8.possiblyEvaluate(t, e, r), i10, w1(a5));
                    }
                }
                return i10;
            }
        }
        class Gs {
            constructor(t51){
                this._properties = t51, this._values = Object.create(t51.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t, e, r) {
                const n13 = new Ks(this._properties);
                for (const i10 of Object.keys(this._values))n13._values[i10] = this._values[i10].possiblyEvaluate(t, e, r);
                return n13;
            }
            hasTransition() {
                for (const t52 of Object.keys(this._values))if (this._values[t52].prior) return !0;
                return !1;
            }
        }
        class Xs {
            constructor(t52){
                this._properties = t52, this._values = Object.create(t52.defaultPropertyValues);
            }
            getValue(t) {
                return j(this._values[t].value);
            }
            setValue(t, e) {
                this._values[t] = new $s(this._values[t].property, null === e ? void 0 : j(e));
            }
            serialize() {
                const t53 = {
                };
                for (const e40 of Object.keys(this._values)){
                    const r21 = this.getValue(e40);
                    (void 0) !== r21 && (t53[e40] = r21);
                }
                return t53;
            }
            possiblyEvaluate(t, e, r) {
                const n13 = new Ks(this._properties);
                for (const i10 of Object.keys(this._values))n13._values[i10] = this._values[i10].possiblyEvaluate(t, e, r);
                return n13;
            }
        }
        class Zs {
            constructor(t53, e40, r21){
                this.property = t53, this.value = e40, this.parameters = r21;
            }
            isConstant() {
                return "constant" === this.value.kind;
            }
            constantOr(t) {
                return "constant" === this.value.kind ? this.value.value : t;
            }
            evaluate(t, e, r, n) {
                return this.property.evaluate(this.value, this.parameters, t, e, r, n);
            }
        }
        class Ks {
            constructor(t54){
                this._properties = t54, this._values = Object.create(t54.defaultPossiblyEvaluatedValues);
            }
            get(t) {
                return this._values[t];
            }
        }
        class Ys {
            constructor(t55){
                this.specification = t55;
            }
            possiblyEvaluate(t, e) {
                return t.expression.evaluate(e);
            }
            interpolate(t, e, r) {
                const n13 = Tr[this.specification.type];
                return n13 ? n13(t, e, r) : t;
            }
        }
        class Hs {
            constructor(t56, e41){
                this.specification = t56, this.overrides = e41;
            }
            possiblyEvaluate(t, e, r, n) {
                return new Zs(this, "constant" === t.expression.kind || "camera" === t.expression.kind ? {
                    kind: "constant",
                    value: t.expression.evaluate(e, null, {
                    }, r, n)
                } : t.expression, e);
            }
            interpolate(t, e, r) {
                if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t;
                if ((void 0) === t.value.value || (void 0) === e.value.value) return new Zs(this, {
                    kind: "constant",
                    value: void 0
                }, t.parameters);
                const n13 = Tr[this.specification.type];
                return n13 ? new Zs(this, {
                    kind: "constant",
                    value: n13(t.value.value, e.value.value, r)
                }, t.parameters) : t;
            }
            evaluate(t, e, r, n, i, s) {
                return "constant" === t.kind ? t.value : t.evaluate(e, r, n, i, s);
            }
        }
        class Ws {
            constructor(t57){
                this.specification = t57;
            }
            possiblyEvaluate(t, e, r, n) {
                return !!t.expression.evaluate(e, null, {
                }, r, n);
            }
            interpolate() {
                return !1;
            }
        }
        class Js {
            constructor(t58){
                this.properties = t58, this.defaultPropertyValues = {
                }, this.defaultTransitionablePropertyValues = {
                }, this.defaultTransitioningPropertyValues = {
                }, this.defaultPossiblyEvaluatedValues = {
                }, this.overridableProperties = [];
                const e42 = new Us(0, {
                });
                for(const r22 in t58){
                    const n13 = t58[r22];
                    n13.specification.overridable && this.overridableProperties.push(r22);
                    const i10 = this.defaultPropertyValues[r22] = new $s(n13, void 0), s8 = this.defaultTransitionablePropertyValues[r22] = new Os(n13);
                    this.defaultTransitioningPropertyValues[r22] = s8.untransitioned(), this.defaultPossiblyEvaluatedValues[r22] = i10.possiblyEvaluate(e42);
                }
            }
        }
        function Qs(t59, e43) {
            return 256 * (t59 = S1(Math.floor(t59), 0, 255)) + S1(Math.floor(e43), 0, 255);
        }
        Oi(Hs, "DataDrivenProperty"), Oi(Ys, "DataConstantProperty"), Oi(Ws, "ColorRampProperty");
        const ta = {
            Int8: Int8Array,
            Uint8: Uint8Array,
            Int16: Int16Array,
            Uint16: Uint16Array,
            Int32: Int32Array,
            Uint32: Uint32Array,
            Float32: Float32Array
        };
        class ea {
            constructor(t59, e43){
                this._structArray = t59, this._pos1 = e43 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
        }
        class ra {
            constructor(){
                this.isTransferred = !1, this.capacity = -1, this.resize(0);
            }
            static serialize(t, e) {
                return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), {
                    length: t.length,
                    arrayBuffer: t.arrayBuffer
                };
            }
            static deserialize(t) {
                const e44 = Object.create(this.prototype);
                return e44.arrayBuffer = t.arrayBuffer, e44.length = t.length, e44.capacity = t.arrayBuffer.byteLength / e44.bytesPerElement, e44._refreshViews(), e44;
            }
            _trim() {
                this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
                this.length = 0;
            }
            resize(t) {
                this.reserve(t), this.length = t;
            }
            reserve(t) {
                if (t > this.capacity) {
                    this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const e44 = this.uint8;
                    this._refreshViews(), e44 && this.uint8.set(e44);
                }
            }
            _refreshViews() {
                throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
            destroy() {
                this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
        }
        function na(t60, e44 = 1) {
            let r23 = 0, n13 = 0;
            return {
                members: t60.map((t61)=>{
                    const i10 = ta[t61.type].BYTES_PER_ELEMENT, s8 = r23 = ia(r23, Math.max(e44, i10)), a5 = t61.components || 1;
                    return n13 = Math.max(n13, i10), r23 += i10 * a5, {
                        name: t61.name,
                        type: t61.type,
                        components: a5,
                        offset: s8
                    };
                }),
                size: ia(r23, Math.max(n13, e44)),
                alignment: e44
            };
        }
        function ia(t60, e44) {
            return Math.ceil(t60 / e44) * e44;
        }
        class sa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e) {
                const r23 = this.length;
                return this.resize(r23 + 1), this.emplace(r23, t, e);
            }
            emplace(t, e, r) {
                const n13 = 2 * t;
                return this.int16[n13 + 0] = e, this.int16[n13 + 1] = r, t;
            }
        }
        sa.prototype.bytesPerElement = 4, Oi(sa, "StructArrayLayout2i4");
        class aa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r) {
                const n13 = this.length;
                return this.resize(n13 + 1), this.emplace(n13, t, e, r);
            }
            emplace(t, e, r, n) {
                const i10 = 3 * t;
                return this.int16[i10 + 0] = e, this.int16[i10 + 1] = r, this.int16[i10 + 2] = n, t;
            }
        }
        aa.prototype.bytesPerElement = 6, Oi(aa, "StructArrayLayout3i6");
        class oa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n) {
                const i10 = this.length;
                return this.resize(i10 + 1), this.emplace(i10, t, e, r, n);
            }
            emplace(t, e, r, n, i) {
                const s8 = 4 * t;
                return this.int16[s8 + 0] = e, this.int16[s8 + 1] = r, this.int16[s8 + 2] = n, this.int16[s8 + 3] = i, t;
            }
        }
        oa.prototype.bytesPerElement = 8, Oi(oa, "StructArrayLayout4i8");
        class la extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a) {
                const o5 = this.length;
                return this.resize(o5 + 1), this.emplace(o5, t, e, r, n, i, s, a);
            }
            emplace(t, e, r, n, i, s, a, o) {
                const l4 = 6 * t, u3 = 12 * t, c3 = 3 * t;
                return this.int16[l4 + 0] = e, this.int16[l4 + 1] = r, this.uint8[u3 + 4] = n, this.uint8[u3 + 5] = i, this.uint8[u3 + 6] = s, this.uint8[u3 + 7] = a, this.float32[c3 + 2] = o, t;
            }
        }
        la.prototype.bytesPerElement = 12, Oi(la, "StructArrayLayout2i4ub1f12");
        class ua extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n) {
                const i10 = this.length;
                return this.resize(i10 + 1), this.emplace(i10, t, e, r, n);
            }
            emplace(t, e, r, n, i) {
                const s8 = 4 * t;
                return this.float32[s8 + 0] = e, this.float32[s8 + 1] = r, this.float32[s8 + 2] = n, this.float32[s8 + 3] = i, t;
            }
        }
        ua.prototype.bytesPerElement = 16, Oi(ua, "StructArrayLayout4f16");
        class ca extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i) {
                const s8 = this.length;
                return this.resize(s8 + 1), this.emplace(s8, t, e, r, n, i);
            }
            emplace(t, e, r, n, i, s) {
                const a5 = 6 * t, o5 = 3 * t;
                return this.uint16[a5 + 0] = e, this.uint16[a5 + 1] = r, this.uint16[a5 + 2] = n, this.uint16[a5 + 3] = i, this.float32[o5 + 2] = s, t;
            }
        }
        ca.prototype.bytesPerElement = 12, Oi(ca, "StructArrayLayout4ui1f12");
        class ha extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n) {
                const i10 = this.length;
                return this.resize(i10 + 1), this.emplace(i10, t, e, r, n);
            }
            emplace(t, e, r, n, i) {
                const s8 = 4 * t;
                return this.uint16[s8 + 0] = e, this.uint16[s8 + 1] = r, this.uint16[s8 + 2] = n, this.uint16[s8 + 3] = i, t;
            }
        }
        ha.prototype.bytesPerElement = 8, Oi(ha, "StructArrayLayout4ui8");
        class pa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s) {
                const a5 = this.length;
                return this.resize(a5 + 1), this.emplace(a5, t, e, r, n, i, s);
            }
            emplace(t, e, r, n, i, s, a) {
                const o5 = 6 * t;
                return this.int16[o5 + 0] = e, this.int16[o5 + 1] = r, this.int16[o5 + 2] = n, this.int16[o5 + 3] = i, this.int16[o5 + 4] = s, this.int16[o5 + 5] = a, t;
            }
        }
        pa.prototype.bytesPerElement = 12, Oi(pa, "StructArrayLayout6i12");
        class fa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h) {
                const p4 = this.length;
                return this.resize(p4 + 1), this.emplace(p4, t, e, r, n, i, s, a, o, l, u, c, h);
            }
            emplace(t, e, r, n, i, s, a, o, l, u, c, h, p) {
                const f2 = 12 * t;
                return this.int16[f2 + 0] = e, this.int16[f2 + 1] = r, this.int16[f2 + 2] = n, this.int16[f2 + 3] = i, this.uint16[f2 + 4] = s, this.uint16[f2 + 5] = a, this.uint16[f2 + 6] = o, this.uint16[f2 + 7] = l, this.int16[f2 + 8] = u, this.int16[f2 + 9] = c, this.int16[f2 + 10] = h, this.int16[f2 + 11] = p, t;
            }
        }
        fa.prototype.bytesPerElement = 24, Oi(fa, "StructArrayLayout4i4ui4i24");
        class da extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s) {
                const a5 = this.length;
                return this.resize(a5 + 1), this.emplace(a5, t, e, r, n, i, s);
            }
            emplace(t, e, r, n, i, s, a) {
                const o5 = 10 * t, l4 = 5 * t;
                return this.int16[o5 + 0] = e, this.int16[o5 + 1] = r, this.int16[o5 + 2] = n, this.float32[l4 + 2] = i, this.float32[l4 + 3] = s, this.float32[l4 + 4] = a, t;
            }
        }
        da.prototype.bytesPerElement = 20, Oi(da, "StructArrayLayout3i3f20");
        class ya extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t) {
                const e44 = this.length;
                return this.resize(e44 + 1), this.emplace(e44, t);
            }
            emplace(t, e) {
                return this.uint32[1 * t + 0] = e, t;
            }
        }
        ya.prototype.bytesPerElement = 4, Oi(ya, "StructArrayLayout1ul4");
        class ma extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p) {
                const f2 = this.length;
                return this.resize(f2 + 1), this.emplace(f2, t, e, r, n, i, s, a, o, l, u, c, h, p);
            }
            emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {
                const d2 = 20 * t, y1 = 10 * t;
                return this.int16[d2 + 0] = e, this.int16[d2 + 1] = r, this.int16[d2 + 2] = n, this.int16[d2 + 3] = i, this.int16[d2 + 4] = s, this.float32[y1 + 3] = a, this.float32[y1 + 4] = o, this.float32[y1 + 5] = l, this.float32[y1 + 6] = u, this.int16[d2 + 14] = c, this.uint32[y1 + 8] = h, this.uint16[d2 + 18] = p, this.uint16[d2 + 19] = f, t;
            }
        }
        ma.prototype.bytesPerElement = 40, Oi(ma, "StructArrayLayout5i4f1i1ul2ui40");
        class ga extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a) {
                const o5 = this.length;
                return this.resize(o5 + 1), this.emplace(o5, t, e, r, n, i, s, a);
            }
            emplace(t, e, r, n, i, s, a, o) {
                const l4 = 8 * t;
                return this.int16[l4 + 0] = e, this.int16[l4 + 1] = r, this.int16[l4 + 2] = n, this.int16[l4 + 4] = i, this.int16[l4 + 5] = s, this.int16[l4 + 6] = a, this.int16[l4 + 7] = o, t;
            }
        }
        ga.prototype.bytesPerElement = 16, Oi(ga, "StructArrayLayout3i2i2i16");
        class xa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i) {
                const s8 = this.length;
                return this.resize(s8 + 1), this.emplace(s8, t, e, r, n, i);
            }
            emplace(t, e, r, n, i, s) {
                const a5 = 4 * t, o5 = 8 * t;
                return this.float32[a5 + 0] = e, this.float32[a5 + 1] = r, this.float32[a5 + 2] = n, this.int16[o5 + 6] = i, this.int16[o5 + 7] = s, t;
            }
        }
        xa.prototype.bytesPerElement = 16, Oi(xa, "StructArrayLayout2f1f2i16");
        class va extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n) {
                const i10 = this.length;
                return this.resize(i10 + 1), this.emplace(i10, t, e, r, n);
            }
            emplace(t, e, r, n, i) {
                const s8 = 12 * t, a5 = 3 * t;
                return this.uint8[s8 + 0] = e, this.uint8[s8 + 1] = r, this.float32[a5 + 1] = n, this.float32[a5 + 2] = i, t;
            }
        }
        va.prototype.bytesPerElement = 12, Oi(va, "StructArrayLayout2ub2f12");
        class ba extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r) {
                const n13 = this.length;
                return this.resize(n13 + 1), this.emplace(n13, t, e, r);
            }
            emplace(t, e, r, n) {
                const i10 = 3 * t;
                return this.float32[i10 + 0] = e, this.float32[i10 + 1] = r, this.float32[i10 + 2] = n, t;
            }
        }
        ba.prototype.bytesPerElement = 12, Oi(ba, "StructArrayLayout3f12");
        class wa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r) {
                const n13 = this.length;
                return this.resize(n13 + 1), this.emplace(n13, t, e, r);
            }
            emplace(t, e, r, n) {
                const i10 = 3 * t;
                return this.uint16[i10 + 0] = e, this.uint16[i10 + 1] = r, this.uint16[i10 + 2] = n, t;
            }
        }
        wa.prototype.bytesPerElement = 6, Oi(wa, "StructArrayLayout3ui6");
        class _a extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b) {
                const w1 = this.length;
                return this.resize(w1 + 1), this.emplace(w1, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b);
            }
            emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w) {
                const _1 = 30 * t, A1 = 15 * t, S1 = 60 * t;
                return this.int16[_1 + 0] = e, this.int16[_1 + 1] = r, this.int16[_1 + 2] = n, this.float32[A1 + 2] = i, this.float32[A1 + 3] = s, this.uint16[_1 + 8] = a, this.uint16[_1 + 9] = o, this.uint32[A1 + 5] = l, this.uint32[A1 + 6] = u, this.uint32[A1 + 7] = c, this.uint16[_1 + 16] = h, this.uint16[_1 + 17] = p, this.uint16[_1 + 18] = f, this.float32[A1 + 10] = d, this.float32[A1 + 11] = y, this.uint8[S1 + 48] = m, this.uint8[S1 + 49] = g, this.uint8[S1 + 50] = x, this.uint32[A1 + 13] = v, this.int16[_1 + 28] = b, this.uint8[S1 + 58] = w, t;
            }
        }
        _a.prototype.bytesPerElement = 60, Oi(_a, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class Aa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z) {
                const B1 = this.length;
                return this.resize(B1 + 1), this.emplace(B1, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z);
            }
            emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z, B) {
                const E1 = 38 * t, C1 = 19 * t;
                return this.int16[E1 + 0] = e, this.int16[E1 + 1] = r, this.int16[E1 + 2] = n, this.float32[C1 + 2] = i, this.float32[C1 + 3] = s, this.int16[E1 + 8] = a, this.int16[E1 + 9] = o, this.int16[E1 + 10] = l, this.int16[E1 + 11] = u, this.int16[E1 + 12] = c, this.int16[E1 + 13] = h, this.uint16[E1 + 14] = p, this.uint16[E1 + 15] = f, this.uint16[E1 + 16] = d, this.uint16[E1 + 17] = y, this.uint16[E1 + 18] = m, this.uint16[E1 + 19] = g, this.uint16[E1 + 20] = x, this.uint16[E1 + 21] = v, this.uint16[E1 + 22] = b, this.uint16[E1 + 23] = w, this.uint16[E1 + 24] = _, this.uint16[E1 + 25] = A, this.uint16[E1 + 26] = S, this.uint16[E1 + 27] = k, this.uint16[E1 + 28] = I, this.uint32[C1 + 15] = M, this.float32[C1 + 16] = T, this.float32[C1 + 17] = z, this.float32[C1 + 18] = B, t;
            }
        }
        Aa.prototype.bytesPerElement = 76, Oi(Aa, "StructArrayLayout3i2f6i15ui1ul3f76");
        class Sa extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t) {
                const e44 = this.length;
                return this.resize(e44 + 1), this.emplace(e44, t);
            }
            emplace(t, e) {
                return this.float32[1 * t + 0] = e, t;
            }
        }
        Sa.prototype.bytesPerElement = 4, Oi(Sa, "StructArrayLayout1f4");
        class ka extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n, i) {
                const s8 = this.length;
                return this.resize(s8 + 1), this.emplace(s8, t, e, r, n, i);
            }
            emplace(t, e, r, n, i, s) {
                const a5 = 5 * t;
                return this.float32[a5 + 0] = e, this.float32[a5 + 1] = r, this.float32[a5 + 2] = n, this.float32[a5 + 3] = i, this.float32[a5 + 4] = s, t;
            }
        }
        ka.prototype.bytesPerElement = 20, Oi(ka, "StructArrayLayout5f20");
        class Ia extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e, r, n) {
                const i10 = this.length;
                return this.resize(i10 + 1), this.emplace(i10, t, e, r, n);
            }
            emplace(t, e, r, n, i) {
                const s8 = 6 * t;
                return this.uint32[3 * t + 0] = e, this.uint16[s8 + 2] = r, this.uint16[s8 + 3] = n, this.uint16[s8 + 4] = i, t;
            }
        }
        Ia.prototype.bytesPerElement = 12, Oi(Ia, "StructArrayLayout1ul3ui12");
        class Ma extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t, e) {
                const r23 = this.length;
                return this.resize(r23 + 1), this.emplace(r23, t, e);
            }
            emplace(t, e, r) {
                const n13 = 2 * t;
                return this.uint16[n13 + 0] = e, this.uint16[n13 + 1] = r, t;
            }
        }
        Ma.prototype.bytesPerElement = 4, Oi(Ma, "StructArrayLayout2ui4");
        class Ta extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t) {
                const e44 = this.length;
                return this.resize(e44 + 1), this.emplace(e44, t);
            }
            emplace(t, e) {
                return this.uint16[1 * t + 0] = e, t;
            }
        }
        Ta.prototype.bytesPerElement = 2, Oi(Ta, "StructArrayLayout1ui2");
        class za extends ra {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t, e) {
                const r23 = this.length;
                return this.resize(r23 + 1), this.emplace(r23, t, e);
            }
            emplace(t, e, r) {
                const n13 = 2 * t;
                return this.float32[n13 + 0] = e, this.float32[n13 + 1] = r, t;
            }
        }
        za.prototype.bytesPerElement = 8, Oi(za, "StructArrayLayout2f8");
        class Ba extends ea {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
            }
            get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get x1() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get y1() {
                return this._structArray.float32[this._pos4 + 4];
            }
            get x2() {
                return this._structArray.float32[this._pos4 + 5];
            }
            get y2() {
                return this._structArray.float32[this._pos4 + 6];
            }
            get padding() {
                return this._structArray.int16[this._pos2 + 14];
            }
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
        }
        Ba.prototype.size = 40;
        class Ea extends ma {
            get(t) {
                return new Ba(this, t);
            }
        }
        Oi(Ea, "CollisionBoxArray");
        class Ca extends ea {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
            }
            get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
            }
            get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
            }
            get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
            }
            get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
            }
            get segment() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
            }
            get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
            }
            get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
            }
            get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
            }
            set placedOrientation(t) {
                this._structArray.uint8[this._pos1 + 49] = t;
            }
            get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
            }
            set hidden(t) {
                this._structArray.uint8[this._pos1 + 50] = t;
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 13] = t;
            }
            get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
            }
            get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
            }
            set flipState(t) {
                this._structArray.uint8[this._pos1 + 58] = t;
            }
        }
        Ca.prototype.size = 60;
        class Pa extends _a {
            get(t) {
                return new Ca(this, t);
            }
        }
        Oi(Pa, "PlacedSymbolArray");
        class Da extends ea {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
            }
            get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
            }
            get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
            }
            get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
            }
            get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
            }
            get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 13];
            }
            get key() {
                return this._structArray.uint16[this._pos2 + 14];
            }
            get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15];
            }
            get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
            get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 20];
            }
            get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 21];
            }
            get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 22];
            }
            get featureIndex() {
                return this._structArray.uint16[this._pos2 + 23];
            }
            get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
            }
            get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 25];
            }
            get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
            }
            get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 27];
            }
            get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 28];
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 15];
            }
            set crossTileID(t) {
                this._structArray.uint32[this._pos4 + 15] = t;
            }
            get textOffset0() {
                return this._structArray.float32[this._pos4 + 16];
            }
            get textOffset1() {
                return this._structArray.float32[this._pos4 + 17];
            }
            get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 18];
            }
        }
        Da.prototype.size = 76;
        class Va extends Aa {
            get(t) {
                return new Da(this, t);
            }
        }
        Oi(Va, "SymbolInstanceArray");
        class La extends Sa {
            getoffsetX(t) {
                return this.float32[1 * t + 0];
            }
        }
        Oi(La, "GlyphOffsetArray");
        class Fa extends sa {
            getx(t) {
                return this.int16[2 * t + 0];
            }
            gety(t) {
                return this.int16[2 * t + 1];
            }
        }
        Oi(Fa, "SymbolLineVertexArray");
        class Ra extends ea {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
            }
        }
        Ra.prototype.size = 12;
        class ja extends Ia {
            get(t) {
                return new Ra(this, t);
            }
        }
        Oi(ja, "FeatureIndexArray");
        class Ua extends Ma {
            geta_centroid_pos0(t) {
                return this.uint16[2 * t + 0];
            }
            geta_centroid_pos1(t) {
                return this.uint16[2 * t + 1];
            }
        }
        Oi(Ua, "FillExtrusionCentroidArray");
        const $a = na([
            {
                name: "a_pattern",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixel_ratio",
                components: 1,
                type: "Float32"
            }
        ]), Oa = na([
            {
                name: "a_dash",
                components: 4,
                type: "Uint16"
            }
        ]);
        var qa = {
            exports: {
            }
        }, Na = {
            exports: {
            }
        };
        Na.exports = function(t60, e44) {
            var r23, n13, i10, s8, a5, o5, l4, u4;
            for(n13 = t60.length - (r23 = 3 & t60.length), i10 = e44, a5 = 3432918353, o5 = 461845907, u4 = 0; u4 < n13;)l4 = 255 & t60.charCodeAt(u4) | (255 & t60.charCodeAt(++u4)) << 8 | (255 & t60.charCodeAt(++u4)) << 16 | (255 & t60.charCodeAt(++u4)) << 24, ++u4, i10 = 27492 + (65535 & (s8 = 5 * (65535 & (i10 = (i10 ^= l4 = (65535 & (l4 = (l4 = (65535 & l4) * a5 + (((l4 >>> 16) * a5 & 65535) << 16) & 4294967295) << 15 | l4 >>> 17)) * o5 + (((l4 >>> 16) * o5 & 65535) << 16) & 4294967295) << 13 | i10 >>> 19)) + ((5 * (i10 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s8 >>> 16) & 65535) << 16);
            switch(l4 = 0, r23){
                case 3:
                    l4 ^= (255 & t60.charCodeAt(u4 + 2)) << 16;
                case 2:
                    l4 ^= (255 & t60.charCodeAt(u4 + 1)) << 8;
                case 1:
                    i10 ^= l4 = (65535 & (l4 = (l4 = (65535 & (l4 ^= 255 & t60.charCodeAt(u4))) * a5 + (((l4 >>> 16) * a5 & 65535) << 16) & 4294967295) << 15 | l4 >>> 17)) * o5 + (((l4 >>> 16) * o5 & 65535) << 16) & 4294967295;
            }
            return i10 ^= t60.length, i10 = 2246822507 * (65535 & (i10 ^= i10 >>> 16)) + ((2246822507 * (i10 >>> 16) & 65535) << 16) & 4294967295, i10 = 3266489909 * (65535 & (i10 ^= i10 >>> 13)) + ((3266489909 * (i10 >>> 16) & 65535) << 16) & 4294967295, (i10 ^= i10 >>> 16) >>> 0;
        };
        var Ga = {
            exports: {
            }
        };
        Ga.exports = function(t60, e44) {
            for(var r23, n13 = t60.length, i10 = e44 ^ n13, s8 = 0; n13 >= 4;)r23 = 1540483477 * (65535 & (r23 = 255 & t60.charCodeAt(s8) | (255 & t60.charCodeAt(++s8)) << 8 | (255 & t60.charCodeAt(++s8)) << 16 | (255 & t60.charCodeAt(++s8)) << 24)) + ((1540483477 * (r23 >>> 16) & 65535) << 16), i10 = 1540483477 * (65535 & i10) + ((1540483477 * (i10 >>> 16) & 65535) << 16) ^ (r23 = 1540483477 * (65535 & (r23 ^= r23 >>> 24)) + ((1540483477 * (r23 >>> 16) & 65535) << 16)), n13 -= 4, ++s8;
            switch(n13){
                case 3:
                    i10 ^= (255 & t60.charCodeAt(s8 + 2)) << 16;
                case 2:
                    i10 ^= (255 & t60.charCodeAt(s8 + 1)) << 8;
                case 1:
                    i10 = 1540483477 * (65535 & (i10 ^= 255 & t60.charCodeAt(s8))) + ((1540483477 * (i10 >>> 16) & 65535) << 16);
            }
            return i10 = 1540483477 * (65535 & (i10 ^= i10 >>> 13)) + ((1540483477 * (i10 >>> 16) & 65535) << 16), (i10 ^= i10 >>> 15) >>> 0;
        };
        var Xa = Na.exports, Za = Ga.exports;
        qa.exports = Xa, qa.exports.murmur3 = Xa, qa.exports.murmur2 = Za;
        class Ka {
            constructor(){
                this.ids = [], this.positions = [], this.indexed = !1;
            }
            add(t, e, r, n) {
                this.ids.push(Ya(t)), this.positions.push(e, r, n);
            }
            getPositions(t) {
                const e44 = Ya(t);
                let r23 = 0, n13 = this.ids.length - 1;
                for(; r23 < n13;){
                    const t60 = r23 + n13 >> 1;
                    this.ids[t60] >= e44 ? n13 = t60 : r23 = t60 + 1;
                }
                const i10 = [];
                for(; this.ids[r23] === e44;)i10.push({
                    index: this.positions[3 * r23],
                    start: this.positions[3 * r23 + 1],
                    end: this.positions[3 * r23 + 2]
                }), r23++;
                return i10;
            }
            static serialize(t, e) {
                const r23 = new Float64Array(t.ids), n13 = new Uint32Array(t.positions);
                return Ha(r23, n13, 0, r23.length - 1), e && e.push(r23.buffer, n13.buffer), {
                    ids: r23,
                    positions: n13
                };
            }
            static deserialize(t) {
                const e44 = new Ka;
                return e44.ids = t.ids, e44.positions = t.positions, e44.indexed = !0, e44;
            }
        }
        function Ya(t60) {
            const e44 = +t60;
            return !isNaN(e44) && Number.MIN_SAFE_INTEGER <= e44 && e44 <= Number.MAX_SAFE_INTEGER ? e44 : qa.exports(String(t60));
        }
        function Ha(t60, e44, r23, n13) {
            for(; r23 < n13;){
                const i10 = t60[r23 + n13 >> 1];
                let s8 = r23 - 1, a5 = n13 + 1;
                for(;;){
                    do s8++;
                    while (t60[s8] < i10)
                    do a5--;
                    while (t60[a5] > i10)
                    if (s8 >= a5) break;
                    Wa(t60, s8, a5), Wa(e44, 3 * s8, 3 * a5), Wa(e44, 3 * s8 + 1, 3 * a5 + 1), Wa(e44, 3 * s8 + 2, 3 * a5 + 2);
                }
                a5 - r23 < n13 - a5 ? (Ha(t60, e44, r23, a5), r23 = a5 + 1) : (Ha(t60, e44, a5 + 1, n13), n13 = a5);
            }
        }
        function Wa(t60, e44, r23) {
            const n13 = t60[e44];
            t60[e44] = t60[r23], t60[r23] = n13;
        }
        Oi(Ka, "FeaturePositionMap");
        class Ja {
            constructor(t60){
                this.gl = t60.gl, this.initialized = !1;
            }
            fetchUniformLocation(t, e) {
                return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t, e), this.initialized = !0), !!this.location;
            }
        }
        class Qa extends Ja {
            constructor(t61){
                super(t61), this.current = 0;
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));
            }
        }
        class to extends Ja {
            constructor(t62){
                super(t62), this.current = [
                    0,
                    0,
                    0,
                    0
                ];
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
            }
        }
        class eo extends Ja {
            constructor(t63){
                super(t63), this.current = Me.transparent;
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
            }
        }
        const ro = new Float32Array(16), no = new Float32Array(9), io = new Float32Array(4);
        function so(t64) {
            return [
                Qs(255 * t64.r, 255 * t64.g),
                Qs(255 * t64.b, 255 * t64.a)
            ];
        }
        class ao {
            constructor(t64, e44, r23){
                this.value = t64, this.uniformNames = e44.map((t65)=>`u_${t65}`
                ), this.type = r23;
            }
            setUniform(t, e, r, n, i) {
                e.set(t, i, n.constantOr(this.value));
            }
            getBinding(t, e) {
                return "color" === this.type ? new eo(t) : new Qa(t);
            }
        }
        class oo {
            constructor(t65, e45){
                this.uniformNames = e45.map((t66)=>`u_${t66}`
                ), this.pattern = null, this.pixelRatio = 1;
            }
            setConstantPatternPositions(t) {
                this.pixelRatio = t.pixelRatio || 1, this.pattern = t.tl.concat(t.br);
            }
            setUniform(t, e, r, n, i) {
                const s8 = "u_pattern" === i || "u_dash" === i ? this.pattern : "u_pixel_ratio" === i ? this.pixelRatio : null;
                s8 && e.set(t, i, s8);
            }
            getBinding(t, e) {
                return "u_pattern" === e || "u_dash" === e ? new to(t) : new Qa(t);
            }
        }
        class lo {
            constructor(t66, e46, r24, n13){
                this.expression = t66, this.type = r24, this.maxValue = 0, this.paintVertexAttributes = e46.map((t67)=>({
                        name: `a_${t67}`,
                        type: "Float32",
                        components: "color" === r24 ? 2 : 1,
                        offset: 0
                    })
                ), this.paintVertexArray = new n13;
            }
            populatePaintArray(t, e, r, n, i, s) {
                const a5 = this.paintVertexArray.length, o5 = this.expression.evaluate(new Us(0), e, {
                }, i, n, s);
                this.paintVertexArray.resize(t), this._setPaintValue(a5, t, o5);
            }
            updatePaintArray(t, e, r, n, i) {
                const s8 = this.expression.evaluate({
                    zoom: 0
                }, r, n, void 0, i);
                this._setPaintValue(t, e, s8);
            }
            _setPaintValue(t, e, r) {
                if ("color" === this.type) {
                    const n14 = so(r);
                    for(let r25 = t; r25 < e; r25++)this.paintVertexArray.emplace(r25, n14[0], n14[1]);
                } else {
                    for(let n14 = t; n14 < e; n14++)this.paintVertexArray.emplace(n14, r);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r));
                }
            }
            upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class uo {
            constructor(t67, e47, r25, n14, i10, s8){
                this.expression = t67, this.uniformNames = e47.map((t68)=>`u_${t68}_t`
                ), this.type = r25, this.useIntegerZoom = n14, this.zoom = i10, this.maxValue = 0, this.paintVertexAttributes = e47.map((t68)=>({
                        name: `a_${t68}`,
                        type: "Float32",
                        components: "color" === r25 ? 4 : 2,
                        offset: 0
                    })
                ), this.paintVertexArray = new s8;
            }
            populatePaintArray(t, e, r, n, i, s) {
                const a5 = this.expression.evaluate(new Us(this.zoom), e, {
                }, i, n, s), o5 = this.expression.evaluate(new Us(this.zoom + 1), e, {
                }, i, n, s), l4 = this.paintVertexArray.length;
                this.paintVertexArray.resize(t), this._setPaintValue(l4, t, a5, o5);
            }
            updatePaintArray(t, e, r, n, i) {
                const s9 = this.expression.evaluate({
                    zoom: this.zoom
                }, r, n, void 0, i), a5 = this.expression.evaluate({
                    zoom: this.zoom + 1
                }, r, n, void 0, i);
                this._setPaintValue(t, e, s9, a5);
            }
            _setPaintValue(t, e, r, n) {
                if ("color" === this.type) {
                    const i11 = so(r), s9 = so(n);
                    for(let r26 = t; r26 < e; r26++)this.paintVertexArray.emplace(r26, i11[0], i11[1], s9[0], s9[1]);
                } else {
                    for(let i11 = t; i11 < e; i11++)this.paintVertexArray.emplace(i11, r, n);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
                }
            }
            upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t, e, r, n, i) {
                const s9 = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, a5 = S1(this.expression.interpolationFactor(s9, this.zoom, this.zoom + 1), 0, 1);
                e.set(t, i, a5);
            }
            getBinding(t, e) {
                return new Qa(t);
            }
        }
        class co {
            constructor(t68, e48, r26, n15, i11){
                this.expression = t68, this.layerId = i11, this.paintVertexAttributes = ("array" === r26 ? Oa : $a).members;
                for(let t69 = 0; t69 < e48.length; ++t69);
                this.paintVertexArray = new n15;
            }
            populatePaintArray(t, e, r) {
                const n16 = this.paintVertexArray.length;
                this.paintVertexArray.resize(t), this._setPaintValues(n16, t, e.patterns && e.patterns[this.layerId], r);
            }
            updatePaintArray(t, e, r, n, i, s) {
                this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], s);
            }
            _setPaintValues(t, e, r, n) {
                if (!n || !r) return;
                const i12 = n[r];
                if (!i12) return;
                const { tl: s9 , br: a5 , pixelRatio: o5  } = i12;
                for(let r27 = t; r27 < e; r27++)this.paintVertexArray.emplace(r27, s9[0], s9[1], a5[0], a5[1], o5);
            }
            upload(t) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class ho {
            constructor(t70, e49, r27 = ()=>!0
            ){
                this.binders = {
                }, this._buffers = [];
                const n16 = [];
                for(const i12 in t70.paint._values){
                    if (!r27(i12)) continue;
                    const s9 = t70.paint.get(i12);
                    if (!(s9 instanceof Zs && En(s9.property.specification))) continue;
                    const a5 = yo(i12, t70.type), o5 = s9.value, l4 = s9.property.specification.type, u4 = s9.property.useIntegerZoom, c3 = "line-dasharray" === i12 || i12.endsWith("pattern"), h3 = "line-dasharray" === i12 && "constant" !== t70.layout.get("line-cap").value.kind;
                    if ("constant" !== o5.kind || h3) {
                        if ("source" === o5.kind || h3 || c3) {
                            const e50 = xo(i12, l4, "source");
                            this.binders[i12] = c3 ? new co(o5, a5, l4, e50, t70.id) : new lo(o5, a5, l4, e50), n16.push(`/a_${i12}`);
                        } else {
                            const t71 = xo(i12, l4, "composite");
                            this.binders[i12] = new uo(o5, a5, l4, u4, e49, t71), n16.push(`/z_${i12}`);
                        }
                    } else this.binders[i12] = c3 ? new oo(o5.value, a5) : new ao(o5.value, a5, l4), n16.push(`/u_${i12}`);
                }
                this.cacheKey = n16.sort().join("");
            }
            getMaxValue(t) {
                const e50 = this.binders[t];
                return e50 instanceof lo || e50 instanceof uo ? e50.maxValue : 0;
            }
            populatePaintArrays(t, e, r, n, i, s) {
                for(const a5 in this.binders){
                    const o5 = this.binders[a5];
                    (o5 instanceof lo || o5 instanceof uo || o5 instanceof co) && o5.populatePaintArray(t, e, r, n, i, s);
                }
            }
            setConstantPatternPositions(t) {
                for(const e50 in this.binders){
                    const r28 = this.binders[e50];
                    r28 instanceof oo && r28.setConstantPatternPositions(t);
                }
            }
            updatePaintArrays(t, e, r, n, i, s) {
                let a5 = !1;
                for(const o5 in t){
                    const l4 = e.getPositions(o5);
                    for (const e50 of l4){
                        const l5 = r.feature(e50.index);
                        for(const r28 in this.binders){
                            const u4 = this.binders[r28];
                            if ((u4 instanceof lo || u4 instanceof uo || u4 instanceof co) && !0 === u4.expression.isStateDependent) {
                                const c3 = n.paint.get(r28);
                                u4.expression = c3.value, u4.updatePaintArray(e50.start, e50.end, l5, t[o5], i, s), a5 = !0;
                            }
                        }
                    }
                }
                return a5;
            }
            defines() {
                const t71 = [];
                for(const e50 in this.binders){
                    const r28 = this.binders[e50];
                    (r28 instanceof ao || r28 instanceof oo) && t71.push(...r28.uniformNames.map((t72)=>`#define HAS_UNIFORM_${t72}`
                    ));
                }
                return t71;
            }
            getBinderAttributes() {
                const t71 = [];
                for(const e50 in this.binders){
                    const r28 = this.binders[e50];
                    if (r28 instanceof lo || r28 instanceof uo || r28 instanceof co) for(let e51 = 0; e51 < r28.paintVertexAttributes.length; e51++)t71.push(r28.paintVertexAttributes[e51].name);
                }
                return t71;
            }
            getBinderUniforms() {
                const t71 = [];
                for(const e50 in this.binders){
                    const r28 = this.binders[e50];
                    if (r28 instanceof ao || r28 instanceof oo || r28 instanceof uo) for (const e51 of r28.uniformNames)t71.push(e51);
                }
                return t71;
            }
            getPaintVertexBuffers() {
                return this._buffers;
            }
            getUniforms(t) {
                const e50 = [];
                for(const r28 in this.binders){
                    const n17 = this.binders[r28];
                    if (n17 instanceof ao || n17 instanceof oo || n17 instanceof uo) for (const i13 of n17.uniformNames)e50.push({
                        name: i13,
                        property: r28,
                        binding: n17.getBinding(t, i13)
                    });
                }
                return e50;
            }
            setUniforms(t, e, r, n, i) {
                for (const { name: e50 , property: s9 , binding: a5  } of r)this.binders[s9].setUniform(t, a5, i, n.get(s9), e50);
            }
            updatePaintBuffers() {
                this._buffers = [];
                for(const t71 in this.binders){
                    const e50 = this.binders[t71];
                    (e50 instanceof lo || e50 instanceof uo || e50 instanceof co) && e50.paintVertexBuffer && this._buffers.push(e50.paintVertexBuffer);
                }
            }
            upload(t) {
                for(const e50 in this.binders){
                    const r28 = this.binders[e50];
                    (r28 instanceof lo || r28 instanceof uo || r28 instanceof co) && r28.upload(t);
                }
                this.updatePaintBuffers();
            }
            destroy() {
                for(const t71 in this.binders){
                    const e50 = this.binders[t71];
                    (e50 instanceof lo || e50 instanceof uo || e50 instanceof co) && e50.destroy();
                }
            }
        }
        class po {
            constructor(t71, e50, r28 = ()=>!0
            ){
                this.programConfigurations = {
                };
                for (const n17 of t71)this.programConfigurations[n17.id] = new ho(n17, e50, r28);
                this.needsUpload = !1, this._featureMap = new Ka, this._bufferOffset = 0;
            }
            populatePaintArrays(t, e, r, n, i, s, a) {
                for(const r29 in this.programConfigurations)this.programConfigurations[r29].populatePaintArrays(t, e, n, i, s, a);
                (void 0) !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
            }
            updatePaintArrays(t, e, r, n, i) {
                for (const s9 of r)this.needsUpload = this.programConfigurations[s9.id].updatePaintArrays(t, this._featureMap, e, s9, n, i) || this.needsUpload;
            }
            get(t) {
                return this.programConfigurations[t];
            }
            upload(t) {
                if (this.needsUpload) {
                    for(const e51 in this.programConfigurations)this.programConfigurations[e51].upload(t);
                    this.needsUpload = !1;
                }
            }
            destroy() {
                for(const t72 in this.programConfigurations)this.programConfigurations[t72].destroy();
            }
        }
        const fo = {
            "text-opacity": [
                "opacity"
            ],
            "icon-opacity": [
                "opacity"
            ],
            "text-color": [
                "fill_color"
            ],
            "icon-color": [
                "fill_color"
            ],
            "text-halo-color": [
                "halo_color"
            ],
            "icon-halo-color": [
                "halo_color"
            ],
            "text-halo-blur": [
                "halo_blur"
            ],
            "icon-halo-blur": [
                "halo_blur"
            ],
            "text-halo-width": [
                "halo_width"
            ],
            "icon-halo-width": [
                "halo_width"
            ],
            "line-gap-width": [
                "gapwidth"
            ],
            "line-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "fill-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "fill-extrusion-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "line-dasharray": [
                "dash"
            ]
        };
        function yo(t72, e51) {
            return fo[t72] || [
                t72.replace(`${e51}-`, "").replace(/-/g, "_")
            ];
        }
        const mo = {
            "line-pattern": {
                source: ca,
                composite: ca
            },
            "fill-pattern": {
                source: ca,
                composite: ca
            },
            "fill-extrusion-pattern": {
                source: ca,
                composite: ca
            },
            "line-dasharray": {
                source: ha,
                composite: ha
            }
        }, go = {
            color: {
                source: za,
                composite: ua
            },
            number: {
                source: Sa,
                composite: za
            }
        };
        function xo(t72, e51, r29) {
            const n18 = mo[t72];
            return n18 && n18[r29] || go[e51][r29];
        }
        Oi(ao, "ConstantBinder"), Oi(oo, "PatternConstantBinder"), Oi(lo, "SourceExpressionBinder"), Oi(co, "PatternCompositeBinder"), Oi(uo, "CompositeExpressionBinder"), Oi(ho, "ProgramConfiguration", {
            omit: [
                "_buffers"
            ]
        }), Oi(po, "ProgramConfigurationSet");
        const vo = "-transition";
        class bo extends Yt {
            constructor(t72, e51){
                if (super(), this.id = t72.id, this.type = t72.type, this._featureFilter = {
                    filter: ()=>!0
                    ,
                    needGeometry: !1,
                    needFeature: !1
                }, this._filterCompiled = !1, "custom" !== t72.type && (this.metadata = t72.metadata, this.minzoom = t72.minzoom, this.maxzoom = t72.maxzoom, "background" !== t72.type && "sky" !== t72.type && (this.source = t72.source, this.sourceLayer = t72["source-layer"], this.filter = t72.filter), e51.layout && (this._unevaluatedLayout = new Xs(e51.layout)), e51.paint)) {
                    this._transitionablePaint = new qs(e51.paint);
                    for(const e52 in t72.paint)this.setPaintProperty(e52, t72.paint[e52], {
                        validate: !1
                    });
                    for(const e53 in t72.layout)this.setLayoutProperty(e53, t72.layout[e53], {
                        validate: !1
                    });
                    this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ks(e51.paint);
                }
            }
            getLayoutProperty(t) {
                return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t);
            }
            setLayoutProperty(t, e, r = {
            }) {
                null != e && this._validate(Li, `layers.${this.id}.layout.${t}`, t, e, r) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);
            }
            getPaintProperty(t) {
                return L(t, vo) ? this._transitionablePaint.getTransition(t.slice(0, -vo.length)) : this._transitionablePaint.getValue(t);
            }
            setPaintProperty(t, e, r = {
            }) {
                if (null != e && this._validate(Vi, `layers.${this.id}.paint.${t}`, t, e, r)) return !1;
                if (L(t, vo)) return this._transitionablePaint.setTransition(t.slice(0, -vo.length), e || void 0), !1;
                {
                    const r29 = this._transitionablePaint._values[t], n18 = r29.value.isDataDriven(), i13 = r29.value;
                    this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);
                    const s9 = this._transitionablePaint._values[t].value, a5 = s9.isDataDriven(), o5 = L(t, "pattern") || "line-dasharray" === t;
                    return a5 || n18 || o5 || this._handleOverridablePaintPropertyUpdate(t, i13, s9);
                }
            }
            _handleSpecialPaintPropertyUpdate(t) {
            }
            getProgramIds() {
                return null;
            }
            getProgramConfiguration(t) {
                return null;
            }
            _handleOverridablePaintPropertyUpdate(t, e, r) {
                return !1;
            }
            isHidden(t) {
                return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
            }
            hasTransition() {
                return this._transitioningPaint.hasTransition();
            }
            recalculate(t, e) {
                this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);
            }
            serialize() {
                const t73 = {
                    id: this.id,
                    type: this.type,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                    paint: this._transitionablePaint && this._transitionablePaint.serialize()
                };
                return this.visibility && (t73.layout = t73.layout || {
                }, t73.layout.visibility = this.visibility), R(t73, (t74, e52)=>!((void 0) === t74 || "layout" === e52 && !Object.keys(t74).length || "paint" === e52 && !Object.keys(t74).length)
                );
            }
            _validate(t, e, r, n, i = {
            }) {
                return (!i || !1 !== i.validate) && Ri(this, t.call(Di, {
                    key: e,
                    layerType: this.type,
                    objectKey: r,
                    value: n,
                    styleSpec: Ht,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    }
                }));
            }
            is3D() {
                return !1;
            }
            isSky() {
                return !1;
            }
            isTileClipped() {
                return !1;
            }
            hasOffscreenPass() {
                return !1;
            }
            resize() {
            }
            isStateDependent() {
                for(const t73 in this.paint._values){
                    const e52 = this.paint.get(t73);
                    if (e52 instanceof Zs && En(e52.property.specification) && ("source" === e52.value.kind || "composite" === e52.value.kind) && e52.value.isStateDependent) return !0;
                }
                return !1;
            }
            compileFilter() {
                this._filterCompiled || (this._featureFilter = ai(this.filter), this._filterCompiled = !0);
            }
            invalidateCompiledFilter() {
                this._filterCompiled = !1;
            }
            dynamicFilter() {
                return this._featureFilter.dynamicFilter;
            }
            dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
            }
        }
        const wo = na([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), _o = na([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]);
        class Ao {
            constructor(t73 = []){
                this.segments = t73;
            }
            prepareSegment(t, e, r, n) {
                let i13 = this.segments[this.segments.length - 1];
                return t > Ao.MAX_VERTEX_ARRAY_LENGTH && $(`Max vertices per segment is ${Ao.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!i13 || i13.vertexLength + t > Ao.MAX_VERTEX_ARRAY_LENGTH || i13.sortKey !== n) && (i13 = {
                    vertexOffset: e.length,
                    primitiveOffset: r.length,
                    vertexLength: 0,
                    primitiveLength: 0
                }, (void 0) !== n && (i13.sortKey = n), this.segments.push(i13)), i13;
            }
            get() {
                return this.segments;
            }
            destroy() {
                for (const t74 of this.segments)for(const e52 in t74.vaos)t74.vaos[e52].destroy();
            }
            static simpleSegment(t, e, r, n) {
                return new Ao([
                    {
                        vertexOffset: t,
                        primitiveOffset: e,
                        vertexLength: r,
                        primitiveLength: n,
                        vaos: {
                        },
                        sortKey: 0
                    }
                ]);
            }
        }
        Ao.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Oi(Ao, "SegmentVector");
        var So = 8192;
        class ko {
            constructor(t74, e52){
                t74 && (e52 ? this.setSouthWest(t74).setNorthEast(e52) : 4 === t74.length ? this.setSouthWest([
                    t74[0],
                    t74[1]
                ]).setNorthEast([
                    t74[2],
                    t74[3]
                ]) : this.setSouthWest(t74[0]).setNorthEast(t74[1]));
            }
            setNorthEast(t) {
                return this._ne = t instanceof Mo ? new Mo(t.lng, t.lat) : Mo.convert(t), this;
            }
            setSouthWest(t) {
                return this._sw = t instanceof Mo ? new Mo(t.lng, t.lat) : Mo.convert(t), this;
            }
            extend(t) {
                const e53 = this._sw, r29 = this._ne;
                let n18, i13;
                if (t instanceof Mo) n18 = t, i13 = t;
                else {
                    if (!(t instanceof ko)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(ko.convert(t)) : this.extend(Mo.convert(t)) : "object" == typeof t && null !== t && t.hasOwnProperty("lat") && t.hasOwnProperty("lon") ? this.extend(Mo.convert(t)) : this;
                    if (n18 = t._sw, i13 = t._ne, !n18 || !i13) return this;
                }
                return e53 || r29 ? (e53.lng = Math.min(n18.lng, e53.lng), e53.lat = Math.min(n18.lat, e53.lat), r29.lng = Math.max(i13.lng, r29.lng), r29.lat = Math.max(i13.lat, r29.lat)) : (this._sw = new Mo(n18.lng, n18.lat), this._ne = new Mo(i13.lng, i13.lat)), this;
            }
            getCenter() {
                return new Mo((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
                return this._sw;
            }
            getNorthEast() {
                return this._ne;
            }
            getNorthWest() {
                return new Mo(this.getWest(), this.getNorth());
            }
            getSouthEast() {
                return new Mo(this.getEast(), this.getSouth());
            }
            getWest() {
                return this._sw.lng;
            }
            getSouth() {
                return this._sw.lat;
            }
            getEast() {
                return this._ne.lng;
            }
            getNorth() {
                return this._ne.lat;
            }
            toArray() {
                return [
                    this._sw.toArray(),
                    this._ne.toArray()
                ];
            }
            toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
                return !(this._sw && this._ne);
            }
            contains(t) {
                const { lng: e53 , lat: r29  } = Mo.convert(t);
                let n18 = this._sw.lng <= e53 && e53 <= this._ne.lng;
                return this._sw.lng > this._ne.lng && (n18 = this._sw.lng >= e53 && e53 >= this._ne.lng), this._sw.lat <= r29 && r29 <= this._ne.lat && n18;
            }
            static convert(t) {
                return !t || t instanceof ko ? t : new ko(t);
            }
        }
        const Io = 6371008.8;
        class Mo {
            constructor(t75, e53){
                if (isNaN(t75) || isNaN(e53)) throw new Error(`Invalid LngLat object: (${t75}, ${e53})`);
                if (this.lng = +t75, this.lat = +e53, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
                return new Mo(I1(this.lng, -180, 180), this.lat);
            }
            toArray() {
                return [
                    this.lng,
                    this.lat
                ];
            }
            toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t) {
                const e54 = Math.PI / 180, r29 = this.lat * e54, n18 = t.lat * e54, i13 = Math.sin(r29) * Math.sin(n18) + Math.cos(r29) * Math.cos(n18) * Math.cos((t.lng - this.lng) * e54);
                return Io * Math.acos(Math.min(i13, 1));
            }
            toBounds(t = 0) {
                const e54 = 360 * t / 40075017, r29 = e54 / Math.cos(Math.PI / 180 * this.lat);
                return new ko(new Mo(this.lng - r29, this.lat - e54), new Mo(this.lng + r29, this.lat + e54));
            }
            static convert(t) {
                if (t instanceof Mo) return t;
                if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Mo(Number(t[0]), Number(t[1]));
                if (!Array.isArray(t) && "object" == typeof t && null !== t) return new Mo(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
                throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
        }
        const To = 2 * Math.PI * Io;
        function zo(t76) {
            return To * Math.cos(t76 * Math.PI / 180);
        }
        function Bo(t76) {
            return (180 + t76) / 360;
        }
        function Eo(t76) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t76 * Math.PI / 360))) / 360;
        }
        function Co(t76, e54) {
            return t76 / zo(e54);
        }
        function Po(t76) {
            return 360 * t76 - 180;
        }
        function Do(t76) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t76) * Math.PI / 180)) - 90;
        }
        function Vo(t76, e54) {
            return t76 * zo(Do(e54));
        }
        const Lo = 85.051129;
        function Fo(t76) {
            return 1 / Math.cos(t76 * Math.PI / 180);
        }
        class Ro {
            constructor(t76, e54, r29 = 0){
                this.x = +t76, this.y = +e54, this.z = +r29;
            }
            static fromLngLat(t, e = 0) {
                const r30 = Mo.convert(t);
                return new Ro(Bo(r30.lng), Eo(r30.lat), Co(e, r30.lat));
            }
            toLngLat() {
                return new Mo(Po(this.x), Do(this.y));
            }
            toAltitude() {
                return Vo(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
                return 1 / To * Fo(Do(this.y));
            }
        }
        function jo(t77, e55, r30, n18, i13, s9, a5, o5, l4) {
            const u4 = (e55 + n18) / 2, c3 = (r30 + i13) / 2, h3 = new d2(u4, c3);
            o5(h3), (function(t78, e56, r31, n19, i14, s10) {
                const a6 = r31 - i14, o6 = n19 - s10;
                return Math.abs((n19 - e56) * a6 - (r31 - t78) * o6) / Math.hypot(a6, o6);
            })(h3.x, h3.y, s9.x, s9.y, a5.x, a5.y) >= l4 ? (jo(t77, e55, r30, u4, c3, s9, h3, o5, l4), jo(t77, u4, c3, n18, i13, h3, a5, o5, l4)) : t77.push(a5);
        }
        function Uo(t77, e55, r30) {
            let n18 = t77[0], i13 = n18.x, s9 = n18.y;
            e55(n18);
            const a5 = [
                n18
            ];
            for(let o5 = 1; o5 < t77.length; o5++){
                const l4 = t77[o5], { x: u4 , y: c3  } = l4;
                e55(l4), jo(a5, i13, s9, u4, c3, n18, l4, e55, r30), i13 = u4, s9 = c3, n18 = l4;
            }
            return a5;
        }
        function $o(t77, e55, r30, n18) {
            if (n18(e55, r30)) {
                const i13 = e55.add(r30)._mult(0.5);
                $o(t77, e55, i13, n18), $o(t77, i13, r30, n18);
            } else t77.push(r30);
        }
        function Oo(t77, e55) {
            let r30 = t77[0];
            const n18 = [
                r30
            ];
            for(let i13 = 1; i13 < t77.length; i13++){
                const s9 = t77[i13];
                $o(n18, r30, s9, e55), r30 = s9;
            }
            return n18;
        }
        const qo = Math.pow(2, 14) - 1, No = -qo - 1;
        function Go(t77, e55) {
            const r30 = Math.round(t77.x * e55), n18 = Math.round(t77.y * e55);
            return t77.x = S1(r30, No, qo), t77.y = S1(n18, No, qo), (r30 < t77.x || r30 > t77.x + 1 || n18 < t77.y || n18 > t77.y + 1) && $("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t77;
        }
        function Xo(t77, e55, r30) {
            const n18 = t77.loadGeometry(), i13 = t77.extent, s9 = So / i13;
            if (e55 && r30 && r30.projection.isReprojectedInTileSpace) {
                const s10 = 1 << e55.z, { scale: a5 , x: o5 , y: l4 , projection: u4  } = r30, c3 = (t78)=>{
                    const r31 = Po((e55.x + t78.x / i13) / s10), n19 = Do((e55.y + t78.y / i13) / s10), c4 = u4.project(r31, n19);
                    t78.x = (c4.x * a5 - o5) * i13, t78.y = (c4.y * a5 - l4) * i13;
                };
                for(let e56 = 0; e56 < n18.length; e56++)if (1 !== t77.type) n18[e56] = Uo(n18[e56], c3, 1);
                else {
                    const t78 = [];
                    for (const r31 of n18[e56])r31.x < 0 || r31.x >= i13 || r31.y < 0 || r31.y >= i13 || (c3(r31), t78.push(r31));
                    n18[e56] = t78;
                }
            }
            for (const t78 of n18)for (const e56 of t78)Go(e56, s9);
            return n18;
        }
        function Zo(t77, e55) {
            return {
                type: t77.type,
                id: t77.id,
                properties: t77.properties,
                geometry: e55 ? Xo(t77) : []
            };
        }
        function Ko(t77, e55, r30, n18, i13) {
            t77.emplaceBack(2 * e55 + (n18 + 1) / 2, 2 * r30 + (i13 + 1) / 2);
        }
        function Yo(t77, e55, r30) {
            const n18 = 16384;
            t77.emplaceBack(e55.x, e55.y, e55.z, r30[0] * n18, r30[1] * n18, r30[2] * n18);
        }
        class Ho {
            constructor(t77){
                this.zoom = t77.zoom, this.overscaling = t77.overscaling, this.layers = t77.layers, this.layerIds = this.layers.map((t78)=>t78.id
                ), this.index = t77.index, this.hasPattern = !1, this.projection = t77.projection, this.layoutVertexArray = new sa, this.indexArray = new wa, this.segments = new Ao, this.programConfigurations = new po(t77.layers, t77.zoom), this.stateDependentLayerIds = this.layers.filter((t78)=>t78.isStateDependent()
                ).map((t78)=>t78.id
                );
            }
            populate(t, e, r, n) {
                const i13 = this.layers[0], s9 = [];
                let a5 = null;
                "circle" === i13.type && (a5 = i13.layout.get("circle-sort-key"));
                for (const { feature: e55 , id: i14 , index: o5 , sourceLayerIndex: l4  } of t){
                    const t78 = this.layers[0]._featureFilter.needGeometry, u4 = Zo(e55, t78);
                    if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), u4, r)) continue;
                    const c3 = a5 ? a5.evaluate(u4, {
                    }, r) : void 0, h3 = {
                        id: i14,
                        properties: e55.properties,
                        type: e55.type,
                        sourceLayerIndex: l4,
                        index: o5,
                        geometry: t78 ? u4.geometry : Xo(e55, r, n),
                        patterns: {
                        },
                        sortKey: c3
                    };
                    s9.push(h3);
                }
                a5 && s9.sort((t78, e56)=>t78.sortKey - e56.sortKey
                );
                let o6 = null;
                "globe" === n.projection.name && (this.globeExtVertexArray = new pa, o6 = n.projection);
                for (const n18 of s9){
                    const { geometry: i15 , index: s10 , sourceLayerIndex: a6  } = n18, l5 = t[s10].feature;
                    this.addFeature(n18, i15, s10, e.availableImages, r, o6), e.featureIndex.insert(l5, i15, s10, a6, this.index);
                }
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, wo.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, _o.members))), this.programConfigurations.upload(t), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
            addFeature(t, e, r, n, i, s) {
                for (const r30 of e)for (const e55 of r30){
                    const r31 = e55.x, n18 = e55.y;
                    if (r31 < 0 || r31 >= So || n18 < 0 || n18 >= So) continue;
                    if (s) {
                        const t78 = s.projectTilePoint(r31, n18, i), e56 = s.upVector(i, r31, n18), a5 = this.globeExtVertexArray;
                        Yo(a5, t78, e56), Yo(a5, t78, e56), Yo(a5, t78, e56), Yo(a5, t78, e56);
                    }
                    const a5 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey), o5 = a5.vertexLength;
                    Ko(this.layoutVertexArray, r31, n18, -1, -1), Ko(this.layoutVertexArray, r31, n18, 1, -1), Ko(this.layoutVertexArray, r31, n18, 1, 1), Ko(this.layoutVertexArray, r31, n18, -1, 1), this.indexArray.emplaceBack(o5, o5 + 1, o5 + 2), this.indexArray.emplaceBack(o5, o5 + 2, o5 + 3), a5.vertexLength += 4, a5.primitiveLength += 2;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {
                }, n, i);
            }
        }
        function Wo(t78, e55) {
            for(let r30 = 0; r30 < t78.length; r30++)if (al(e55, t78[r30])) return !0;
            for(let r31 = 0; r31 < e55.length; r31++)if (al(t78, e55[r31])) return !0;
            return !!el(t78, e55);
        }
        function Jo(t78, e55, r30) {
            return !!al(t78, e55) || !!nl(e55, t78, r30);
        }
        function Qo(t78, e55) {
            if (1 === t78.length) return sl(e55, t78[0]);
            for(let r30 = 0; r30 < e55.length; r30++){
                const n18 = e55[r30];
                for(let e56 = 0; e56 < n18.length; e56++)if (al(t78, n18[e56])) return !0;
            }
            for(let r31 = 0; r31 < t78.length; r31++)if (sl(e55, t78[r31])) return !0;
            for(let r32 = 0; r32 < e55.length; r32++)if (el(t78, e55[r32])) return !0;
            return !1;
        }
        function tl(t78, e55, r30) {
            if (t78.length > 1) {
                if (el(t78, e55)) return !0;
                for(let n18 = 0; n18 < e55.length; n18++)if (nl(e55[n18], t78, r30)) return !0;
            }
            for(let n18 = 0; n18 < t78.length; n18++)if (nl(t78[n18], e55, r30)) return !0;
            return !1;
        }
        function el(t78, e55) {
            if (0 === t78.length || 0 === e55.length) return !1;
            for(let r30 = 0; r30 < t78.length - 1; r30++){
                const n18 = t78[r30], i13 = t78[r30 + 1];
                for(let t79 = 0; t79 < e55.length - 1; t79++)if (rl(n18, i13, e55[t79], e55[t79 + 1])) return !0;
            }
            return !1;
        }
        function rl(t78, e55, r30, n18) {
            return O(t78, r30, n18) !== O(e55, r30, n18) && O(t78, e55, r30) !== O(t78, e55, n18);
        }
        function nl(t78, e55, r30) {
            const n18 = r30 * r30;
            if (1 === e55.length) return t78.distSqr(e55[0]) < n18;
            for(let r31 = 1; r31 < e55.length; r31++)if (il(t78, e55[r31 - 1], e55[r31]) < n18) return !0;
            return !1;
        }
        function il(t78, e55, r30) {
            const n18 = e55.distSqr(r30);
            if (0 === n18) return t78.distSqr(e55);
            const i13 = ((t78.x - e55.x) * (r30.x - e55.x) + (t78.y - e55.y) * (r30.y - e55.y)) / n18;
            return t78.distSqr(i13 < 0 ? e55 : i13 > 1 ? r30 : r30.sub(e55)._mult(i13)._add(e55));
        }
        function sl(t78, e55) {
            let r30, n18, i13, s9 = !1;
            for(let a5 = 0; a5 < t78.length; a5++){
                r30 = t78[a5];
                for(let t79 = 0, a6 = r30.length - 1; t79 < r30.length; a6 = t79++)n18 = r30[t79], i13 = r30[a6], n18.y > e55.y != i13.y > e55.y && e55.x < (i13.x - n18.x) * (e55.y - n18.y) / (i13.y - n18.y) + n18.x && (s9 = !s9);
            }
            return s9;
        }
        function al(t78, e55) {
            let r30 = !1;
            for(let n18 = 0, i13 = t78.length - 1; n18 < t78.length; i13 = n18++){
                const s9 = t78[n18], a5 = t78[i13];
                s9.y > e55.y != a5.y > e55.y && e55.x < (a5.x - s9.x) * (e55.y - s9.y) / (a5.y - s9.y) + s9.x && (r30 = !r30);
            }
            return r30;
        }
        function ol(t78, e55, r30, n18, i13) {
            for (const s9 of t78)if (e55 <= s9.x && r30 <= s9.y && n18 >= s9.x && i13 >= s9.y) return !0;
            const s10 = [
                new d2(e55, r30),
                new d2(e55, i13),
                new d2(n18, i13),
                new d2(n18, r30)
            ];
            if (t78.length > 2) for (const e56 of s10)if (al(t78, e56)) return !0;
            for(let e57 = 0; e57 < t78.length - 1; e57++)if (ll(t78[e57], t78[e57 + 1], s10)) return !0;
            return !1;
        }
        function ll(t78, e55, r30) {
            const n18 = r30[0], i13 = r30[2];
            if (t78.x < n18.x && e55.x < n18.x || t78.x > i13.x && e55.x > i13.x || t78.y < n18.y && e55.y < n18.y || t78.y > i13.y && e55.y > i13.y) return !1;
            const s9 = O(t78, e55, r30[0]);
            return s9 !== O(t78, e55, r30[1]) || s9 !== O(t78, e55, r30[2]) || s9 !== O(t78, e55, r30[3]);
        }
        function ul(t78, e55, r30) {
            const n18 = e55.paint.get(t78).value;
            return "constant" === n18.kind ? n18.value : r30.programConfigurations.get(e55.id).getMaxValue(t78);
        }
        function cl(t78) {
            return Math.sqrt(t78[0] * t78[0] + t78[1] * t78[1]);
        }
        function hl(t78, e55, r30, n18, i13) {
            if (!e55[0] && !e55[1]) return t78;
            const s9 = d2.convert(e55)._mult(i13);
            "viewport" === r30 && s9._rotate(-n18);
            const a5 = [];
            for(let e56 = 0; e56 < t78.length; e56++)a5.push(t78[e56].sub(s9));
            return a5;
        }
        function pl(t78, e55, r30, n18) {
            const i13 = d2.convert(t78)._mult(n18);
            return "viewport" === e55 && i13._rotate(-r30), i13;
        }
        Oi(Ho, "CircleBucket", {
            omit: [
                "layers"
            ]
        });
        const fl = new Js({
            "circle-sort-key": new Hs(Ht.layout_circle["circle-sort-key"])
        });
        var dl = {
            paint: new Js({
                "circle-radius": new Hs(Ht.paint_circle["circle-radius"]),
                "circle-color": new Hs(Ht.paint_circle["circle-color"]),
                "circle-blur": new Hs(Ht.paint_circle["circle-blur"]),
                "circle-opacity": new Hs(Ht.paint_circle["circle-opacity"]),
                "circle-translate": new Ys(Ht.paint_circle["circle-translate"]),
                "circle-translate-anchor": new Ys(Ht.paint_circle["circle-translate-anchor"]),
                "circle-pitch-scale": new Ys(Ht.paint_circle["circle-pitch-scale"]),
                "circle-pitch-alignment": new Ys(Ht.paint_circle["circle-pitch-alignment"]),
                "circle-stroke-width": new Hs(Ht.paint_circle["circle-stroke-width"]),
                "circle-stroke-color": new Hs(Ht.paint_circle["circle-stroke-color"]),
                "circle-stroke-opacity": new Hs(Ht.paint_circle["circle-stroke-opacity"])
            }),
            layout: fl
        }, yl = 0.000001, ml = "undefined" != typeof Float32Array ? Float32Array : Array;
        function gl() {
            var t78 = new ml(9);
            return ml != Float32Array && (t78[1] = 0, t78[2] = 0, t78[3] = 0, t78[5] = 0, t78[6] = 0, t78[7] = 0), t78[0] = 1, t78[4] = 1, t78[8] = 1, t78;
        }
        function xl(t78, e55, r30) {
            var n18 = e55[0], i13 = e55[1], s9 = e55[2], a5 = e55[3], o5 = e55[4], l4 = e55[5], u4 = e55[6], c3 = e55[7], h3 = e55[8], p4 = r30[0], f3 = r30[1], d3 = r30[2], y2 = r30[3], m2 = r30[4], g2 = r30[5], x2 = r30[6], v2 = r30[7], b2 = r30[8];
            return t78[0] = p4 * n18 + f3 * a5 + d3 * u4, t78[1] = p4 * i13 + f3 * o5 + d3 * c3, t78[2] = p4 * s9 + f3 * l4 + d3 * h3, t78[3] = y2 * n18 + m2 * a5 + g2 * u4, t78[4] = y2 * i13 + m2 * o5 + g2 * c3, t78[5] = y2 * s9 + m2 * l4 + g2 * h3, t78[6] = x2 * n18 + v2 * a5 + b2 * u4, t78[7] = x2 * i13 + v2 * o5 + b2 * c3, t78[8] = x2 * s9 + v2 * l4 + b2 * h3, t78;
        }
        function vl(t78) {
            return t78[0] = 1, t78[1] = 0, t78[2] = 0, t78[3] = 0, t78[4] = 0, t78[5] = 1, t78[6] = 0, t78[7] = 0, t78[8] = 0, t78[9] = 0, t78[10] = 1, t78[11] = 0, t78[12] = 0, t78[13] = 0, t78[14] = 0, t78[15] = 1, t78;
        }
        function bl(t78, e55) {
            var r30 = e55[0], n18 = e55[1], i13 = e55[2], s9 = e55[3], a5 = e55[4], o5 = e55[5], l4 = e55[6], u4 = e55[7], c3 = e55[8], h3 = e55[9], p4 = e55[10], f3 = e55[11], d3 = e55[12], y2 = e55[13], m2 = e55[14], g2 = e55[15], x2 = r30 * o5 - n18 * a5, v2 = r30 * l4 - i13 * a5, b2 = r30 * u4 - s9 * a5, w2 = n18 * l4 - i13 * o5, _2 = n18 * u4 - s9 * o5, A2 = i13 * u4 - s9 * l4, S2 = c3 * y2 - h3 * d3, k2 = c3 * m2 - p4 * d3, I2 = c3 * g2 - f3 * d3, M2 = h3 * m2 - p4 * y2, T2 = h3 * g2 - f3 * y2, z2 = p4 * g2 - f3 * m2, B2 = x2 * z2 - v2 * T2 + b2 * M2 + w2 * I2 - _2 * k2 + A2 * S2;
            return B2 ? (t78[0] = (o5 * z2 - l4 * T2 + u4 * M2) * (B2 = 1 / B2), t78[1] = (i13 * T2 - n18 * z2 - s9 * M2) * B2, t78[2] = (y2 * A2 - m2 * _2 + g2 * w2) * B2, t78[3] = (p4 * _2 - h3 * A2 - f3 * w2) * B2, t78[4] = (l4 * I2 - a5 * z2 - u4 * k2) * B2, t78[5] = (r30 * z2 - i13 * I2 + s9 * k2) * B2, t78[6] = (m2 * b2 - d3 * A2 - g2 * v2) * B2, t78[7] = (c3 * A2 - p4 * b2 + f3 * v2) * B2, t78[8] = (a5 * T2 - o5 * I2 + u4 * S2) * B2, t78[9] = (n18 * I2 - r30 * T2 - s9 * S2) * B2, t78[10] = (d3 * _2 - y2 * b2 + g2 * x2) * B2, t78[11] = (h3 * b2 - c3 * _2 - f3 * x2) * B2, t78[12] = (o5 * k2 - a5 * M2 - l4 * S2) * B2, t78[13] = (r30 * M2 - n18 * k2 + i13 * S2) * B2, t78[14] = (y2 * v2 - d3 * w2 - m2 * x2) * B2, t78[15] = (c3 * w2 - h3 * v2 + p4 * x2) * B2, t78) : null;
        }
        function wl(t78, e55, r30) {
            var n18 = e55[0], i13 = e55[1], s9 = e55[2], a5 = e55[3], o5 = e55[4], l4 = e55[5], u4 = e55[6], c3 = e55[7], h3 = e55[8], p4 = e55[9], f3 = e55[10], d3 = e55[11], y2 = e55[12], m2 = e55[13], g2 = e55[14], x2 = e55[15], v2 = r30[0], b2 = r30[1], w2 = r30[2], _2 = r30[3];
            return t78[0] = v2 * n18 + b2 * o5 + w2 * h3 + _2 * y2, t78[1] = v2 * i13 + b2 * l4 + w2 * p4 + _2 * m2, t78[2] = v2 * s9 + b2 * u4 + w2 * f3 + _2 * g2, t78[3] = v2 * a5 + b2 * c3 + w2 * d3 + _2 * x2, t78[4] = (v2 = r30[4]) * n18 + (b2 = r30[5]) * o5 + (w2 = r30[6]) * h3 + (_2 = r30[7]) * y2, t78[5] = v2 * i13 + b2 * l4 + w2 * p4 + _2 * m2, t78[6] = v2 * s9 + b2 * u4 + w2 * f3 + _2 * g2, t78[7] = v2 * a5 + b2 * c3 + w2 * d3 + _2 * x2, t78[8] = (v2 = r30[8]) * n18 + (b2 = r30[9]) * o5 + (w2 = r30[10]) * h3 + (_2 = r30[11]) * y2, t78[9] = v2 * i13 + b2 * l4 + w2 * p4 + _2 * m2, t78[10] = v2 * s9 + b2 * u4 + w2 * f3 + _2 * g2, t78[11] = v2 * a5 + b2 * c3 + w2 * d3 + _2 * x2, t78[12] = (v2 = r30[12]) * n18 + (b2 = r30[13]) * o5 + (w2 = r30[14]) * h3 + (_2 = r30[15]) * y2, t78[13] = v2 * i13 + b2 * l4 + w2 * p4 + _2 * m2, t78[14] = v2 * s9 + b2 * u4 + w2 * f3 + _2 * g2, t78[15] = v2 * a5 + b2 * c3 + w2 * d3 + _2 * x2, t78;
        }
        function _l(t78, e55, r30) {
            var n18, i13, s9, a5, o5, l4, u4, c3, h3, p4, f3, d3, y2 = r30[0], m2 = r30[1], g2 = r30[2];
            return e55 === t78 ? (t78[12] = e55[0] * y2 + e55[4] * m2 + e55[8] * g2 + e55[12], t78[13] = e55[1] * y2 + e55[5] * m2 + e55[9] * g2 + e55[13], t78[14] = e55[2] * y2 + e55[6] * m2 + e55[10] * g2 + e55[14], t78[15] = e55[3] * y2 + e55[7] * m2 + e55[11] * g2 + e55[15]) : (i13 = e55[1], s9 = e55[2], a5 = e55[3], o5 = e55[4], l4 = e55[5], u4 = e55[6], c3 = e55[7], h3 = e55[8], p4 = e55[9], f3 = e55[10], d3 = e55[11], t78[0] = n18 = e55[0], t78[1] = i13, t78[2] = s9, t78[3] = a5, t78[4] = o5, t78[5] = l4, t78[6] = u4, t78[7] = c3, t78[8] = h3, t78[9] = p4, t78[10] = f3, t78[11] = d3, t78[12] = n18 * y2 + o5 * m2 + h3 * g2 + e55[12], t78[13] = i13 * y2 + l4 * m2 + p4 * g2 + e55[13], t78[14] = s9 * y2 + u4 * m2 + f3 * g2 + e55[14], t78[15] = a5 * y2 + c3 * m2 + d3 * g2 + e55[15]), t78;
        }
        function Al(t78, e55, r30) {
            var n18 = r30[0], i13 = r30[1], s9 = r30[2];
            return t78[0] = e55[0] * n18, t78[1] = e55[1] * n18, t78[2] = e55[2] * n18, t78[3] = e55[3] * n18, t78[4] = e55[4] * i13, t78[5] = e55[5] * i13, t78[6] = e55[6] * i13, t78[7] = e55[7] * i13, t78[8] = e55[8] * s9, t78[9] = e55[9] * s9, t78[10] = e55[10] * s9, t78[11] = e55[11] * s9, t78[12] = e55[12], t78[13] = e55[13], t78[14] = e55[14], t78[15] = e55[15], t78;
        }
        function Sl(t78, e55, r30) {
            var n18 = Math.sin(r30), i13 = Math.cos(r30), s9 = e55[4], a5 = e55[5], o5 = e55[6], l4 = e55[7], u4 = e55[8], c3 = e55[9], h3 = e55[10], p4 = e55[11];
            return e55 !== t78 && (t78[0] = e55[0], t78[1] = e55[1], t78[2] = e55[2], t78[3] = e55[3], t78[12] = e55[12], t78[13] = e55[13], t78[14] = e55[14], t78[15] = e55[15]), t78[4] = s9 * i13 + u4 * n18, t78[5] = a5 * i13 + c3 * n18, t78[6] = o5 * i13 + h3 * n18, t78[7] = l4 * i13 + p4 * n18, t78[8] = u4 * i13 - s9 * n18, t78[9] = c3 * i13 - a5 * n18, t78[10] = h3 * i13 - o5 * n18, t78[11] = p4 * i13 - l4 * n18, t78;
        }
        function kl(t78, e55, r30) {
            var n18 = Math.sin(r30), i13 = Math.cos(r30), s9 = e55[0], a5 = e55[1], o5 = e55[2], l4 = e55[3], u4 = e55[8], c3 = e55[9], h3 = e55[10], p4 = e55[11];
            return e55 !== t78 && (t78[4] = e55[4], t78[5] = e55[5], t78[6] = e55[6], t78[7] = e55[7], t78[12] = e55[12], t78[13] = e55[13], t78[14] = e55[14], t78[15] = e55[15]), t78[0] = s9 * i13 - u4 * n18, t78[1] = a5 * i13 - c3 * n18, t78[2] = o5 * i13 - h3 * n18, t78[3] = l4 * i13 - p4 * n18, t78[8] = s9 * n18 + u4 * i13, t78[9] = a5 * n18 + c3 * i13, t78[10] = o5 * n18 + h3 * i13, t78[11] = l4 * n18 + p4 * i13, t78;
        }
        function Il(t78, e55) {
            return t78[0] = e55[0], t78[1] = 0, t78[2] = 0, t78[3] = 0, t78[4] = 0, t78[5] = e55[1], t78[6] = 0, t78[7] = 0, t78[8] = 0, t78[9] = 0, t78[10] = e55[2], t78[11] = 0, t78[12] = 0, t78[13] = 0, t78[14] = 0, t78[15] = 1, t78;
        }
        function Ml(t78, e55, r30) {
            var n18, i13, s9, a5 = r30[0], o5 = r30[1], l4 = r30[2], u4 = Math.hypot(a5, o5, l4);
            return u4 < yl ? null : (a5 *= u4 = 1 / u4, o5 *= u4, l4 *= u4, n18 = Math.sin(e55), i13 = Math.cos(e55), t78[0] = a5 * a5 * (s9 = 1 - i13) + i13, t78[1] = o5 * a5 * s9 + l4 * n18, t78[2] = l4 * a5 * s9 - o5 * n18, t78[3] = 0, t78[4] = a5 * o5 * s9 - l4 * n18, t78[5] = o5 * o5 * s9 + i13, t78[6] = l4 * o5 * s9 + a5 * n18, t78[7] = 0, t78[8] = a5 * l4 * s9 + o5 * n18, t78[9] = o5 * l4 * s9 - a5 * n18, t78[10] = l4 * l4 * s9 + i13, t78[11] = 0, t78[12] = 0, t78[13] = 0, t78[14] = 0, t78[15] = 1, t78);
        }
        Math.hypot || (Math.hypot = function() {
            for(var t78 = 0, e55 = arguments.length; e55--;)t78 += arguments[e55] * arguments[e55];
            return Math.sqrt(t78);
        });
        var Tl = wl;
        function zl() {
            var t78 = new ml(3);
            return ml != Float32Array && (t78[0] = 0, t78[1] = 0, t78[2] = 0), t78;
        }
        function Bl(t78) {
            var e55 = new ml(3);
            return e55[0] = t78[0], e55[1] = t78[1], e55[2] = t78[2], e55;
        }
        function El(t78) {
            return Math.hypot(t78[0], t78[1], t78[2]);
        }
        function Cl(t78, e55, r30) {
            var n18 = new ml(3);
            return n18[0] = t78, n18[1] = e55, n18[2] = r30, n18;
        }
        function Pl(t78, e55, r30) {
            return t78[0] = e55[0] + r30[0], t78[1] = e55[1] + r30[1], t78[2] = e55[2] + r30[2], t78;
        }
        function Dl(t78, e55, r30) {
            return t78[0] = e55[0] - r30[0], t78[1] = e55[1] - r30[1], t78[2] = e55[2] - r30[2], t78;
        }
        function Vl(t78, e55, r30) {
            return t78[0] = e55[0] * r30[0], t78[1] = e55[1] * r30[1], t78[2] = e55[2] * r30[2], t78;
        }
        function Ll(t78, e55, r30) {
            return t78[0] = Math.min(e55[0], r30[0]), t78[1] = Math.min(e55[1], r30[1]), t78[2] = Math.min(e55[2], r30[2]), t78;
        }
        function Fl(t78, e55, r30) {
            return t78[0] = Math.max(e55[0], r30[0]), t78[1] = Math.max(e55[1], r30[1]), t78[2] = Math.max(e55[2], r30[2]), t78;
        }
        function Rl(t78, e55, r30) {
            return t78[0] = e55[0] * r30, t78[1] = e55[1] * r30, t78[2] = e55[2] * r30, t78;
        }
        function jl(t78, e55, r30, n18) {
            return t78[0] = e55[0] + r30[0] * n18, t78[1] = e55[1] + r30[1] * n18, t78[2] = e55[2] + r30[2] * n18, t78;
        }
        function Ul(t78, e55) {
            var r30 = e55[0], n18 = e55[1], i13 = e55[2], s9 = r30 * r30 + n18 * n18 + i13 * i13;
            return s9 > 0 && (s9 = 1 / Math.sqrt(s9)), t78[0] = e55[0] * s9, t78[1] = e55[1] * s9, t78[2] = e55[2] * s9, t78;
        }
        function $l(t78, e55) {
            return t78[0] * e55[0] + t78[1] * e55[1] + t78[2] * e55[2];
        }
        function Ol(t78, e55, r30) {
            var n18 = e55[0], i13 = e55[1], s9 = e55[2], a5 = r30[0], o5 = r30[1], l4 = r30[2];
            return t78[0] = i13 * l4 - s9 * o5, t78[1] = s9 * a5 - n18 * l4, t78[2] = n18 * o5 - i13 * a5, t78;
        }
        function ql(t78, e55, r30) {
            var n18 = e55[0], i13 = e55[1], s9 = e55[2], a5 = r30[3] * n18 + r30[7] * i13 + r30[11] * s9 + r30[15];
            return t78[0] = (r30[0] * n18 + r30[4] * i13 + r30[8] * s9 + r30[12]) / (a5 = a5 || 1), t78[1] = (r30[1] * n18 + r30[5] * i13 + r30[9] * s9 + r30[13]) / a5, t78[2] = (r30[2] * n18 + r30[6] * i13 + r30[10] * s9 + r30[14]) / a5, t78;
        }
        function Nl(t78, e55, r30) {
            var n18 = r30[0], i13 = r30[1], s9 = r30[2], a5 = e55[0], o5 = e55[1], l4 = e55[2], u4 = i13 * l4 - s9 * o5, c3 = s9 * a5 - n18 * l4, h3 = n18 * o5 - i13 * a5, p4 = i13 * h3 - s9 * c3, f3 = s9 * u4 - n18 * h3, d3 = n18 * c3 - i13 * u4, y2 = 2 * r30[3];
            return c3 *= y2, h3 *= y2, f3 *= 2, d3 *= 2, t78[0] = a5 + (u4 *= y2) + (p4 *= 2), t78[1] = o5 + c3 + f3, t78[2] = l4 + h3 + d3, t78;
        }
        var Gl, Xl = Dl, Zl = Vl, Kl = El;
        function Yl(t78, e55, r30) {
            return t78[0] = e55[0] * r30, t78[1] = e55[1] * r30, t78[2] = e55[2] * r30, t78[3] = e55[3] * r30, t78;
        }
        function Hl(t78, e55) {
            var r30 = e55[0], n18 = e55[1], i13 = e55[2], s9 = e55[3], a5 = r30 * r30 + n18 * n18 + i13 * i13 + s9 * s9;
            return a5 > 0 && (a5 = 1 / Math.sqrt(a5)), t78[0] = r30 * a5, t78[1] = n18 * a5, t78[2] = i13 * a5, t78[3] = s9 * a5, t78;
        }
        function Wl(t78, e55, r30) {
            var n18 = e55[0], i13 = e55[1], s9 = e55[2], a5 = e55[3];
            return t78[0] = r30[0] * n18 + r30[4] * i13 + r30[8] * s9 + r30[12] * a5, t78[1] = r30[1] * n18 + r30[5] * i13 + r30[9] * s9 + r30[13] * a5, t78[2] = r30[2] * n18 + r30[6] * i13 + r30[10] * s9 + r30[14] * a5, t78[3] = r30[3] * n18 + r30[7] * i13 + r30[11] * s9 + r30[15] * a5, t78;
        }
        function Jl() {
            var t78 = new ml(4);
            return ml != Float32Array && (t78[0] = 0, t78[1] = 0, t78[2] = 0), t78[3] = 1, t78;
        }
        function Ql(t78) {
            return t78[0] = 0, t78[1] = 0, t78[2] = 0, t78[3] = 1, t78;
        }
        function tu(t78, e55, r30) {
            r30 *= 0.5;
            var n18 = e55[0], i13 = e55[1], s9 = e55[2], a5 = e55[3], o5 = Math.sin(r30), l4 = Math.cos(r30);
            return t78[0] = n18 * l4 + a5 * o5, t78[1] = i13 * l4 + s9 * o5, t78[2] = s9 * l4 - i13 * o5, t78[3] = a5 * l4 - n18 * o5, t78;
        }
        function eu(t78, e55, r30) {
            r30 *= 0.5;
            var n18 = e55[0], i13 = e55[1], s9 = e55[2], a5 = e55[3], o5 = Math.sin(r30), l4 = Math.cos(r30);
            return t78[0] = n18 * l4 - s9 * o5, t78[1] = i13 * l4 + a5 * o5, t78[2] = s9 * l4 + n18 * o5, t78[3] = a5 * l4 - i13 * o5, t78;
        }
        zl(), Gl = new ml(4), ml != Float32Array && (Gl[0] = 0, Gl[1] = 0, Gl[2] = 0, Gl[3] = 0);
        var ru = Hl;
        zl(), Cl(1, 0, 0), Cl(0, 1, 0), Jl(), Jl(), gl();
        class nu {
            constructor(t78, e55){
                this.pos = t78, this.dir = e55;
            }
            intersectsPlane(t, e, r) {
                const n18 = $l(e, this.dir);
                if (Math.abs(n18) < 0.000001) return !1;
                const i13 = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / n18;
                return r[0] = this.pos[0] + this.dir[0] * i13, r[1] = this.pos[1] + this.dir[1] * i13, r[2] = this.pos[2] + this.dir[2] * i13, !0;
            }
            closestPointOnSphere(t, e, r) {
                if ((function(t79, e56) {
                    var r30 = t79[0], n18 = t79[1], i13 = t79[2], s9 = e56[0], a5 = e56[1], o5 = e56[2];
                    return Math.abs(r30 - s9) <= yl * Math.max(1, Math.abs(r30), Math.abs(s9)) && Math.abs(n18 - a5) <= yl * Math.max(1, Math.abs(n18), Math.abs(a5)) && Math.abs(i13 - o5) <= yl * Math.max(1, Math.abs(i13), Math.abs(o5));
                })(this.pos, t) || 0 === e) return r[0] = r[1] = r[2] = 0, !1;
                const [n18, i13, s9] = this.dir, a5 = this.pos[0] - t[0], o5 = this.pos[1] - t[1], l4 = this.pos[2] - t[2], u4 = n18 * n18 + i13 * i13 + s9 * s9, c3 = 2 * (a5 * n18 + o5 * i13 + l4 * s9), h3 = c3 * c3 - 4 * u4 * (a5 * a5 + o5 * o5 + l4 * l4 - e * e);
                if (h3 < 0) {
                    const t79 = Math.max(-c3 / 2, 0), u5 = a5 + n18 * t79, h4 = o5 + i13 * t79, p4 = l4 + s9 * t79, f3 = Math.hypot(u5, h4, p4);
                    return r[0] = u5 * e / f3, r[1] = h4 * e / f3, r[2] = p4 * e / f3, !1;
                }
                {
                    const t79 = (-c3 - Math.sqrt(h3)) / (2 * u4);
                    if (t79 < 0) {
                        const t80 = Math.hypot(a5, o5, l4);
                        return r[0] = a5 * e / t80, r[1] = o5 * e / t80, r[2] = l4 * e / t80, !1;
                    }
                    return r[0] = a5 + n18 * t79, r[1] = o5 + i13 * t79, r[2] = l4 + s9 * t79, !0;
                }
            }
        }
        class iu {
            constructor(t79, e56, r30, n18, i13){
                this.TL = t79, this.TR = e56, this.BR = r30, this.BL = n18, this.horizon = i13;
            }
            static fromInvProjectionMatrix(t, e, r) {
                const n19 = [
                    -1,
                    1,
                    1
                ], i14 = [
                    1,
                    1,
                    1
                ], s9 = [
                    1,
                    -1,
                    1
                ], a5 = [
                    -1,
                    -1,
                    1
                ], o5 = ql(n19, n19, t), l4 = ql(i14, i14, t), u4 = ql(s9, s9, t), c3 = ql(a5, a5, t);
                return new iu(o5, l4, u4, c3, e / r);
            }
        }
        class su {
            constructor(t80, e57){
                this.points = t80, this.planes = e57;
            }
            static fromInvProjectionMatrix(t, e, r, n) {
                const i14 = Math.pow(2, r), s9 = [
                    [
                        -1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        -1,
                        1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        1,
                        1
                    ]
                ].map((r31)=>{
                    const s10 = Wl([], r31, t), a5 = 1 / s10[3] / e * i14;
                    return (function(t81, e58, r32) {
                        return t81[0] = e58[0] * r32[0], t81[1] = e58[1] * r32[1], t81[2] = e58[2] * r32[2], t81[3] = e58[3] * r32[3], t81;
                    })(s10, s10, [
                        a5,
                        a5,
                        n ? 1 / s10[3] : a5,
                        a5
                    ]);
                }), a5 = [
                    [
                        0,
                        1,
                        2
                    ],
                    [
                        6,
                        5,
                        4
                    ],
                    [
                        0,
                        3,
                        7
                    ],
                    [
                        2,
                        1,
                        5
                    ],
                    [
                        3,
                        2,
                        6
                    ],
                    [
                        0,
                        4,
                        5
                    ]
                ].map((t81)=>{
                    const e58 = Ul([], Ol([], Xl([], s9[t81[0]], s9[t81[1]]), Xl([], s9[t81[2]], s9[t81[1]]))), r31 = -$l(e58, s9[t81[1]]);
                    return e58.concat(r31);
                });
                return new su(s9, a5);
            }
        }
        class au {
            static fromPoints(t) {
                const e58 = [
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], r31 = [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                for (const n19 of t)Ll(e58, e58, n19), Fl(r31, r31, n19);
                return new au(e58, r31);
            }
            static applyTransform(t, e) {
                const r31 = t.getCorners();
                for(let t81 = 0; t81 < r31.length; ++t81)ql(r31[t81], r31[t81], e);
                return au.fromPoints(r31);
            }
            constructor(t81, e58){
                this.min = t81, this.max = e58, this.center = Rl([], Pl([], this.min, this.max), 0.5);
            }
            quadrant(t) {
                const e59 = [
                    t % 2 == 0,
                    t < 2
                ], r31 = Bl(this.min), n19 = Bl(this.max);
                for(let t82 = 0; t82 < e59.length; t82++)r31[t82] = e59[t82] ? this.min[t82] : this.center[t82], n19[t82] = e59[t82] ? this.center[t82] : this.max[t82];
                return n19[2] = this.max[2], new au(r31, n19);
            }
            distanceX(t) {
                return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
            }
            distanceY(t) {
                return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
            }
            distanceZ(t) {
                return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2];
            }
            getCorners() {
                const t82 = this.min, e59 = this.max;
                return [
                    [
                        t82[0],
                        t82[1],
                        t82[2]
                    ],
                    [
                        e59[0],
                        t82[1],
                        t82[2]
                    ],
                    [
                        e59[0],
                        e59[1],
                        t82[2]
                    ],
                    [
                        t82[0],
                        e59[1],
                        t82[2]
                    ],
                    [
                        t82[0],
                        t82[1],
                        e59[2]
                    ],
                    [
                        e59[0],
                        t82[1],
                        e59[2]
                    ],
                    [
                        e59[0],
                        e59[1],
                        e59[2]
                    ],
                    [
                        t82[0],
                        e59[1],
                        e59[2]
                    ]
                ];
            }
            intersects(t) {
                const e59 = this.getCorners();
                let r31 = !0;
                for(let n19 = 0; n19 < t.planes.length; n19++){
                    const i14 = t.planes[n19];
                    let s9 = 0;
                    for(let t82 = 0; t82 < e59.length; t82++)s9 += $l(i14, e59[t82]) + i14[3] >= 0;
                    if (0 === s9) return 0;
                    s9 !== e59.length && (r31 = !1);
                }
                if (r31) return 2;
                for(let e60 = 0; e60 < 3; e60++){
                    let r32 = Number.MAX_VALUE, n20 = -Number.MAX_VALUE;
                    for(let i14 = 0; i14 < t.points.length; i14++){
                        const s9 = t.points[i14][e60] - this.min[e60];
                        r32 = Math.min(r32, s9), n20 = Math.max(n20, s9);
                    }
                    if (n20 < 0 || r32 > this.max[e60] - this.min[e60]) return 0;
                }
                return 1;
            }
        }
        function ou(t82, e59, r31, n19, i14, s9, a5, o5, l4) {
            if (s9 && t82.queryGeometry.isAboveHorizon) return !1;
            s9 && (l4 *= t82.pixelToTileUnitsFactor);
            const u4 = t82.tileID.canonical, c3 = r31.projection.upVectorScale(u4, r31.center.lat, r31.worldSize).metersToTile;
            for (const h3 of e59)for (const e60 of h3){
                const h4 = e60.add(o5), p4 = i14 && r31.elevation ? r31.elevation.exaggeration() * i14.getElevationAt(h4.x, h4.y, !0) : 0, f3 = r31.projection.projectTilePoint(h4.x, h4.y, u4);
                if (p4 > 0) {
                    const t83 = r31.projection.upVector(u4, h4.x, h4.y);
                    f3.x += t83[0] * c3 * p4, f3.y += t83[1] * c3 * p4, f3.z += t83[2] * c3 * p4;
                }
                const d3 = s9 ? h4 : lu(f3.x, f3.y, f3.z, n19), y2 = s9 ? t82.tilespaceRays.map((t83)=>hu(t83, p4)
                ) : t82.queryGeometry.screenGeometry, m2 = Wl([], [
                    f3.x,
                    f3.y,
                    f3.z,
                    1
                ], n19);
                if (!a5 && s9 ? l4 *= m2[3] / r31.cameraToCenterDistance : a5 && !s9 && (l4 *= r31.cameraToCenterDistance / m2[3]), s9) {
                    const t83 = Do((e60.y / So + u4.y) / (1 << u4.z));
                    l4 /= r31.projection.pixelsPerMeter(t83, 1) / Co(1, t83);
                }
                if (Jo(y2, d3, l4)) return !0;
            }
            return !1;
        }
        function lu(t82, e59, r31, n19) {
            const i14 = Wl([], [
                t82,
                e59,
                r31,
                1
            ], n19);
            return new d2(i14[0] / i14[3], i14[1] / i14[3]);
        }
        const uu = Cl(0, 0, 0), cu = Cl(0, 0, 1);
        function hu(t82, e59) {
            const r31 = zl();
            return uu[2] = e59, t82.intersectsPlane(uu, cu, r31), new d2(r31[0], r31[1]);
        }
        class pu extends Ho {
        }
        function fu(t82, { width: e59 , height: r31  }, n19, i14) {
            if (i14) {
                if (i14 instanceof Uint8ClampedArray) i14 = new Uint8Array(i14.buffer);
                else if (i14.length !== e59 * r31 * n19) throw new RangeError("mismatched image size");
            } else i14 = new Uint8Array(e59 * r31 * n19);
            return t82.width = e59, t82.height = r31, t82.data = i14, t82;
        }
        function du(t82, e59, r31) {
            const { width: n19 , height: i14  } = e59;
            n19 === t82.width && i14 === t82.height || (yu(t82, e59, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                width: Math.min(t82.width, n19),
                height: Math.min(t82.height, i14)
            }, r31), t82.width = n19, t82.height = i14, t82.data = e59.data);
        }
        function yu(t82, e59, r31, n19, i14, s9) {
            if (0 === i14.width || 0 === i14.height) return e59;
            if (i14.width > t82.width || i14.height > t82.height || r31.x > t82.width - i14.width || r31.y > t82.height - i14.height) throw new RangeError("out of range source coordinates for image copy");
            if (i14.width > e59.width || i14.height > e59.height || n19.x > e59.width - i14.width || n19.y > e59.height - i14.height) throw new RangeError("out of range destination coordinates for image copy");
            const a5 = t82.data, o5 = e59.data;
            for(let l4 = 0; l4 < i14.height; l4++){
                const u4 = ((r31.y + l4) * t82.width + r31.x) * s9, c3 = ((n19.y + l4) * e59.width + n19.x) * s9;
                for(let t83 = 0; t83 < i14.width * s9; t83++)o5[c3 + t83] = a5[u4 + t83];
            }
            return e59;
        }
        Oi(pu, "HeatmapBucket", {
            omit: [
                "layers"
            ]
        });
        class mu {
            constructor(t82, e59){
                fu(this, t82, 1, e59);
            }
            resize(t) {
                du(this, new mu(t), 1);
            }
            clone() {
                return new mu({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t, e, r, n, i) {
                yu(t, e, r, n, i, 1);
            }
        }
        class gu {
            constructor(t83, e60){
                fu(this, t83, 4, e60);
            }
            resize(t) {
                du(this, new gu(t), 4);
            }
            replace(t, e) {
                e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
            }
            clone() {
                return new gu({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t, e, r, n, i) {
                yu(t, e, r, n, i, 4);
            }
        }
        Oi(mu, "AlphaImage"), Oi(gu, "RGBAImage");
        var xu = {
            paint: new Js({
                "heatmap-radius": new Hs(Ht.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new Hs(Ht.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new Ys(Ht.paint_heatmap["heatmap-intensity"]),
                "heatmap-color": new Ws(Ht.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new Ys(Ht.paint_heatmap["heatmap-opacity"])
            })
        };
        function vu(t84) {
            const e61 = {
            }, r31 = t84.resolution || 256, n19 = t84.clips ? t84.clips.length : 1, i14 = t84.image || new gu({
                width: r31,
                height: n19
            }), s9 = (r32, n20, s10)=>{
                e61[t84.evaluationKey] = s10;
                const a5 = t84.expression.evaluate(e61);
                i14.data[r32 + n20 + 0] = Math.floor(255 * a5.r / a5.a), i14.data[r32 + n20 + 1] = Math.floor(255 * a5.g / a5.a), i14.data[r32 + n20 + 2] = Math.floor(255 * a5.b / a5.a), i14.data[r32 + n20 + 3] = Math.floor(255 * a5.a);
            };
            if (t84.clips) for(let e62 = 0, i15 = 0; e62 < n19; ++e62, i15 += 4 * r31)for(let n20 = 0, a5 = 0; n20 < r31; n20++, a5 += 4){
                const o5 = n20 / (r31 - 1), { start: l4 , end: u4  } = t84.clips[e62];
                s9(i15, a5, l4 * (1 - o5) + u4 * o5);
            }
            else for(let t85 = 0, e63 = 0; t85 < r31; t85++, e63 += 4)s9(0, e63, t85 / (r31 - 1));
            return i14;
        }
        var bu = {
            paint: new Js({
                "hillshade-illumination-direction": new Ys(Ht.paint_hillshade["hillshade-illumination-direction"]),
                "hillshade-illumination-anchor": new Ys(Ht.paint_hillshade["hillshade-illumination-anchor"]),
                "hillshade-exaggeration": new Ys(Ht.paint_hillshade["hillshade-exaggeration"]),
                "hillshade-shadow-color": new Ys(Ht.paint_hillshade["hillshade-shadow-color"]),
                "hillshade-highlight-color": new Ys(Ht.paint_hillshade["hillshade-highlight-color"]),
                "hillshade-accent-color": new Ys(Ht.paint_hillshade["hillshade-accent-color"])
            })
        };
        const wu = na([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), { members: _u  } = wu;
        var Au = {
            exports: {
            }
        };
        function Su(t84, e61, r31) {
            r31 = r31 || 2;
            var n19, i14, s9, a5, o5, l4, u4, c3 = e61 && e61.length, h3 = c3 ? e61[0] * r31 : t84.length, p4 = ku(t84, 0, h3, r31, !0), f3 = [];
            if (!p4 || p4.next === p4.prev) return f3;
            if (c3 && (p4 = (function(t85, e62, r32, n20) {
                var i15, s10, a6, o6 = [];
                for(i15 = 0, s10 = e62.length; i15 < s10; i15++)(a6 = ku(t85, e62[i15] * n20, i15 < s10 - 1 ? e62[i15 + 1] * n20 : t85.length, n20, !1)) === a6.next && (a6.steiner = !0), o6.push(Lu(a6));
                for(o6.sort(Cu), i15 = 0; i15 < o6.length; i15++)r32 = Pu(o6[i15], r32);
                return r32;
            })(t84, e61, p4, r31)), t84.length > 80 * r31) {
                n19 = s9 = t84[0], i14 = a5 = t84[1];
                for(var d3 = r31; d3 < h3; d3 += r31)(o5 = t84[d3]) < n19 && (n19 = o5), (l4 = t84[d3 + 1]) < i14 && (i14 = l4), o5 > s9 && (s9 = o5), l4 > a5 && (a5 = l4);
                u4 = 0 !== (u4 = Math.max(s9 - n19, a5 - i14)) ? 32767 / u4 : 0;
            }
            return Mu(p4, f3, r31, n19, i14, u4, 0), f3;
        }
        function ku(t84, e61, r31, n19, i14) {
            var s9, a5;
            if (i14 === Yu(t84, e61, r31, n19) > 0) for(s9 = e61; s9 < r31; s9 += n19)a5 = Xu(s9, t84[s9], t84[s9 + 1], a5);
            else for(s9 = r31 - n19; s9 >= e61; s9 -= n19)a5 = Xu(s9, t84[s9], t84[s9 + 1], a5);
            return a5 && Uu(a5, a5.next) && (Zu(a5), a5 = a5.next), a5;
        }
        function Iu(t84, e61) {
            if (!t84) return t84;
            e61 || (e61 = t84);
            var r31, n19 = t84;
            do if (r31 = !1, n19.steiner || !Uu(n19, n19.next) && 0 !== ju(n19.prev, n19, n19.next)) n19 = n19.next;
            else {
                if (Zu(n19), (n19 = e61 = n19.prev) === n19.next) break;
                r31 = !0;
            }
            while (r31 || n19 !== e61)
            return e61;
        }
        function Mu(t84, e61, r31, n19, i14, s9, a5) {
            if (t84) {
                !a5 && s9 && (function(t85, e62, r32, n20) {
                    var i15 = t85;
                    do 0 === i15.z && (i15.z = Vu(i15.x, i15.y, e62, r32, n20)), i15.prevZ = i15.prev, i15.nextZ = i15.next, i15 = i15.next;
                    while (i15 !== t85)
                    i15.prevZ.nextZ = null, i15.prevZ = null, (function(t86) {
                        var e63, r33, n21, i16, s10, a6, o5, l4, u4 = 1;
                        do {
                            for(r33 = t86, t86 = null, s10 = null, a6 = 0; r33;){
                                for(a6++, n21 = r33, o5 = 0, e63 = 0; e63 < u4 && (o5++, n21 = n21.nextZ); e63++);
                                for(l4 = u4; o5 > 0 || l4 > 0 && n21;)0 !== o5 && (0 === l4 || !n21 || r33.z <= n21.z) ? (i16 = r33, r33 = r33.nextZ, o5--) : (i16 = n21, n21 = n21.nextZ, l4--), s10 ? s10.nextZ = i16 : t86 = i16, i16.prevZ = s10, s10 = i16;
                                r33 = n21;
                            }
                            s10.nextZ = null, u4 *= 2;
                        }while (a6 > 1)
                    })(i15);
                })(t84, n19, i14, s9);
                for(var o5, l4, u4 = t84; t84.prev !== t84.next;)if (o5 = t84.prev, l4 = t84.next, s9 ? zu(t84, n19, i14, s9) : Tu(t84)) e61.push(o5.i / r31 | 0), e61.push(t84.i / r31 | 0), e61.push(l4.i / r31 | 0), Zu(t84), t84 = l4.next, u4 = l4.next;
                else if ((t84 = l4) === u4) {
                    a5 ? 1 === a5 ? Mu(t84 = Bu(Iu(t84), e61, r31), e61, r31, n19, i14, s9, 2) : 2 === a5 && Eu(t84, e61, r31, n19, i14, s9) : Mu(Iu(t84), e61, r31, n19, i14, s9, 1);
                    break;
                }
            }
        }
        function Tu(t84) {
            var e61 = t84.prev, r31 = t84, n19 = t84.next;
            if (ju(e61, r31, n19) >= 0) return !1;
            for(var i14 = e61.x, s9 = r31.x, a5 = n19.x, o6 = e61.y, l5 = r31.y, u5 = n19.y, c3 = i14 < s9 ? i14 < a5 ? i14 : a5 : s9 < a5 ? s9 : a5, h3 = o6 < l5 ? o6 < u5 ? o6 : u5 : l5 < u5 ? l5 : u5, p4 = i14 > s9 ? i14 > a5 ? i14 : a5 : s9 > a5 ? s9 : a5, f3 = o6 > l5 ? o6 > u5 ? o6 : u5 : l5 > u5 ? l5 : u5, d4 = n19.next; d4 !== e61;){
                if (d4.x >= c3 && d4.x <= p4 && d4.y >= h3 && d4.y <= f3 && Fu(i14, o6, s9, l5, a5, u5, d4.x, d4.y) && ju(d4.prev, d4, d4.next) >= 0) return !1;
                d4 = d4.next;
            }
            return !0;
        }
        function zu(t84, e61, r31, n19) {
            var i14 = t84.prev, s9 = t84, a5 = t84.next;
            if (ju(i14, s9, a5) >= 0) return !1;
            for(var o6 = i14.x, l5 = s9.x, u5 = a5.x, c3 = i14.y, h3 = s9.y, p4 = a5.y, f3 = o6 < l5 ? o6 < u5 ? o6 : u5 : l5 < u5 ? l5 : u5, d4 = c3 < h3 ? c3 < p4 ? c3 : p4 : h3 < p4 ? h3 : p4, y2 = o6 > l5 ? o6 > u5 ? o6 : u5 : l5 > u5 ? l5 : u5, m2 = c3 > h3 ? c3 > p4 ? c3 : p4 : h3 > p4 ? h3 : p4, g2 = Vu(f3, d4, e61, r31, n19), x2 = Vu(y2, m2, e61, r31, n19), v2 = t84.prevZ, b2 = t84.nextZ; v2 && v2.z >= g2 && b2 && b2.z <= x2;){
                if (v2.x >= f3 && v2.x <= y2 && v2.y >= d4 && v2.y <= m2 && v2 !== i14 && v2 !== a5 && Fu(o6, c3, l5, h3, u5, p4, v2.x, v2.y) && ju(v2.prev, v2, v2.next) >= 0) return !1;
                if (v2 = v2.prevZ, b2.x >= f3 && b2.x <= y2 && b2.y >= d4 && b2.y <= m2 && b2 !== i14 && b2 !== a5 && Fu(o6, c3, l5, h3, u5, p4, b2.x, b2.y) && ju(b2.prev, b2, b2.next) >= 0) return !1;
                b2 = b2.nextZ;
            }
            for(; v2 && v2.z >= g2;){
                if (v2.x >= f3 && v2.x <= y2 && v2.y >= d4 && v2.y <= m2 && v2 !== i14 && v2 !== a5 && Fu(o6, c3, l5, h3, u5, p4, v2.x, v2.y) && ju(v2.prev, v2, v2.next) >= 0) return !1;
                v2 = v2.prevZ;
            }
            for(; b2 && b2.z <= x2;){
                if (b2.x >= f3 && b2.x <= y2 && b2.y >= d4 && b2.y <= m2 && b2 !== i14 && b2 !== a5 && Fu(o6, c3, l5, h3, u5, p4, b2.x, b2.y) && ju(b2.prev, b2, b2.next) >= 0) return !1;
                b2 = b2.nextZ;
            }
            return !0;
        }
        function Bu(t84, e61, r31) {
            var n19 = t84;
            do {
                var i14 = n19.prev, s9 = n19.next.next;
                !Uu(i14, s9) && $u(i14, n19, n19.next, s9) && Nu(i14, s9) && Nu(s9, i14) && (e61.push(i14.i / r31 | 0), e61.push(n19.i / r31 | 0), e61.push(s9.i / r31 | 0), Zu(n19), Zu(n19.next), n19 = t84 = s9), n19 = n19.next;
            }while (n19 !== t84)
            return Iu(n19);
        }
        function Eu(t84, e61, r31, n19, i15, s10) {
            var a5 = t84;
            do {
                for(var o6 = a5.next.next; o6 !== a5.prev;){
                    if (a5.i !== o6.i && Ru(a5, o6)) {
                        var l5 = Gu(a5, o6);
                        return a5 = Iu(a5, a5.next), l5 = Iu(l5, l5.next), Mu(a5, e61, r31, n19, i15, s10, 0), void Mu(l5, e61, r31, n19, i15, s10, 0);
                    }
                    o6 = o6.next;
                }
                a5 = a5.next;
            }while (a5 !== t84)
        }
        function Cu(t84, e61) {
            return t84.x - e61.x;
        }
        function Pu(t84, e61) {
            var r31 = function(t85, e62) {
                var r32, n19 = e62, i15 = t85.x, s10 = t85.y, a5 = -1 / 0;
                do {
                    if (s10 <= n19.y && s10 >= n19.next.y && n19.next.y !== n19.y) {
                        var o7 = n19.x + (s10 - n19.y) * (n19.next.x - n19.x) / (n19.next.y - n19.y);
                        if (o7 <= i15 && o7 > a5 && (a5 = o7, r32 = n19.x < n19.next.x ? n19 : n19.next, o7 === i15)) return r32;
                    }
                    n19 = n19.next;
                }while (n19 !== e62)
                if (!r32) return null;
                var l6, u5 = r32, c3 = r32.x, h3 = r32.y, p4 = 1 / 0;
                n19 = r32;
                do i15 >= n19.x && n19.x >= c3 && i15 !== n19.x && Fu(s10 < h3 ? i15 : a5, s10, c3, h3, s10 < h3 ? a5 : i15, s10, n19.x, n19.y) && (l6 = Math.abs(s10 - n19.y) / (i15 - n19.x), Nu(n19, t85) && (l6 < p4 || l6 === p4 && (n19.x > r32.x || n19.x === r32.x && Du(r32, n19))) && (r32 = n19, p4 = l6)), n19 = n19.next;
                while (n19 !== u5)
                return r32;
            }(t84, e61);
            if (!r31) return e61;
            var n19 = Gu(r31, t84);
            return Iu(n19, n19.next), Iu(r31, r31.next);
        }
        function Du(t84, e61) {
            return ju(t84.prev, t84, e61.prev) < 0 && ju(e61.next, t84, t84.next) < 0;
        }
        function Vu(t84, e61, r31, n19, i15) {
            return (t84 = 1431655765 & ((t84 = 858993459 & ((t84 = 252645135 & ((t84 = 16711935 & ((t84 = (t84 - r31) * i15 | 0) | t84 << 8)) | t84 << 4)) | t84 << 2)) | t84 << 1)) | (e61 = 1431655765 & ((e61 = 858993459 & ((e61 = 252645135 & ((e61 = 16711935 & ((e61 = (e61 - n19) * i15 | 0) | e61 << 8)) | e61 << 4)) | e61 << 2)) | e61 << 1)) << 1;
        }
        function Lu(t84) {
            var e61 = t84, r31 = t84;
            do (e61.x < r31.x || e61.x === r31.x && e61.y < r31.y) && (r31 = e61), e61 = e61.next;
            while (e61 !== t84)
            return r31;
        }
        function Fu(t84, e61, r31, n19, i15, s10, a5, o8) {
            return (i15 - a5) * (e61 - o8) >= (t84 - a5) * (s10 - o8) && (t84 - a5) * (n19 - o8) >= (r31 - a5) * (e61 - o8) && (r31 - a5) * (s10 - o8) >= (i15 - a5) * (n19 - o8);
        }
        function Ru(t84, e61) {
            return t84.next.i !== e61.i && t84.prev.i !== e61.i && !function(t85, e62) {
                var r31 = t85;
                do {
                    if (r31.i !== t85.i && r31.next.i !== t85.i && r31.i !== e62.i && r31.next.i !== e62.i && $u(r31, r31.next, t85, e62)) return !0;
                    r31 = r31.next;
                }while (r31 !== t85)
                return !1;
            }(t84, e61) && (Nu(t84, e61) && Nu(e61, t84) && (function(t85, e62) {
                var r31 = t85, n19 = !1, i15 = (t85.x + e62.x) / 2, s10 = (t85.y + e62.y) / 2;
                do r31.y > s10 != r31.next.y > s10 && r31.next.y !== r31.y && i15 < (r31.next.x - r31.x) * (s10 - r31.y) / (r31.next.y - r31.y) + r31.x && (n19 = !n19), r31 = r31.next;
                while (r31 !== t85)
                return n19;
            })(t84, e61) && (ju(t84.prev, t84, e61.prev) || ju(t84, e61.prev, e61)) || Uu(t84, e61) && ju(t84.prev, t84, t84.next) > 0 && ju(e61.prev, e61, e61.next) > 0);
        }
        function ju(t84, e61, r31) {
            return (e61.y - t84.y) * (r31.x - e61.x) - (e61.x - t84.x) * (r31.y - e61.y);
        }
        function Uu(t84, e61) {
            return t84.x === e61.x && t84.y === e61.y;
        }
        function $u(t84, e61, r31, n19) {
            var i15 = qu(ju(t84, e61, r31)), s10 = qu(ju(t84, e61, n19)), a5 = qu(ju(r31, n19, t84)), o8 = qu(ju(r31, n19, e61));
            return i15 !== s10 && a5 !== o8 || !(0 !== i15 || !Ou(t84, r31, e61)) || !(0 !== s10 || !Ou(t84, n19, e61)) || !(0 !== a5 || !Ou(r31, t84, n19)) || !(0 !== o8 || !Ou(r31, e61, n19));
        }
        function Ou(t84, e61, r31) {
            return e61.x <= Math.max(t84.x, r31.x) && e61.x >= Math.min(t84.x, r31.x) && e61.y <= Math.max(t84.y, r31.y) && e61.y >= Math.min(t84.y, r31.y);
        }
        function qu(t84) {
            return t84 > 0 ? 1 : t84 < 0 ? -1 : 0;
        }
        function Nu(t84, e61) {
            return ju(t84.prev, t84, t84.next) < 0 ? ju(t84, e61, t84.next) >= 0 && ju(t84, t84.prev, e61) >= 0 : ju(t84, e61, t84.prev) < 0 || ju(t84, t84.next, e61) < 0;
        }
        function Gu(t84, e61) {
            var r31 = new Ku(t84.i, t84.x, t84.y), n19 = new Ku(e61.i, e61.x, e61.y), i15 = t84.next, s10 = e61.prev;
            return t84.next = e61, e61.prev = t84, r31.next = i15, i15.prev = r31, n19.next = r31, r31.prev = n19, s10.next = n19, n19.prev = s10, n19;
        }
        function Xu(t84, e61, r31, n19) {
            var i15 = new Ku(t84, e61, r31);
            return n19 ? (i15.next = n19.next, i15.prev = n19, n19.next.prev = i15, n19.next = i15) : (i15.prev = i15, i15.next = i15), i15;
        }
        function Zu(t84) {
            t84.next.prev = t84.prev, t84.prev.next = t84.next, t84.prevZ && (t84.prevZ.nextZ = t84.nextZ), t84.nextZ && (t84.nextZ.prevZ = t84.prevZ);
        }
        function Ku(t84, e61, r31) {
            this.i = t84, this.x = e61, this.y = r31, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
        }
        function Yu(t84, e61, r31, n19) {
            for(var i15 = 0, s10 = e61, a5 = r31 - n19; s10 < r31; s10 += n19)i15 += (t84[a5] - t84[s10]) * (t84[s10 + 1] + t84[a5 + 1]), a5 = s10;
            return i15;
        }
        function Hu(t84, e61, r31, n19, i15) {
            Wu(t84, e61, r31 || 0, n19 || t84.length - 1, i15 || Qu);
        }
        function Wu(t84, e61, r31, n19, i15) {
            for(; n19 > r31;){
                if (n19 - r31 > 600) {
                    var s10 = n19 - r31 + 1, a5 = e61 - r31 + 1, o8 = Math.log(s10), l6 = 0.5 * Math.exp(2 * o8 / 3), u5 = 0.5 * Math.sqrt(o8 * l6 * (s10 - l6) / s10) * (a5 - s10 / 2 < 0 ? -1 : 1);
                    Wu(t84, e61, Math.max(r31, Math.floor(e61 - a5 * l6 / s10 + u5)), Math.min(n19, Math.floor(e61 + (s10 - a5) * l6 / s10 + u5)), i15);
                }
                var c3 = t84[e61], h3 = r31, p4 = n19;
                for(Ju(t84, r31, e61), i15(t84[n19], c3) > 0 && Ju(t84, r31, n19); h3 < p4;){
                    for(Ju(t84, h3, p4), h3++, p4--; i15(t84[h3], c3) < 0;)h3++;
                    for(; i15(t84[p4], c3) > 0;)p4--;
                }
                0 === i15(t84[r31], c3) ? Ju(t84, r31, p4) : Ju(t84, ++p4, n19), p4 <= e61 && (r31 = p4 + 1), e61 <= p4 && (n19 = p4 - 1);
            }
        }
        function Ju(t84, e61, r31) {
            var n19 = t84[e61];
            t84[e61] = t84[r31], t84[r31] = n19;
        }
        function Qu(t84, e61) {
            return t84 < e61 ? -1 : t84 > e61 ? 1 : 0;
        }
        function tc(t84, e61) {
            const r31 = t84.length;
            if (r31 <= 1) return [
                t84
            ];
            const n19 = [];
            let i15, s11;
            for(let e62 = 0; e62 < r31; e62++){
                const r32 = q(t84[e62]);
                0 !== r32 && (t84[e62].area = Math.abs(r32), (void 0) === s11 && (s11 = r32 < 0), s11 === r32 < 0 ? (i15 && n19.push(i15), i15 = [
                    t84[e62]
                ]) : i15.push(t84[e62]));
            }
            if (i15 && n19.push(i15), e61 > 1) for(let t85 = 0; t85 < n19.length; t85++)n19[t85].length <= e61 || (Hu(n19[t85], e61, 1, n19[t85].length - 1, ec), n19[t85] = n19[t85].slice(0, e61));
            return n19;
        }
        function ec(t84, e61) {
            return e61.area - t84.area;
        }
        function rc(t84, e61, r31) {
            const n19 = r31.patternDependencies;
            let i15 = !1;
            for (const r32 of e61){
                const e62 = r32.paint.get(`${t84}-pattern`);
                e62.isConstant() || (i15 = !0);
                const s11 = e62.constantOr(null);
                s11 && (i15 = !0, n19[s11] = !0);
            }
            return i15;
        }
        function nc(t84, e61, r31, n19, i15) {
            const s11 = i15.patternDependencies;
            for (const a6 of e61){
                const e62 = a6.paint.get(`${t84}-pattern`).value;
                if ("constant" !== e62.kind) {
                    let t85 = e62.evaluate({
                        zoom: n19
                    }, r31, {
                    }, i15.availableImages);
                    t85 = t85 && t85.name ? t85.name : t85, s11[t85] = !0, r31.patterns[a6.id] = t85;
                }
            }
            return r31;
        }
        Au.exports = Su, Au.exports.default = Su, Su.deviation = function(t84, e61, r31, n19) {
            var i15 = e61 && e61.length, s11 = Math.abs(Yu(t84, 0, i15 ? e61[0] * r31 : t84.length, r31));
            if (i15) for(var a6 = 0, o9 = e61.length; a6 < o9; a6++)s11 -= Math.abs(Yu(t84, e61[a6] * r31, a6 < o9 - 1 ? e61[a6 + 1] * r31 : t84.length, r31));
            var l7 = 0;
            for(a6 = 0; a6 < n19.length; a6 += 3){
                var u6 = n19[a6] * r31, c4 = n19[a6 + 1] * r31, h4 = n19[a6 + 2] * r31;
                l7 += Math.abs((t84[u6] - t84[h4]) * (t84[c4 + 1] - t84[u6 + 1]) - (t84[u6] - t84[c4]) * (t84[h4 + 1] - t84[u6 + 1]));
            }
            return 0 === s11 && 0 === l7 ? 0 : Math.abs((l7 - s11) / s11);
        }, Su.flatten = function(t84) {
            for(var e61 = t84[0][0].length, r31 = {
                vertices: [],
                holes: [],
                dimensions: e61
            }, n19 = 0, i15 = 0; i15 < t84.length; i15++){
                for(var s11 = 0; s11 < t84[i15].length; s11++)for(var a6 = 0; a6 < e61; a6++)r31.vertices.push(t84[i15][s11][a6]);
                i15 > 0 && r31.holes.push(n19 += t84[i15 - 1].length);
            }
            return r31;
        };
        class ic {
            constructor(t84){
                this.zoom = t84.zoom, this.overscaling = t84.overscaling, this.layers = t84.layers, this.layerIds = this.layers.map((t85)=>t85.id
                ), this.index = t84.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new sa, this.indexArray = new wa, this.indexArray2 = new Ma, this.programConfigurations = new po(t84.layers, t84.zoom), this.segments = new Ao, this.segments2 = new Ao, this.stateDependentLayerIds = this.layers.filter((t85)=>t85.isStateDependent()
                ).map((t85)=>t85.id
                ), this.projection = t84.projection;
            }
            populate(t, e, r, n) {
                this.hasPattern = rc("fill", this.layers, e);
                const i15 = this.layers[0].layout.get("fill-sort-key"), s12 = [];
                for (const { feature: a7 , id: o9 , index: l7 , sourceLayerIndex: u7  } of t){
                    const t85 = this.layers[0]._featureFilter.needGeometry, c5 = Zo(a7, t85);
                    if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), c5, r)) continue;
                    const h5 = i15 ? i15.evaluate(c5, {
                    }, r, e.availableImages) : void 0, p5 = {
                        id: o9,
                        properties: a7.properties,
                        type: a7.type,
                        sourceLayerIndex: u7,
                        index: l7,
                        geometry: t85 ? c5.geometry : Xo(a7, r, n),
                        patterns: {
                        },
                        sortKey: h5
                    };
                    s12.push(p5);
                }
                i15 && s12.sort((t85, e61)=>t85.sortKey - e61.sortKey
                );
                for (const n19 of s12){
                    const { geometry: i16 , index: s13 , sourceLayerIndex: a8  } = n19;
                    if (this.hasPattern) {
                        const t85 = nc("fill", this.layers, n19, this.zoom, e);
                        this.patternFeatures.push(t85);
                    } else this.addFeature(n19, i16, s13, r, {
                    }, e.availableImages);
                    e.featureIndex.insert(t[s13].feature, i16, s13, a8, this.index);
                }
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }
            addFeatures(t, e, r, n, i) {
                for (const t85 of this.patternFeatures)this.addFeature(t85, t85.geometry, t85.index, e, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, _u), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t, e, r, n, i, s = []) {
                for (const t85 of tc(e, 500)){
                    let e61 = 0;
                    for (const r31 of t85)e61 += r31.length;
                    const r32 = this.segments.prepareSegment(e61, this.layoutVertexArray, this.indexArray), n19 = r32.vertexLength, i15 = [], s12 = [];
                    for (const e62 of t85){
                        if (0 === e62.length) continue;
                        e62 !== t85[0] && s12.push(i15.length / 2);
                        const r33 = this.segments2.prepareSegment(e62.length, this.layoutVertexArray, this.indexArray2), n20 = r33.vertexLength;
                        this.layoutVertexArray.emplaceBack(e62[0].x, e62[0].y), this.indexArray2.emplaceBack(n20 + e62.length - 1, n20), i15.push(e62[0].x), i15.push(e62[0].y);
                        for(let t86 = 1; t86 < e62.length; t86++)this.layoutVertexArray.emplaceBack(e62[t86].x, e62[t86].y), this.indexArray2.emplaceBack(n20 + t86 - 1, n20 + t86), i15.push(e62[t86].x), i15.push(e62[t86].y);
                        r33.vertexLength += e62.length, r33.primitiveLength += e62.length;
                    }
                    const a7 = Au.exports(i15, s12);
                    for(let t86 = 0; t86 < a7.length; t86 += 3)this.indexArray.emplaceBack(n19 + a7[t86], n19 + a7[t86 + 1], n19 + a7[t86 + 2]);
                    r32.vertexLength += e61, r32.primitiveLength += a7.length / 3;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
            }
        }
        Oi(ic, "FillBucket", {
            omit: [
                "layers",
                "patternFeatures"
            ]
        });
        const sc = new Js({
            "fill-sort-key": new Hs(Ht.layout_fill["fill-sort-key"])
        });
        var ac = {
            paint: new Js({
                "fill-antialias": new Ys(Ht.paint_fill["fill-antialias"]),
                "fill-opacity": new Hs(Ht.paint_fill["fill-opacity"]),
                "fill-color": new Hs(Ht.paint_fill["fill-color"]),
                "fill-outline-color": new Hs(Ht.paint_fill["fill-outline-color"]),
                "fill-translate": new Ys(Ht.paint_fill["fill-translate"]),
                "fill-translate-anchor": new Ys(Ht.paint_fill["fill-translate-anchor"]),
                "fill-pattern": new Hs(Ht.paint_fill["fill-pattern"])
            }),
            layout: sc
        };
        const oc = na([
            {
                name: "a_pos_normal_ed",
                components: 4,
                type: "Int16"
            }
        ]), lc = na([
            {
                name: "a_centroid_pos",
                components: 2,
                type: "Uint16"
            }
        ]), uc = na([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]), { members: cc  } = oc;
        var hc = {
        }, pc = d2, fc = dc;
        function dc(t85, e61, r31, n19, i15) {
            this.properties = {
            }, this.extent = r31, this.type = 0, this._pbf = t85, this._geometry = -1, this._keys = n19, this._values = i15, t85.readFields(yc, this, e61);
        }
        function yc(t85, e61, r31) {
            1 == t85 ? e61.id = r31.readVarint() : 2 == t85 ? (function(t86, e62) {
                for(var r32 = t86.readVarint() + t86.pos; t86.pos < r32;){
                    var n19 = e62._keys[t86.readVarint()], i15 = e62._values[t86.readVarint()];
                    e62.properties[n19] = i15;
                }
            })(r31, e61) : 3 == t85 ? e61.type = r31.readVarint() : 4 == t85 && (e61._geometry = r31.pos);
        }
        function mc(t85) {
            for(var e61, r31, n20 = 0, i16 = 0, s12 = t85.length, a7 = s12 - 1; i16 < s12; a7 = i16++)n20 += ((r31 = t85[a7]).x - (e61 = t85[i16]).x) * (e61.y + r31.y);
            return n20;
        }
        dc.types = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ], dc.prototype.loadGeometry = function() {
            var t85 = this._pbf;
            t85.pos = this._geometry;
            for(var e61, r31 = t85.readVarint() + t85.pos, n20 = 1, i16 = 0, s12 = 0, a7 = 0, o9 = []; t85.pos < r31;){
                if (i16 <= 0) {
                    var l7 = t85.readVarint();
                    n20 = 7 & l7, i16 = l7 >> 3;
                }
                if (i16--, 1 === n20 || 2 === n20) s12 += t85.readSVarint(), a7 += t85.readSVarint(), 1 === n20 && (e61 && o9.push(e61), e61 = []), e61.push(new pc(s12, a7));
                else {
                    if (7 !== n20) throw new Error("unknown command " + n20);
                    e61 && e61.push(e61[0].clone());
                }
            }
            return e61 && o9.push(e61), o9;
        }, dc.prototype.bbox = function() {
            var t85 = this._pbf;
            t85.pos = this._geometry;
            for(var e61 = t85.readVarint() + t85.pos, r31 = 1, n20 = 0, i16 = 0, s12 = 0, a7 = 1 / 0, o9 = -1 / 0, l8 = 1 / 0, u7 = -1 / 0; t85.pos < e61;){
                if (n20 <= 0) {
                    var c5 = t85.readVarint();
                    r31 = 7 & c5, n20 = c5 >> 3;
                }
                if (n20--, 1 === r31 || 2 === r31) (i16 += t85.readSVarint()) < a7 && (a7 = i16), i16 > o9 && (o9 = i16), (s12 += t85.readSVarint()) < l8 && (l8 = s12), s12 > u7 && (u7 = s12);
                else if (7 !== r31) throw new Error("unknown command " + r31);
            }
            return [
                a7,
                l8,
                o9,
                u7
            ];
        }, dc.prototype.toGeoJSON = function(t85, e61, r31) {
            var n20, i16, s12 = this.extent * Math.pow(2, r31), a7 = this.extent * t85, o9 = this.extent * e61, l8 = this.loadGeometry(), u7 = dc.types[this.type];
            function c6(t86) {
                for(var e62 = 0; e62 < t86.length; e62++){
                    var r32 = t86[e62];
                    t86[e62] = [
                        360 * (r32.x + a7) / s12 - 180,
                        360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r32.y + o9) / s12) * Math.PI / 180)) - 90
                    ];
                }
            }
            switch(this.type){
                case 1:
                    var h5 = [];
                    for(n20 = 0; n20 < l8.length; n20++)h5[n20] = l8[n20][0];
                    c6(l8 = h5);
                    break;
                case 2:
                    for(n20 = 0; n20 < l8.length; n20++)c6(l8[n20]);
                    break;
                case 3:
                    for(l8 = (function(t86) {
                        var e62 = t86.length;
                        if (e62 <= 1) return [
                            t86
                        ];
                        for(var r33, n21, i17 = [], s13 = 0; s13 < e62; s13++){
                            var a8 = mc(t86[s13]);
                            0 !== a8 && ((void 0) === n21 && (n21 = a8 < 0), n21 === a8 < 0 ? (r33 && i17.push(r33), r33 = [
                                t86[s13]
                            ]) : r33.push(t86[s13]));
                        }
                        return r33 && i17.push(r33), i17;
                    })(l8), n20 = 0; n20 < l8.length; n20++)for(i16 = 0; i16 < l8[n20].length; i16++)c6(l8[n20][i16]);
            }
            1 === l8.length ? l8 = l8[0] : u7 = "Multi" + u7;
            var p5 = {
                type: "Feature",
                geometry: {
                    type: u7,
                    coordinates: l8
                },
                properties: this.properties
            };
            return "id" in this && (p5.id = this.id), p5;
        };
        var gc = fc, xc = vc;
        function vc(t85, e61) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t85, this._keys = [], this._values = [], this._features = [], t85.readFields(bc, this, e61), this.length = this._features.length;
        }
        function bc(t85, e61, r31) {
            15 === t85 ? e61.version = r31.readVarint() : 1 === t85 ? e61.name = r31.readString() : 5 === t85 ? e61.extent = r31.readVarint() : 2 === t85 ? e61._features.push(r31.pos) : 3 === t85 ? e61._keys.push(r31.readString()) : 4 === t85 && e61._values.push(function(t86) {
                for(var e62 = null, r33 = t86.readVarint() + t86.pos; t86.pos < r33;){
                    var n20 = t86.readVarint() >> 3;
                    e62 = 1 === n20 ? t86.readString() : 2 === n20 ? t86.readFloat() : 3 === n20 ? t86.readDouble() : 4 === n20 ? t86.readVarint64() : 5 === n20 ? t86.readVarint() : 6 === n20 ? t86.readSVarint() : 7 === n20 ? t86.readBoolean() : null;
                }
                return e62;
            }(r31));
        }
        vc.prototype.feature = function(t85) {
            if (t85 < 0 || t85 >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t85];
            var e61 = this._pbf.readVarint() + this._pbf.pos;
            return new gc(this._pbf, e61, this.extent, this._keys, this._values);
        };
        var wc = xc;
        function _c(t85, e61, r31) {
            if (3 === t85) {
                var n21 = new wc(r31, r31.readVarint() + r31.pos);
                n21.length && (e61[n21.name] = n21);
            }
        }
        var Ac = hc.VectorTile = function(t85, e61) {
            this.layers = t85.readFields(_c, {
            }, e61);
        }, Sc = hc.VectorTileFeature = fc;
        function kc(t85, e61, r31, n22) {
            const i16 = [], s12 = 0 === n22 ? (t86, e62, r33, n23, i17, s13)=>{
                t86.push(new d2(s13, r33 + (s13 - e62) / (n23 - e62) * (i17 - r33)));
            } : (t86, e62, r33, n23, i17, s13)=>{
                t86.push(new d2(e62 + (s13 - r33) / (i17 - r33) * (n23 - e62), s13));
            };
            for (const a7 of t85){
                const t86 = [];
                for (const i17 of a7){
                    if (i17.length <= 2) continue;
                    const a9 = [];
                    for(let t87 = 0; t87 < i17.length - 1; t87++){
                        const o9 = i17[t87].x, l8 = i17[t87].y, u7 = i17[t87 + 1].x, c6 = i17[t87 + 1].y, h5 = 0 === n22 ? o9 : l8, p5 = 0 === n22 ? u7 : c6;
                        h5 < e61 ? p5 > e61 && s12(a9, o9, l8, u7, c6, e61) : h5 > r31 ? p5 < r31 && s12(a9, o9, l8, u7, c6, r31) : a9.push(i17[t87]), p5 < e61 && h5 >= e61 && s12(a9, o9, l8, u7, c6, e61), p5 > r31 && h5 <= r31 && s12(a9, o9, l8, u7, c6, r31);
                    }
                    let o9 = i17[i17.length - 1];
                    const l8 = 0 === n22 ? o9.x : o9.y;
                    l8 >= e61 && l8 <= r31 && a9.push(o9), a9.length && (o9 = a9[a9.length - 1], a9[0].x === o9.x && a9[0].y === o9.y || a9.push(a9[0]), t86.push(a9));
                }
                t86.length && i16.push(t86);
            }
            return i16;
        }
        hc.VectorTileLayer = xc;
        const Ic = Sc.types, Mc = Math.pow(2, 13);
        function Tc(t85, e61, r31, n22, i16, s12, a7, o9) {
            t85.emplaceBack((e61 << 1) + a7, (r31 << 1) + s12, (Math.floor(n22 * Mc) << 1) + i16, Math.round(o9));
        }
        function zc(t85, e61, r31) {
            const n22 = 16384;
            t85.emplaceBack(e61.x, e61.y, e61.z, r31[0] * n22, r31[1] * n22, r31[2] * n22);
        }
        class Bc {
            constructor(){
                this.acc = new d2(0, 0), this.polyCount = [];
            }
            startRing(t) {
                this.currentPolyCount = {
                    edges: 0,
                    top: 0
                }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new d2(t.x, t.y), this.max = new d2(t.x, t.y));
            }
            append(t, e) {
                this.currentPolyCount.edges++, this.acc._add(t);
                const r31 = this.min, n22 = this.max;
                t.x < r31.x ? r31.x = t.x : t.x > n22.x && (n22.x = t.x), t.y < r31.y ? r31.y = t.y : t.y > n22.y && (n22.y = t.y), ((0 === t.x || t.x === So) && t.x === e.x) != ((0 === t.y || t.y === So) && t.y === e.y) && this.processBorderOverlap(t, e), e.x < 0 != t.x < 0 && this.addBorderIntersection(0, Mr(e.y, t.y, (0 - e.x) / (t.x - e.x))), e.x > So != t.x > So && this.addBorderIntersection(1, Mr(e.y, t.y, (So - e.x) / (t.x - e.x))), e.y < 0 != t.y < 0 && this.addBorderIntersection(2, Mr(e.x, t.x, (0 - e.y) / (t.y - e.y))), e.y > So != t.y > So && this.addBorderIntersection(3, Mr(e.x, t.x, (So - e.y) / (t.y - e.y)));
            }
            addBorderIntersection(t, e) {
                this.borders || (this.borders = [
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ]
                ]);
                const r31 = this.borders[t];
                e < r31[0] && (r31[0] = e), e > r31[1] && (r31[1] = e);
            }
            processBorderOverlap(t, e) {
                if (t.x === e.x) {
                    if (t.y === e.y) return;
                    const r31 = 0 === t.x ? 0 : 1;
                    this.addBorderIntersection(r31, e.y), this.addBorderIntersection(r31, t.y);
                } else {
                    const r31 = 0 === t.y ? 2 : 3;
                    this.addBorderIntersection(r31, e.x), this.addBorderIntersection(r31, t.x);
                }
            }
            centroid() {
                const t85 = this.polyCount.reduce((t86, e61)=>t86 + e61.edges
                , 0);
                return 0 !== t85 ? this.acc.div(t85)._round() : new d2(0, 0);
            }
            span() {
                return new d2(this.max.x - this.min.x, this.max.y - this.min.y);
            }
            intersectsCount() {
                return this.borders.reduce((t85, e61)=>t85 + +(e61[0] !== Number.MAX_VALUE)
                , 0);
            }
        }
        class Ec {
            constructor(t85){
                this.zoom = t85.zoom, this.canonical = t85.canonical, this.overscaling = t85.overscaling, this.layers = t85.layers, this.layerIds = this.layers.map((t86)=>t86.id
                ), this.index = t85.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t85.projection, this.layoutVertexArray = new oa, this.centroidVertexArray = new Ua, this.indexArray = new wa, this.programConfigurations = new po(t85.layers, t85.zoom), this.segments = new Ao, this.stateDependentLayerIds = this.layers.filter((t86)=>t86.isStateDependent()
                ).map((t86)=>t86.id
                ), this.enableTerrain = t85.enableTerrain;
            }
            populate(t, e, r, n) {
                this.features = [], this.hasPattern = rc("fill-extrusion", this.layers, e), this.featuresOnBorder = [], this.borders = [
                    [],
                    [],
                    [],
                    []
                ], this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ], this.tileToMeter = (function(t86) {
                    const e61 = Math.exp(Math.PI * (1 - t86.y / (1 << t86.z) * 2));
                    return 80150034 * e61 / (e61 * e61 + 1) / So / (1 << t86.z);
                })(r), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
                for (const { feature: i16 , id: s12 , index: a7 , sourceLayerIndex: o9  } of t){
                    const t86 = this.layers[0]._featureFilter.needGeometry, l8 = Zo(i16, t86);
                    if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), l8, r)) continue;
                    const u7 = {
                        id: s12,
                        sourceLayerIndex: o9,
                        index: a7,
                        geometry: t86 ? l8.geometry : Xo(i16, r, n),
                        properties: i16.properties,
                        type: i16.type,
                        patterns: {
                        }
                    }, c6 = this.layoutVertexArray.length;
                    this.hasPattern ? this.features.push(nc("fill-extrusion", this.layers, u7, this.zoom, e)) : this.addFeature(u7, u7.geometry, a7, r, {
                    }, e.availableImages, n), e.featureIndex.insert(i16, u7.geometry, a7, o9, this.index, c6);
                }
                this.sortBorders();
            }
            addFeatures(t, e, r, n, i) {
                for (const t86 of this.features){
                    const { geometry: s12  } = t86;
                    this.addFeature(t86, s12, t86.index, e, r, n, i);
                }
                this.sortBorders();
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t) {
                this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, cc), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, uc.members, !0))), this.programConfigurations.upload(t), this.uploaded = !0;
            }
            uploadCentroid(t) {
                0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, lc.members, !0), this.needsCentroidUpdate = !1);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t, e, r, n, i, s, a) {
                const o9 = [
                    new d2(0, 0),
                    new d2(So, So)
                ], l8 = a.projection, u7 = "globe" === l8.name, c6 = this.enableTerrain && !u7 ? new Bc : null, h5 = "Polygon" === Ic[t.type];
                u7 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new pa);
                const p5 = tc(e, 500);
                for(let t86 = p5.length - 1; t86 >= 0; t86--){
                    const e61 = p5[t86];
                    (0 === e61.length || (f3 = e61[0]).every((t87)=>t87.x <= 0
                    ) || f3.every((t87)=>t87.x >= So
                    ) || f3.every((t87)=>t87.y <= 0
                    ) || f3.every((t87)=>t87.y >= So
                    )) && p5.splice(t86, 1);
                }
                var f3;
                let y2;
                if (u7) y2 = jc(p5, o9, n);
                else {
                    y2 = [];
                    for (const t87 of p5)y2.push({
                        polygon: t87,
                        bounds: o9
                    });
                }
                const m2 = h5 ? this.edgeRadius : 0;
                for (const { polygon: t87 , bounds: e61  } of y2){
                    let r31 = 0, i16 = 0;
                    for (const e62 of t87)h5 && !e62[0].equals(e62[e62.length - 1]) && e62.push(e62[0]), i16 += h5 ? e62.length - 1 : e62.length;
                    const s12 = this.segments.prepareSegment((h5 ? 5 : 4) * i16, this.layoutVertexArray, this.indexArray);
                    if (h5) {
                        const e63 = [], i17 = [];
                        r31 = s12.vertexLength;
                        for (const r33 of t87){
                            let a7, o10;
                            r33.length && r33 !== t87[0] && i17.push(e63.length / 2), a7 = r33[1].sub(r33[0])._perp()._unit();
                            for(let t88 = 1; t88 < r33.length; t88++){
                                const i18 = r33[t88], c7 = r33[t88 === r33.length - 1 ? 1 : t88 + 1];
                                let { x: h6 , y: p6  } = i18;
                                if (m2) {
                                    o10 = c7.sub(i18)._perp()._unit();
                                    const t89 = a7.add(o10)._unit(), e64 = m2 * Math.min(4, 1 / (a7.x * t89.x + a7.y * t89.y));
                                    h6 += e64 * t89.x, p6 += e64 * t89.y, a7 = o10;
                                }
                                Tc(this.layoutVertexArray, h6, p6, 0, 0, 1, 1, 0), s12.vertexLength++, e63.push(i18.x, i18.y), u7 && zc(this.layoutVertexExtArray, l8.projectTilePoint(h6, p6, n), l8.upVector(n, h6, p6));
                            }
                        }
                        const a7 = Au.exports(e63, i17);
                        for(let t88 = 0; t88 < a7.length; t88 += 3)this.indexArray.emplaceBack(r31 + a7[t88], r31 + a7[t88 + 2], r31 + a7[t88 + 1]), s12.primitiveLength++;
                    }
                    for (const i17 of t87){
                        c6 && i17.length && c6.startRing(i17[0]);
                        let t88, a7, o10, p6 = i17.length > 4 && Lc(i17[i17.length - 2], i17[0], i17[1]), f4 = m2 ? Pc(i17[i17.length - 2], i17[0], i17[1], m2) : 0;
                        a7 = i17[1].sub(i17[0])._perp()._unit();
                        let d4 = !0;
                        for(let y3 = 1, g2 = 0; y3 < i17.length; y3++){
                            let x2 = i17[y3 - 1], v2 = i17[y3];
                            const b2 = i17[y3 === i17.length - 1 ? 1 : y3 + 1];
                            if (c6 && h5 && c6.currentPolyCount.top++, Vc(v2, x2, e61)) {
                                m2 && (a7 = b2.sub(v2)._perp()._unit(), d4 = !d4);
                                continue;
                            }
                            c6 && c6.append(v2, x2);
                            const w2 = v2.sub(x2)._perp(), _2 = w2.x / (Math.abs(w2.x) + Math.abs(w2.y)), A2 = w2.y > 0 ? 1 : 0, S2 = x2.dist(v2);
                            if (g2 + S2 > 32768 && (g2 = 0), m2) {
                                o10 = b2.sub(v2)._perp()._unit();
                                let t89 = Dc(x2, v2, b2, Cc(a7, o10), m2);
                                isNaN(t89) && (t89 = 0);
                                const e63 = v2.sub(x2)._unit();
                                x2 = x2.add(e63.mult(f4))._round(), v2 = v2.add(e63.mult(-t89))._round(), f4 = t89, a7 = o10;
                            }
                            const k2 = s12.vertexLength, I2 = i17.length > 4 && Lc(x2, v2, b2);
                            let M2 = Fc(g2, p6, d4);
                            if (Tc(this.layoutVertexArray, x2.x, x2.y, _2, A2, 0, 0, M2), Tc(this.layoutVertexArray, x2.x, x2.y, _2, A2, 0, 1, M2), g2 += S2, M2 = Fc(g2, I2, !d4), p6 = I2, Tc(this.layoutVertexArray, v2.x, v2.y, _2, A2, 0, 0, M2), Tc(this.layoutVertexArray, v2.x, v2.y, _2, A2, 0, 1, M2), s12.vertexLength += 4, this.indexArray.emplaceBack(k2 + 0, k2 + 1, k2 + 2), this.indexArray.emplaceBack(k2 + 1, k2 + 3, k2 + 2), s12.primitiveLength += 2, m2) {
                                const n22 = r31 + (1 === y3 ? i17.length - 2 : y3 - 2), a9 = 1 === y3 ? r31 : n22 + 1;
                                if (this.indexArray.emplaceBack(k2 + 1, n22, k2 + 3), this.indexArray.emplaceBack(n22, a9, k2 + 3), s12.primitiveLength += 2, (void 0) === t88 && (t88 = k2), !Vc(b2, i17[y3], e61)) {
                                    const e63 = y3 === i17.length - 1 ? t88 : s12.vertexLength;
                                    this.indexArray.emplaceBack(k2 + 2, k2 + 3, e63), this.indexArray.emplaceBack(k2 + 3, e63 + 1, e63), this.indexArray.emplaceBack(k2 + 3, a9, e63 + 1), s12.primitiveLength += 3;
                                }
                                d4 = !d4;
                            }
                            if (u7) {
                                const t89 = this.layoutVertexExtArray, e63 = l8.projectTilePoint(x2.x, x2.y, n), r33 = l8.projectTilePoint(v2.x, v2.y, n), i18 = l8.upVector(n, x2.x, x2.y), s13 = l8.upVector(n, v2.x, v2.y);
                                zc(t89, e63, i18), zc(t89, e63, i18), zc(t89, r33, s13), zc(t89, r33, s13);
                            }
                        }
                        h5 && (r31 += i17.length - 1);
                    }
                }
                if (c6 && c6.polyCount.length > 0) {
                    if (c6.borders) {
                        c6.vertexArrayOffset = this.centroidVertexArray.length;
                        const t88 = c6.borders, e62 = this.featuresOnBorder.push(c6) - 1;
                        for(let r31 = 0; r31 < 4; r31++)t88[r31][0] !== Number.MAX_VALUE && this.borders[r31].push(e62);
                    }
                    this.encodeCentroid(c6.borders ? void 0 : c6.centroid(), c6);
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
            }
            sortBorders() {
                for(let t86 = 0; t86 < 4; t86++)this.borders[t86].sort((e61, r31)=>this.featuresOnBorder[e61].borders[t86][0] - this.featuresOnBorder[r31].borders[t86][0]
                );
            }
            encodeCentroid(t, e, r = !0) {
                let n22, i16;
                if (t) {
                    if (0 !== t.y) {
                        const r31 = e.span()._mult(this.tileToMeter);
                        n22 = (Math.max(t.x, 1) << 3) + Math.min(7, Math.round(r31.x / 10)), i16 = (Math.max(t.y, 1) << 3) + Math.min(7, Math.round(r31.y / 10));
                    } else n22 = Math.ceil(7 * (t.x + 450)), i16 = 0;
                } else n22 = 0, i16 = +r;
                let s12 = r ? this.centroidVertexArray.length : e.vertexArrayOffset;
                for (const t86 of e.polyCount){
                    r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t86.edges + t86.top);
                    for(let e61 = 0; e61 < t86.top; e61++)this.centroidVertexArray.emplace(s12++, n22, i16);
                    for(let e62 = 0; e62 < 2 * t86.edges; e62++)this.centroidVertexArray.emplace(s12++, 0, i16), this.centroidVertexArray.emplace(s12++, n22, i16);
                }
            }
        }
        function Cc(t86, e61) {
            const r31 = t86.add(e61)._unit();
            return t86.x * r31.x + t86.y * r31.y;
        }
        function Pc(t86, e61, r31, n22) {
            const i16 = e61.sub(t86)._perp()._unit(), s12 = r31.sub(e61)._perp()._unit();
            return Dc(t86, e61, r31, Cc(i16, s12), n22);
        }
        function Dc(t86, e61, r31, n22, i16) {
            const s12 = Math.sqrt(1 - n22 * n22);
            return Math.min(t86.dist(e61) / 3, e61.dist(r31) / 3, i16 * s12 / n22);
        }
        function Vc(t86, e61, r31) {
            return t86.x < r31[0].x && e61.x < r31[0].x || t86.x > r31[1].x && e61.x > r31[1].x || t86.y < r31[0].y && e61.y < r31[0].y || t86.y > r31[1].y && e61.y > r31[1].y;
        }
        function Lc(t86, e61, r31) {
            if (t86.x < 0 || t86.x >= So || e61.x < 0 || e61.x >= So || r31.x < 0 || r31.x >= So) return !1;
            const n22 = r31.sub(e61), i16 = n22.perp(), s12 = t86.sub(e61);
            return (n22.x * s12.x + n22.y * s12.y) / Math.sqrt((n22.x * n22.x + n22.y * n22.y) * (s12.x * s12.x + s12.y * s12.y)) > -0.866 && i16.x * s12.x + i16.y * s12.y < 0;
        }
        function Fc(t86, e61, r31) {
            const n22 = e61 ? 2 | t86 : -3 & t86;
            return r31 ? 1 | n22 : -2 & n22;
        }
        function Rc() {
            const t86 = Math.PI / 32, e61 = Math.tan(t86), r31 = Io;
            return r31 * Math.sqrt(1 + 2 * e61 * e61) - r31;
        }
        function jc(t86, e61, r31) {
            const n22 = 1 << r31.z, i16 = Po(r31.x / n22), s12 = Po((r31.x + 1) / n22), a7 = Do(r31.y / n22), o9 = Do((r31.y + 1) / n22);
            return (function(t87, e62, r33, n23, i17 = 0, s13) {
                const a9 = [];
                if (!t87.length || !r33 || !n23) return a9;
                const o10 = (t88, e63)=>{
                    for (const r34 of t88)a9.push({
                        polygon: r34,
                        bounds: e63
                    });
                }, l8 = Math.ceil(Math.log2(r33)), u7 = Math.ceil(Math.log2(n23)), c6 = l8 - u7, h5 = [];
                for(let t88 = 0; t88 < Math.abs(c6); t88++)h5.push(c6 > 0 ? 0 : 1);
                for(let t89 = 0; t89 < Math.min(l8, u7); t89++)h5.push(0), h5.push(1);
                let p5 = t87;
                if (p5 = kc(p5, e62[0].y - i17, e62[1].y + i17, 1), p5 = kc(p5, e62[0].x - i17, e62[1].x + i17, 0), !p5.length) return a9;
                const f4 = [];
                for(h5.length ? f4.push({
                    polygons: p5,
                    bounds: e62,
                    depth: 0
                }) : o10(p5, e62); f4.length;){
                    const t90 = f4.pop(), e63 = t90.depth, r34 = h5[e63], n24 = t90.bounds[0], a10 = t90.bounds[1], l9 = 0 === r34 ? n24.x : n24.y, u8 = 0 === r34 ? a10.x : a10.y, c7 = s13 ? s13(r34, l9, u8) : 0.5 * (l9 + u8), p6 = kc(t90.polygons, l9 - i17, c7 + i17, r34), y2 = kc(t90.polygons, c7 - i17, u8 + i17, r34);
                    if (p6.length) {
                        const t91 = [
                            n24,
                            new d2(0 === r34 ? c7 : a10.x, 1 === r34 ? c7 : a10.y)
                        ];
                        h5.length > e63 + 1 ? f4.push({
                            polygons: p6,
                            bounds: t91,
                            depth: e63 + 1
                        }) : o10(p6, t91);
                    }
                    if (y2.length) {
                        const t91 = [
                            new d2(0 === r34 ? c7 : n24.x, 1 === r34 ? c7 : n24.y),
                            a10
                        ];
                        h5.length > e63 + 1 ? f4.push({
                            polygons: y2,
                            bounds: t91,
                            depth: e63 + 1
                        }) : o10(y2, t91);
                    }
                }
                return a9;
            })(t86, e61, Math.ceil((s12 - i16) / 11.25), Math.ceil((a7 - o9) / 11.25), 1, (t87, e62, i17)=>{
                if (0 === t87) return 0.5 * (e62 + i17);
                {
                    const t88 = Do((r31.y + e62 / So) / n22);
                    return (Eo(0.5 * (Do((r31.y + i17 / So) / n22) + t88)) * n22 - r31.y) * So;
                }
            });
        }
        Oi(Ec, "FillExtrusionBucket", {
            omit: [
                "layers",
                "features"
            ]
        }), Oi(Bc, "PartMetadata");
        const Uc = new Js({
            "fill-extrusion-edge-radius": new Ys(Ht["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
        });
        var $c = {
            paint: new Js({
                "fill-extrusion-opacity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                "fill-extrusion-color": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-color"]),
                "fill-extrusion-translate": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate"]),
                "fill-extrusion-translate-anchor": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                "fill-extrusion-pattern": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                "fill-extrusion-height": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-height"]),
                "fill-extrusion-base": new Hs(Ht["paint_fill-extrusion"]["fill-extrusion-base"]),
                "fill-extrusion-vertical-gradient": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                "fill-extrusion-ambient-occlusion-intensity": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                "fill-extrusion-ambient-occlusion-radius": new Ys(Ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"])
            }),
            layout: Uc
        };
        function Oc(t86, e61, r31) {
            var n22 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r31);
            return [
                t86 * n22 - 2 * Math.PI * 6378137 / 2,
                e61 * n22 - 2 * Math.PI * 6378137 / 2
            ];
        }
        class qc {
            constructor(t86, e61, r31){
                this.z = t86, this.x = e61, this.y = r31, this.key = Xc(0, t86, t86, e61, r31);
            }
            equals(t) {
                return this.z === t.z && this.x === t.x && this.y === t.y;
            }
            url(t, e) {
                const r33 = function(t87, e62, r34) {
                    var n22 = Oc(256 * t87, 256 * (e62 = Math.pow(2, r34) - e62 - 1), r34), i16 = Oc(256 * (t87 + 1), 256 * (e62 + 1), r34);
                    return n22[0] + "," + n22[1] + "," + i16[0] + "," + i16[1];
                }(this.x, this.y, this.z), n22 = function(t87, e62, r34) {
                    let n23, i16 = "";
                    for(let s12 = t87; s12 > 0; s12--)n23 = 1 << s12 - 1, i16 += (e62 & n23 ? 1 : 0) + (r34 & n23 ? 2 : 0);
                    return i16;
                }(this.z, this.x, this.y);
                return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n22).replace("{bbox-epsg-3857}", r33);
            }
            toString() {
                return `${this.z}/${this.x}/${this.y}`;
            }
        }
        class Nc {
            constructor(t87, e62){
                this.wrap = t87, this.canonical = e62, this.key = Xc(t87, e62.z, e62.z, e62.x, e62.y);
            }
        }
        class Gc {
            constructor(t88, e63, r33, n22, i16){
                this.overscaledZ = t88, this.wrap = e63, this.canonical = new qc(r33, +n22, +i16), this.key = 0 === e63 && t88 === r33 ? this.canonical.key : Xc(e63, t88, r33, n22, i16);
            }
            equals(t) {
                return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
            }
            scaledTo(t) {
                const e64 = this.canonical.z - t;
                return t > this.canonical.z ? new Gc(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Gc(t, this.wrap, t, this.canonical.x >> e64, this.canonical.y >> e64);
            }
            calculateScaledKey(t, e = !0) {
                if (this.overscaledZ === t && e) return this.key;
                if (t > this.canonical.z) return Xc(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);
                {
                    const r34 = this.canonical.z - t;
                    return Xc(this.wrap * +e, t, t, this.canonical.x >> r34, this.canonical.y >> r34);
                }
            }
            isChildOf(t) {
                if (t.wrap !== this.wrap) return !1;
                const e64 = this.canonical.z - t.canonical.z;
                return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e64 && t.canonical.y === this.canonical.y >> e64;
            }
            children(t) {
                if (this.overscaledZ >= t) return [
                    new Gc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
                ];
                const e64 = this.canonical.z + 1, r34 = 2 * this.canonical.x, n23 = 2 * this.canonical.y;
                return [
                    new Gc(e64, this.wrap, e64, r34, n23),
                    new Gc(e64, this.wrap, e64, r34 + 1, n23),
                    new Gc(e64, this.wrap, e64, r34, n23 + 1),
                    new Gc(e64, this.wrap, e64, r34 + 1, n23 + 1)
                ];
            }
            isLessThan(t) {
                return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
            }
            wrapped() {
                return new Gc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t) {
                return new Gc(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
                return new Nc(this.wrap, this.canonical);
            }
            toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
        }
        function Xc(t89, e64, r34, n23, i17) {
            const s12 = 1 << Math.min(r34, 22);
            let a7 = s12 * (i17 % s12) + n23 % s12;
            return t89 && r34 < 22 && (a7 += s12 * s12 * ((t89 < 0 ? -2 * t89 - 1 : 2 * t89) % (1 << 2 * (22 - r34)))), 16 * (32 * a7 + r34) + (e64 - r34);
        }
        Oi(qc, "CanonicalTileID"), Oi(Gc, "OverscaledTileID", {
            omit: [
                "projMatrix"
            ]
        });
        class Zc extends d2 {
            constructor(t89, e64, r34){
                super(t89, e64), this.z = r34;
            }
        }
        function Kc(t90, e65) {
            return t90.x * e65.x + t90.y * e65.y;
        }
        function Yc(t90, e65) {
            if (1 === t90.length) {
                let r35 = 0;
                const n23 = e65[r35++];
                let i17;
                for(; !i17 || n23.equals(i17);)if (i17 = e65[r35++], !i17) return 1 / 0;
                for(; r35 < e65.length; r35++){
                    const s12 = e65[r35], a7 = t90[0], o9 = i17.sub(n23), l8 = s12.sub(n23), u7 = a7.sub(n23), c6 = Kc(o9, o9), h5 = Kc(o9, l8), p5 = Kc(l8, l8), f4 = Kc(u7, o9), d4 = Kc(u7, l8), y2 = c6 * p5 - h5 * h5, m2 = (p5 * f4 - h5 * d4) / y2, g2 = (c6 * d4 - h5 * f4) / y2, x2 = n23.z * (1 - m2 - g2) + i17.z * m2 + s12.z * g2;
                    if (isFinite(x2)) return x2;
                }
                return 1 / 0;
            }
            {
                let t91 = 1 / 0;
                for (const r35 of e65)t91 = Math.min(t91, r35.z);
                return t91;
            }
        }
        function Hc(t90, e65, r35, n23, i17, s12, a7, o9) {
            const l8 = a7 * i17.getElevationAt(t90, e65, !0, !0), u7 = 0 !== s12[0], c6 = u7 ? 0 === s12[1] ? a7 * (s12[0] / 7 - 450) : a7 * function(t91, e66, r36) {
                const n24 = Math.floor(e66[0] / 8), i18 = Math.floor(e66[1] / 8), s13 = 10 * (e66[0] - 8 * n24), a9 = 10 * (e66[1] - 8 * i18), o10 = t91.getElevationAt(n24, i18, !0, !0), l9 = t91.getMeterToDEM(r36), u8 = Math.floor(0.5 * (s13 * l9 - 1)), c7 = Math.floor(0.5 * (a9 * l9 - 1)), h5 = t91.tileCoordToPixel(n24, i18), p5 = 2 * u8 + 1, f4 = 2 * c7 + 1, d4 = function(t92, e67, r37, n25, i19) {
                    return [
                        t92.getElevationAtPixel(e67, r37, !0),
                        t92.getElevationAtPixel(e67 + i19, r37, !0),
                        t92.getElevationAtPixel(e67, r37 + i19, !0),
                        t92.getElevationAtPixel(e67 + n25, r37 + i19, !0)
                    ];
                }(t91, h5.x - u8, h5.y - c7, p5, f4), y2 = Math.abs(d4[0] - d4[1]), m2 = Math.abs(d4[2] - d4[3]), g2 = Math.abs(d4[0] - d4[2]) + Math.abs(d4[1] - d4[3]), x2 = Math.min(0.25, 0.5 * l9 * (y2 + m2) / p5), v2 = Math.min(0.25, 0.5 * l9 * g2 / f4);
                return o10 + Math.max(x2 * s13, v2 * a9);
            }(i17, s12, o9) : l8;
            return {
                base: l8 + (0 === r35) ? -1 : r35,
                top: u7 ? Math.max(c6 + n23, l8 + r35 + 2) : l8 + n23
            };
        }
        const Wc = na([
            {
                name: "a_pos_normal",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_data",
                components: 4,
                type: "Uint8"
            },
            {
                name: "a_linesofar",
                components: 1,
                type: "Float32"
            }
        ], 4), { members: Jc  } = Wc, Qc = na([
            {
                name: "a_packed",
                components: 4,
                type: "Float32"
            }
        ]), { members: th  } = Qc, eh = Sc.types, rh = Math.cos(Math.PI / 180 * 37.5);
        class nh {
            constructor(t90){
                this.zoom = t90.zoom, this.overscaling = t90.overscaling, this.layers = t90.layers, this.layerIds = this.layers.map((t91)=>t91.id
                ), this.index = t90.index, this.projection = t90.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {
                }, this.layers.forEach((t91)=>{
                    this.gradients[t91.id] = {
                    };
                }), this.layoutVertexArray = new la, this.layoutVertexArray2 = new ua, this.indexArray = new wa, this.programConfigurations = new po(t90.layers, t90.zoom), this.segments = new Ao, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t91)=>t91.isStateDependent()
                ).map((t91)=>t91.id
                );
            }
            populate(t, e, r, n) {
                this.hasPattern = rc("line", this.layers, e);
                const i17 = this.layers[0].layout.get("line-sort-key"), s12 = [];
                for (const { feature: e65 , id: a7 , index: o9 , sourceLayerIndex: l8  } of t){
                    const t91 = this.layers[0]._featureFilter.needGeometry, u7 = Zo(e65, t91);
                    if (!this.layers[0]._featureFilter.filter(new Us(this.zoom), u7, r)) continue;
                    const c6 = i17 ? i17.evaluate(u7, {
                    }, r) : void 0, h5 = {
                        id: a7,
                        properties: e65.properties,
                        type: e65.type,
                        sourceLayerIndex: l8,
                        index: o9,
                        geometry: t91 ? u7.geometry : Xo(e65, r, n),
                        patterns: {
                        },
                        sortKey: c6
                    };
                    s12.push(h5);
                }
                i17 && s12.sort((t91, e66)=>t91.sortKey - e66.sortKey
                );
                const { lineAtlas: a9 , featureIndex: o10  } = e, l9 = this.addConstantDashes(a9);
                for (const n23 of s12){
                    const { geometry: i18 , index: s13 , sourceLayerIndex: u7  } = n23;
                    if (l9 && this.addFeatureDashes(n23, a9), this.hasPattern) {
                        const t91 = nc("line", this.layers, n23, this.zoom, e);
                        this.patternFeatures.push(t91);
                    } else this.addFeature(n23, i18, s13, r, a9.positions, e.availableImages);
                    o10.insert(t[s13].feature, i18, s13, u7, this.index);
                }
            }
            addConstantDashes(t) {
                let e65 = !1;
                for (const r35 of this.layers){
                    const n23 = r35.paint.get("line-dasharray").value, i17 = r35.layout.get("line-cap").value;
                    if ("constant" !== n23.kind || "constant" !== i17.kind) e65 = !0;
                    else {
                        const e66 = i17.value, r36 = n23.value;
                        if (!r36) continue;
                        t.addDash(r36, e66);
                    }
                }
                return e65;
            }
            addFeatureDashes(t, e) {
                const r35 = this.zoom;
                for (const n23 of this.layers){
                    const i17 = n23.paint.get("line-dasharray").value, s12 = n23.layout.get("line-cap").value;
                    if ("constant" === i17.kind && "constant" === s12.kind) continue;
                    let a7, o9;
                    if ("constant" === i17.kind) {
                        if (a7 = i17.value, !a7) continue;
                    } else a7 = i17.evaluate({
                        zoom: r35
                    }, t);
                    o9 = "constant" === s12.kind ? s12.value : s12.evaluate({
                        zoom: r35
                    }, t), e.addDash(a7, o9), t.patterns[n23.id] = e.getKey(a7, o9);
                }
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
            }
            addFeatures(t, e, r, n, i) {
                for (const t91 of this.patternFeatures)this.addFeature(t91, t91.geometry, t91.index, e, r, n);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, th)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Jc), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t) {
                if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end")) return {
                    start: +t.properties.mapbox_clip_start,
                    end: +t.properties.mapbox_clip_end
                };
            }
            addFeature(t, e, r, n, i, s) {
                const a7 = this.layers[0].layout, o9 = a7.get("line-join").evaluate(t, {
                }), l8 = a7.get("line-cap").evaluate(t, {
                }), u7 = a7.get("line-miter-limit"), c6 = a7.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t);
                for (const r35 of e)this.addLine(r35, t, o9, l8, u7, c6);
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
            }
            addLine(t, e, r, n, i, s) {
                if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
                    this.lineClipsArray.push(this.lineClips);
                    for(let e65 = 0; e65 < t.length - 1; e65++)this.totalDistance += t[e65].dist(t[e65 + 1]);
                    this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                }
                const a7 = "Polygon" === eh[e.type];
                let o9 = t.length;
                for(; o9 >= 2 && t[o9 - 1].equals(t[o9 - 2]);)o9--;
                let l8 = 0;
                for(; l8 < o9 - 1 && t[l8].equals(t[l8 + 1]);)l8++;
                if (o9 < (a7 ? 3 : 2)) return;
                "bevel" === r && (i = 1.05);
                const u7 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c6 = this.segments.prepareSegment(10 * o9, this.layoutVertexArray, this.indexArray);
                let h5, p5, f4, d4, y2;
                this.e1 = this.e2 = -1, a7 && (h5 = t[o9 - 2], y2 = t[l8].sub(h5)._unit()._perp());
                for(let e65 = l8; e65 < o9; e65++){
                    if (f4 = e65 === o9 - 1 ? a7 ? t[l8 + 1] : void 0 : t[e65 + 1], f4 && t[e65].equals(f4)) continue;
                    y2 && (d4 = y2), h5 && (p5 = h5), h5 = t[e65], y2 = f4 ? f4.sub(h5)._unit()._perp() : d4, d4 = d4 || y2;
                    let m2 = d4.add(y2);
                    0 === m2.x && 0 === m2.y || m2._unit();
                    const g2 = d4.x * y2.x + d4.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < rh && p5 && f4, _2 = d4.x * y2.y - d4.y * y2.x > 0;
                    if (w2 && e65 > l8) {
                        const t91 = h5.dist(p5);
                        if (t91 > 2 * u7) {
                            const e66 = h5.sub(h5.sub(p5)._mult(u7 / t91)._round());
                            this.updateDistance(p5, e66), this.addCurrentVertex(e66, d4, 0, 0, c6), p5 = e66;
                        }
                    }
                    const A2 = p5 && f4;
                    let S2 = A2 ? r : a7 ? "butt" : n;
                    if (A2 && "round" === S2 && (v2 < s ? S2 = "miter" : v2 <= 2 && (S2 = "fakeround")), "miter" === S2 && v2 > i && (S2 = "bevel"), "bevel" === S2 && (v2 > 2 && (S2 = "flipbevel"), v2 < i && (S2 = "miter")), p5 && this.updateDistance(p5, h5), "miter" === S2) m2._mult(v2), this.addCurrentVertex(h5, m2, 0, 0, c6);
                    else if ("flipbevel" === S2) {
                        if (v2 > 100) m2 = y2.mult(-1);
                        else {
                            const t91 = v2 * d4.add(y2).mag() / d4.sub(y2).mag();
                            m2._perp()._mult(t91 * (_2 ? -1 : 1));
                        }
                        this.addCurrentVertex(h5, m2, 0, 0, c6), this.addCurrentVertex(h5, m2.mult(-1), 0, 0, c6);
                    } else if ("bevel" === S2 || "fakeround" === S2) {
                        const t91 = -Math.sqrt(v2 * v2 - 1), e66 = _2 ? t91 : 0, r35 = _2 ? 0 : t91;
                        if (p5 && this.addCurrentVertex(h5, d4, e66, r35, c6), "fakeround" === S2) {
                            const t92 = Math.round(180 * b2 / Math.PI / 20);
                            for(let e67 = 1; e67 < t92; e67++){
                                let r36 = e67 / t92;
                                if (0.5 !== r36) {
                                    const t93 = r36 - 0.5;
                                    r36 += r36 * t93 * (r36 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t93 * t93 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                                }
                                const n23 = y2.sub(d4)._mult(r36)._add(d4)._unit()._mult(_2 ? -1 : 1);
                                this.addHalfVertex(h5, n23.x, n23.y, !1, _2, 0, c6);
                            }
                        }
                        f4 && this.addCurrentVertex(h5, y2, -e66, -r35, c6);
                    } else if ("butt" === S2) this.addCurrentVertex(h5, m2, 0, 0, c6);
                    else if ("square" === S2) {
                        const t91 = p5 ? 1 : -1;
                        p5 || this.addCurrentVertex(h5, m2, t91, t91, c6), this.addCurrentVertex(h5, m2, 0, 0, c6), p5 && this.addCurrentVertex(h5, m2, t91, t91, c6);
                    } else "round" === S2 && (p5 && (this.addCurrentVertex(h5, d4, 0, 0, c6), this.addCurrentVertex(h5, d4, 1, 1, c6, !0)), f4 && (this.addCurrentVertex(h5, y2, -1, -1, c6, !0), this.addCurrentVertex(h5, y2, 0, 0, c6)));
                    if (w2 && e65 < o9 - 1) {
                        const t91 = h5.dist(f4);
                        if (t91 > 2 * u7) {
                            const e66 = h5.add(f4.sub(h5)._mult(u7 / t91)._round());
                            this.updateDistance(h5, e66), this.addCurrentVertex(e66, y2, 0, 0, c6), h5 = e66;
                        }
                    }
                }
            }
            addCurrentVertex(t, e, r, n, i, s = !1) {
                const a7 = e.y * n - e.x, o9 = -e.y - e.x * n;
                this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, s, !1, r, i), this.addHalfVertex(t, a7, o9, s, !0, -n, i);
            }
            addHalfVertex({ x: t , y: e  }, r, n, i, s, a, o) {
                this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
                const l8 = o.vertexLength++;
                this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l8), o.primitiveLength++), s ? this.e2 = l8 : this.e1 = l8;
            }
            updateScaledDistance() {
                if (this.lineClips) {
                    const t91 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                    this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t91 * this.lineClips.start + this.distance;
                } else this.lineSoFar = this.distance;
            }
            updateDistance(t, e) {
                this.distance += t.dist(e), this.updateScaledDistance();
            }
        }
        Oi(nh, "LineBucket", {
            omit: [
                "layers",
                "patternFeatures"
            ]
        });
        const ih = new Js({
            "line-cap": new Hs(Ht.layout_line["line-cap"]),
            "line-join": new Hs(Ht.layout_line["line-join"]),
            "line-miter-limit": new Ys(Ht.layout_line["line-miter-limit"]),
            "line-round-limit": new Ys(Ht.layout_line["line-round-limit"]),
            "line-sort-key": new Hs(Ht.layout_line["line-sort-key"])
        });
        var sh = {
            paint: new Js({
                "line-opacity": new Hs(Ht.paint_line["line-opacity"]),
                "line-color": new Hs(Ht.paint_line["line-color"]),
                "line-translate": new Ys(Ht.paint_line["line-translate"]),
                "line-translate-anchor": new Ys(Ht.paint_line["line-translate-anchor"]),
                "line-width": new Hs(Ht.paint_line["line-width"]),
                "line-gap-width": new Hs(Ht.paint_line["line-gap-width"]),
                "line-offset": new Hs(Ht.paint_line["line-offset"]),
                "line-blur": new Hs(Ht.paint_line["line-blur"]),
                "line-dasharray": new Hs(Ht.paint_line["line-dasharray"]),
                "line-pattern": new Hs(Ht.paint_line["line-pattern"]),
                "line-gradient": new Ws(Ht.paint_line["line-gradient"]),
                "line-trim-offset": new Ys(Ht.paint_line["line-trim-offset"])
            }),
            layout: ih
        };
        const ah = new class extends Hs {
            possiblyEvaluate(t, e) {
                return e = new Us(Math.floor(e.zoom), {
                    now: e.now,
                    fadeDuration: e.fadeDuration,
                    transition: e.transition
                }), super.possiblyEvaluate(t, e);
            }
            evaluate(t, e, r, n) {
                return e = z1({
                }, e, {
                    zoom: Math.floor(e.zoom)
                }), super.evaluate(t, e, r, n);
            }
        }(sh.paint.properties["line-width"].specification);
        function oh(t91, e65) {
            return e65 > 0 ? e65 + 2 * t91 : t91;
        }
        ah.useIntegerZoom = !0;
        const lh = na([
            {
                name: "a_pos_offset",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_tex_size",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixeloffset",
                components: 4,
                type: "Int16"
            }
        ], 4), uh = na([
            {
                name: "a_globe_anchor",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_globe_normal",
                components: 3,
                type: "Float32"
            }
        ], 4), ch = na([
            {
                name: "a_projected_pos",
                components: 4,
                type: "Float32"
            }
        ], 4);
        na([
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint32"
            }
        ], 4);
        const hh = na([
            {
                name: "a_placed",
                components: 2,
                type: "Uint8"
            },
            {
                name: "a_shift",
                components: 2,
                type: "Float32"
            }
        ]), ph = na([
            {
                name: "a_size_scale",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_padding",
                components: 2,
                type: "Float32"
            }
        ]);
        na([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "tileAnchorX"
            },
            {
                type: "Int16",
                name: "tileAnchorY"
            },
            {
                type: "Float32",
                name: "x1"
            },
            {
                type: "Float32",
                name: "y1"
            },
            {
                type: "Float32",
                name: "x2"
            },
            {
                type: "Float32",
                name: "y2"
            },
            {
                type: "Int16",
                name: "padding"
            },
            {
                type: "Uint32",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "sourceLayerIndex"
            },
            {
                type: "Uint16",
                name: "bucketIndex"
            }
        ]);
        const fh = na([
            {
                name: "a_pos",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_anchor_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_extrude",
                components: 2,
                type: "Int16"
            }
        ], 4), dh = na([
            {
                name: "a_pos_2f",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_radius",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_flags",
                components: 2,
                type: "Int16"
            }
        ], 4);
        na([
            {
                name: "triangle",
                components: 3,
                type: "Uint16"
            }
        ]), na([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Uint16",
                name: "glyphStartIndex"
            },
            {
                type: "Uint16",
                name: "numGlyphs"
            },
            {
                type: "Uint32",
                name: "vertexStartIndex"
            },
            {
                type: "Uint32",
                name: "lineStartIndex"
            },
            {
                type: "Uint32",
                name: "lineLength"
            },
            {
                type: "Uint16",
                name: "segment"
            },
            {
                type: "Uint16",
                name: "lowerSize"
            },
            {
                type: "Uint16",
                name: "upperSize"
            },
            {
                type: "Float32",
                name: "lineOffsetX"
            },
            {
                type: "Float32",
                name: "lineOffsetY"
            },
            {
                type: "Uint8",
                name: "writingMode"
            },
            {
                type: "Uint8",
                name: "placedOrientation"
            },
            {
                type: "Uint8",
                name: "hidden"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Int16",
                name: "associatedIconIndex"
            },
            {
                type: "Uint8",
                name: "flipState"
            }
        ]), na([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "centerJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "placedIconSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedIconSymbolIndex"
            },
            {
                type: "Uint16",
                name: "key"
            },
            {
                type: "Uint16",
                name: "textBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "textBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "numHorizontalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numIconVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalIconVertices"
            },
            {
                type: "Uint16",
                name: "useRuntimeCollisionCircles"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Float32",
                components: 2,
                name: "textOffset"
            },
            {
                type: "Float32",
                name: "collisionCircleDiameter"
            }
        ]), na([
            {
                type: "Float32",
                name: "offsetX"
            }
        ]), na([
            {
                type: "Int16",
                name: "x"
            },
            {
                type: "Int16",
                name: "y"
            }
        ]);
        var yh = 24;
        const mh = 128;
        function gh(t91, e65) {
            const { expression: r35  } = e65;
            if ("constant" === r35.kind) return {
                kind: "constant",
                layoutSize: r35.evaluate(new Us(t91 + 1))
            };
            if ("source" === r35.kind) return {
                kind: "source"
            };
            {
                const { zoomStops: e66 , interpolationType: n23  } = r35;
                let i17 = 0;
                for(; i17 < e66.length && e66[i17] <= t91;)i17++;
                i17 = Math.max(0, i17 - 1);
                let s12 = i17;
                for(; s12 < e66.length && e66[s12] < t91 + 1;)s12++;
                s12 = Math.min(e66.length - 1, s12);
                const a7 = e66[i17], o9 = e66[s12];
                return "composite" === r35.kind ? {
                    kind: "composite",
                    minZoom: a7,
                    maxZoom: o9,
                    interpolationType: n23
                } : {
                    kind: "camera",
                    minZoom: a7,
                    maxZoom: o9,
                    minSize: r35.evaluate(new Us(a7)),
                    maxSize: r35.evaluate(new Us(o9)),
                    interpolationType: n23
                };
            }
        }
        function xh(t91, { uSize: e65 , uSizeT: r35  }, { lowerSize: n23 , upperSize: i17  }) {
            return "source" === t91.kind ? n23 / mh : "composite" === t91.kind ? Mr(n23 / mh, i17 / mh, r35) : e65;
        }
        function vh(t91, e65) {
            let r35 = 0, n23 = 0;
            if ("constant" === t91.kind) n23 = t91.layoutSize;
            else if ("source" !== t91.kind) {
                const { interpolationType: i17 , minZoom: s12 , maxZoom: a7  } = t91, o9 = i17 ? S1(Kr.interpolationFactor(i17, e65, s12, a7), 0, 1) : 0;
                "camera" === t91.kind ? n23 = Mr(t91.minSize, t91.maxSize, o9) : r35 = o9;
            }
            return {
                uSizeT: r35,
                uSize: n23
            };
        }
        var bh = Object.freeze({
            __proto__: null,
            getSizeData: gh,
            evaluateSizeForFeature: xh,
            evaluateSizeForZoom: vh,
            SIZE_PACK_FACTOR: mh
        });
        function wh(t91, e65, r35) {
            return t91.sections.forEach((t92)=>{
                t92.text = (function(t93, e66, r36) {
                    const n23 = e66.layout.get("text-transform").evaluate(r36, {
                    });
                    return "uppercase" === n23 ? t93 = t93.toLocaleUpperCase() : "lowercase" === n23 && (t93 = t93.toLocaleLowerCase()), js.applyArabicShaping && (t93 = js.applyArabicShaping(t93)), t93;
                })(t92.text, e65, r35);
            }), t91;
        }
        const _h = {
            "!": "︕",
            "#": "＃",
            $: "＄",
            "%": "％",
            "&": "＆",
            "(": "︵",
            ")": "︶",
            "*": "＊",
            "+": "＋",
            ",": "︐",
            "-": "︲",
            ".": "・",
            "/": "／",
            ":": "︓",
            ";": "︔",
            "<": "︿",
            "=": "＝",
            ">": "﹀",
            "?": "︖",
            "@": "＠",
            "[": "﹇",
            "\\": "＼",
            "]": "﹈",
            "^": "＾",
            _: "︳",
            "`": "｀",
            "{": "︷",
            "|": "―",
            "}": "︸",
            "~": "～",
            "¢": "￠",
            "£": "￡",
            "¥": "￥",
            "¦": "￤",
            "¬": "￢",
            "¯": "￣",
            "–": "︲",
            "—": "︱",
            "‘": "﹃",
            "’": "﹄",
            "“": "﹁",
            "”": "﹂",
            "…": "︙",
            "‧": "・",
            "₩": "￦",
            "、": "︑",
            "。": "︒",
            "〈": "︿",
            "〉": "﹀",
            "《": "︽",
            "》": "︾",
            "「": "﹁",
            "」": "﹂",
            "『": "﹃",
            "』": "﹄",
            "【": "︻",
            "】": "︼",
            "〔": "︹",
            "〕": "︺",
            "〖": "︗",
            "〗": "︘",
            "！": "︕",
            "（": "︵",
            "）": "︶",
            "，": "︐",
            "－": "︲",
            "．": "・",
            "：": "︓",
            "；": "︔",
            "＜": "︿",
            "＞": "﹀",
            "？": "︖",
            "［": "﹇",
            "］": "﹈",
            "＿": "︳",
            "｛": "︷",
            "｜": "―",
            "｝": "︸",
            "｟": "︵",
            "｠": "︶",
            "｡": "︒",
            "｢": "﹁",
            "｣": "﹂"
        };
        function Ah(t91) {
            return "︶" === t91 || "﹈" === t91 || "︸" === t91 || "﹄" === t91 || "﹂" === t91 || "︾" === t91 || "︼" === t91 || "︺" === t91 || "︘" === t91 || "﹀" === t91 || "︐" === t91 || "︓" === t91 || "︔" === t91 || "｀" === t91 || "￣" === t91 || "︑" === t91 || "︒" === t91;
        }
        function Sh(t91) {
            return "︵" === t91 || "﹇" === t91 || "︷" === t91 || "﹃" === t91 || "﹁" === t91 || "︽" === t91 || "︻" === t91 || "︹" === t91 || "︗" === t91 || "︿" === t91;
        }
        var kh = Th, Ih = function(t91, e65, r35, n23, i17) {
            var s12, a7, o9 = 8 * i17 - n23 - 1, l8 = (1 << o9) - 1, u7 = l8 >> 1, c6 = -7, h5 = r35 ? i17 - 1 : 0, p5 = r35 ? -1 : 1, f4 = t91[e65 + h5];
            for(h5 += p5, s12 = f4 & (1 << -c6) - 1, f4 >>= -c6, c6 += o9; c6 > 0; s12 = 256 * s12 + t91[e65 + h5], h5 += p5, c6 -= 8);
            for(a7 = s12 & (1 << -c6) - 1, s12 >>= -c6, c6 += n23; c6 > 0; a7 = 256 * a7 + t91[e65 + h5], h5 += p5, c6 -= 8);
            if (0 === s12) s12 = 1 - u7;
            else {
                if (s12 === l8) return a7 ? NaN : 1 / 0 * (f4 ? -1 : 1);
                a7 += Math.pow(2, n23), s12 -= u7;
            }
            return (f4 ? -1 : 1) * a7 * Math.pow(2, s12 - n23);
        }, Mh = function(t91, e65, r35, n23, i17, s12) {
            var a7, o9, l8, u7 = 8 * s12 - i17 - 1, c6 = (1 << u7) - 1, h5 = c6 >> 1, p5 = 23 === i17 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f4 = n23 ? 0 : s12 - 1, d4 = n23 ? 1 : -1, y2 = e65 < 0 || 0 === e65 && 1 / e65 < 0 ? 1 : 0;
            for(e65 = Math.abs(e65), isNaN(e65) || e65 === 1 / 0 ? (o9 = isNaN(e65) ? 1 : 0, a7 = c6) : (a7 = Math.floor(Math.log(e65) / Math.LN2), e65 * (l8 = Math.pow(2, -a7)) < 1 && (a7--, l8 *= 2), (e65 += a7 + h5 >= 1 ? p5 / l8 : p5 * Math.pow(2, 1 - h5)) * l8 >= 2 && (a7++, l8 /= 2), a7 + h5 >= c6 ? (o9 = 0, a7 = c6) : a7 + h5 >= 1 ? (o9 = (e65 * l8 - 1) * Math.pow(2, i17), a7 += h5) : (o9 = e65 * Math.pow(2, h5 - 1) * Math.pow(2, i17), a7 = 0)); i17 >= 8; t91[r35 + f4] = 255 & o9, f4 += d4, o9 /= 256, i17 -= 8);
            for(a7 = a7 << i17 | o9, u7 += i17; u7 > 0; t91[r35 + f4] = 255 & a7, f4 += d4, a7 /= 256, u7 -= 8);
            t91[r35 + f4 - d4] |= 128 * y2;
        };
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ function Th(t91) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t91) ? t91 : new Uint8Array(t91 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        Th.Varint = 0, Th.Fixed64 = 1, Th.Bytes = 2, Th.Fixed32 = 5;
        var zh = 4294967296, Bh = 1 / zh, Eh = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function Ch(t91) {
            return t91.type === Th.Bytes ? t91.readVarint() + t91.pos : t91.pos + 1;
        }
        function Ph(t91, e65, r35) {
            return r35 ? 4294967296 * e65 + (t91 >>> 0) : 4294967296 * (e65 >>> 0) + (t91 >>> 0);
        }
        function Dh(t91, e65, r35) {
            var n23 = e65 <= 16383 ? 1 : e65 <= 2097151 ? 2 : e65 <= 268435455 ? 3 : Math.floor(Math.log(e65) / (7 * Math.LN2));
            r35.realloc(n23);
            for(var i17 = r35.pos - 1; i17 >= t91; i17--)r35.buf[i17 + n23] = r35.buf[i17];
        }
        function Vh(t91, e65) {
            for(var r35 = 0; r35 < t91.length; r35++)e65.writeVarint(t91[r35]);
        }
        function Lh(t91, e65) {
            for(var r35 = 0; r35 < t91.length; r35++)e65.writeSVarint(t91[r35]);
        }
        function Fh(t91, e65) {
            for(var r35 = 0; r35 < t91.length; r35++)e65.writeFloat(t91[r35]);
        }
        function Rh(t91, e65) {
            for(var r35 = 0; r35 < t91.length; r35++)e65.writeDouble(t91[r35]);
        }
        function jh(t91, e65) {
            for(var r35 = 0; r35 < t91.length; r35++)e65.writeBoolean(t91[r35]);
        }
        function Uh(t91, e65) {
            for(var r35 = 0; r35 < t91.length; r35++)e65.writeFixed32(t91[r35]);
        }
        function $h(t91, e65) {
            for(var r35 = 0; r35 < t91.length; r35++)e65.writeSFixed32(t91[r35]);
        }
        function Oh(t91, e65) {
            for(var r35 = 0; r35 < t91.length; r35++)e65.writeFixed64(t91[r35]);
        }
        function qh(t91, e65) {
            for(var r35 = 0; r35 < t91.length; r35++)e65.writeSFixed64(t91[r35]);
        }
        function Nh(t91, e65) {
            return (t91[e65] | t91[e65 + 1] << 8 | t91[e65 + 2] << 16) + 16777216 * t91[e65 + 3];
        }
        function Gh(t91, e65, r35) {
            t91[r35] = e65, t91[r35 + 1] = e65 >>> 8, t91[r35 + 2] = e65 >>> 16, t91[r35 + 3] = e65 >>> 24;
        }
        function Xh(t91, e65) {
            return (t91[e65] | t91[e65 + 1] << 8 | t91[e65 + 2] << 16) + (t91[e65 + 3] << 24);
        }
        function Zh(t91, e65, r35) {
            e65.glyphs = [], 1 === t91 && r35.readMessage(Kh, e65);
        }
        function Kh(t91, e65, r35) {
            if (3 === t91) {
                const { id: t92 , bitmap: n23 , width: i17 , height: s12 , left: a7 , top: o9 , advance: l8  } = r35.readMessage(Yh, {
                });
                e65.glyphs.push({
                    id: t92,
                    bitmap: new mu({
                        width: i17 + 6,
                        height: s12 + 6
                    }, n23),
                    metrics: {
                        width: i17,
                        height: s12,
                        left: a7,
                        top: o9,
                        advance: l8
                    }
                });
            } else 4 === t91 ? e65.ascender = r35.readSVarint() : 5 === t91 && (e65.descender = r35.readSVarint());
        }
        function Yh(t91, e65, r35) {
            1 === t91 ? e65.id = r35.readVarint() : 2 === t91 ? e65.bitmap = r35.readBytes() : 3 === t91 ? e65.width = r35.readVarint() : 4 === t91 ? e65.height = r35.readVarint() : 5 === t91 ? e65.left = r35.readSVarint() : 6 === t91 ? e65.top = r35.readSVarint() : 7 === t91 && (e65.advance = r35.readVarint());
        }
        function Hh(t91) {
            let e65 = 0, r35 = 0;
            for (const n23 of t91)e65 += n23.w * n23.h, r35 = Math.max(r35, n23.w);
            t91.sort((t92, e66)=>e66.h - t92.h
            );
            const n24 = [
                {
                    x: 0,
                    y: 0,
                    w: Math.max(Math.ceil(Math.sqrt(e65 / 0.95)), r35),
                    h: 1 / 0
                }
            ];
            let i17 = 0, s12 = 0;
            for (const e66 of t91)for(let t92 = n24.length - 1; t92 >= 0; t92--){
                const r36 = n24[t92];
                if (!(e66.w > r36.w || e66.h > r36.h)) {
                    if (e66.x = r36.x, e66.y = r36.y, s12 = Math.max(s12, e66.y + e66.h), i17 = Math.max(i17, e66.x + e66.w), e66.w === r36.w && e66.h === r36.h) {
                        const e67 = n24.pop();
                        t92 < n24.length && (n24[t92] = e67);
                    } else e66.h === r36.h ? (r36.x += e66.w, r36.w -= e66.w) : e66.w === r36.w ? (r36.y += e66.h, r36.h -= e66.h) : (n24.push({
                        x: r36.x + e66.w,
                        y: r36.y,
                        w: r36.w - e66.w,
                        h: e66.h
                    }), r36.y += e66.h, r36.h -= e66.h);
                    break;
                }
            }
            return {
                w: i17,
                h: s12,
                fill: e65 / (i17 * s12) || 0
            };
        }
        Th.prototype = {
            destroy: function() {
                this.buf = null;
            },
            readFields: function(t91, e65, r35) {
                for(r35 = r35 || this.length; this.pos < r35;){
                    var n23 = this.readVarint(), i17 = n23 >> 3, s12 = this.pos;
                    this.type = 7 & n23, t91(i17, e65, this), this.pos === s12 && this.skip(n23);
                }
                return e65;
            },
            readMessage: function(t91, e65) {
                return this.readFields(t91, e65, this.readVarint() + this.pos);
            },
            readFixed32: function() {
                var t91 = Nh(this.buf, this.pos);
                return this.pos += 4, t91;
            },
            readSFixed32: function() {
                var t91 = Xh(this.buf, this.pos);
                return this.pos += 4, t91;
            },
            readFixed64: function() {
                var t91 = Nh(this.buf, this.pos) + Nh(this.buf, this.pos + 4) * zh;
                return this.pos += 8, t91;
            },
            readSFixed64: function() {
                var t91 = Nh(this.buf, this.pos) + Xh(this.buf, this.pos + 4) * zh;
                return this.pos += 8, t91;
            },
            readFloat: function() {
                var t91 = Ih(this.buf, this.pos, !0, 23, 4);
                return this.pos += 4, t91;
            },
            readDouble: function() {
                var t91 = Ih(this.buf, this.pos, !0, 52, 8);
                return this.pos += 8, t91;
            },
            readVarint: function(t91) {
                var e65, r35, n24 = this.buf;
                return e65 = 127 & (r35 = n24[this.pos++]), r35 < 128 ? e65 : (e65 |= (127 & (r35 = n24[this.pos++])) << 7, r35 < 128 ? e65 : (e65 |= (127 & (r35 = n24[this.pos++])) << 14, r35 < 128 ? e65 : (e65 |= (127 & (r35 = n24[this.pos++])) << 21, r35 < 128 ? e65 : (function(t92, e66, r36) {
                    var n25, i18, s13 = r36.buf;
                    if (n25 = (112 & (i18 = s13[r36.pos++])) >> 4, i18 < 128) return Ph(t92, n25, e66);
                    if (n25 |= (127 & (i18 = s13[r36.pos++])) << 3, i18 < 128) return Ph(t92, n25, e66);
                    if (n25 |= (127 & (i18 = s13[r36.pos++])) << 10, i18 < 128) return Ph(t92, n25, e66);
                    if (n25 |= (127 & (i18 = s13[r36.pos++])) << 17, i18 < 128) return Ph(t92, n25, e66);
                    if (n25 |= (127 & (i18 = s13[r36.pos++])) << 24, i18 < 128) return Ph(t92, n25, e66);
                    if (n25 |= (1 & (i18 = s13[r36.pos++])) << 31, i18 < 128) return Ph(t92, n25, e66);
                    throw new Error("Expected varint not more than 10 bytes");
                })(e65 |= (15 & (r35 = n24[this.pos])) << 28, t91, this))));
            },
            readVarint64: function() {
                return this.readVarint(!0);
            },
            readSVarint: function() {
                var t91 = this.readVarint();
                return t91 % 2 == 1 ? (t91 + 1) / -2 : t91 / 2;
            },
            readBoolean: function() {
                return Boolean(this.readVarint());
            },
            readString: function() {
                var t91 = this.readVarint() + this.pos, e65 = this.pos;
                return this.pos = t91, t91 - e65 >= 12 && Eh ? (function(t92, e66, r35) {
                    return Eh.decode(t92.subarray(e66, r35));
                })(this.buf, e65, t91) : (function(t92, e66, r35) {
                    for(var n24 = "", i18 = e66; i18 < r35;){
                        var s13, a7, o9, l8 = t92[i18], u7 = null, c6 = l8 > 239 ? 4 : l8 > 223 ? 3 : l8 > 191 ? 2 : 1;
                        if (i18 + c6 > r35) break;
                        1 === c6 ? l8 < 128 && (u7 = l8) : 2 === c6 ? 128 == (192 & (s13 = t92[i18 + 1])) && (u7 = (31 & l8) << 6 | 63 & s13) <= 127 && (u7 = null) : 3 === c6 ? (a7 = t92[i18 + 2], 128 == (192 & (s13 = t92[i18 + 1])) && 128 == (192 & a7) && ((u7 = (15 & l8) << 12 | (63 & s13) << 6 | 63 & a7) <= 2047 || u7 >= 55296 && u7 <= 57343) && (u7 = null)) : 4 === c6 && (a7 = t92[i18 + 2], o9 = t92[i18 + 3], 128 == (192 & (s13 = t92[i18 + 1])) && 128 == (192 & a7) && 128 == (192 & o9) && ((u7 = (15 & l8) << 18 | (63 & s13) << 12 | (63 & a7) << 6 | 63 & o9) <= 65535 || u7 >= 1114112) && (u7 = null)), null === u7 ? (u7 = 65533, c6 = 1) : u7 > 65535 && (u7 -= 65536, n24 += String.fromCharCode(u7 >>> 10 & 1023 | 55296), u7 = 56320 | 1023 & u7), n24 += String.fromCharCode(u7), i18 += c6;
                    }
                    return n24;
                })(this.buf, e65, t91);
            },
            readBytes: function() {
                var t91 = this.readVarint() + this.pos, e65 = this.buf.subarray(this.pos, t91);
                return this.pos = t91, e65;
            },
            readPackedVarint: function(t91, e65) {
                if (this.type !== Th.Bytes) return t91.push(this.readVarint(e65));
                var r35 = Ch(this);
                for(t91 = t91 || []; this.pos < r35;)t91.push(this.readVarint(e65));
                return t91;
            },
            readPackedSVarint: function(t91) {
                if (this.type !== Th.Bytes) return t91.push(this.readSVarint());
                var e65 = Ch(this);
                for(t91 = t91 || []; this.pos < e65;)t91.push(this.readSVarint());
                return t91;
            },
            readPackedBoolean: function(t91) {
                if (this.type !== Th.Bytes) return t91.push(this.readBoolean());
                var e65 = Ch(this);
                for(t91 = t91 || []; this.pos < e65;)t91.push(this.readBoolean());
                return t91;
            },
            readPackedFloat: function(t91) {
                if (this.type !== Th.Bytes) return t91.push(this.readFloat());
                var e65 = Ch(this);
                for(t91 = t91 || []; this.pos < e65;)t91.push(this.readFloat());
                return t91;
            },
            readPackedDouble: function(t91) {
                if (this.type !== Th.Bytes) return t91.push(this.readDouble());
                var e65 = Ch(this);
                for(t91 = t91 || []; this.pos < e65;)t91.push(this.readDouble());
                return t91;
            },
            readPackedFixed32: function(t91) {
                if (this.type !== Th.Bytes) return t91.push(this.readFixed32());
                var e65 = Ch(this);
                for(t91 = t91 || []; this.pos < e65;)t91.push(this.readFixed32());
                return t91;
            },
            readPackedSFixed32: function(t91) {
                if (this.type !== Th.Bytes) return t91.push(this.readSFixed32());
                var e65 = Ch(this);
                for(t91 = t91 || []; this.pos < e65;)t91.push(this.readSFixed32());
                return t91;
            },
            readPackedFixed64: function(t91) {
                if (this.type !== Th.Bytes) return t91.push(this.readFixed64());
                var e65 = Ch(this);
                for(t91 = t91 || []; this.pos < e65;)t91.push(this.readFixed64());
                return t91;
            },
            readPackedSFixed64: function(t91) {
                if (this.type !== Th.Bytes) return t91.push(this.readSFixed64());
                var e65 = Ch(this);
                for(t91 = t91 || []; this.pos < e65;)t91.push(this.readSFixed64());
                return t91;
            },
            skip: function(t91) {
                var e65 = 7 & t91;
                if (e65 === Th.Varint) for(; this.buf[this.pos++] > 127;);
                else if (e65 === Th.Bytes) this.pos = this.readVarint() + this.pos;
                else if (e65 === Th.Fixed32) this.pos += 4;
                else {
                    if (e65 !== Th.Fixed64) throw new Error("Unimplemented type: " + e65);
                    this.pos += 8;
                }
            },
            writeTag: function(t91, e65) {
                this.writeVarint(t91 << 3 | e65);
            },
            realloc: function(t91) {
                for(var e65 = this.length || 16; e65 < this.pos + t91;)e65 *= 2;
                if (e65 !== this.length) {
                    var r35 = new Uint8Array(e65);
                    r35.set(this.buf), this.buf = r35, this.length = e65;
                }
            },
            finish: function() {
                return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            },
            writeFixed32: function(t91) {
                this.realloc(4), Gh(this.buf, t91, this.pos), this.pos += 4;
            },
            writeSFixed32: function(t91) {
                this.realloc(4), Gh(this.buf, t91, this.pos), this.pos += 4;
            },
            writeFixed64: function(t91) {
                this.realloc(8), Gh(this.buf, -1 & t91, this.pos), Gh(this.buf, Math.floor(t91 * Bh), this.pos + 4), this.pos += 8;
            },
            writeSFixed64: function(t91) {
                this.realloc(8), Gh(this.buf, -1 & t91, this.pos), Gh(this.buf, Math.floor(t91 * Bh), this.pos + 4), this.pos += 8;
            },
            writeVarint: function(t91) {
                (t91 = +t91 || 0) > 268435455 || t91 < 0 ? (function(t92, e65) {
                    var r36, n24;
                    if (t92 >= 0 ? (r36 = t92 % 4294967296 | 0, n24 = t92 / 4294967296 | 0) : (n24 = ~(-t92 / 4294967296), 4294967295 ^ (r36 = ~(-t92 % 4294967296)) ? r36 = r36 + 1 | 0 : (r36 = 0, n24 = n24 + 1 | 0)), t92 >= 18446744073709552000 || t92 < -18446744073709552000) throw new Error("Given varint doesn't fit into 10 bytes");
                    e65.realloc(10), (function(t93, e66, r37) {
                        r37.buf[r37.pos++] = 127 & t93 | 128, t93 >>>= 7, r37.buf[r37.pos++] = 127 & t93 | 128, t93 >>>= 7, r37.buf[r37.pos++] = 127 & t93 | 128, t93 >>>= 7, r37.buf[r37.pos++] = 127 & t93 | 128, r37.buf[r37.pos] = 127 & (t93 >>>= 7);
                    })(r36, 0, e65), (function(t93, e66) {
                        var r37 = (7 & t93) << 4;
                        e66.buf[e66.pos++] |= r37 | (t93 >>>= 3, 128), t93 && (e66.buf[e66.pos++] = 127 & t93 | (t93 >>>= 7, 128), t93 && (e66.buf[e66.pos++] = 127 & t93 | (t93 >>>= 7, 128), t93 && (e66.buf[e66.pos++] = 127 & t93 | (t93 >>>= 7, 128), t93 && (e66.buf[e66.pos++] = 127 & t93 | (t93 >>>= 7, 128), t93 && (e66.buf[e66.pos++] = 127 & t93)))));
                    })(n24, e65);
                })(t91, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t91 | (t91 > 127 ? 128 : 0), t91 <= 127 || (this.buf[this.pos++] = 127 & (t91 >>>= 7) | (t91 > 127 ? 128 : 0), t91 <= 127 || (this.buf[this.pos++] = 127 & (t91 >>>= 7) | (t91 > 127 ? 128 : 0), t91 <= 127 || (this.buf[this.pos++] = t91 >>> 7 & 127))));
            },
            writeSVarint: function(t91) {
                this.writeVarint(t91 < 0 ? 2 * -t91 - 1 : 2 * t91);
            },
            writeBoolean: function(t91) {
                this.writeVarint(Boolean(t91));
            },
            writeString: function(t91) {
                t91 = String(t91), this.realloc(4 * t91.length), this.pos++;
                var e65 = this.pos;
                this.pos = (function(t92, e66, r36) {
                    for(var n24, i18, s14 = 0; s14 < e66.length; s14++){
                        if ((n24 = e66.charCodeAt(s14)) > 55295 && n24 < 57344) {
                            if (!i18) {
                                n24 > 56319 || s14 + 1 === e66.length ? (t92[r36++] = 239, t92[r36++] = 191, t92[r36++] = 189) : i18 = n24;
                                continue;
                            }
                            if (n24 < 56320) {
                                t92[r36++] = 239, t92[r36++] = 191, t92[r36++] = 189, i18 = n24;
                                continue;
                            }
                            n24 = i18 - 55296 << 10 | n24 - 56320 | 65536, i18 = null;
                        } else i18 && (t92[r36++] = 239, t92[r36++] = 191, t92[r36++] = 189, i18 = null);
                        n24 < 128 ? t92[r36++] = n24 : (n24 < 2048 ? t92[r36++] = n24 >> 6 | 192 : (n24 < 65536 ? t92[r36++] = n24 >> 12 | 224 : (t92[r36++] = n24 >> 18 | 240, t92[r36++] = n24 >> 12 & 63 | 128), t92[r36++] = n24 >> 6 & 63 | 128), t92[r36++] = 63 & n24 | 128);
                    }
                    return r36;
                })(this.buf, t91, this.pos);
                var r36 = this.pos - e65;
                r36 >= 128 && Dh(e65, r36, this), this.pos = e65 - 1, this.writeVarint(r36), this.pos += r36;
            },
            writeFloat: function(t91) {
                this.realloc(4), Mh(this.buf, t91, this.pos, !0, 23, 4), this.pos += 4;
            },
            writeDouble: function(t91) {
                this.realloc(8), Mh(this.buf, t91, this.pos, !0, 52, 8), this.pos += 8;
            },
            writeBytes: function(t91) {
                var e65 = t91.length;
                this.writeVarint(e65), this.realloc(e65);
                for(var r36 = 0; r36 < e65; r36++)this.buf[this.pos++] = t91[r36];
            },
            writeRawMessage: function(t91, e65) {
                this.pos++;
                var r36 = this.pos;
                t91(e65, this);
                var n24 = this.pos - r36;
                n24 >= 128 && Dh(r36, n24, this), this.pos = r36 - 1, this.writeVarint(n24), this.pos += n24;
            },
            writeMessage: function(t91, e65, r36) {
                this.writeTag(t91, Th.Bytes), this.writeRawMessage(e65, r36);
            },
            writePackedVarint: function(t91, e65) {
                e65.length && this.writeMessage(t91, Vh, e65);
            },
            writePackedSVarint: function(t91, e65) {
                e65.length && this.writeMessage(t91, Lh, e65);
            },
            writePackedBoolean: function(t91, e65) {
                e65.length && this.writeMessage(t91, jh, e65);
            },
            writePackedFloat: function(t91, e65) {
                e65.length && this.writeMessage(t91, Fh, e65);
            },
            writePackedDouble: function(t91, e65) {
                e65.length && this.writeMessage(t91, Rh, e65);
            },
            writePackedFixed32: function(t91, e65) {
                e65.length && this.writeMessage(t91, Uh, e65);
            },
            writePackedSFixed32: function(t91, e65) {
                e65.length && this.writeMessage(t91, $h, e65);
            },
            writePackedFixed64: function(t91, e65) {
                e65.length && this.writeMessage(t91, Oh, e65);
            },
            writePackedSFixed64: function(t91, e65) {
                e65.length && this.writeMessage(t91, qh, e65);
            },
            writeBytesField: function(t91, e65) {
                this.writeTag(t91, Th.Bytes), this.writeBytes(e65);
            },
            writeFixed32Field: function(t91, e65) {
                this.writeTag(t91, Th.Fixed32), this.writeFixed32(e65);
            },
            writeSFixed32Field: function(t91, e65) {
                this.writeTag(t91, Th.Fixed32), this.writeSFixed32(e65);
            },
            writeFixed64Field: function(t91, e65) {
                this.writeTag(t91, Th.Fixed64), this.writeFixed64(e65);
            },
            writeSFixed64Field: function(t91, e65) {
                this.writeTag(t91, Th.Fixed64), this.writeSFixed64(e65);
            },
            writeVarintField: function(t91, e65) {
                this.writeTag(t91, Th.Varint), this.writeVarint(e65);
            },
            writeSVarintField: function(t91, e65) {
                this.writeTag(t91, Th.Varint), this.writeSVarint(e65);
            },
            writeStringField: function(t91, e65) {
                this.writeTag(t91, Th.Bytes), this.writeString(e65);
            },
            writeFloatField: function(t91, e65) {
                this.writeTag(t91, Th.Fixed32), this.writeFloat(e65);
            },
            writeDoubleField: function(t91, e65) {
                this.writeTag(t91, Th.Fixed64), this.writeDouble(e65);
            },
            writeBooleanField: function(t91, e65) {
                this.writeVarintField(t91, Boolean(e65));
            }
        };
        class Wh {
            constructor(t91, { pixelRatio: e65 , version: r36 , stretchX: n24 , stretchY: i18 , content: s14  }){
                this.paddedRect = t91, this.pixelRatio = e65, this.stretchX = n24, this.stretchY = i18, this.content = s14, this.version = r36;
            }
            get tl() {
                return [
                    this.paddedRect.x + 1,
                    this.paddedRect.y + 1
                ];
            }
            get br() {
                return [
                    this.paddedRect.x + this.paddedRect.w - 1,
                    this.paddedRect.y + this.paddedRect.h - 1
                ];
            }
            get displaySize() {
                return [
                    (this.paddedRect.w - 2) / this.pixelRatio,
                    (this.paddedRect.h - 2) / this.pixelRatio
                ];
            }
        }
        class Jh {
            constructor(t92, e66){
                const r37 = {
                }, n25 = {
                };
                this.haveRenderCallbacks = [];
                const i19 = [];
                this.addImages(t92, r37, i19), this.addImages(e66, n25, i19);
                const { w: s15 , h: a9  } = Hh(i19), o10 = new gu({
                    width: s15 || 1,
                    height: a9 || 1
                });
                for(const e67 in t92){
                    const n26 = t92[e67], i20 = r37[e67].paddedRect;
                    gu.copy(n26.data, o10, {
                        x: 0,
                        y: 0
                    }, {
                        x: i20.x + 1,
                        y: i20.y + 1
                    }, n26.data);
                }
                for(const t93 in e66){
                    const r38 = e66[t93], i20 = n25[t93].paddedRect, s16 = i20.x + 1, a10 = i20.y + 1, l9 = r38.data.width, u8 = r38.data.height;
                    gu.copy(r38.data, o10, {
                        x: 0,
                        y: 0
                    }, {
                        x: s16,
                        y: a10
                    }, r38.data), gu.copy(r38.data, o10, {
                        x: 0,
                        y: u8 - 1
                    }, {
                        x: s16,
                        y: a10 - 1
                    }, {
                        width: l9,
                        height: 1
                    }), gu.copy(r38.data, o10, {
                        x: 0,
                        y: 0
                    }, {
                        x: s16,
                        y: a10 + u8
                    }, {
                        width: l9,
                        height: 1
                    }), gu.copy(r38.data, o10, {
                        x: l9 - 1,
                        y: 0
                    }, {
                        x: s16 - 1,
                        y: a10
                    }, {
                        width: 1,
                        height: u8
                    }), gu.copy(r38.data, o10, {
                        x: 0,
                        y: 0
                    }, {
                        x: s16 + l9,
                        y: a10
                    }, {
                        width: 1,
                        height: u8
                    });
                }
                this.image = o10, this.iconPositions = r37, this.patternPositions = n25;
            }
            addImages(t, e, r) {
                for(const n26 in t){
                    const i20 = t[n26], s16 = {
                        x: 0,
                        y: 0,
                        w: i20.data.width + 2,
                        h: i20.data.height + 2
                    };
                    r.push(s16), e[n26] = new Wh(s16, i20), i20.hasRenderCallback && this.haveRenderCallbacks.push(n26);
                }
            }
            patchUpdatedImages(t, e) {
                this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e68)=>t.hasImage(e68)
                ), t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                for(const r38 in t.updatedImages)this.patchUpdatedImage(this.iconPositions[r38], t.getImage(r38), e), this.patchUpdatedImage(this.patternPositions[r38], t.getImage(r38), e);
            }
            patchUpdatedImage(t, e, r) {
                if (!t || !e) return;
                if (t.version === e.version) return;
                t.version = e.version;
                const [n26, i20] = t.tl;
                r.update(e.data, void 0, {
                    x: n26,
                    y: i20
                });
            }
        }
        Oi(Wh, "ImagePosition"), Oi(Jh, "ImageAtlas");
        const Qh = {
            horizontal: 1,
            vertical: 2,
            horizontalOnly: 3
        };
        class tp {
            constructor(){
                this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t, e) {
                const r38 = new tp;
                return r38.scale = t || 1, r38.fontStack = e, r38;
            }
            static forImage(t) {
                const e68 = new tp;
                return e68.imageName = t, e68;
            }
        }
        class ep {
            constructor(){
                this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t, e) {
                const r38 = new ep;
                for(let n26 = 0; n26 < t.sections.length; n26++){
                    const i20 = t.sections[n26];
                    i20.image ? r38.addImageSection(i20) : r38.addTextSection(i20, e);
                }
                return r38;
            }
            length() {
                return this.text.length;
            }
            getSection(t) {
                return this.sections[this.sectionIndex[t]];
            }
            getSections() {
                return this.sections;
            }
            getSectionIndex(t) {
                return this.sectionIndex[t];
            }
            getCharCode(t) {
                return this.text.charCodeAt(t);
            }
            verticalizePunctuation(t) {
                this.text = (function(t94, e68) {
                    let r38 = "";
                    for(let n26 = 0; n26 < t94.length; n26++){
                        const i20 = t94.charCodeAt(n26 + 1) || null, s16 = t94.charCodeAt(n26 - 1) || null;
                        r38 += !e68 && (i20 && Ss(i20) && !_h[t94[n26 + 1]] || s16 && Ss(s16) && !_h[t94[n26 - 1]]) || !_h[t94[n26]] ? t94[n26] : _h[t94[n26]];
                    }
                    return r38;
                })(this.text, t);
            }
            trim() {
                let t94 = 0;
                for(let e68 = 0; e68 < this.text.length && np[this.text.charCodeAt(e68)]; e68++)t94++;
                let e69 = this.text.length;
                for(let r38 = this.text.length - 1; r38 >= 0 && r38 >= t94 && np[this.text.charCodeAt(r38)]; r38--)e69--;
                this.text = this.text.substring(t94, e69), this.sectionIndex = this.sectionIndex.slice(t94, e69);
            }
            substring(t, e) {
                const r38 = new ep;
                return r38.text = this.text.substring(t, e), r38.sectionIndex = this.sectionIndex.slice(t, e), r38.sections = this.sections, r38;
            }
            toString() {
                return this.text;
            }
            getMaxScale() {
                return this.sectionIndex.reduce((t94, e68)=>Math.max(t94, this.sections[e68].scale)
                , 0);
            }
            addTextSection(t, e) {
                this.text += t.text, this.sections.push(tp.forText(t.scale, t.fontStack || e));
                const r38 = this.sections.length - 1;
                for(let e68 = 0; e68 < t.text.length; ++e68)this.sectionIndex.push(r38);
            }
            addImageSection(t) {
                const e68 = t.image ? t.image.name : "";
                if (0 === e68.length) return void $("Can't add FormattedSection with an empty image.");
                const r38 = this.getNextImageSectionCharCode();
                r38 ? (this.text += String.fromCharCode(r38), this.sections.push(tp.forImage(e68)), this.sectionIndex.push(this.sections.length - 1)) : $("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
        }
        function rp(t94, e68, r38, n26, i20, s16, a10, o11, l9, u8, c7, h5, p5, f4, d4) {
            const y2 = ep.fromFeature(t94, i20);
            h5 === Qh.vertical && y2.verticalizePunctuation(p5);
            let m2 = [];
            const g2 = function(t95, e69, r39, n27, i21, s17) {
                if (!t95) return [];
                const a11 = [], o12 = function(t96, e70, r40, n28, i22, s18) {
                    let a12 = 0;
                    for(let r41 = 0; r41 < t96.length(); r41++){
                        const o13 = t96.getSection(r41);
                        a12 += sp(t96.getCharCode(r41), o13, n28, i22, e70, s18);
                    }
                    return a12 / Math.max(1, Math.ceil(a12 / r40));
                }(t95, e69, r39, n27, i21, s17), l10 = t95.text.indexOf("​") >= 0;
                let u9 = 0;
                for(let r40 = 0; r40 < t95.length(); r40++){
                    const h6 = t95.getSection(r40), p6 = t95.getCharCode(r40);
                    if (np[p6] || (u9 += sp(p6, h6, n27, i21, e69, s17)), r40 < t95.length() - 1) {
                        const e70 = !((c8 = p6) < 11904 || !(ns(c8) || rs(c8) || ms(c8) || fs(c8) || os(c8) || Hi(c8) || is(c8) || Qi(c8) || ls(c8) || us(c8) || as(c8) || vs(c8) || ts(c8) || Ji(c8) || Wi(c8) || ss(c8) || es(c8) || ys(c8) || hs(c8) || cs(c8)));
                        (ip[p6] || e70 || h6.imageName) && a11.push(lp(r40 + 1, u9, o12, a11, op(p6, t95.getCharCode(r40 + 1), e70 && l10), !1));
                    }
                }
                var c8;
                return up(lp(t95.length(), u9, o12, a11, 0, !0));
            }(y2, u8, s16, e68, n26, f4), { processBidirectionalText: x2 , processStyledBidirectionalText: v2  } = js;
            if (x2 && 1 === y2.sections.length) {
                const t95 = x2(y2.toString(), g2);
                for (const e69 of t95){
                    const t96 = new ep;
                    t96.text = e69, t96.sections = y2.sections;
                    for(let r39 = 0; r39 < e69.length; r39++)t96.sectionIndex.push(0);
                    m2.push(t96);
                }
            } else if (v2) {
                const t95 = v2(y2.text, y2.sectionIndex, g2);
                for (const e69 of t95){
                    const t96 = new ep;
                    t96.text = e69[0], t96.sectionIndex = e69[1], t96.sections = y2.sections, m2.push(t96);
                }
            } else m2 = (function(t95, e69) {
                const r39 = [], n27 = t95.text;
                let i21 = 0;
                for (const n28 of e69)r39.push(t95.substring(i21, n28)), i21 = n28;
                return i21 < n27.length && r39.push(t95.substring(i21, n27.length)), r39;
            })(y2, g2);
            const b2 = [], w2 = {
                positionedLines: b2,
                text: y2.toString(),
                top: c7[1],
                bottom: c7[1],
                left: c7[0],
                right: c7[0],
                writingMode: h5,
                iconsInText: !1,
                verticalizable: !1,
                hasBaseline: !1
            };
            return (function(t95, e69, r39, n27, i21, s17, a11, o12, l10, u9, c8, h6) {
                let p6 = 0, f5 = 0, d5 = 0;
                const y3 = "right" === o12 ? 1 : "left" === o12 ? 0 : 0.5;
                let m3 = !1;
                for (const t96 of i21){
                    const r40 = t96.getSections();
                    for (const t97 of r40){
                        if (t97.imageName) continue;
                        const r41 = e69[t97.fontStack];
                        if (r41 && (m3 = (void 0) !== r41.ascender && (void 0) !== r41.descender, !m3)) break;
                    }
                    if (!m3) break;
                }
                let g3 = 0;
                for (const a12 of i21){
                    a12.trim();
                    const i22 = a12.getMaxScale(), o13 = (i22 - 1) * yh, v3 = {
                        positionedGlyphs: [],
                        lineOffset: 0
                    };
                    t95.positionedLines[g3] = v3;
                    const b3 = v3.positionedGlyphs;
                    let w3 = 0;
                    if (!a12.length()) {
                        f5 += s17, ++g3;
                        continue;
                    }
                    let _2 = 0, A2 = 0;
                    for(let s18 = 0; s18 < a12.length(); s18++){
                        const o14 = a12.getSection(s18), d6 = a12.getSectionIndex(s18), y4 = a12.getCharCode(s18);
                        let g4 = o14.scale, v4 = null, S2 = null, k2 = null, I2 = yh, M2 = 0;
                        const T2 = !(l10 === Qh.horizontal || !c8 && !As(y4) || c8 && (np[y4] || (x3 = y4, Zi(x3) || Ki(x3) || Yi(x3) || ds(x3) || xs(x3))));
                        if (o14.imageName) {
                            const e70 = n27[o14.imageName];
                            if (!e70) continue;
                            k2 = o14.imageName, t95.iconsInText = t95.iconsInText || !0, S2 = e70.paddedRect;
                            const r40 = e70.displaySize;
                            g4 = g4 * yh / h6, v4 = {
                                width: r40[0],
                                height: r40[1],
                                left: 1,
                                top: -3,
                                advance: T2 ? r40[1] : r40[0],
                                localGlyph: !1
                            }, M2 = m3 ? -v4.height * g4 : i22 * yh - 17 - r40[1] * g4, I2 = v4.advance;
                            const s19 = (T2 ? r40[0] : r40[1]) * g4 - yh * i22;
                            s19 > 0 && s19 > w3 && (w3 = s19);
                        } else {
                            const t97 = r39[o14.fontStack];
                            if (!t97) continue;
                            t97[y4] && (S2 = t97[y4]);
                            const n28 = e69[o14.fontStack];
                            if (!n28) continue;
                            const s19 = n28.glyphs[y4];
                            if (!s19) continue;
                            if (v4 = s19.metrics, I2 = 8203 !== y4 ? yh : 0, m3) {
                                const t98 = (void 0) !== n28.ascender ? Math.abs(n28.ascender) : 0, e70 = (void 0) !== n28.descender ? Math.abs(n28.descender) : 0, r40 = (t98 + e70) * g4;
                                _2 < r40 && (_2 = r40, A2 = (t98 - e70) / 2 * g4), M2 = -t98 * g4;
                            } else M2 = (i22 - g4) * yh - 17;
                        }
                        T2 ? (t95.verticalizable = !0, b3.push({
                            glyph: y4,
                            imageName: k2,
                            x: p6,
                            y: f5 + M2,
                            vertical: T2,
                            scale: g4,
                            localGlyph: v4.localGlyph,
                            fontStack: o14.fontStack,
                            sectionIndex: d6,
                            metrics: v4,
                            rect: S2
                        }), p6 += I2 * g4 + u9) : (b3.push({
                            glyph: y4,
                            imageName: k2,
                            x: p6,
                            y: f5 + M2,
                            vertical: T2,
                            scale: g4,
                            localGlyph: v4.localGlyph,
                            fontStack: o14.fontStack,
                            sectionIndex: d6,
                            metrics: v4,
                            rect: S2
                        }), p6 += v4.advance * g4 + u9);
                    }
                    0 !== b3.length && (d5 = Math.max(p6 - u9, d5), m3 ? hp(b3, y3, w3, A2, s17 * i22 / 2) : hp(b3, y3, w3, 0, s17 / 2)), p6 = 0;
                    const S2 = s17 * i22 + w3;
                    v3.lineOffset = Math.max(w3, o13), f5 += S2, ++g3;
                }
                var x3;
                const v3 = f5, { horizontalAlign: b3 , verticalAlign: w3  } = cp(a11);
                (function(t97, e70, r40, n28, i22, s18) {
                    const a13 = (e70 - r40) * i22, o13 = -s18 * n28;
                    for (const e71 of t97)for (const t98 of e71.positionedGlyphs)t98.x += a13, t98.y += o13;
                })(t95.positionedLines, y3, b3, w3, d5, v3), t95.top += -w3 * v3, t95.bottom = t95.top + v3, t95.left += -b3 * d5, t95.right = t95.left + d5, t95.hasBaseline = m3;
            })(w2, e68, r38, n26, m2, a10, o11, l9, h5, u8, p5, d4), !function(t95) {
                for (const e69 of t95)if (0 !== e69.positionedGlyphs.length) return !1;
                return !0;
            }(b2) && w2;
        }
        const np = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
        }, ip = {
            10: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
        };
        function sp(t94, e68, r38, n26, i20, s16) {
            if (e68.imageName) {
                const t95 = n26[e68.imageName];
                return t95 ? t95.displaySize[0] * e68.scale * yh / s16 + i20 : 0;
            }
            {
                const n27 = r38[e68.fontStack], s17 = n27 && n27.glyphs[t94];
                return s17 ? s17.metrics.advance * e68.scale + i20 : 0;
            }
        }
        function ap(t94, e68, r38, n26) {
            const i20 = Math.pow(t94 - e68, 2);
            return n26 ? t94 < e68 ? i20 / 2 : 2 * i20 : i20 + Math.abs(r38) * r38;
        }
        function op(t94, e68, r38) {
            let n26 = 0;
            return 10 === t94 && (n26 -= 10000), r38 && (n26 += 150), 40 !== t94 && 65288 !== t94 || (n26 += 50), 41 !== e68 && 65289 !== e68 || (n26 += 50), n26;
        }
        function lp(t94, e68, r38, n26, i20, s16) {
            let a10 = null, o11 = ap(e68, r38, i20, s16);
            for (const t95 of n26){
                const n27 = ap(e68 - t95.x, r38, i20, s16) + t95.badness;
                n27 <= o11 && (a10 = t95, o11 = n27);
            }
            return {
                index: t94,
                x: e68,
                priorBreak: a10,
                badness: o11
            };
        }
        function up(t94) {
            return t94 ? up(t94.priorBreak).concat(t94.index) : [];
        }
        function cp(t94) {
            let e68 = 0.5, r38 = 0.5;
            switch(t94){
                case "right":
                case "top-right":
                case "bottom-right":
                    e68 = 1;
                    break;
                case "left":
                case "top-left":
                case "bottom-left":
                    e68 = 0;
            }
            switch(t94){
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                    r38 = 1;
                    break;
                case "top":
                case "top-right":
                case "top-left":
                    r38 = 0;
            }
            return {
                horizontalAlign: e68,
                verticalAlign: r38
            };
        }
        function hp(t94, e68, r38, n26, i20) {
            if (!(e68 || r38 || n26 || i20)) return;
            const s16 = t94.length - 1, a10 = t94[s16], o11 = (a10.x + a10.metrics.advance * a10.scale) * e68;
            for(let e69 = 0; e69 <= s16; e69++)t94[e69].x -= o11, t94[e69].y += r38 + n26 + i20;
        }
        function pp(t94, e68, r38) {
            const { horizontalAlign: n26 , verticalAlign: i20  } = cp(r38), s16 = e68[0] - t94.displaySize[0] * n26, a10 = e68[1] - t94.displaySize[1] * i20;
            return {
                image: t94,
                top: a10,
                bottom: a10 + t94.displaySize[1],
                left: s16,
                right: s16 + t94.displaySize[0]
            };
        }
        function fp(t94, e68, r38, n26, i20, s16) {
            const a10 = t94.image;
            let o11;
            if (a10.content) {
                const t95 = a10.content, e69 = a10.pixelRatio || 1;
                o11 = [
                    t95[0] / e69,
                    t95[1] / e69,
                    a10.displaySize[0] - t95[2] / e69,
                    a10.displaySize[1] - t95[3] / e69
                ];
            }
            const l9 = e68.left * s16, u8 = e68.right * s16;
            let c7, h5, p5, f4;
            "width" === r38 || "both" === r38 ? (f4 = i20[0] + l9 - n26[3], h5 = i20[0] + u8 + n26[1]) : (f4 = i20[0] + (l9 + u8 - a10.displaySize[0]) / 2, h5 = f4 + a10.displaySize[0]);
            const d4 = e68.top * s16, y2 = e68.bottom * s16;
            return "height" === r38 || "both" === r38 ? (c7 = i20[1] + d4 - n26[0], p5 = i20[1] + y2 + n26[2]) : (c7 = i20[1] + (d4 + y2 - a10.displaySize[1]) / 2, p5 = c7 + a10.displaySize[1]), {
                image: a10,
                top: c7,
                right: h5,
                bottom: p5,
                left: f4,
                collisionPadding: o11
            };
        }
        class dp extends d2 {
            constructor(t94, e68, r38, n26, i20){
                super(t94, e68), this.angle = n26, this.z = r38, (void 0) !== i20 && (this.segment = i20);
            }
            clone() {
                return new dp(this.x, this.y, this.z, this.angle, this.segment);
            }
        }
        function yp(t95, e69, r39, n27, i21) {
            if ((void 0) === e69.segment) return !0;
            let s16 = e69, a10 = e69.segment + 1, o11 = 0;
            for(; o11 > -r39 / 2;){
                if (a10--, a10 < 0) return !1;
                o11 -= t95[a10].dist(s16), s16 = t95[a10];
            }
            o11 += t95[a10].dist(t95[a10 + 1]), a10++;
            const l9 = [];
            let u8 = 0;
            for(; o11 < r39 / 2;){
                const e70 = t95[a10], r40 = t95[a10 + 1];
                if (!r40) return !1;
                let s17 = t95[a10 - 1].angleTo(e70) - e70.angleTo(r40);
                for(s17 = Math.abs((s17 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l9.push({
                    distance: o11,
                    angleDelta: s17
                }), u8 += s17; o11 - l9[0].distance > n27;)u8 -= l9.shift().angleDelta;
                if (u8 > i21) return !1;
                a10++, o11 += e70.dist(r40);
            }
            return !0;
        }
        function mp(t95) {
            let e69 = 0;
            for(let r39 = 0; r39 < t95.length - 1; r39++)e69 += t95[r39].dist(t95[r39 + 1]);
            return e69;
        }
        function gp(t95, e69, r39) {
            return t95 ? 0.6 * e69 * r39 : 0;
        }
        function xp(t95, e69) {
            return Math.max(t95 ? t95.right - t95.left : 0, e69 ? e69.right - e69.left : 0);
        }
        function vp(t95, e69, r39, n27, i21, s16) {
            const a10 = gp(r39, i21, s16), o11 = xp(r39, n27) * s16;
            let l9 = 0;
            const u8 = mp(t95) / 2;
            for(let r40 = 0; r40 < t95.length - 1; r40++){
                const n28 = t95[r40], i22 = t95[r40 + 1], s17 = n28.dist(i22);
                if (l9 + s17 > u8) {
                    const c7 = (u8 - l9) / s17, h5 = Mr(n28.x, i22.x, c7), p5 = Mr(n28.y, i22.y, c7), f4 = new dp(h5, p5, 0, i22.angleTo(n28), r40);
                    return !a10 || yp(t95, f4, o11, a10, e69) ? f4 : void 0;
                }
                l9 += s17;
            }
        }
        function bp(t95, e69, r39, n27, i21, s16, a10, o11, l9) {
            const u8 = gp(n27, s16, a10), c7 = xp(n27, i21), h5 = c7 * a10, p5 = 0 === t95[0].x || t95[0].x === l9 || 0 === t95[0].y || t95[0].y === l9;
            return e69 - h5 < e69 / 4 && (e69 = h5 + e69 / 4), wp(t95, p5 ? e69 / 2 * o11 % e69 : (c7 / 2 + 2 * s16) * a10 * o11 % e69, e69, u8, r39, h5, p5, !1, l9);
        }
        function wp(t95, e69, r39, n27, i21, s16, a10, o11, l9) {
            const u8 = s16 / 2, c7 = mp(t95);
            let h5 = 0, p5 = e69 - r39, f4 = [];
            for(let e70 = 0; e70 < t95.length - 1; e70++){
                const a11 = t95[e70], o12 = t95[e70 + 1], d4 = a11.dist(o12), y2 = o12.angleTo(a11);
                for(; p5 + r39 < h5 + d4;){
                    p5 += r39;
                    const m2 = (p5 - h5) / d4, g2 = Mr(a11.x, o12.x, m2), x2 = Mr(a11.y, o12.y, m2);
                    if (g2 >= 0 && g2 < l9 && x2 >= 0 && x2 < l9 && p5 - u8 >= 0 && p5 + u8 <= c7) {
                        const r40 = new dp(g2, x2, 0, y2, e70);
                        r40._round(), n27 && !yp(t95, r40, s16, n27, i21) || f4.push(r40);
                    }
                }
                h5 += d4;
            }
            return o11 || f4.length || a10 || (f4 = wp(t95, h5 / 2, r39, n27, i21, s16, a10, !0, l9)), f4;
        }
        function _p(t95, e69, r39, n27, i21) {
            const s16 = [];
            for(let a10 = 0; a10 < t95.length; a10++){
                const o11 = t95[a10];
                let l9;
                for(let t96 = 0; t96 < o11.length - 1; t96++){
                    let a11 = o11[t96], u8 = o11[t96 + 1];
                    a11.x < e69 && u8.x < e69 || (a11.x < e69 ? a11 = new d2(e69, a11.y + (e69 - a11.x) / (u8.x - a11.x) * (u8.y - a11.y))._round() : u8.x < e69 && (u8 = new d2(e69, a11.y + (e69 - a11.x) / (u8.x - a11.x) * (u8.y - a11.y))._round()), a11.y < r39 && u8.y < r39 || (a11.y < r39 ? a11 = new d2(a11.x + (r39 - a11.y) / (u8.y - a11.y) * (u8.x - a11.x), r39)._round() : u8.y < r39 && (u8 = new d2(a11.x + (r39 - a11.y) / (u8.y - a11.y) * (u8.x - a11.x), r39)._round()), a11.x >= n27 && u8.x >= n27 || (a11.x >= n27 ? a11 = new d2(n27, a11.y + (n27 - a11.x) / (u8.x - a11.x) * (u8.y - a11.y))._round() : u8.x >= n27 && (u8 = new d2(n27, a11.y + (n27 - a11.x) / (u8.x - a11.x) * (u8.y - a11.y))._round()), a11.y >= i21 && u8.y >= i21 || (a11.y >= i21 ? a11 = new d2(a11.x + (i21 - a11.y) / (u8.y - a11.y) * (u8.x - a11.x), i21)._round() : u8.y >= i21 && (u8 = new d2(a11.x + (i21 - a11.y) / (u8.y - a11.y) * (u8.x - a11.x), i21)._round()), l9 && a11.equals(l9[l9.length - 1]) || (l9 = [
                        a11
                    ], s16.push(l9)), l9.push(u8)))));
                }
            }
            return s16;
        }
        Oi(dp, "Anchor");
        const Ap = 100000000000000000000;
        function Sp(t95, e69, r39, n27, i21, s16, a10, o11, l9) {
            for(let u8 = e69; u8 < e69 + n27; u8++)kp(t95, r39 * s16 + u8, s16, i21, a10, o11, l9);
            for(let u9 = r39; u9 < r39 + i21; u9++)kp(t95, u9 * s16 + e69, 1, n27, a10, o11, l9);
        }
        function kp(t95, e69, r39, n27, i21, s16, a10) {
            s16[0] = 0, a10[0] = -Ap, a10[1] = Ap, i21[0] = t95[e69];
            for(let o11 = 1, l9 = 0, u8 = 0; o11 < n27; o11++){
                i21[o11] = t95[e69 + o11 * r39];
                const n28 = o11 * o11;
                do {
                    const t96 = s16[l9];
                    u8 = (i21[o11] - i21[t96] + n28 - t96 * t96) / (o11 - t96) / 2;
                }while (u8 <= a10[l9] && (--l9) > -1)
                l9++, s16[l9] = o11, a10[l9] = u8, a10[l9 + 1] = Ap;
            }
            for(let o12 = 0, l10 = 0; o12 < n27; o12++){
                for(; a10[l10 + 1] < o12;)l10++;
                const n28 = s16[l10], u9 = o12 - n28;
                t95[e69 + o12 * r39] = i21[n28] + u9 * u9;
            }
        }
        const Ip = {
            none: 0,
            ideographs: 1,
            all: 2
        };
        class Mp {
            constructor(t95, e69, r39){
                this.requestManager = t95, this.localGlyphMode = e69, this.localFontFamily = r39, this.entries = {
                }, this.localGlyphs = {
                    200: {
                    },
                    400: {
                    },
                    500: {
                    },
                    900: {
                    }
                };
            }
            setURL(t) {
                this.url = t;
            }
            getGlyphs(t, e) {
                const r40 = [];
                for(const e70 in t)for (const n27 of t[e70])r40.push({
                    stack: e70,
                    id: n27
                });
                M1(r40, ({ stack: t96 , id: e71  }, r41)=>{
                    let n28 = this.entries[t96];
                    n28 || (n28 = this.entries[t96] = {
                        glyphs: {
                        },
                        requests: {
                        },
                        ranges: {
                        },
                        ascender: void 0,
                        descender: void 0
                    });
                    let i21 = n28.glyphs[e71];
                    if ((void 0) !== i21) return void r41(null, {
                        stack: t96,
                        id: e71,
                        glyph: i21
                    });
                    if (i21 = this._tinySDF(n28, t96, e71), i21) return n28.glyphs[e71] = i21, void r41(null, {
                        stack: t96,
                        id: e71,
                        glyph: i21
                    });
                    const s16 = Math.floor(e71 / 256);
                    if (256 * s16 > 65535) return void r41(new Error("glyphs > 65535 not supported"));
                    if (n28.ranges[s16]) return void r41(null, {
                        stack: t96,
                        id: e71,
                        glyph: i21
                    });
                    let a10 = n28.requests[s16];
                    a10 || (a10 = n28.requests[s16] = [], Mp.loadGlyphRange(t96, s16, this.url, this.requestManager, (t97, e72)=>{
                        if (e72) {
                            n28.ascender = e72.ascender, n28.descender = e72.descender;
                            for(const t98 in e72.glyphs)this._doesCharSupportLocalGlyph(+t98) || (n28.glyphs[+t98] = e72.glyphs[+t98]);
                            n28.ranges[s16] = !0;
                        }
                        for (const r42 of a10)r42(t97, e72);
                        delete n28.requests[s16];
                    })), a10.push((n29, i22)=>{
                        n29 ? r41(n29) : i22 && r41(null, {
                            stack: t96,
                            id: e71,
                            glyph: i22.glyphs[e71] || null
                        });
                    });
                }, (t96, r41)=>{
                    if (t96) e(t96);
                    else if (r41) {
                        const t97 = {
                        };
                        for (const { stack: e71 , id: n28 , glyph: i21  } of r41)(void 0) === t97[e71] && (t97[e71] = {
                        }), (void 0) === t97[e71].glyphs && (t97[e71].glyphs = {
                        }), t97[e71].glyphs[n28] = i21 && {
                            id: i21.id,
                            bitmap: i21.bitmap.clone(),
                            metrics: i21.metrics
                        }, t97[e71].ascender = this.entries[e71].ascender, t97[e71].descender = this.entries[e71].descender;
                        e(null, t97);
                    }
                });
            }
            _doesCharSupportLocalGlyph(t) {
                return this.localGlyphMode !== Ip.none && (this.localGlyphMode === Ip.all ? !!this.localFontFamily : !!this.localFontFamily && (us(t) || ps(t) || ts(t) || es(t) || Qi(t)));
            }
            _tinySDF(t, e, r) {
                const n27 = this.localFontFamily;
                if (!n27 || !this._doesCharSupportLocalGlyph(r)) return;
                let i21 = t.tinySDF;
                if (!i21) {
                    let r40 = "400";
                    /bold/i.test(e) ? r40 = "900" : /medium/i.test(e) ? r40 = "500" : /light/i.test(e) && (r40 = "200"), i21 = t.tinySDF = new Mp.TinySDF({
                        fontFamily: n27,
                        fontWeight: r40,
                        fontSize: 48,
                        buffer: 6,
                        radius: 16
                    }), i21.fontWeight = r40;
                }
                if (this.localGlyphs[i21.fontWeight][r]) return this.localGlyphs[i21.fontWeight][r];
                const s16 = String.fromCharCode(r), { data: a10 , width: o11 , height: l9 , glyphWidth: u8 , glyphHeight: c7 , glyphLeft: h5 , glyphTop: p5 , glyphAdvance: f4  } = i21.draw(s16);
                return this.localGlyphs[i21.fontWeight][r] = {
                    id: r,
                    bitmap: new mu({
                        width: o11,
                        height: l9
                    }, a10),
                    metrics: {
                        width: u8 / 2,
                        height: c7 / 2,
                        left: h5 / 2,
                        top: p5 / 2 - 27,
                        advance: f4 / 2,
                        localGlyph: !0
                    }
                };
            }
        }
        function Tp(t96, e70, r40, n27) {
            const i21 = [], s16 = t96.image, a10 = s16.pixelRatio, o11 = s16.paddedRect.w - 2, l9 = s16.paddedRect.h - 2, u8 = t96.right - t96.left, c7 = t96.bottom - t96.top, h5 = s16.stretchX || [
                [
                    0,
                    o11
                ]
            ], p5 = s16.stretchY || [
                [
                    0,
                    l9
                ]
            ], f4 = (t97, e71)=>t97 + e71[1] - e71[0]
            , y2 = h5.reduce(f4, 0), m2 = p5.reduce(f4, 0), g2 = o11 - y2, x2 = l9 - m2;
            let v2 = 0, b2 = y2, w2 = 0, _2 = m2, A2 = 0, S2 = g2, k2 = 0, I2 = x2;
            if (s16.content && n27) {
                const t97 = s16.content;
                v2 = zp(h5, 0, t97[0]), w2 = zp(p5, 0, t97[1]), b2 = zp(h5, t97[0], t97[2]), _2 = zp(p5, t97[1], t97[3]), A2 = t97[0] - v2, k2 = t97[1] - w2, S2 = t97[2] - t97[0] - b2, I2 = t97[3] - t97[1] - _2;
            }
            const M2 = (n28, i22, o12, l10)=>{
                const h6 = Ep(n28.stretch - v2, b2, u8, t96.left), p6 = Cp(n28.fixed - A2, S2, n28.stretch, y2), f5 = Ep(i22.stretch - w2, _2, c7, t96.top), g3 = Cp(i22.fixed - k2, I2, i22.stretch, m2), x3 = Ep(o12.stretch - v2, b2, u8, t96.left), M3 = Cp(o12.fixed - A2, S2, o12.stretch, y2), T2 = Ep(l10.stretch - w2, _2, c7, t96.top), z2 = Cp(l10.fixed - k2, I2, l10.stretch, m2), B2 = new d2(h6, f5), E1 = new d2(x3, f5), C1 = new d2(x3, T2), P1 = new d2(h6, T2), D1 = new d2(p6 / a10, g3 / a10), V1 = new d2(M3 / a10, z2 / a10), L1 = e70 * Math.PI / 180;
                if (L1) {
                    const t97 = Math.sin(L1), e71 = Math.cos(L1), r41 = [
                        e71,
                        -t97,
                        t97,
                        e71
                    ];
                    B2._matMult(r41), E1._matMult(r41), P1._matMult(r41), C1._matMult(r41);
                }
                const F1 = n28.stretch + n28.fixed, R1 = i22.stretch + i22.fixed;
                return {
                    tl: B2,
                    tr: E1,
                    bl: P1,
                    br: C1,
                    tex: {
                        x: s16.paddedRect.x + 1 + F1,
                        y: s16.paddedRect.y + 1 + R1,
                        w: o12.stretch + o12.fixed - F1,
                        h: l10.stretch + l10.fixed - R1
                    },
                    writingMode: void 0,
                    glyphOffset: [
                        0,
                        0
                    ],
                    sectionIndex: 0,
                    pixelOffsetTL: D1,
                    pixelOffsetBR: V1,
                    minFontScaleX: S2 / a10 / u8,
                    minFontScaleY: I2 / a10 / c7,
                    isSDF: r40
                };
            };
            if (n27 && (s16.stretchX || s16.stretchY)) {
                const t97 = Bp(h5, g2, y2), e71 = Bp(p5, x2, m2);
                for(let r41 = 0; r41 < t97.length - 1; r41++){
                    const n28 = t97[r41], s17 = t97[r41 + 1];
                    for(let t98 = 0; t98 < e71.length - 1; t98++)i21.push(M2(n28, e71[t98], s17, e71[t98 + 1]));
                }
            } else i21.push(M2({
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: o11 + 1
            }, {
                fixed: 0,
                stretch: l9 + 1
            }));
            return i21;
        }
        function zp(t96, e70, r40) {
            let n27 = 0;
            for (const i21 of t96)n27 += Math.max(e70, Math.min(r40, i21[1])) - Math.max(e70, Math.min(r40, i21[0]));
            return n27;
        }
        function Bp(t96, e70, r40) {
            const n27 = [
                {
                    fixed: -1,
                    stretch: 0
                }
            ];
            for (const [e71, r41] of t96){
                const t97 = n27[n27.length - 1];
                n27.push({
                    fixed: e71 - t97.stretch,
                    stretch: t97.stretch
                }), n27.push({
                    fixed: e71 - t97.stretch,
                    stretch: t97.stretch + (r41 - e71)
                });
            }
            return n27.push({
                fixed: e70 + 1,
                stretch: r40
            }), n27;
        }
        function Ep(t96, e70, r40, n27) {
            return t96 / e70 * r40 + n27;
        }
        function Cp(t96, e70, r40, n27) {
            return t96 - e70 * r40 / n27;
        }
        function Pp(t96, e70, r40, n27) {
            const i21 = e70 + t96.positionedLines[n27].lineOffset;
            return 0 === n27 ? r40 + i21 / 2 : r40 + (i21 + (e70 + t96.positionedLines[n27 - 1].lineOffset)) / 2;
        }
        Mp.loadGlyphRange = function(t96, e70, r40, n27, i21) {
            const s16 = 256 * e70, a10 = s16 + 255, o11 = n27.transformRequest(n27.normalizeGlyphsURL(r40).replace("{fontstack}", t96).replace("{range}", `${s16}-${a10}`), st.Glyphs);
            ut(o11, (t97, e71)=>{
                if (t97) i21(t97);
                else if (e71) {
                    const t98 = {
                    }, r41 = function(t99) {
                        return new kh(t99).readFields(Zh, {
                        });
                    }(e71);
                    for (const e72 of r41.glyphs)t98[e72.id] = e72;
                    i21(null, {
                        glyphs: t98,
                        ascender: r41.ascender,
                        descender: r41.descender
                    });
                }
            });
        }, Mp.TinySDF = class {
            constructor({ fontSize: t96 = 24 , buffer: e70 = 3 , radius: r40 = 8 , cutoff: n27 = 0.25 , fontFamily: i21 = "sans-serif" , fontWeight: s16 = "normal" , fontStyle: a10 = "normal"  } = {
            }){
                this.buffer = e70, this.cutoff = n27, this.radius = r40;
                const o11 = this.size = t96 + 4 * e70, l9 = this._createCanvas(o11), u8 = this.ctx = l9.getContext("2d", {
                    willReadFrequently: !0
                });
                u8.font = `${a10} ${s16} ${t96}px ${i21}`, u8.textBaseline = "alphabetic", u8.textAlign = "left", u8.fillStyle = "black", this.gridOuter = new Float64Array(o11 * o11), this.gridInner = new Float64Array(o11 * o11), this.f = new Float64Array(o11), this.z = new Float64Array(o11 + 1), this.v = new Uint16Array(o11);
            }
            _createCanvas(t) {
                const e71 = document.createElement("canvas");
                return e71.width = e71.height = t, e71;
            }
            draw(t) {
                const { width: e71 , actualBoundingBoxAscent: r41 , actualBoundingBoxDescent: n28 , actualBoundingBoxLeft: i22 , actualBoundingBoxRight: s17  } = this.ctx.measureText(t), a11 = Math.ceil(r41), o12 = Math.min(this.size - this.buffer, Math.ceil(s17 - i22)), l10 = Math.min(this.size - this.buffer, a11 + Math.ceil(n28)), u9 = o12 + 2 * this.buffer, c7 = l10 + 2 * this.buffer, h5 = Math.max(u9 * c7, 0), p5 = new Uint8ClampedArray(h5), f4 = {
                    data: p5,
                    width: u9,
                    height: c7,
                    glyphWidth: o12,
                    glyphHeight: l10,
                    glyphTop: a11,
                    glyphLeft: 0,
                    glyphAdvance: e71
                };
                if (0 === o12 || 0 === l10) return f4;
                const { ctx: d4 , buffer: y2 , gridInner: m2 , gridOuter: g2  } = this;
                d4.clearRect(y2, y2, o12, l10), d4.fillText(t, y2, y2 + a11);
                const x2 = d4.getImageData(y2, y2, o12, l10);
                g2.fill(Ap, 0, h5), m2.fill(0, 0, h5);
                for(let t97 = 0; t97 < l10; t97++)for(let e72 = 0; e72 < o12; e72++){
                    const r42 = x2.data[4 * (t97 * o12 + e72) + 3] / 255;
                    if (0 === r42) continue;
                    const n29 = (t97 + y2) * u9 + e72 + y2;
                    if (1 === r42) g2[n29] = 0, m2[n29] = Ap;
                    else {
                        const t98 = 0.5 - r42;
                        g2[n29] = t98 > 0 ? t98 * t98 : 0, m2[n29] = t98 < 0 ? t98 * t98 : 0;
                    }
                }
                Sp(g2, 0, 0, u9, c7, u9, this.f, this.v, this.z), Sp(m2, y2, y2, o12, l10, u9, this.f, this.v, this.z);
                for(let t98 = 0; t98 < h5; t98++){
                    const e73 = Math.sqrt(g2[t98]) - Math.sqrt(m2[t98]);
                    p5[t98] = Math.round(255 - 255 * (e73 / this.radius + this.cutoff));
                }
                return f4;
            }
        };
        class Dp {
            constructor(t97 = [], e71 = Vp){
                if (this.data = t97, this.length = this.data.length, this.compare = e71, this.length > 0) for(let t98 = (this.length >> 1) - 1; t98 >= 0; t98--)this._down(t98);
            }
            push(t) {
                this.data.push(t), this.length++, this._up(this.length - 1);
            }
            pop() {
                if (0 === this.length) return;
                const t99 = this.data[0], e72 = this.data.pop();
                return this.length--, this.length > 0 && (this.data[0] = e72, this._down(0)), t99;
            }
            peek() {
                return this.data[0];
            }
            _up(t) {
                const { data: e72 , compare: r41  } = this, n28 = e72[t];
                for(; t > 0;){
                    const i22 = t - 1 >> 1, s17 = e72[i22];
                    if (r41(n28, s17) >= 0) break;
                    e72[t] = s17, t = i22;
                }
                e72[t] = n28;
            }
            _down(t) {
                const { data: e72 , compare: r41  } = this, n28 = this.length >> 1, i22 = e72[t];
                for(; t < n28;){
                    let n29 = 1 + (t << 1), s17 = e72[n29];
                    const a11 = n29 + 1;
                    if (a11 < this.length && r41(e72[a11], s17) < 0 && (n29 = a11, s17 = e72[a11]), r41(s17, i22) >= 0) break;
                    e72[t] = s17, t = n29;
                }
                e72[t] = i22;
            }
        }
        function Vp(t99, e72) {
            return t99 < e72 ? -1 : t99 > e72 ? 1 : 0;
        }
        function Lp(t99, e72 = 1, r41 = !1) {
            let n28 = 1 / 0, i22 = 1 / 0, s17 = -1 / 0, a11 = -1 / 0;
            const o12 = t99[0];
            for(let t100 = 0; t100 < o12.length; t100++){
                const e73 = o12[t100];
                (!t100 || e73.x < n28) && (n28 = e73.x), (!t100 || e73.y < i22) && (i22 = e73.y), (!t100 || e73.x > s17) && (s17 = e73.x), (!t100 || e73.y > a11) && (a11 = e73.y);
            }
            const l10 = Math.min(s17 - n28, a11 - i22);
            let u9 = l10 / 2;
            const c7 = new Dp([], Fp);
            if (0 === l10) return new d2(n28, i22);
            for(let e73 = n28; e73 < s17; e73 += l10)for(let r42 = i22; r42 < a11; r42 += l10)c7.push(new Rp(e73 + u9, r42 + u9, u9, t99));
            let h5 = function(t101) {
                let e74 = 0, r43 = 0, n29 = 0;
                const i23 = t101[0];
                for(let t102 = 0, s18 = i23.length, a12 = s18 - 1; t102 < s18; a12 = t102++){
                    const s18 = i23[t102], o13 = i23[a12], l11 = s18.x * o13.y - o13.x * s18.y;
                    r43 += (s18.x + o13.x) * l11, n29 += (s18.y + o13.y) * l11, e74 += 3 * l11;
                }
                return new Rp(r43 / e74, n29 / e74, 0, t101);
            }(t99), p5 = c7.length;
            for(; c7.length;){
                const n29 = c7.pop();
                (n29.d > h5.d || !h5.d) && (h5 = n29, r41 && console.log("found best %d after %d probes", Math.round(10000 * n29.d) / 10000, p5)), n29.max - h5.d <= e72 || (u9 = n29.h / 2, c7.push(new Rp(n29.p.x - u9, n29.p.y - u9, u9, t99)), c7.push(new Rp(n29.p.x + u9, n29.p.y - u9, u9, t99)), c7.push(new Rp(n29.p.x - u9, n29.p.y + u9, u9, t99)), c7.push(new Rp(n29.p.x + u9, n29.p.y + u9, u9, t99)), p5 += 4);
            }
            return r41 && (console.log(`num probes: ${p5}`), console.log(`best distance: ${h5.d}`)), h5.p;
        }
        function Fp(t99, e72) {
            return e72.max - t99.max;
        }
        function Rp(t99, e72, r41, n28) {
            this.p = new d2(t99, e72), this.h = r41, this.d = (function(t100, e73) {
                let r42 = !1, n29 = 1 / 0;
                for(let i22 = 0; i22 < e73.length; i22++){
                    const s17 = e73[i22];
                    for(let e74 = 0, i23 = s17.length, a11 = i23 - 1; e74 < i23; a11 = e74++){
                        const i23 = s17[e74], o12 = s17[a11];
                        i23.y > t100.y != o12.y > t100.y && t100.x < (o12.x - i23.x) * (t100.y - i23.y) / (o12.y - i23.y) + i23.x && (r42 = !r42), n29 = Math.min(n29, il(t100, i23, o12));
                    }
                }
                return (r42 ? 1 : -1) * Math.sqrt(n29);
            })(this.p, n28), this.max = this.d + this.h * Math.SQRT2;
        }
        const jp = Number.POSITIVE_INFINITY, Up = Math.sqrt(2);
        function $p(t99, [e72, r41]) {
            let n28 = 0, i22 = 0;
            if (r41 === jp) {
                e72 < 0 && (e72 = 0);
                const r42 = e72 / Up;
                switch(t99){
                    case "top-right":
                    case "top-left":
                        i22 = r42 - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                        i22 = 7 - r42;
                        break;
                    case "bottom":
                        i22 = 7 - e72;
                        break;
                    case "top":
                        i22 = e72 - 7;
                }
                switch(t99){
                    case "top-right":
                    case "bottom-right":
                        n28 = -r42;
                        break;
                    case "top-left":
                    case "bottom-left":
                        n28 = r42;
                        break;
                    case "left":
                        n28 = e72;
                        break;
                    case "right":
                        n28 = -e72;
                }
            } else {
                switch(e72 = Math.abs(e72), r41 = Math.abs(r41), t99){
                    case "top-right":
                    case "top-left":
                    case "top":
                        i22 = r41 - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                    case "bottom":
                        i22 = 7 - r41;
                }
                switch(t99){
                    case "top-right":
                    case "bottom-right":
                    case "right":
                        n28 = -e72;
                        break;
                    case "top-left":
                    case "bottom-left":
                    case "left":
                        n28 = e72;
                }
            }
            return [
                n28,
                i22
            ];
        }
        function Op(t99, e72, r41, n28, i22, s17, a11, o12, l10, u9) {
            t99.createArrays(), t99.tilePixelRatio = So / (512 * t99.overscaling), t99.compareText = {
            }, t99.iconsNeedLinear = !1;
            const c7 = t99.layers[0].layout, h5 = t99.layers[0]._unevaluatedLayout._values, p5 = {
            };
            if ("composite" === t99.textSizeData.kind) {
                const { minZoom: e73 , maxZoom: r42  } = t99.textSizeData;
                p5.compositeTextSizes = [
                    h5["text-size"].possiblyEvaluate(new Us(e73), o12),
                    h5["text-size"].possiblyEvaluate(new Us(r42), o12)
                ];
            }
            if ("composite" === t99.iconSizeData.kind) {
                const { minZoom: e73 , maxZoom: r42  } = t99.iconSizeData;
                p5.compositeIconSizes = [
                    h5["icon-size"].possiblyEvaluate(new Us(e73), o12),
                    h5["icon-size"].possiblyEvaluate(new Us(r42), o12)
                ];
            }
            p5.layoutTextSize = h5["text-size"].possiblyEvaluate(new Us(l10 + 1), o12), p5.layoutIconSize = h5["icon-size"].possiblyEvaluate(new Us(l10 + 1), o12), p5.textMaxSize = h5["text-size"].possiblyEvaluate(new Us(18), o12);
            const f4 = "map" === c7.get("text-rotation-alignment") && "point" !== c7.get("symbol-placement"), d4 = c7.get("text-size");
            for (const s18 of t99.features){
                const l11 = c7.get("text-font").evaluate(s18, {
                }, o12).join(","), h6 = d4.evaluate(s18, {
                }, o12), y2 = p5.layoutTextSize.evaluate(s18, {
                }, o12), m2 = (p5.layoutIconSize.evaluate(s18, {
                }, o12), {
                    horizontal: {
                    },
                    vertical: void 0
                }), g2 = s18.text;
                let x2, v2 = [
                    0,
                    0
                ];
                if (g2) {
                    const n29 = g2.toString(), a12 = c7.get("text-letter-spacing").evaluate(s18, {
                    }, o12) * yh, u10 = c7.get("text-line-height").evaluate(s18, {
                    }, o12) * yh, p6 = ws(n29) ? a12 : 0, d5 = c7.get("text-anchor").evaluate(s18, {
                    }, o12), x3 = c7.get("text-variable-anchor");
                    if (!x3) {
                        const t100 = c7.get("text-radial-offset").evaluate(s18, {
                        }, o12);
                        v2 = t100 ? $p(d5, [
                            t100 * yh,
                            jp
                        ]) : c7.get("text-offset").evaluate(s18, {
                        }, o12).map((t101)=>t101 * yh
                        );
                    }
                    let b2 = f4 ? "center" : c7.get("text-justify").evaluate(s18, {
                    }, o12);
                    const w2 = "point" === c7.get("symbol-placement"), _2 = w2 ? c7.get("text-max-width").evaluate(s18, {
                    }, o12) * yh : 1 / 0, A2 = (s19)=>{
                        t99.allowVerticalPlacement && bs(n29) && (m2.vertical = rp(g2, e72, r41, i22, l11, _2, u10, d5, s19, p6, v2, Qh.vertical, !0, y2, h6));
                    };
                    if (!f4 && x3) {
                        const t100 = "auto" === b2 ? x3.map((t101)=>qp(t101)
                        ) : [
                            b2
                        ];
                        let n30 = !1;
                        for(let s19 = 0; s19 < t100.length; s19++){
                            const a13 = t100[s19];
                            if (!m2.horizontal[a13]) {
                                if (n30) m2.horizontal[a13] = m2.horizontal[0];
                                else {
                                    const t101 = rp(g2, e72, r41, i22, l11, _2, u10, "center", a13, p6, v2, Qh.horizontal, !1, y2, h6);
                                    t101 && (m2.horizontal[a13] = t101, n30 = 1 === t101.positionedLines.length);
                                }
                            }
                        }
                        A2("left");
                    } else {
                        if ("auto" === b2 && (b2 = qp(d5)), w2 || c7.get("text-writing-mode").indexOf("horizontal") >= 0 || !bs(n29)) {
                            const t100 = rp(g2, e72, r41, i22, l11, _2, u10, d5, b2, p6, v2, Qh.horizontal, !1, y2, h6);
                            t100 && (m2.horizontal[b2] = t100);
                        }
                        A2(w2 ? "left" : b2);
                    }
                }
                let b2 = !1;
                if (s18.icon && s18.icon.name) {
                    const e73 = n28[s18.icon.name];
                    e73 && (x2 = pp(i22[s18.icon.name], c7.get("icon-offset").evaluate(s18, {
                    }, o12), c7.get("icon-anchor").evaluate(s18, {
                    }, o12)), b2 = e73.sdf, (void 0) === t99.sdfIcons ? t99.sdfIcons = e73.sdf : t99.sdfIcons !== e73.sdf && $("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e73.pixelRatio !== t99.pixelRatio || 0 !== c7.get("icon-rotate").constantOr(1)) && (t99.iconsNeedLinear = !0));
                }
                const w2 = Zp(m2.horizontal) || m2.vertical;
                t99.iconsInText || (t99.iconsInText = !!w2 && w2.iconsInText), (w2 || x2) && Np(t99, s18, m2, x2, n28, p5, y2, 0, v2, b2, a11, o12, u9);
            }
            s17 && t99.generateCollisionDebugBuffers(l10, t99.collisionBoxArray);
        }
        function qp(t99) {
            switch(t99){
                case "right":
                case "top-right":
                case "bottom-right":
                    return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                    return "left";
            }
            return "center";
        }
        function Np(t99, e72, r41, n28, i22, s17, a11, o12, l10, u9, c7, h5, p5) {
            let f4 = s17.textMaxSize.evaluate(e72, {
            }, h5);
            (void 0) === f4 && (f4 = a11);
            const d4 = t99.layers[0].layout, y2 = d4.get("icon-offset").evaluate(e72, {
            }, h5), m2 = Zp(r41.horizontal) || r41.vertical, g2 = "globe" === p5.name, v2 = a11 / 24, b2 = t99.tilePixelRatio * f4 / 24, w2 = (z2 = t99.overscaling, t99.zoom > 18 && z2 > 2 && (z2 >>= 1), Math.max(So / (512 * z2), 1) * d4.get("symbol-spacing")), _2 = d4.get("text-padding") * t99.tilePixelRatio, A2 = d4.get("icon-padding") * t99.tilePixelRatio, S2 = x1(d4.get("text-max-angle")), k2 = "map" === d4.get("text-rotation-alignment") && "point" !== d4.get("symbol-placement"), I2 = "map" === d4.get("icon-rotation-alignment") && "point" !== d4.get("symbol-placement"), M2 = d4.get("symbol-placement"), T2 = w2 / 2;
            var z2;
            const B2 = d4.get("icon-text-fit");
            let E1;
            n28 && "none" !== B2 && (t99.allowVerticalPlacement && r41.vertical && (E1 = fp(n28, r41.vertical, B2, d4.get("icon-text-fit-padding"), y2, v2)), m2 && (n28 = fp(n28, m2, B2, d4.get("icon-text-fit-padding"), y2, v2)));
            const C1 = (a12, o13, f5)=>{
                if (o13.x < 0 || o13.x >= So || o13.y < 0 || o13.y >= So) return;
                let d5 = null;
                if (g2) {
                    const { x: t100 , y: e73 , z: r42  } = p5.projectTilePoint(o13.x, o13.y, f5);
                    d5 = {
                        anchor: new dp(t100, e73, r42, 0, void 0),
                        up: p5.upVector(f5, o13.x, o13.y)
                    };
                }
                !function(t100, e73, r42, n29, i23, s18, a13, o14, l11, u10, c8, h6, p6, f6, d6, y3, m3, g3, x2, v3, b3, w3, _3, A3, S3) {
                    const k3 = t100.addToLineVertexArray(e73, n29);
                    let I3, M3, T3, z3, B3, E2, C2, P1 = 0, D1 = 0, V1 = 0, L1 = 0, F1 = -1, R1 = -1;
                    const j1 = {
                    };
                    let U1 = qa.exports("");
                    const O1 = r42 ? r42.anchor : e73;
                    let q1 = 0, N1 = 0;
                    if ((void 0) === l11._unevaluatedLayout.getValue("text-radial-offset") ? [q1, N1] = l11.layout.get("text-offset").evaluate(b3, {
                    }, S3).map((t101)=>t101 * yh
                    ) : (q1 = l11.layout.get("text-radial-offset").evaluate(b3, {
                    }, S3) * yh, N1 = jp), t100.allowVerticalPlacement && i23.vertical) {
                        const t101 = i23.vertical;
                        if (d6) E2 = Yp(t101), o14 && (C2 = Yp(o14));
                        else {
                            const r43 = l11.layout.get("text-rotate").evaluate(b3, {
                            }, S3) + 90;
                            T3 = Kp(u10, O1, e73, c8, h6, p6, t101, f6, r43, y3), o14 && (z3 = Kp(u10, O1, e73, c8, h6, p6, o14, g3, r43));
                        }
                    }
                    if (s18) {
                        const n30 = l11.layout.get("icon-rotate").evaluate(b3, {
                        }, S3), i24 = "none" !== l11.layout.get("icon-text-fit"), a14 = Tp(s18, n30, _3, i24), f7 = o14 ? Tp(o14, n30, _3, i24) : void 0;
                        M3 = Kp(u10, O1, e73, c8, h6, p6, s18, g3, n30), P1 = 4 * a14.length;
                        const d7 = t100.iconSizeData;
                        let y4 = null;
                        "source" === d7.kind ? (y4 = [
                            mh * l11.layout.get("icon-size").evaluate(b3, {
                            }, S3)
                        ], y4[0] > Gp && $(`${t100.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d7.kind && (y4 = [
                            mh * w3.compositeIconSizes[0].evaluate(b3, {
                            }, S3),
                            mh * w3.compositeIconSizes[1].evaluate(b3, {
                            }, S3)
                        ], (y4[0] > Gp || y4[1] > Gp) && $(`${t100.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t100.addSymbols(t100.icon, a14, y4, v3, x2, b3, !1, r42, e73, k3.lineStartIndex, k3.lineLength, -1, A3, S3), F1 = t100.icon.placedSymbolArray.length - 1, f7 && (D1 = 4 * f7.length, t100.addSymbols(t100.icon, f7, y4, v3, x2, b3, Qh.vertical, r42, e73, k3.lineStartIndex, k3.lineLength, -1, A3, S3), R1 = t100.icon.placedSymbolArray.length - 1);
                    }
                    for(const n30 in i23.horizontal){
                        const s19 = i23.horizontal[n30];
                        I3 || (U1 = qa.exports(s19.text), d6 ? B3 = Yp(s19) : I3 = Kp(u10, O1, e73, c8, h6, p6, s19, f6, l11.layout.get("text-rotate").evaluate(b3, {
                        }, S3), y3));
                        const o15 = 1 === s19.positionedLines.length;
                        if (V1 += Xp(t100, r42, e73, s19, a13, l11, d6, b3, y3, k3, i23.vertical ? Qh.horizontal : Qh.horizontalOnly, o15 ? Object.keys(i23.horizontal) : [
                            n30
                        ], j1, F1, w3, A3, S3), o15) break;
                    }
                    i23.vertical && (L1 += Xp(t100, r42, e73, i23.vertical, a13, l11, d6, b3, y3, k3, Qh.vertical, [
                        "vertical"
                    ], j1, R1, w3, A3, S3));
                    let G1 = -1;
                    const X1 = (t101, e74)=>t101 ? Math.max(t101, e74) : e74
                    ;
                    G1 = X1(B3, G1), G1 = X1(E2, G1), G1 = X1(C2, G1);
                    const Z1 = G1 > -1 ? 1 : 0;
                    t100.glyphOffsetArray.length >= cd.MAX_GLYPHS && $("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), (void 0) !== b3.sortKey && t100.addToSortKeyRanges(t100.symbolInstances.length, b3.sortKey), t100.symbolInstances.emplaceBack(O1.x, O1.y, O1.z, e73.x, e73.y, j1.right >= 0 ? j1.right : -1, j1.center >= 0 ? j1.center : -1, j1.left >= 0 ? j1.left : -1, j1.vertical >= 0 ? j1.vertical : -1, F1, R1, U1, (void 0) !== I3 ? I3 : t100.collisionBoxArray.length, (void 0) !== I3 ? I3 + 1 : t100.collisionBoxArray.length, (void 0) !== T3 ? T3 : t100.collisionBoxArray.length, (void 0) !== T3 ? T3 + 1 : t100.collisionBoxArray.length, (void 0) !== M3 ? M3 : t100.collisionBoxArray.length, (void 0) !== M3 ? M3 + 1 : t100.collisionBoxArray.length, z3 || t100.collisionBoxArray.length, z3 ? z3 + 1 : t100.collisionBoxArray.length, c8, V1, L1, P1, D1, Z1, 0, q1, N1, G1);
                }(t99, o13, d5, a12, r41, n28, i22, E1, t99.layers[0], t99.collisionBoxArray, e72.index, e72.sourceLayerIndex, t99.index, _2, k2, l10, 0, A2, I2, y2, e72, s17, u9, c7, h5);
            };
            if ("line" === M2) for (const i23 of _p(e72.geometry, 0, 0, So, So)){
                const e73 = bp(i23, w2, S2, r41.vertical || m2, n28, 24, b2, t99.overscaling, So);
                for (const r42 of e73){
                    const e74 = m2;
                    e74 && Hp(t99, e74.text, T2, r42) || C1(i23, r42, h5);
                }
            }
            else if ("line-center" === M2) {
                for (const t100 of e72.geometry)if (t100.length > 1) {
                    const e73 = vp(t100, S2, r41.vertical || m2, n28, 24, b2);
                    e73 && C1(t100, e73, h5);
                }
            } else if ("Polygon" === e72.type) for (const t100 of tc(e72.geometry, 0)){
                const e73 = Lp(t100, 16);
                C1(t100[0], new dp(e73.x, e73.y, 0, 0, void 0), h5);
            }
            else if ("LineString" === e72.type) for (const t101 of e72.geometry)C1(t101, new dp(t101[0].x, t101[0].y, 0, 0, void 0), h5);
            else if ("Point" === e72.type) for (const t102 of e72.geometry)for (const e73 of t102)C1([
                e73
            ], new dp(e73.x, e73.y, 0, 0, void 0), h5);
        }
        const Gp = 32640;
        function Xp(t99, e72, r41, n28, i22, s17, a11, o12, l10, u9, c7, h5, p5, f4, y2, m2, g2) {
            const x2 = function(t100, e73, r42, n29, i23, s18, a12, o13) {
                const l11 = [];
                if (0 === e73.positionedLines.length) return l11;
                const u10 = n29.layout.get("text-rotate").evaluate(s18, {
                }) * Math.PI / 180, c8 = function(t101) {
                    const e74 = t101[0], r43 = t101[1], n30 = e74 * r43;
                    return n30 > 0 ? [
                        e74,
                        -r43
                    ] : n30 < 0 ? [
                        -e74,
                        r43
                    ] : 0 === e74 ? [
                        r43,
                        e74
                    ] : [
                        r43,
                        -e74
                    ];
                }(r42);
                let h6 = Math.abs(e73.top - e73.bottom);
                for (const t101 of e73.positionedLines)h6 -= t101.lineOffset;
                const p6 = e73.positionedLines.length, f5 = h6 / p6;
                let y3 = e73.top - r42[1];
                for(let t102 = 0; t102 < p6; ++t102){
                    const n30 = e73.positionedLines[t102];
                    y3 = Pp(e73, f5, y3, t102);
                    for (const t103 of n30.positionedGlyphs){
                        if (!t103.rect) continue;
                        const n31 = t103.rect || {
                        };
                        let s19 = 4, h7 = !0, p7 = 1, f6 = 0;
                        if (t103.imageName) {
                            const e74 = a12[t103.imageName];
                            if (!e74) continue;
                            if (e74.sdf) {
                                $("SDF images are not supported in formatted text and will be ignored.");
                                continue;
                            }
                            h7 = !1, p7 = e74.pixelRatio, s19 = 1 / p7;
                        }
                        const m3 = (i23 || o13) && t103.vertical, g3 = t103.metrics.advance * t103.scale / 2, x3 = t103.metrics, v2 = t103.rect;
                        if (null === v2) continue;
                        o13 && e73.verticalizable && (f6 = t103.imageName ? g3 - t103.metrics.width * t103.scale / 2 : 0);
                        const b2 = i23 ? [
                            t103.x + g3,
                            t103.y
                        ] : [
                            0,
                            0
                        ];
                        let w2 = [
                            0,
                            0
                        ], _2 = [
                            0,
                            0
                        ], A2 = !1;
                        i23 || (m3 ? (_2 = [
                            t103.x + g3 + c8[0],
                            t103.y + c8[1] - f6
                        ], A2 = !0) : w2 = [
                            t103.x + g3 + r42[0],
                            t103.y + r42[1] - f6
                        ]);
                        const S2 = v2.w * t103.scale / (p7 * (t103.localGlyph ? 2 : 1)), k2 = v2.h * t103.scale / (p7 * (t103.localGlyph ? 2 : 1));
                        let I2, M2, T2, z2;
                        if (m3) {
                            const e74 = t103.y - y3, r43 = new d2(-g3, g3 - e74), n32 = -Math.PI / 2, i24 = new d2(..._2);
                            I2 = new d2(-g3 + w2[0], w2[1]), I2._rotateAround(n32, r43)._add(i24), I2.x += -e74 + g3, I2.y -= (x3.left - s19) * t103.scale;
                            const a13 = t103.imageName ? x3.advance * t103.scale : yh * t103.scale, o14 = String.fromCharCode(t103.glyph);
                            Ah(o14) ? I2.x += (1 - s19) * t103.scale : Sh(o14) ? I2.x += a13 - x3.height * t103.scale + (-s19 - 1) * t103.scale : I2.x += t103.imageName || x3.width + 2 * s19 === v2.w && x3.height + 2 * s19 === v2.h ? (a13 - k2) / 2 : (a13 - (x3.height + 2 * s19) * t103.scale) / 2, M2 = new d2(I2.x, I2.y - S2), T2 = new d2(I2.x + k2, I2.y), z2 = new d2(I2.x + k2, I2.y - S2);
                        } else {
                            const e74 = (x3.left - s19) * t103.scale - g3 + w2[0], r43 = (-x3.top - s19) * t103.scale + w2[1], n32 = e74 + S2, i24 = r43 + k2;
                            I2 = new d2(e74, r43), M2 = new d2(n32, r43), T2 = new d2(e74, i24), z2 = new d2(n32, i24);
                        }
                        if (u10) {
                            let t104;
                            t104 = i23 ? new d2(0, 0) : A2 ? new d2(c8[0], c8[1]) : new d2(r42[0], r42[1]), I2._rotateAround(u10, t104), M2._rotateAround(u10, t104), T2._rotateAround(u10, t104), z2._rotateAround(u10, t104);
                        }
                        const B2 = new d2(0, 0), E1 = new d2(0, 0);
                        l11.push({
                            tl: I2,
                            tr: M2,
                            bl: T2,
                            br: z2,
                            tex: n31,
                            writingMode: e73.writingMode,
                            glyphOffset: b2,
                            sectionIndex: t103.sectionIndex,
                            isSDF: h7,
                            pixelOffsetTL: B2,
                            pixelOffsetBR: E1,
                            minFontScaleX: 0,
                            minFontScaleY: 0
                        });
                    }
                }
                return l11;
            }(0, n28, l10, s17, a11, o12, i22, t99.allowVerticalPlacement), v2 = t99.textSizeData;
            let b2 = null;
            "source" === v2.kind ? (b2 = [
                mh * s17.layout.get("text-size").evaluate(o12, {
                }, g2)
            ], b2[0] > Gp && $(`${t99.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === v2.kind && (b2 = [
                mh * y2.compositeTextSizes[0].evaluate(o12, {
                }, g2),
                mh * y2.compositeTextSizes[1].evaluate(o12, {
                }, g2)
            ], (b2[0] > Gp || b2[1] > Gp) && $(`${t99.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t99.addSymbols(t99.text, x2, b2, l10, a11, o12, c7, e72, r41, u9.lineStartIndex, u9.lineLength, f4, m2, g2);
            for (const e73 of h5)p5[e73] = t99.text.placedSymbolArray.length - 1;
            return 4 * x2.length;
        }
        function Zp(t99) {
            for(const e72 in t99)return t99[e72];
            return null;
        }
        function Kp(t99, e72, r41, n28, i22, s17, a11, o12, l10, u9) {
            let c7 = a11.top, h5 = a11.bottom, p5 = a11.left, f4 = a11.right;
            const y2 = a11.collisionPadding;
            if (y2 && (p5 -= y2[0], c7 -= y2[1], f4 += y2[2], h5 += y2[3]), l10) {
                const t100 = new d2(p5, c7), e73 = new d2(f4, c7), r42 = new d2(p5, h5), n29 = new d2(f4, h5), i23 = x1(l10);
                let s18 = new d2(0, 0);
                u9 && (s18 = new d2(u9[0], u9[1])), t100._rotateAround(i23, s18), e73._rotateAround(i23, s18), r42._rotateAround(i23, s18), n29._rotateAround(i23, s18), p5 = Math.min(t100.x, e73.x, r42.x, n29.x), f4 = Math.max(t100.x, e73.x, r42.x, n29.x), c7 = Math.min(t100.y, e73.y, r42.y, n29.y), h5 = Math.max(t100.y, e73.y, r42.y, n29.y);
            }
            return t99.emplaceBack(e72.x, e72.y, e72.z, r41.x, r41.y, p5, c7, f4, h5, o12, n28, i22, s17), t99.length - 1;
        }
        function Yp(t99) {
            t99.collisionPadding && (t99.top -= t99.collisionPadding[1], t99.bottom += t99.collisionPadding[3]);
            const e72 = t99.bottom - t99.top;
            return e72 > 0 ? Math.max(10, e72) : null;
        }
        function Hp(t99, e72, r41, n28) {
            const i22 = t99.compareText;
            if (e72 in i22) {
                const t100 = i22[e72];
                for(let e73 = t100.length - 1; e73 >= 0; e73--)if (n28.dist(t100[e73]) < r41) return !0;
            } else i22[e72] = [];
            return i22[e72].push(n28), !1;
        }
        const Wp = na([
            {
                type: "Float32",
                name: "a_globe_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]), { members: Jp  } = Wp, Qp = na([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            }
        ]);
        var tf = na([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            }
        ]);
        const ef = So / Math.PI / 2, rf = 2 * Co(1, 0) * ef * Math.PI, nf = 64, sf = [
            nf,
            32,
            16
        ], af = -ef, of = ef, lf = [
            new au([
                af,
                af,
                af
            ], [
                of,
                of,
                of
            ]),
            new au([
                af,
                af,
                af
            ], [
                0,
                0,
                of
            ]),
            new au([
                0,
                af,
                af
            ], [
                of,
                0,
                of
            ]),
            new au([
                af,
                0,
                af
            ], [
                0,
                of,
                of
            ]),
            new au([
                0,
                0,
                af
            ], [
                of,
                of,
                of
            ])
        ];
        function uf(t99, e72, r41, n28 = !0) {
            const i22 = Rl([], t99._camera.position, t99.worldSize), s17 = [
                e72,
                r41,
                1,
                1
            ];
            Wl(s17, s17, t99.pixelMatrixInverse), Yl(s17, s17, 1 / s17[3]);
            const a11 = Ul([], Xl([], s17, i22)), o12 = t99.globeMatrix, l10 = [
                o12[12],
                o12[13],
                o12[14]
            ], u9 = Xl([], l10, i22), c7 = El(u9), h5 = Ul([], u9), p5 = t99.worldSize / (2 * Math.PI), f4 = $l(h5, a11), d4 = Math.asin(p5 / c7);
            if (d4 < Math.acos(f4)) {
                if (!n28) return null;
                const t100 = [], e73 = [];
                Rl(t100, a11, c7 / f4), Ul(e73, Xl(e73, t100, u9)), Ul(a11, Pl(a11, u9, Rl(a11, e73, Math.tan(d4) * c7)));
            }
            const y2 = [];
            new nu(i22, a11).closestPointOnSphere(l10, p5, y2);
            const m2 = Ul([], Y(o12, 0)), g2 = Ul([], Y(o12, 1)), x2 = Ul([], Y(o12, 2)), b2 = $l(m2, y2), w2 = $l(g2, y2), _2 = $l(x2, y2), A2 = v1(Math.asin(-w2 / p5));
            let k2 = v1(Math.atan2(b2, _2));
            k2 = t99.center.lng + (function(t100, e73) {
                const r42 = (e73 - t100 + 180) % 360 - 180;
                return r42 < -180 ? r42 + 360 : r42;
            })(t99.center.lng, k2);
            const I2 = Bo(k2), M2 = S1(Eo(A2), 0, 1);
            return new Ro(I2, M2);
        }
        class cf {
            constructor(t99, e72, r41){
                this.a = Xl([], t99, r41), this.b = Xl([], e72, r41), this.center = r41;
                const n28 = Ul([], this.a), i22 = Ul([], this.b);
                this.angle = Math.acos($l(n28, i22));
            }
        }
        function hf(t100, e73) {
            if (0 === t100.angle) return null;
            let r42;
            return r42 = 0 === t100.a[e73] ? 1 / t100.angle * 0.5 * Math.PI : 1 / t100.angle * Math.atan(t100.b[e73] / t100.a[e73] / Math.sin(t100.angle) - 1 / Math.tan(t100.angle)), r42 < 0 || r42 > 1 ? null : (function(t101, e74, r43, n29) {
                const i23 = Math.sin(r43);
                return t101 * (Math.sin((1 - n29) * r43) / i23) + e74 * (Math.sin(n29 * r43) / i23);
            })(t100.a[e73], t100.b[e73], t100.angle, S1(r42, 0, 1)) + t100.center[e73];
        }
        function pf(t100) {
            if (t100.z <= 1) return lf[t100.z + 2 * t100.y + t100.x];
            const e73 = xf(gf(t100));
            return au.fromPoints(e73);
        }
        function ff(t100, e73, r42) {
            return Rl(t100, t100, 1 - r42), jl(t100, t100, e73, r42);
        }
        function df(t100, e73) {
            const r42 = Mf(e73.zoom);
            if (0 === r42) return pf(t100);
            const n29 = gf(t100), i23 = xf(n29), s17 = Bo(n29.getWest()) * e73.worldSize, a11 = Bo(n29.getEast()) * e73.worldSize, o12 = Eo(n29.getNorth()) * e73.worldSize, l10 = Eo(n29.getSouth()) * e73.worldSize, u9 = [
                s17,
                o12,
                0
            ], c7 = [
                a11,
                o12,
                0
            ], h5 = [
                s17,
                l10,
                0
            ], p5 = [
                a11,
                l10,
                0
            ], f4 = bl([], e73.globeMatrix);
            return ql(u9, u9, f4), ql(c7, c7, f4), ql(h5, h5, f4), ql(p5, p5, f4), i23[0] = ff(i23[0], h5, r42), i23[1] = ff(i23[1], p5, r42), i23[2] = ff(i23[2], c7, r42), i23[3] = ff(i23[3], u9, r42), au.fromPoints(i23);
        }
        function yf(t100, e73, r42) {
            for (const n29 of t100)ql(n29, n29, e73), Rl(n29, n29, r42);
        }
        function mf(t100, e73, r42) {
            const n29 = e73 / t100.worldSize, i23 = t100.globeMatrix;
            if (r42.z <= 1) {
                const t101 = pf(r42).getCorners();
                return yf(t101, i23, n29), au.fromPoints(t101);
            }
            const s17 = gf(r42), a11 = xf(s17);
            yf(a11, i23, n29);
            const o12 = Number.MAX_VALUE, l10 = [
                -o12,
                -o12,
                -o12
            ], u9 = [
                o12,
                o12,
                o12
            ];
            if (s17.contains(t100.center)) {
                for (const t101 of a11)Ll(u9, u9, t101), Fl(l10, l10, t101);
                l10[2] = 0;
                const e74 = t100.point, r43 = [
                    e74.x * n29,
                    e74.y * n29,
                    0
                ];
                return Ll(u9, u9, r43), Fl(l10, l10, r43), new au(u9, l10);
            }
            const c7 = [
                i23[12] * n29,
                i23[13] * n29,
                i23[14] * n29
            ], h5 = s17.getCenter(), p5 = S1(t100.center.lat, -85.051129, Lo), f4 = S1(h5.lat, -85.051129, Lo), d4 = Bo(t100.center.lng), y2 = Eo(p5);
            let m2 = d4 - Bo(h5.lng);
            const g2 = y2 - Eo(f4);
            m2 > 0.5 ? m2 -= 1 : m2 < -0.5 && (m2 += 1);
            let v2 = 0;
            Math.abs(m2) > Math.abs(g2) ? v2 = m2 >= 0 ? 1 : 3 : (v2 = g2 >= 0 ? 0 : 2, jl(c7, c7, [
                i23[4] * n29,
                i23[5] * n29,
                i23[6] * n29
            ], -Math.sin(x1(g2 >= 0 ? s17.getSouth() : s17.getNorth())) * ef));
            const b2 = a11[v2], w2 = a11[(v2 + 1) % 4], _2 = new cf(b2, w2, c7), A2 = [
                hf(_2, 0) || b2[0],
                hf(_2, 1) || b2[1],
                hf(_2, 2) || b2[2]
            ], k2 = Mf(t100.zoom);
            if (k2 > 0) {
                const n30 = function({ x: t101 , y: e74 , z: r43  }, n31, i24, s18, a12) {
                    const o13 = 1 / (1 << r43);
                    let l11 = t101 * o13, u10 = l11 + o13, c8 = e74 * o13, h6 = c8 + o13, p6 = 0;
                    const f5 = (l11 + u10) / 2 - s18;
                    return f5 > 0.5 ? p6 = -1 : f5 < -0.5 && (p6 = 1), l11 = ((l11 + p6) * n31 - (s18 *= n31)) * i24 + s18, u10 = ((u10 + p6) * n31 - s18) * i24 + s18, c8 = (c8 * n31 - (a12 *= n31)) * i24 + a12, h6 = (h6 * n31 - a12) * i24 + a12, [
                        [
                            l11,
                            h6,
                            0
                        ],
                        [
                            u10,
                            h6,
                            0
                        ],
                        [
                            u10,
                            c8,
                            0
                        ],
                        [
                            l11,
                            c8,
                            0
                        ]
                    ];
                }(r42, e73, t100._pixelsPerMercatorPixel, d4, y2);
                for(let t101 = 0; t101 < a11.length; t101++)ff(a11[t101], n30[t101], k2);
                const i24 = Pl([], n30[v2], n30[(v2 + 1) % 4]);
                Rl(i24, i24, 0.5), ff(A2, i24, k2);
            }
            for (const t101 of a11)Ll(u9, u9, t101), Fl(l10, l10, t101);
            return u9[2] = Math.min(b2[2], w2[2]), Ll(u9, u9, A2), Fl(l10, l10, A2), new au(u9, l10);
        }
        function gf({ x: t100 , y: e73 , z: r42  }) {
            const n29 = 1 / (1 << r42), i23 = new Mo(Po(t100 * n29), Do((e73 + 1) * n29)), s17 = new Mo(Po((t100 + 1) * n29), Do(e73 * n29));
            return new ko(i23, s17);
        }
        function xf(t100) {
            const e73 = x1(t100.getNorth()), r42 = x1(t100.getSouth()), n29 = Math.cos(e73), i23 = Math.cos(r42), s17 = Math.sin(e73), a11 = Math.sin(r42), o12 = t100.getWest(), l10 = t100.getEast();
            return [
                vf(i23, a11, o12),
                vf(i23, a11, l10),
                vf(n29, s17, l10),
                vf(n29, s17, o12)
            ];
        }
        function vf(t100, e73, r42, n29 = ef) {
            return r42 = x1(r42), [
                t100 * Math.sin(r42) * n29,
                -e73 * n29,
                t100 * Math.cos(r42) * n29
            ];
        }
        function bf(t100, e73, r42) {
            return vf(Math.cos(x1(t100)), Math.sin(x1(t100)), e73, r42);
        }
        function wf(t100, e73, r42, n29) {
            const i23 = 1 << r42.z, s17 = (t100 / So + r42.x) / i23;
            return bf(Do((e73 / So + r42.y) / i23), Po(s17), n29);
        }
        function _f({ min: t100 , max: e73  }) {
            return 16383 / Math.max(e73[0] - t100[0], e73[1] - t100[1], e73[2] - t100[2]);
        }
        const Af = new Float64Array(16);
        function Sf(t100) {
            const e73 = _f(t100), r42 = Il(Af, [
                e73,
                e73,
                e73
            ]);
            var n29, i23;
            return _l(r42, r42, ((n29 = [])[0] = -(i23 = t100.min)[0], n29[1] = -i23[1], n29[2] = -i23[2], n29));
        }
        function kf(t100) {
            const e73 = (n29 = t100.min, (r42 = Af)[0] = 1, r42[1] = 0, r42[2] = 0, r42[3] = 0, r42[4] = 0, r42[5] = 1, r42[6] = 0, r42[7] = 0, r42[8] = 0, r42[9] = 0, r42[10] = 1, r42[11] = 0, r42[12] = n29[0], r42[13] = n29[1], r42[14] = n29[2], r42[15] = 1, r42);
            var r42, n29;
            const i23 = 1 / _f(t100);
            return Al(e73, e73, [
                i23,
                i23,
                i23
            ]);
        }
        function If(t100, e73, r42, n29, i23) {
            const s17 = function(t101) {
                const e74 = So / (2 * Math.PI);
                return t101 / (2 * Math.PI) / e74;
            }(r42), a11 = [
                t100,
                e73,
                -r42 / (2 * Math.PI)
            ], o12 = vl(new Float64Array(16));
            return _l(o12, o12, a11), Al(o12, o12, [
                s17,
                s17,
                s17
            ]), Sl(o12, o12, x1(-i23)), kl(o12, o12, x1(-n29)), o12;
        }
        function Mf(t100) {
            return k1(5, 6, t100);
        }
        function Tf(t100, e73) {
            const r42 = bf(e73.lat, e73.lng), n29 = function(t101) {
                const e74 = bf(t101._center.lat, t101._center.lng);
                let r43 = Ol([], Cl(0, 1, 0), e74);
                const n30 = Ml([], -t101.angle, e74);
                r43 = ql(r43, r43, n30), Ml(n30, -t101._pitch, r43);
                const i23 = Ul([], e74);
                return Rl(i23, i23, t101.cameraToCenterDistance / t101.pixelsPerMeter * rf), ql(i23, i23, n30), Pl([], e74, i23);
            }(t100);
            var i23, s17, a11, o12, l10, u9, c7, h5, p5, f4;
            return a11 = (i23 = Dl([], n29, r42))[0], o12 = i23[1], l10 = i23[2], u9 = (s17 = r42)[0], c7 = s17[1], h5 = s17[2], f4 = (p5 = Math.sqrt(a11 * a11 + o12 * o12 + l10 * l10) * Math.sqrt(u9 * u9 + c7 * c7 + h5 * h5)) && $l(i23, s17) / p5, Math.acos(Math.min(Math.max(f4, -1), 1));
        }
        function zf(t100, e73) {
            return Tf(t100, e73) > Math.PI / 2 * 1.01;
        }
        const Bf = x1(85), Ef = Math.cos(Bf), Cf = Math.sin(Bf);
        function Pf(t100, e73) {
            const r42 = t100.fovAboveCenter, n29 = t100.elevation ? t100.elevation.getMinElevationBelowMSL() * e73 : 0, i23 = (t100._camera.position[2] * t100.worldSize - n29) / Math.cos(t100._pitch), s17 = Math.sin(r42) * i23 / Math.sin(Math.max(Math.PI / 2 - t100._pitch - r42, 0.01)), a11 = Math.sin(t100._pitch) * s17 + i23;
            return Math.min(1.01 * a11, i23 * (1 / t100._horizonShift));
        }
        function Df(t100, e73) {
            if (!e73.isReprojectedInTileSpace) return {
                scale: 1 << t100.z,
                x: t100.x,
                y: t100.y,
                x2: t100.x + 1,
                y2: t100.y + 1,
                projection: e73
            };
            const r42 = Math.pow(2, -t100.z), n29 = t100.x * r42, i23 = (t100.x + 1) * r42, s17 = t100.y * r42, a11 = (t100.y + 1) * r42, o12 = Po(n29), l10 = Po(i23), u9 = Do(s17), c7 = Do(a11), h5 = e73.project(o12, u9), p5 = e73.project(l10, u9), f4 = e73.project(l10, c7), d4 = e73.project(o12, c7);
            let y2 = Math.min(h5.x, p5.x, f4.x, d4.x), m2 = Math.min(h5.y, p5.y, f4.y, d4.y), g2 = Math.max(h5.x, p5.x, f4.x, d4.x), x2 = Math.max(h5.y, p5.y, f4.y, d4.y);
            const v2 = r42 / 16;
            function b2(t101, r43, n30, i24, s18, a12) {
                const o13 = (n30 + s18) / 2, l11 = (i24 + a12) / 2, u10 = e73.project(Po(o13), Do(l11)), c8 = Math.max(0, y2 - u10.x, m2 - u10.y, u10.x - g2, u10.y - x2);
                y2 = Math.min(y2, u10.x), g2 = Math.max(g2, u10.x), m2 = Math.min(m2, u10.y), x2 = Math.max(x2, u10.y), c8 > v2 && (b2(t101, u10, n30, i24, o13, l11), b2(u10, r43, o13, l11, s18, a12));
            }
            b2(h5, p5, n29, s17, i23, s17), b2(p5, f4, i23, s17, i23, a11), b2(f4, d4, i23, a11, n29, a11), b2(d4, h5, n29, a11, n29, s17), y2 -= v2, m2 -= v2, g2 += v2, x2 += v2;
            const w2 = 1 / Math.max(g2 - y2, x2 - m2);
            return {
                scale: w2,
                x: y2 * w2,
                y: m2 * w2,
                x2: g2 * w2,
                y2: x2 * w2,
                projection: e73
            };
        }
        const Vf = vl(new Float32Array(16));
        class Lf {
            constructor(t100){
                this.spec = t100, this.name = t100.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [
                    "custom"
                ], this.center = [
                    0,
                    0
                ], this.range = [
                    3.5,
                    7
                ];
            }
            project(t, e) {
                return {
                    x: 0,
                    y: 0,
                    z: 0
                };
            }
            unproject(t, e) {
                return new Mo(0, 0);
            }
            projectTilePoint(t, e, r) {
                return {
                    x: t,
                    y: e,
                    z: 0
                };
            }
            locationPoint(t, e, r = !0) {
                return t._coordinatePoint(t.locationCoordinate(e), r);
            }
            pixelsPerMeter(t, e) {
                return Co(1, t) * e;
            }
            pixelSpaceConversion(t, e, r) {
                return 1;
            }
            farthestPixelDistance(t) {
                return Pf(t, t.pixelsPerMeter);
            }
            pointCoordinate(t, e, r, n) {
                const i23 = t.horizonLineFromTop(!1), s17 = new d2(e, Math.max(i23, r));
                return t.rayIntersectionCoordinate(t.pointRayIntersection(s17, n));
            }
            pointCoordinate3D(t, e, r) {
                const n29 = new d2(e, r);
                if (t.elevation) return t.elevation.pointCoordinate(n29);
                {
                    const e73 = this.pointCoordinate(t, n29.x, n29.y, 0);
                    return [
                        e73.x,
                        e73.y,
                        e73.z
                    ];
                }
            }
            isPointAboveHorizon(t, e) {
                if (t.elevation) return !this.pointCoordinate3D(t, e.x, e.y);
                const r42 = t.horizonLineFromTop();
                return e.y < r42;
            }
            createInversionMatrix(t, e) {
                return Vf;
            }
            createTileMatrix(t, e, r) {
                let n29, i23, s17;
                const a11 = r.canonical, o12 = vl(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                    const l10 = Df(a11, this);
                    n29 = 1, i23 = l10.x + r.wrap * l10.scale, s17 = l10.y, Al(o12, o12, [
                        n29 / l10.scale,
                        n29 / l10.scale,
                        t.pixelsPerMeter / e
                    ]);
                } else n29 = e / t.zoomScale(a11.z), i23 = (a11.x + Math.pow(2, a11.z) * r.wrap) * n29, s17 = a11.y * n29;
                return _l(o12, o12, [
                    i23,
                    s17,
                    0
                ]), Al(o12, o12, [
                    n29 / So,
                    n29 / So,
                    1
                ]), o12;
            }
            upVector(t, e, r) {
                return [
                    0,
                    0,
                    1
                ];
            }
            upVectorScale(t, e, r) {
                return {
                    metersToTile: 1
                };
            }
        }
        class Ff extends Lf {
            constructor(t101){
                super(t101), this.range = [
                    4,
                    7
                ], this.center = t101.center || [
                    -96,
                    37.5
                ];
                const [e73, r42] = this.parallels = t101.parallels || [
                    29.5,
                    45.5
                ], n29 = Math.sin(x1(e73));
                this.n = (n29 + Math.sin(x1(r42))) / 2, this.c = 1 + n29 * (2 * this.n - n29), this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t, e) {
                const { n: r43 , c: n30 , r0: i23  } = this, s17 = x1(t - this.center[0]), a11 = x1(e), o12 = Math.sqrt(n30 - 2 * r43 * Math.sin(a11)) / r43;
                return {
                    x: o12 * Math.sin(s17 * r43),
                    y: o12 * Math.cos(s17 * r43) - i23,
                    z: 0
                };
            }
            unproject(t, e) {
                const { n: r43 , c: n30 , r0: i23  } = this, s17 = i23 + e;
                let a11 = Math.atan2(t, Math.abs(s17)) * Math.sign(s17);
                s17 * r43 < 0 && (a11 -= Math.PI * Math.sign(t) * Math.sign(s17));
                const o12 = x1(this.center[0]) * r43;
                a11 = I1(a11, -Math.PI - o12, Math.PI - o12);
                const l10 = S1(v1(a11 / r43) + this.center[0], -180, 180), u9 = Math.asin(S1((n30 - (t * t + s17 * s17) * r43 * r43) / (2 * r43), -1, 1)), c7 = S1(v1(u9), -85.051129, Lo);
                return new Mo(l10, c7);
            }
        }
        const Rf = 1.340264, jf = -0.081106, Uf = 0.000893, $f = 0.003796, Of = Math.sqrt(3) / 2;
        class qf extends Lf {
            project(t, e) {
                e = e / 180 * Math.PI, t = t / 180 * Math.PI;
                const r43 = Math.asin(Of * Math.sin(e)), n30 = r43 * r43, i23 = n30 * n30 * n30;
                return {
                    x: 0.5 * (t * Math.cos(r43) / (Of * (Rf + 3 * jf * n30 + i23 * (7 * Uf + 9 * $f * n30))) / Math.PI + 0.5),
                    y: 1 - 0.5 * (r43 * (Rf + jf * n30 + i23 * (Uf + $f * n30)) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t, e) {
                t = (2 * t - 0.5) * Math.PI;
                let r43 = e = (2 * (1 - e) - 1) * Math.PI, n30 = r43 * r43, i23 = n30 * n30 * n30;
                for(let t102, s17, a11, o12 = 0; o12 < 12 && (s17 = r43 * (Rf + jf * n30 + i23 * (Uf + $f * n30)) - e, a11 = Rf + 3 * jf * n30 + i23 * (7 * Uf + 9 * $f * n30), t102 = s17 / a11, r43 = S1(r43 - t102, -Math.PI / 3, Math.PI / 3), n30 = r43 * r43, i23 = n30 * n30 * n30, !(Math.abs(t102) < 0.000000000001)); ++o12);
                const s18 = Of * t * (Rf + 3 * jf * n30 + i23 * (7 * Uf + 9 * $f * n30)) / Math.cos(r43), a12 = Math.asin(Math.sin(r43) / Of), o13 = S1(180 * s18 / Math.PI, -180, 180), l10 = S1(180 * a12 / Math.PI, -85.051129, Lo);
                return new Mo(o13, l10);
            }
        }
        class Nf extends Lf {
            constructor(t102){
                super(t102), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t, e) {
                return {
                    x: 0.5 + t / 360,
                    y: 0.5 - e / 360,
                    z: 0
                };
            }
            unproject(t, e) {
                const r43 = 360 * (t - 0.5), n30 = S1(360 * (0.5 - e), -85.051129, Lo);
                return new Mo(r43, n30);
            }
        }
        const Gf = Math.PI / 2;
        function Xf(t103) {
            return Math.tan((Gf + t103) / 2);
        }
        class Zf extends Lf {
            constructor(t103){
                super(t103), this.center = t103.center || [
                    0,
                    30
                ];
                const [e74, r43] = this.parallels = t103.parallels || [
                    30,
                    30
                ];
                let n30 = x1(e74), i23 = x1(r43);
                this.southernCenter = n30 + i23 < 0, this.southernCenter && (n30 = -n30, i23 = -i23);
                const s17 = Math.cos(n30), a11 = Xf(n30);
                this.n = n30 === i23 ? Math.sin(n30) : Math.log(s17 / Math.cos(i23)) / Math.log(Xf(i23) / a11), this.f = s17 * Math.pow(Xf(n30), this.n) / this.n;
            }
            project(t, e) {
                e = x1(e), this.southernCenter && (e = -e), t = x1(t - this.center[0]);
                const r44 = 0.000001, { n: n31 , f: i24  } = this;
                i24 > 0 ? e < -Gf + r44 && (e = -Gf + r44) : e > Gf - r44 && (e = Gf - r44);
                const s18 = i24 / Math.pow(Xf(e), n31);
                let a12 = s18 * Math.sin(n31 * t), o12 = i24 - s18 * Math.cos(n31 * t);
                return a12 = 0.5 * (a12 / Math.PI + 0.5), o12 = 0.5 * (o12 / Math.PI + 0.5), {
                    x: a12,
                    y: this.southernCenter ? o12 : 1 - o12,
                    z: 0
                };
            }
            unproject(t, e) {
                t = (2 * t - 0.5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - 0.5) * Math.PI;
                const { n: r44 , f: n31  } = this, i24 = n31 - e, s18 = Math.sign(i24), a12 = Math.sign(r44) * Math.sqrt(t * t + i24 * i24);
                let o12 = Math.atan2(t, Math.abs(i24)) * s18;
                i24 * r44 < 0 && (o12 -= Math.PI * Math.sign(t) * s18);
                const l10 = S1(v1(o12 / r44) + this.center[0], -180, 180), u9 = S1(v1(2 * Math.atan(Math.pow(n31 / a12, 1 / r44)) - Gf), -85.051129, Lo);
                return new Mo(l10, this.southernCenter ? -u9 : u9);
            }
        }
        class Kf extends Lf {
            constructor(t104){
                super(t104), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
            }
            project(t, e) {
                return {
                    x: Bo(t),
                    y: Eo(e),
                    z: 0
                };
            }
            unproject(t, e) {
                const r44 = Po(t), n31 = Do(e);
                return new Mo(r44, n31);
            }
        }
        const Yf = x1(Lo);
        class Hf extends Lf {
            project(t, e) {
                const r44 = (e = x1(e)) * e, n31 = r44 * r44;
                return {
                    x: 0.5 * ((t = x1(t)) * (0.8707 - 0.131979 * r44 + n31 * (n31 * (0.003971 * r44 - 0.001529 * n31) - 0.013791)) / Math.PI + 0.5),
                    y: 1 - 0.5 * (e * (1.007226 + r44 * (0.015085 + n31 * (0.028874 * r44 - 0.044475 - 0.005916 * n31))) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t, e) {
                t = (2 * t - 0.5) * Math.PI;
                let r44 = e = (2 * (1 - e) - 1) * Math.PI, n31 = 25, i24 = 0, s18 = r44 * r44;
                do {
                    s18 = r44 * r44;
                    const t105 = s18 * s18;
                    i24 = (r44 * (1.007226 + s18 * (0.015085 + t105 * (0.028874 * s18 - 0.044475 - 0.005916 * t105))) - e) / (1.007226 + s18 * (0.045255 + t105 * (0.259866 * s18 - 0.311325 - 0.005916 * 11 * t105))), r44 = S1(r44 - i24, -Yf, Yf);
                }while (Math.abs(i24) > 0.000001 && (--n31) > 0)
                s18 = r44 * r44;
                const a12 = S1(v1(t / (0.8707 + s18 * (s18 * (s18 * s18 * s18 * (0.003971 - 0.001529 * s18) - 0.013791) - 0.131979))), -180, 180), o12 = v1(r44);
                return new Mo(a12, o12);
            }
        }
        const Wf = x1(Lo);
        class Jf extends Lf {
            project(t, e) {
                e = x1(e), t = x1(t);
                const r44 = Math.cos(e), n31 = 2 / Math.PI, i24 = Math.acos(r44 * Math.cos(t / 2)), s18 = Math.sin(i24) / i24, a12 = 0.5 * (t * n31 + 2 * r44 * Math.sin(t / 2) / s18) || 0, o12 = 0.5 * (e + Math.sin(e) / s18) || 0;
                return {
                    x: 0.5 * (a12 / Math.PI + 0.5),
                    y: 1 - 0.5 * (o12 / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t, e) {
                let r44 = t = (2 * t - 0.5) * Math.PI, n31 = e = (2 * (1 - e) - 1) * Math.PI, i24 = 25;
                const s18 = 0.000001;
                let a12 = 0, o12 = 0;
                do {
                    const i25 = Math.cos(n31), s19 = Math.sin(n31), l10 = 2 * s19 * i25, u9 = s19 * s19, c7 = i25 * i25, h5 = Math.cos(r44 / 2), p5 = Math.sin(r44 / 2), f4 = 2 * h5 * p5, d4 = p5 * p5, y2 = 1 - c7 * h5 * h5, m2 = y2 ? 1 / y2 : 0, g2 = y2 ? Math.acos(i25 * h5) * Math.sqrt(1 / y2) : 0, x2 = 0.5 * (2 * g2 * i25 * p5 + 2 * r44 / Math.PI) - t, v2 = 0.5 * (g2 * s19 + n31) - e, b2 = 0.5 * m2 * (c7 * d4 + g2 * i25 * h5 * u9) + 1 / Math.PI, w2 = m2 * (f4 * l10 / 4 - g2 * s19 * p5), _2 = 0.125 * m2 * (l10 * p5 - g2 * s19 * c7 * f4), A2 = 0.5 * m2 * (u9 * h5 + g2 * d4 * i25) + 0.5, k2 = w2 * _2 - A2 * b2;
                    a12 = (v2 * w2 - x2 * A2) / k2, o12 = (x2 * _2 - v2 * b2) / k2, r44 = S1(r44 - a12, -Math.PI, Math.PI), n31 = S1(n31 - o12, -Wf, Wf);
                }while ((Math.abs(a12) > s18 || Math.abs(o12) > s18) && (--i24) > 0)
                return new Mo(v1(r44), v1(n31));
            }
        }
        class Qf extends Lf {
            constructor(t105){
                super(t105), this.center = t105.center || [
                    0,
                    0
                ], this.parallels = t105.parallels || [
                    0,
                    0
                ], this.cosPhi = Math.max(0.01, Math.cos(x1(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t, e) {
                const { scale: r44 , cosPhi: n31  } = this;
                return {
                    x: x1(t) * n31 * r44 + 0.5,
                    y: -Math.sin(x1(e)) / n31 * r44 + 0.5,
                    z: 0
                };
            }
            unproject(t, e) {
                const { scale: r44 , cosPhi: n31  } = this, i24 = -(e - 0.5) / r44, s18 = S1(v1((t - 0.5) / r44) / n31, -180, 180), a12 = Math.asin(S1(i24 * n31, -1, 1)), o12 = S1(v1(a12), -85.051129, Lo);
                return new Mo(s18, o12);
            }
        }
        class td extends Kf {
            constructor(t106){
                super(t106), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = [
                    "debug",
                    "custom"
                ], this.range = [
                    3,
                    5
                ];
            }
            projectTilePoint(t, e, r) {
                const n31 = wf(t, e, r);
                return ql(n31, n31, Sf(pf(r))), {
                    x: n31[0],
                    y: n31[1],
                    z: n31[2]
                };
            }
            locationPoint(t, e) {
                const r44 = bf(e.lat, e.lng), n31 = Ul([], r44), i24 = t.elevation ? t.elevation.getAtPointOrZero(t.locationCoordinate(e), t._centerAltitude) : t._centerAltitude;
                jl(r44, r44, n31, Co(1, 0) * So * i24);
                const s18 = vl(new Float64Array(16));
                return wl(s18, t.pixelMatrix, t.globeMatrix), ql(r44, r44, s18), new d2(r44[0], r44[1]);
            }
            pixelsPerMeter(t, e) {
                return Co(1, 0) * e;
            }
            pixelSpaceConversion(t, e, r) {
                const n31 = Co(1, t) * e, i24 = Mr(Co(1, 45) * e, n31, r);
                return this.pixelsPerMeter(t, e) / i24;
            }
            createTileMatrix(t, e, r) {
                const n31 = kf(pf(r.canonical));
                return wl(new Float64Array(16), t.globeMatrix, n31);
            }
            createInversionMatrix(t, e) {
                const { center: r44  } = t, n31 = Sf(pf(e));
                return kl(n31, n31, x1(r44.lng)), Sl(n31, n31, x1(r44.lat)), Al(n31, n31, [
                    t._pixelsPerMercatorPixel,
                    t._pixelsPerMercatorPixel,
                    1
                ]), Float32Array.from(n31);
            }
            pointCoordinate(t, e, r, n) {
                return uf(t, e, r, !0) || new Ro(0, 0);
            }
            pointCoordinate3D(t, e, r) {
                const n31 = this.pointCoordinate(t, e, r, 0);
                return [
                    n31.x,
                    n31.y,
                    n31.z
                ];
            }
            isPointAboveHorizon(t, e) {
                return !uf(t, e.x, e.y, !1);
            }
            farthestPixelDistance(t) {
                const e75 = function(t107, e76) {
                    const r44 = t107.cameraToCenterDistance, n31 = t107._centerAltitude * e76, i24 = t107._camera, s18 = t107._camera.forward(), a12 = Pl([], Rl([], s18, -r44), [
                        0,
                        0,
                        n31
                    ]), o12 = t107.worldSize / (2 * Math.PI), l10 = [
                        0,
                        0,
                        -o12
                    ], u9 = t107.width / t107.height, c7 = Math.tan(t107.fovAboveCenter), h5 = Rl([], i24.up(), c7), p5 = Rl([], i24.right(), c7 * u9), f4 = Ul([], Pl([], Pl([], s18, h5), p5)), d4 = [];
                    let y2;
                    if (new nu(a12, f4).closestPointOnSphere(l10, o12, d4)) {
                        const e77 = Pl([], d4, l10), r45 = Xl([], e77, a12);
                        y2 = Math.cos(t107.fovAboveCenter) * El(r45);
                    } else {
                        const t108 = Xl([], a12, l10), e77 = Xl([], l10, a12);
                        Ul(e77, e77);
                        const r45 = El(t108) - o12;
                        y2 = Math.sqrt(r45 * (r45 + 2 * o12));
                        const n32 = Math.acos(y2 / (o12 + r45)) - Math.acos($l(s18, e77));
                        y2 *= Math.cos(n32);
                    }
                    return 1.01 * y2;
                }(t, this.pixelsPerMeter(t.center.lat, t.worldSize)), r44 = Mf(t.zoom);
                if (r44 > 0) {
                    const n31 = Pf(t, Co(1, t.center.lat) * t.worldSize), i24 = t.worldSize / (2 * Math.PI), s18 = Math.max(t.width, t.height) / t.worldSize * Math.PI;
                    return Mr(e75, n31 + i24 * (1 - Math.cos(s18)), Math.pow(r44, 10));
                }
                return e75;
            }
            upVector(t, e, r) {
                return wf(e, r, t, 1);
            }
            upVectorScale(t) {
                return {
                    metersToTile: rf * _f(pf(t))
                };
            }
        }
        function ed(t107) {
            const e75 = t107.parallels, r44 = !!e75 && Math.abs(e75[0] + e75[1]) < 0.01;
            switch(t107.name){
                case "mercator":
                    return new Kf(t107);
                case "equirectangular":
                    return new Nf(t107);
                case "naturalEarth":
                    return new Hf(t107);
                case "equalEarth":
                    return new qf(t107);
                case "winkelTripel":
                    return new Jf(t107);
                case "albers":
                    return r44 ? new Qf(t107) : new Ff(t107);
                case "lambertConformalConic":
                    return r44 ? new Qf(t107) : new Zf(t107);
                case "globe":
                    return new td(t107);
            }
            throw new Error(`Invalid projection name: ${t107.name}`);
        }
        const rd = Sc.types, nd = [
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint8",
                offset: 0
            }
        ];
        function id(t107, e75, r44, n31, i24, s18, a12, o12, l10, u9, c7, h5, p5) {
            const f4 = o12 ? Math.min(Gp, Math.round(o12[0])) : 0, d4 = o12 ? Math.min(Gp, Math.round(o12[1])) : 0;
            t107.emplaceBack(e75, r44, Math.round(32 * n31), Math.round(32 * i24), s18, a12, (f4 << 1) + (l10 ? 1 : 0), d4, 16 * u9, 16 * c7, 256 * h5, 256 * p5);
        }
        function sd(t107, e75, r44, n31, i24, s18, a12) {
            t107.emplaceBack(e75, r44, n31, i24, s18, a12);
        }
        function ad(t107, e75, r44, n31, i24) {
            t107.emplaceBack(e75, r44, n31, i24), t107.emplaceBack(e75, r44, n31, i24), t107.emplaceBack(e75, r44, n31, i24), t107.emplaceBack(e75, r44, n31, i24);
        }
        function od(t107) {
            for (const e75 of t107.sections)if (Ms(e75.text)) return !0;
            return !1;
        }
        class ld {
            constructor(t107){
                this.layoutVertexArray = new fa, this.indexArray = new wa, this.programConfigurations = t107, this.segments = new Ao, this.dynamicLayoutVertexArray = new ua, this.opacityVertexArray = new ya, this.placedSymbolArray = new Pa, this.globeExtVertexArray = new da;
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }
            upload(t, e, r, n) {
                this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, lh.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, ch.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, nd, !0), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, uh.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
        }
        Oi(ld, "SymbolBuffers");
        class ud {
            constructor(t108, e75, r44){
                this.layoutVertexArray = new t108, this.layoutAttributes = e75, this.indexArray = new r44, this.segments = new Ao, this.collisionVertexArray = new va, this.collisionVertexArrayExt = new ba;
            }
            upload(t) {
                this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, hh.members, !0), this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, ph.members, !0);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
        }
        Oi(ud, "CollisionBuffers");
        class cd {
            constructor(t109){
                this.collisionBoxArray = t109.collisionBoxArray, this.zoom = t109.zoom, this.overscaling = t109.overscaling, this.layers = t109.layers, this.layerIds = this.layers.map((t110)=>t110.id
                ), this.index = t109.index, this.pixelRatio = t109.pixelRatio, this.sourceLayerIndex = t109.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = vl([]), this.placementViewportMatrix = vl([]);
                const e76 = this.layers[0]._unevaluatedLayout._values;
                this.textSizeData = gh(this.zoom, e76["text-size"]), this.iconSizeData = gh(this.zoom, e76["icon-size"]);
                const r45 = this.layers[0].layout, n31 = r45.get("symbol-sort-key"), i24 = r45.get("symbol-z-order");
                this.canOverlap = r45.get("text-allow-overlap") || r45.get("icon-allow-overlap") || r45.get("text-ignore-placement") || r45.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i24 && (void 0) !== n31.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i24 || "auto" === i24 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r45.get("text-writing-mode").map((t110)=>Qh[t110]
                ), this.stateDependentLayerIds = this.layers.filter((t110)=>t110.isStateDependent()
                ).map((t110)=>t110.id
                ), this.sourceID = t109.sourceID, this.projection = t109.projection;
            }
            createArrays() {
                this.text = new ld(new po(this.layers, this.zoom, (t110)=>/^text/.test(t110)
                )), this.icon = new ld(new po(this.layers, this.zoom, (t110)=>/^icon/.test(t110)
                )), this.glyphOffsetArray = new La, this.lineVertexArray = new Fa, this.symbolInstances = new Va;
            }
            calculateGlyphDependencies(t, e, r, n, i) {
                for(let r46 = 0; r46 < t.length; r46++)if (e[t.charCodeAt(r46)] = !0, n && i) {
                    const n32 = _h[t.charAt(r46)];
                    n32 && (e[n32.charCodeAt(0)] = !0);
                }
            }
            populate(t, e, r, n) {
                const i25 = this.layers[0], s18 = i25.layout, a12 = "globe" === this.projection.name, o12 = s18.get("text-font"), l10 = s18.get("text-field"), u9 = s18.get("icon-image"), c7 = ("constant" !== l10.value.kind || l10.value.value instanceof Be && !l10.value.value.isEmpty() || l10.value.value.toString().length > 0) && ("constant" !== o12.value.kind || o12.value.value.length > 0), h5 = "constant" !== u9.value.kind || !!u9.value.value || Object.keys(u9.parameters).length > 0, p5 = s18.get("symbol-sort-key");
                if (this.features = [], !c7 && !h5) return;
                const f4 = e.iconDependencies, d4 = e.glyphDependencies, y2 = e.availableImages, m2 = new Us(this.zoom);
                for (const { feature: e77 , id: l11 , index: u10 , sourceLayerIndex: g2  } of t){
                    const t110 = i25._featureFilter.needGeometry, x2 = Zo(e77, t110);
                    if (!i25._featureFilter.filter(m2, x2, r)) continue;
                    if (t110 || (x2.geometry = Xo(e77, r, n)), a12 && 1 !== e77.type && r.z <= 5) {
                        const t111 = x2.geometry, e78 = 0.98078528056, n32 = (t112, n33)=>$l(wf(t112.x, t112.y, r, 1), wf(n33.x, n33.y, r, 1)) < e78
                        ;
                        for(let e79 = 0; e79 < t111.length; e79++)t111[e79] = Oo(t111[e79], n32);
                    }
                    let v2, b2;
                    if (c7) {
                        const t111 = i25.getValueAndResolveTokens("text-field", x2, r, y2), e78 = Be.factory(t111);
                        od(e78) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === Fs() || this.hasRTLText && js.isParsed()) && (v2 = wh(e78, i25, x2));
                    }
                    if (h5) {
                        const t111 = i25.getValueAndResolveTokens("icon-image", x2, r, y2);
                        b2 = t111 instanceof Ee ? t111 : Ee.fromString(t111);
                    }
                    if (!v2 && !b2) continue;
                    const w2 = this.sortFeaturesByKey ? p5.evaluate(x2, {
                    }, r) : void 0;
                    if (this.features.push({
                        id: l11,
                        text: v2,
                        icon: b2,
                        index: u10,
                        sourceLayerIndex: g2,
                        geometry: x2.geometry,
                        properties: e77.properties,
                        type: rd[e77.type],
                        sortKey: w2
                    }), b2 && (f4[b2.name] = !0), v2) {
                        const t111 = o12.evaluate(x2, {
                        }, r).join(","), e78 = "map" === s18.get("text-rotation-alignment") && "point" !== s18.get("symbol-placement");
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Qh.vertical) >= 0;
                        for (const r46 of v2.sections)if (r46.image) f4[r46.image.name] = !0;
                        else {
                            const n32 = bs(v2.toString()), i26 = r46.fontStack || t111, s19 = d4[i26] = d4[i26] || {
                            };
                            this.calculateGlyphDependencies(r46.text, s19, e78, this.allowVerticalPlacement, n32);
                        }
                    }
                }
                "line" === s18.get("symbol-placement") && (this.features = (function(t110) {
                    const e78 = {
                    }, r46 = {
                    }, n32 = [];
                    let i26 = 0;
                    function s19(e79) {
                        n32.push(t110[e79]), i26++;
                    }
                    function a13(t111, e79, i27) {
                        const s20 = r46[t111];
                        return delete r46[t111], r46[e79] = s20, n32[s20].geometry[0].pop(), n32[s20].geometry[0] = n32[s20].geometry[0].concat(i27[0]), s20;
                    }
                    function o13(t111, r47, i27) {
                        const s20 = e78[r47];
                        return delete e78[r47], e78[t111] = s20, n32[s20].geometry[0].shift(), n32[s20].geometry[0] = i27[0].concat(n32[s20].geometry[0]), s20;
                    }
                    function l12(t111, e79, r47) {
                        const n33 = r47 ? e79[0][e79[0].length - 1] : e79[0][0];
                        return `${t111}:${n33.x}:${n33.y}`;
                    }
                    for(let u11 = 0; u11 < t110.length; u11++){
                        const c8 = t110[u11], h6 = c8.geometry, p6 = c8.text ? c8.text.toString() : null;
                        if (!p6) {
                            s19(u11);
                            continue;
                        }
                        const f5 = l12(p6, h6), d5 = l12(p6, h6, !0);
                        if (f5 in r46 && d5 in e78 && r46[f5] !== e78[d5]) {
                            const t111 = o13(f5, d5, h6), i27 = a13(f5, d5, n32[t111].geometry);
                            delete e78[f5], delete r46[d5], r46[l12(p6, n32[i27].geometry, !0)] = i27, n32[t111].geometry = null;
                        } else f5 in r46 ? a13(f5, d5, h6) : d5 in e78 ? o13(f5, d5, h6) : (s19(u11), e78[f5] = i26 - 1, r46[d5] = i26 - 1);
                    }
                    return n32.filter((t111)=>t111.geometry
                    );
                })(this.features)), this.sortFeaturesByKey && this.features.sort((t110, e78)=>t110.sortKey - e78.sortKey
                );
            }
            update(t, e, r, n) {
                this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r, n), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r, n));
            }
            isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
            }
            destroyDebugData() {
                this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            getProjection() {
                return this.projectionInstance || (this.projectionInstance = ed(this.projection)), this.projectionInstance;
            }
            destroy() {
                this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t, e) {
                const r46 = this.lineVertexArray.length;
                if ((void 0) !== t.segment) for (const { x: t110 , y: r47  } of e)this.lineVertexArray.emplaceBack(t110, r47);
                return {
                    lineStartIndex: r46,
                    lineLength: this.lineVertexArray.length - r46
                };
            }
            addSymbols(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {
                const d4 = t.indexArray, y2 = t.layoutVertexArray, m2 = t.globeExtVertexArray, g2 = t.segments.prepareSegment(4 * e.length, y2, d4, this.canOverlap ? s.sortKey : void 0), x2 = this.glyphOffsetArray.length, v2 = g2.vertexLength, b2 = this.allowVerticalPlacement && a === Qh.vertical ? Math.PI / 2 : 0, w2 = s.text && s.text.sections;
                for(let n32 = 0; n32 < e.length; n32++){
                    const { tl: i25 , tr: a12 , bl: u9 , br: c7 , tex: h5 , pixelOffsetTL: x3 , pixelOffsetBR: v3 , minFontScaleX: _2 , minFontScaleY: A2 , glyphOffset: S2 , isSDF: k2 , sectionIndex: I2  } = e[n32], M2 = g2.vertexLength, T2 = S2[1];
                    if (id(y2, l.x, l.y, i25.x, T2 + i25.y, h5.x, h5.y, r, k2, x3.x, x3.y, _2, A2), id(y2, l.x, l.y, a12.x, T2 + a12.y, h5.x + h5.w, h5.y, r, k2, v3.x, x3.y, _2, A2), id(y2, l.x, l.y, u9.x, T2 + u9.y, h5.x, h5.y + h5.h, r, k2, x3.x, v3.y, _2, A2), id(y2, l.x, l.y, c7.x, T2 + c7.y, h5.x + h5.w, h5.y + h5.h, r, k2, v3.x, v3.y, _2, A2), o) {
                        const { x: e77 , y: r46 , z: n33  } = o.anchor, [i26, s18, a13] = o.up;
                        sd(m2, e77, r46, n33, i26, s18, a13), sd(m2, e77, r46, n33, i26, s18, a13), sd(m2, e77, r46, n33, i26, s18, a13), sd(m2, e77, r46, n33, i26, s18, a13), ad(t.dynamicLayoutVertexArray, e77, r46, n33, b2);
                    } else ad(t.dynamicLayoutVertexArray, l.x, l.y, l.z, b2);
                    d4.emplaceBack(M2, M2 + 1, M2 + 2), d4.emplaceBack(M2 + 1, M2 + 2, M2 + 3), g2.vertexLength += 4, g2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S2[0]), n32 !== e.length - 1 && I2 === e[n32 + 1].sectionIndex || t.programConfigurations.populatePaintArrays(y2.length, s, s.index, {
                    }, p, f, w2 && w2[I2]);
                }
                const _2 = o ? o.anchor : l;
                t.placedSymbolArray.emplaceBack(_2.x, _2.y, _2.z, l.x, l.y, x2, this.glyphOffsetArray.length - x2, v2, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);
            }
            _commitLayoutVertex(t, e, r, n, i, s, a) {
                t.emplaceBack(e, r, n, i, s, Math.round(a.x), Math.round(a.y));
            }
            _addCollisionDebugVertices(t, e, r, n, i, s, a) {
                const o12 = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray), l10 = o12.vertexLength, u9 = a.tileAnchorX, c7 = a.tileAnchorY;
                for(let t110 = 0; t110 < 4; t110++)r.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                r.collisionVertexArrayExt.emplaceBack(e, -t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, t.padding), r.collisionVertexArrayExt.emplaceBack(e, -t.padding, t.padding), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u9, c7, new d2(t.x1, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u9, c7, new d2(t.x2, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u9, c7, new d2(t.x2, t.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u9, c7, new d2(t.x1, t.y2)), o12.vertexLength += 4;
                const h5 = r.indexArray;
                h5.emplaceBack(l10, l10 + 1), h5.emplaceBack(l10 + 1, l10 + 2), h5.emplaceBack(l10 + 2, l10 + 3), h5.emplaceBack(l10 + 3, l10), o12.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t, e, r, n, i, s) {
                for(let a12 = n; a12 < i; a12++){
                    const n32 = r.get(a12), i25 = this.getSymbolInstanceTextSize(t, s, e, a12);
                    this._addCollisionDebugVertices(n32, i25, this.textCollisionBox, n32.projectedAnchorX, n32.projectedAnchorY, n32.projectedAnchorZ, s);
                }
            }
            _addIconDebugCollisionBoxes(t, e, r, n, i, s) {
                for(let a12 = n; a12 < i; a12++){
                    const n32 = r.get(a12), i25 = this.getSymbolInstanceIconSize(t, e, s.placedIconSymbolIndex);
                    this._addCollisionDebugVertices(n32, i25, this.iconCollisionBox, n32.projectedAnchorX, n32.projectedAnchorY, n32.projectedAnchorZ, s);
                }
            }
            generateCollisionDebugBuffers(t, e) {
                this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ud(ga, fh.members, Ma), this.iconCollisionBox = new ud(ga, fh.members, Ma);
                const r46 = vh(this.iconSizeData, t), n32 = vh(this.textSizeData, t);
                for(let i25 = 0; i25 < this.symbolInstances.length; i25++){
                    const s18 = this.symbolInstances.get(i25);
                    this._addTextDebugCollisionBoxes(n32, t, e, s18.textBoxStartIndex, s18.textBoxEndIndex, s18), this._addTextDebugCollisionBoxes(n32, t, e, s18.verticalTextBoxStartIndex, s18.verticalTextBoxEndIndex, s18), this._addIconDebugCollisionBoxes(r46, t, e, s18.iconBoxStartIndex, s18.iconBoxEndIndex, s18), this._addIconDebugCollisionBoxes(r46, t, e, s18.verticalIconBoxStartIndex, s18.verticalIconBoxEndIndex, s18);
                }
            }
            getSymbolInstanceTextSize(t, e, r, n) {
                const i25 = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n), s18 = xh(this.textSizeData, t, i25) / yh;
                return this.tilePixelRatio * s18;
            }
            getSymbolInstanceIconSize(t, e, r) {
                const n32 = this.icon.placedSymbolArray.get(r), i25 = xh(this.iconSizeData, t, n32);
                return this.tilePixelRatio * i25;
            }
            _commitDebugCollisionVertexUpdate(t, e, r) {
                t.emplaceBack(e, -r, -r), t.emplaceBack(e, r, -r), t.emplaceBack(e, r, r), t.emplaceBack(e, -r, r);
            }
            _updateTextDebugCollisionBoxes(t, e, r, n, i, s) {
                for(let a12 = n; a12 < i; a12++){
                    const n32 = r.get(a12), i25 = this.getSymbolInstanceTextSize(t, s, e, a12);
                    this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i25, n32.padding);
                }
            }
            _updateIconDebugCollisionBoxes(t, e, r, n, i, s) {
                for(let a12 = n; a12 < i; a12++){
                    const n32 = r.get(a12), i25 = this.getSymbolInstanceIconSize(t, e, s);
                    this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i25, n32.padding);
                }
            }
            updateCollisionDebugBuffers(t, e) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                const r46 = vh(this.iconSizeData, t), n32 = vh(this.textSizeData, t);
                for(let i25 = 0; i25 < this.symbolInstances.length; i25++){
                    const s18 = this.symbolInstances.get(i25);
                    this._updateTextDebugCollisionBoxes(n32, t, e, s18.textBoxStartIndex, s18.textBoxEndIndex, s18), this._updateTextDebugCollisionBoxes(n32, t, e, s18.verticalTextBoxStartIndex, s18.verticalTextBoxEndIndex, s18), this._updateIconDebugCollisionBoxes(r46, t, e, s18.iconBoxStartIndex, s18.iconBoxEndIndex, s18.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r46, t, e, s18.verticalIconBoxStartIndex, s18.verticalIconBoxEndIndex, s18.placedIconSymbolIndex);
                }
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, a, o, l) {
                const u9 = {
                };
                if (e < r) {
                    const { x1: r46 , y1: n32 , x2: i25 , y2: s18 , padding: a12 , projectedAnchorX: o12 , projectedAnchorY: l10 , projectedAnchorZ: c7 , tileAnchorX: h5 , tileAnchorY: p5 , featureIndex: f4  } = t.get(e);
                    u9.textBox = {
                        x1: r46,
                        y1: n32,
                        x2: i25,
                        y2: s18,
                        padding: a12,
                        projectedAnchorX: o12,
                        projectedAnchorY: l10,
                        projectedAnchorZ: c7,
                        tileAnchorX: h5,
                        tileAnchorY: p5
                    }, u9.textFeatureIndex = f4;
                }
                if (n < i) {
                    const { x1: e77 , y1: r46 , x2: i25 , y2: s18 , padding: a12 , projectedAnchorX: o12 , projectedAnchorY: l10 , projectedAnchorZ: c7 , tileAnchorX: h5 , tileAnchorY: p5 , featureIndex: f4  } = t.get(n);
                    u9.verticalTextBox = {
                        x1: e77,
                        y1: r46,
                        x2: i25,
                        y2: s18,
                        padding: a12,
                        projectedAnchorX: o12,
                        projectedAnchorY: l10,
                        projectedAnchorZ: c7,
                        tileAnchorX: h5,
                        tileAnchorY: p5
                    }, u9.verticalTextFeatureIndex = f4;
                }
                if (s < a) {
                    const { x1: e77 , y1: r46 , x2: n32 , y2: i25 , padding: a12 , projectedAnchorX: o12 , projectedAnchorY: l10 , projectedAnchorZ: c7 , tileAnchorX: h5 , tileAnchorY: p5 , featureIndex: f4  } = t.get(s);
                    u9.iconBox = {
                        x1: e77,
                        y1: r46,
                        x2: n32,
                        y2: i25,
                        padding: a12,
                        projectedAnchorX: o12,
                        projectedAnchorY: l10,
                        projectedAnchorZ: c7,
                        tileAnchorX: h5,
                        tileAnchorY: p5
                    }, u9.iconFeatureIndex = f4;
                }
                if (o < l) {
                    const { x1: e77 , y1: r46 , x2: n32 , y2: i25 , padding: s18 , projectedAnchorX: a12 , projectedAnchorY: l10 , projectedAnchorZ: c7 , tileAnchorX: h5 , tileAnchorY: p5 , featureIndex: f4  } = t.get(o);
                    u9.verticalIconBox = {
                        x1: e77,
                        y1: r46,
                        x2: n32,
                        y2: i25,
                        padding: s18,
                        projectedAnchorX: a12,
                        projectedAnchorY: l10,
                        projectedAnchorZ: c7,
                        tileAnchorX: h5,
                        tileAnchorY: p5
                    }, u9.verticalIconFeatureIndex = f4;
                }
                return u9;
            }
            deserializeCollisionBoxes(t) {
                this.collisionArrays = [];
                for(let e77 = 0; e77 < this.symbolInstances.length; e77++){
                    const r46 = this.symbolInstances.get(e77);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r46.textBoxStartIndex, r46.textBoxEndIndex, r46.verticalTextBoxStartIndex, r46.verticalTextBoxEndIndex, r46.iconBoxStartIndex, r46.iconBoxEndIndex, r46.verticalIconBoxStartIndex, r46.verticalIconBoxEndIndex));
                }
            }
            hasTextData() {
                return this.text.segments.get().length > 0;
            }
            hasIconData() {
                return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t, e) {
                const r46 = t.placedSymbolArray.get(e), n32 = r46.vertexStartIndex + 4 * r46.numGlyphs;
                for(let e77 = r46.vertexStartIndex; e77 < n32; e77 += 4)t.indexArray.emplaceBack(e77, e77 + 1, e77 + 2), t.indexArray.emplaceBack(e77 + 1, e77 + 2, e77 + 3);
            }
            getSortedSymbolIndexes(t) {
                if (this.sortedAngle === t && (void 0) !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
                const e77 = Math.sin(t), r46 = Math.cos(t), n32 = [], i25 = [], s18 = [];
                for(let t110 = 0; t110 < this.symbolInstances.length; ++t110){
                    s18.push(t110);
                    const a12 = this.symbolInstances.get(t110);
                    n32.push(0 | Math.round(e77 * a12.tileAnchorX + r46 * a12.tileAnchorY)), i25.push(a12.featureIndex);
                }
                return s18.sort((t111, e78)=>n32[t111] - n32[e78] || i25[e78] - i25[t111]
                ), s18;
            }
            addToSortKeyRanges(t, e) {
                const r46 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                r46 && r46.sortKey === e ? r46.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
                    sortKey: e,
                    symbolInstanceStart: t,
                    symbolInstanceEnd: t + 1
                });
            }
            sortFeatures(t) {
                if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                    for (const t110 of this.symbolInstanceIndexes){
                        const e77 = this.symbolInstances.get(t110);
                        this.featureSortOrder.push(e77.featureIndex);
                        const { rightJustifiedTextSymbolIndex: r46 , centerJustifiedTextSymbolIndex: n32 , leftJustifiedTextSymbolIndex: i25 , verticalPlacedTextSymbolIndex: s18 , placedIconSymbolIndex: a12 , verticalPlacedIconSymbolIndex: o12  } = e77;
                        r46 >= 0 && this.addIndicesForPlacedSymbol(this.text, r46), n32 >= 0 && n32 !== r46 && this.addIndicesForPlacedSymbol(this.text, n32), i25 >= 0 && i25 !== n32 && i25 !== r46 && this.addIndicesForPlacedSymbol(this.text, i25), s18 >= 0 && this.addIndicesForPlacedSymbol(this.text, s18), a12 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a12), o12 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o12);
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
            }
        }
        Oi(cd, "SymbolBucket", {
            omit: [
                "layers",
                "collisionBoxArray",
                "features",
                "compareText"
            ]
        }), cd.MAX_GLYPHS = 65535, cd.addDynamicAttributes = ad;
        const hd = new Js({
            "symbol-placement": new Ys(Ht.layout_symbol["symbol-placement"]),
            "symbol-spacing": new Ys(Ht.layout_symbol["symbol-spacing"]),
            "symbol-avoid-edges": new Ys(Ht.layout_symbol["symbol-avoid-edges"]),
            "symbol-sort-key": new Hs(Ht.layout_symbol["symbol-sort-key"]),
            "symbol-z-order": new Ys(Ht.layout_symbol["symbol-z-order"]),
            "icon-allow-overlap": new Ys(Ht.layout_symbol["icon-allow-overlap"]),
            "icon-ignore-placement": new Ys(Ht.layout_symbol["icon-ignore-placement"]),
            "icon-optional": new Ys(Ht.layout_symbol["icon-optional"]),
            "icon-rotation-alignment": new Ys(Ht.layout_symbol["icon-rotation-alignment"]),
            "icon-size": new Hs(Ht.layout_symbol["icon-size"]),
            "icon-text-fit": new Ys(Ht.layout_symbol["icon-text-fit"]),
            "icon-text-fit-padding": new Ys(Ht.layout_symbol["icon-text-fit-padding"]),
            "icon-image": new Hs(Ht.layout_symbol["icon-image"]),
            "icon-rotate": new Hs(Ht.layout_symbol["icon-rotate"]),
            "icon-padding": new Ys(Ht.layout_symbol["icon-padding"]),
            "icon-keep-upright": new Ys(Ht.layout_symbol["icon-keep-upright"]),
            "icon-offset": new Hs(Ht.layout_symbol["icon-offset"]),
            "icon-anchor": new Hs(Ht.layout_symbol["icon-anchor"]),
            "icon-pitch-alignment": new Ys(Ht.layout_symbol["icon-pitch-alignment"]),
            "text-pitch-alignment": new Ys(Ht.layout_symbol["text-pitch-alignment"]),
            "text-rotation-alignment": new Ys(Ht.layout_symbol["text-rotation-alignment"]),
            "text-field": new Hs(Ht.layout_symbol["text-field"]),
            "text-font": new Hs(Ht.layout_symbol["text-font"]),
            "text-size": new Hs(Ht.layout_symbol["text-size"]),
            "text-max-width": new Hs(Ht.layout_symbol["text-max-width"]),
            "text-line-height": new Hs(Ht.layout_symbol["text-line-height"]),
            "text-letter-spacing": new Hs(Ht.layout_symbol["text-letter-spacing"]),
            "text-justify": new Hs(Ht.layout_symbol["text-justify"]),
            "text-radial-offset": new Hs(Ht.layout_symbol["text-radial-offset"]),
            "text-variable-anchor": new Ys(Ht.layout_symbol["text-variable-anchor"]),
            "text-anchor": new Hs(Ht.layout_symbol["text-anchor"]),
            "text-max-angle": new Ys(Ht.layout_symbol["text-max-angle"]),
            "text-writing-mode": new Ys(Ht.layout_symbol["text-writing-mode"]),
            "text-rotate": new Hs(Ht.layout_symbol["text-rotate"]),
            "text-padding": new Ys(Ht.layout_symbol["text-padding"]),
            "text-keep-upright": new Ys(Ht.layout_symbol["text-keep-upright"]),
            "text-transform": new Hs(Ht.layout_symbol["text-transform"]),
            "text-offset": new Hs(Ht.layout_symbol["text-offset"]),
            "text-allow-overlap": new Ys(Ht.layout_symbol["text-allow-overlap"]),
            "text-ignore-placement": new Ys(Ht.layout_symbol["text-ignore-placement"]),
            "text-optional": new Ys(Ht.layout_symbol["text-optional"])
        });
        var pd = {
            paint: new Js({
                "icon-opacity": new Hs(Ht.paint_symbol["icon-opacity"]),
                "icon-color": new Hs(Ht.paint_symbol["icon-color"]),
                "icon-halo-color": new Hs(Ht.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new Hs(Ht.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new Hs(Ht.paint_symbol["icon-halo-blur"]),
                "icon-translate": new Ys(Ht.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new Ys(Ht.paint_symbol["icon-translate-anchor"]),
                "text-opacity": new Hs(Ht.paint_symbol["text-opacity"]),
                "text-color": new Hs(Ht.paint_symbol["text-color"], {
                    runtimeType: le,
                    getOverride: (t110)=>t110.textColor
                    ,
                    hasOverride: (t110)=>!!t110.textColor
                }),
                "text-halo-color": new Hs(Ht.paint_symbol["text-halo-color"]),
                "text-halo-width": new Hs(Ht.paint_symbol["text-halo-width"]),
                "text-halo-blur": new Hs(Ht.paint_symbol["text-halo-blur"]),
                "text-translate": new Ys(Ht.paint_symbol["text-translate"]),
                "text-translate-anchor": new Ys(Ht.paint_symbol["text-translate-anchor"])
            }),
            layout: hd
        };
        class fd {
            constructor(t110){
                this.type = t110.property.overrides ? t110.property.overrides.runtimeType : ie, this.defaultValue = t110;
            }
            evaluate(t) {
                if (t.formattedSection) {
                    const e77 = this.defaultValue.property.overrides;
                    if (e77 && e77.hasOverride(t.formattedSection)) return e77.getOverride(t.formattedSection);
                }
                return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t) {
                this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return null;
            }
        }
        Oi(fd, "FormatSectionOverride", {
            omit: [
                "defaultValue"
            ]
        });
        class dd extends bo {
            constructor(t111){
                super(t111, pd);
            }
            recalculate(t, e) {
                super.recalculate(t, e), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                const r46 = this.layout.get("text-writing-mode");
                if (r46) {
                    const t112 = [];
                    for (const e77 of r46)t112.indexOf(e77) < 0 && t112.push(e77);
                    this.layout._values["text-writing-mode"] = t112;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? [
                    "horizontal"
                ] : [
                    "horizontal",
                    "vertical"
                ];
                this._setPaintOverrides();
            }
            getValueAndResolveTokens(t, e, r, n) {
                const i25 = this.layout.get(t).evaluate(e, {
                }, r, n), s18 = this._unevaluatedLayout._values[t];
                return s18.isDataDriven() || Nn(s18.value) || !i25 ? i25 : (function(t112, e77) {
                    return e77.replace(/{([^{}]+)}/g, (e78, r46)=>r46 in t112 ? String(t112[r46]) : ""
                    );
                })(e.properties, i25);
            }
            createBucket(t) {
                return new cd(t);
            }
            queryRadius() {
                return 0;
            }
            queryIntersectsFeature() {
                return !1;
            }
            _setPaintOverrides() {
                for (const t112 of pd.paint.overridableProperties){
                    if (!dd.hasPaintOverride(this.layout, t112)) continue;
                    const e77 = this.paint.get(t112), r46 = new fd(e77), n32 = new qn(r46, e77.property.specification);
                    let i25 = null;
                    i25 = "constant" === e77.value.kind || "source" === e77.value.kind ? new Xn("source", n32) : new Zn("composite", n32, e77.value.zoomStops, e77.value._interpolationType), this.paint._values[t112] = new Zs(e77.property, i25, e77.parameters);
                }
            }
            _handleOverridablePaintPropertyUpdate(t, e, r) {
                return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && dd.hasPaintOverride(this.layout, t);
            }
            static hasPaintOverride(t, e) {
                const r46 = t.get("text-field"), n32 = pd.paint.properties[e];
                let i25 = !1;
                const s18 = (t112)=>{
                    for (const e77 of t112)if (n32.overrides && n32.overrides.hasOverride(e77)) return void (i25 = !0);
                };
                if ("constant" === r46.value.kind && r46.value.value instanceof Be) s18(r46.value.value.sections);
                else if ("source" === r46.value.kind) {
                    const t112 = (e77)=>{
                        i25 || (e77 instanceof Fe && De(e77.value) === pe ? s18(e77.value.sections) : e77 instanceof Oe ? s18(e77.sections) : e77.eachChild(t112));
                    }, e77 = r46.value;
                    e77._styleExpression && t112(e77._styleExpression.expression);
                }
                return i25;
            }
            getProgramConfiguration(t) {
                return new ho(this, t);
            }
        }
        var yd = {
            paint: new Js({
                "background-color": new Ys(Ht.paint_background["background-color"]),
                "background-pattern": new Ys(Ht.paint_background["background-pattern"]),
                "background-opacity": new Ys(Ht.paint_background["background-opacity"])
            })
        }, md = {
            paint: new Js({
                "raster-opacity": new Ys(Ht.paint_raster["raster-opacity"]),
                "raster-hue-rotate": new Ys(Ht.paint_raster["raster-hue-rotate"]),
                "raster-brightness-min": new Ys(Ht.paint_raster["raster-brightness-min"]),
                "raster-brightness-max": new Ys(Ht.paint_raster["raster-brightness-max"]),
                "raster-saturation": new Ys(Ht.paint_raster["raster-saturation"]),
                "raster-contrast": new Ys(Ht.paint_raster["raster-contrast"]),
                "raster-resampling": new Ys(Ht.paint_raster["raster-resampling"]),
                "raster-fade-duration": new Ys(Ht.paint_raster["raster-fade-duration"])
            })
        };
        class gd extends bo {
            constructor(t112){
                super(t112, {
                }), this.implementation = t112;
            }
            is3D() {
                return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
                return (void 0) !== this.implementation.prerender;
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
                return !1;
            }
            serialize() {
            }
            onAdd(t) {
                this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);
            }
            onRemove(t) {
                this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);
            }
        }
        var xd = {
            paint: new Js({
                "sky-type": new Ys(Ht.paint_sky["sky-type"]),
                "sky-atmosphere-sun": new Ys(Ht.paint_sky["sky-atmosphere-sun"]),
                "sky-atmosphere-sun-intensity": new Ys(Ht.paint_sky["sky-atmosphere-sun-intensity"]),
                "sky-gradient-center": new Ys(Ht.paint_sky["sky-gradient-center"]),
                "sky-gradient-radius": new Ys(Ht.paint_sky["sky-gradient-radius"]),
                "sky-gradient": new Ws(Ht.paint_sky["sky-gradient"]),
                "sky-atmosphere-halo-color": new Ys(Ht.paint_sky["sky-atmosphere-halo-color"]),
                "sky-atmosphere-color": new Ys(Ht.paint_sky["sky-atmosphere-color"]),
                "sky-opacity": new Ys(Ht.paint_sky["sky-opacity"])
            })
        };
        function vd(t113, e77, r46) {
            const n32 = [
                0,
                0,
                1
            ], i25 = Ql([]);
            return eu(i25, i25, r46 ? -x1(t113) + Math.PI : x1(t113)), tu(i25, i25, -x1(e77)), Nl(n32, n32, i25), Ul(n32, n32);
        }
        const bd = {
            circle: class extends bo {
                constructor(t113){
                    super(t113, dl);
                }
                createBucket(t) {
                    return new Ho(t);
                }
                queryRadius(t) {
                    const e77 = t;
                    return ul("circle-radius", this, e77) + ul("circle-stroke-width", this, e77) + cl(this.paint.get("circle-translate"));
                }
                queryIntersectsFeature(t, e, r, n, i, s, a, o) {
                    const l10 = pl(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, t.pixelToTileUnitsFactor), u9 = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r);
                    return ou(t, n, s, a, o, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l10, u9);
                }
                getProgramIds() {
                    return [
                        "circle"
                    ];
                }
                getProgramConfiguration(t) {
                    return new ho(this, t);
                }
            },
            heatmap: class extends bo {
                createBucket(t) {
                    return new pu(t);
                }
                constructor(t114){
                    super(t114, xu), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t) {
                    "heatmap-color" === t && this._updateColorRamp();
                }
                _updateColorRamp() {
                    this.colorRamp = vu({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }), this.colorRampTexture = null;
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
                }
                queryRadius(t) {
                    return ul("heatmap-radius", this, t);
                }
                queryIntersectsFeature(t, e, r, n, i, s, a, o) {
                    const l10 = this.paint.get("heatmap-radius").evaluate(e, r);
                    return ou(t, n, s, a, o, !0, !0, new d2(0, 0), l10);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "heatmap",
                        "heatmapTexture"
                    ];
                }
                getProgramConfiguration(t) {
                    return new ho(this, t);
                }
            },
            hillshade: class extends bo {
                constructor(t115){
                    super(t115, bu);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "hillshade",
                        "hillshadePrepare"
                    ];
                }
            },
            fill: class extends bo {
                constructor(t116){
                    super(t116, ac);
                }
                getProgramIds() {
                    const t117 = this.paint.get("fill-pattern"), e77 = t117 && t117.constantOr(1), r46 = [
                        e77 ? "fillPattern" : "fill"
                    ];
                    return this.paint.get("fill-antialias") && r46.push(e77 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r46;
                }
                getProgramConfiguration(t) {
                    return new ho(this, t);
                }
                recalculate(t, e) {
                    super.recalculate(t, e);
                    const r46 = this.paint._values["fill-outline-color"];
                    "constant" === r46.value.kind && (void 0) === r46.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                }
                createBucket(t) {
                    return new ic(t);
                }
                queryRadius() {
                    return cl(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(t, e, r, n, i, s) {
                    return !t.queryGeometry.isAboveHorizon && Qo(hl(t.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, t.pixelToTileUnitsFactor), n);
                }
                isTileClipped() {
                    return !0;
                }
            },
            "fill-extrusion": class extends bo {
                constructor(t117){
                    super(t117, $c);
                }
                createBucket(t) {
                    return new Ec(t);
                }
                queryRadius() {
                    return cl(this.paint.get("fill-extrusion-translate"));
                }
                is3D() {
                    return !0;
                }
                getProgramIds() {
                    return [
                        this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"
                    ];
                }
                getProgramConfiguration(t) {
                    return new ho(this, t);
                }
                queryIntersectsFeature(t, e, r, n, i, s, a, o, l) {
                    const u9 = pl(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s.angle, t.pixelToTileUnitsFactor), c7 = this.paint.get("fill-extrusion-height").evaluate(e, r), h5 = this.paint.get("fill-extrusion-base").evaluate(e, r), p5 = [
                        0,
                        0
                    ], f4 = o && s.elevation, y2 = s.elevation ? s.elevation.exaggeration() : 1, m2 = t.tile.getBucket(this);
                    if (f4 && m2 instanceof Ec) {
                        const t118 = m2.centroidVertexArray, e77 = l + 1;
                        e77 < t118.length && (p5[0] = t118.geta_centroid_pos0(e77), p5[1] = t118.geta_centroid_pos1(e77));
                    }
                    if (0 === p5[0] && 1 === p5[1]) return !1;
                    "globe" === s.projection.name && (n = jc([
                        n
                    ], [
                        new d2(0, 0),
                        new d2(So, So)
                    ], t.tileID.canonical).map((t118)=>t118.polygon
                    ).flat());
                    const g2 = f4 ? o : null, [x2, v2] = function(t118, e77, r46, n32, i25, s18, a12, o12, l10, u10, c8) {
                        return "globe" === t118.projection.name ? (function(t119, e78, r47, n33, i26, s19, a13, o13, l11, u11, c9) {
                            const h6 = [], p6 = [], f5 = t119.projection.upVectorScale(c9, t119.center.lat, t119.worldSize).metersToTile, d4 = [
                                0,
                                0,
                                0,
                                1
                            ], y3 = [
                                0,
                                0,
                                0,
                                1
                            ], m3 = (t120, e79, r48, n34)=>{
                                t120[0] = e79, t120[1] = r48, t120[2] = n34, t120[3] = 1;
                            }, g3 = Rc();
                            r47 > 0 && (r47 += g3), n33 += g3;
                            for (const g4 of e78){
                                const e79 = [], x3 = [];
                                for (const h7 of g4){
                                    const p7 = h7.x + i26.x, g5 = h7.y + i26.y, v3 = t119.projection.projectTilePoint(p7, g5, c9), b2 = t119.projection.upVector(c9, h7.x, h7.y);
                                    let w2 = r47, _2 = n33;
                                    if (a13) {
                                        const t120 = Hc(p7, g5, r47, n33, a13, o13, l11, u11);
                                        w2 += t120.base, _2 += t120.top;
                                    }
                                    0 !== r47 ? m3(d4, v3.x + b2[0] * f5 * w2, v3.y + b2[1] * f5 * w2, v3.z + b2[2] * f5 * w2) : m3(d4, v3.x, v3.y, v3.z), m3(y3, v3.x + b2[0] * f5 * _2, v3.y + b2[1] * f5 * _2, v3.z + b2[2] * f5 * _2), ql(d4, d4, s19), ql(y3, y3, s19), e79.push(new Zc(d4[0], d4[1], d4[2])), x3.push(new Zc(y3[0], y3[1], y3[2]));
                                }
                                h6.push(e79), p6.push(x3);
                            }
                            return [
                                h6,
                                p6
                            ];
                        })(t118, e77, r46, n32, i25, s18, a12, o12, l10, u10, c8) : a12 ? (function(t119, e78, r47, n33, i26, s19, a13, o13, l11) {
                            const u11 = [], c9 = [], h6 = [
                                0,
                                0,
                                0,
                                1
                            ];
                            for (const p6 of t119){
                                const t120 = [], f5 = [];
                                for (const u12 of p6){
                                    const c10 = u12.x + n33.x, p7 = u12.y + n33.y, d4 = Hc(c10, p7, e78, r47, s19, a13, o13, l11);
                                    h6[0] = c10, h6[1] = p7, h6[2] = d4.base, h6[3] = 1, Wl(h6, h6, i26), h6[3] = Math.max(h6[3], 0.00001);
                                    const y3 = new Zc(h6[0] / h6[3], h6[1] / h6[3], h6[2] / h6[3]);
                                    h6[0] = c10, h6[1] = p7, h6[2] = d4.top, h6[3] = 1, Wl(h6, h6, i26), h6[3] = Math.max(h6[3], 0.00001);
                                    const m3 = new Zc(h6[0] / h6[3], h6[1] / h6[3], h6[2] / h6[3]);
                                    t120.push(y3), f5.push(m3);
                                }
                                u11.push(t120), c9.push(f5);
                            }
                            return [
                                u11,
                                c9
                            ];
                        })(e77, r46, n32, i25, s18, a12, o12, l10, u10) : (function(t119, e78, r47, n33, i26) {
                            const s19 = [], a13 = [], o13 = i26[8] * e78, l11 = i26[9] * e78, u11 = i26[10] * e78, c9 = i26[11] * e78, h6 = i26[8] * r47, p6 = i26[9] * r47, f5 = i26[10] * r47, d4 = i26[11] * r47;
                            for (const e79 of t119){
                                const t120 = [], r48 = [];
                                for (const s20 of e79){
                                    const e80 = s20.x + n33.x, a14 = s20.y + n33.y, y3 = i26[0] * e80 + i26[4] * a14 + i26[12], m3 = i26[1] * e80 + i26[5] * a14 + i26[13], g3 = i26[2] * e80 + i26[6] * a14 + i26[14], x3 = i26[3] * e80 + i26[7] * a14 + i26[15], v3 = y3 + o13, b2 = m3 + l11, w2 = g3 + u11, _2 = Math.max(x3 + c9, 0.00001), A2 = y3 + h6, S2 = m3 + p6, k2 = g3 + f5, I2 = Math.max(x3 + d4, 0.00001);
                                    t120.push(new Zc(v3 / _2, b2 / _2, w2 / _2)), r48.push(new Zc(A2 / I2, S2 / I2, k2 / I2));
                                }
                                s19.push(t120), a13.push(r48);
                            }
                            return [
                                s19,
                                a13
                            ];
                        })(e77, r46, n32, i25, s18);
                    }(s, n, h5, c7, u9, a, g2, p5, y2, s.center.lat, t.tileID.canonical), b2 = t.queryGeometry;
                    return (function(t118, e77, r46) {
                        let n32 = 1 / 0;
                        Qo(r46, e77) && (n32 = Yc(r46, e77[0]));
                        for(let i25 = 0; i25 < e77.length; i25++){
                            const s18 = e77[i25], a12 = t118[i25];
                            for(let t119 = 0; t119 < s18.length - 1; t119++){
                                const e78 = s18[t119], i26 = [
                                    e78,
                                    s18[t119 + 1],
                                    a12[t119 + 1],
                                    a12[t119],
                                    e78
                                ];
                                Wo(r46, i26) && (n32 = Math.min(n32, Yc(r46, i26)));
                            }
                        }
                        return n32 !== 1 / 0 && n32;
                    })(x2, v2, b2.isPointQuery() ? b2.screenBounds : b2.screenGeometry);
                }
            },
            line: class extends bo {
                constructor(t118){
                    super(t118, sh), this.gradientVersion = 0;
                }
                _handleSpecialPaintPropertyUpdate(t) {
                    if ("line-gradient" === t) {
                        const t119 = this._transitionablePaint._values["line-gradient"].value.expression;
                        this.stepInterpolant = t119._styleExpression && t119._styleExpression.expression instanceof Ir, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                    }
                }
                gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression;
                }
                recalculate(t, e) {
                    super.recalculate(t, e), this.paint._values["line-floorwidth"] = ah.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
                }
                createBucket(t) {
                    return new nh(t);
                }
                getProgramIds() {
                    return [
                        this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"
                    ];
                }
                getProgramConfiguration(t) {
                    return new ho(this, t);
                }
                queryRadius(t) {
                    const e77 = t, r46 = oh(ul("line-width", this, e77), ul("line-gap-width", this, e77)), n32 = ul("line-offset", this, e77);
                    return r46 / 2 + Math.abs(n32) + cl(this.paint.get("line-translate"));
                }
                queryIntersectsFeature(t, e, r, n, i, s) {
                    if (t.queryGeometry.isAboveHorizon) return !1;
                    const a12 = hl(t.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s.angle, t.pixelToTileUnitsFactor), o12 = t.pixelToTileUnitsFactor / 2 * oh(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)), l10 = this.paint.get("line-offset").evaluate(e, r);
                    return l10 && (n = (function(t119, e77) {
                        const r46 = [], n32 = new d2(0, 0);
                        for(let i25 = 0; i25 < t119.length; i25++){
                            const s18 = t119[i25], a13 = [];
                            for(let t120 = 0; t120 < s18.length; t120++){
                                const r47 = s18[t120 - 1], i26 = s18[t120], o13 = s18[t120 + 1], l11 = 0 === t120 ? n32 : i26.sub(r47)._unit()._perp(), u9 = t120 === s18.length - 1 ? n32 : o13.sub(i26)._unit()._perp(), c7 = l11._add(u9)._unit();
                                c7._mult(1 / (c7.x * u9.x + c7.y * u9.y)), a13.push(c7._mult(e77)._add(i26));
                            }
                            r46.push(a13);
                        }
                        return r46;
                    })(n, l10 * t.pixelToTileUnitsFactor)), (function(t119, e77, r46) {
                        for(let n32 = 0; n32 < e77.length; n32++){
                            const i25 = e77[n32];
                            if (t119.length >= 3) for(let e78 = 0; e78 < i25.length; e78++)if (al(t119, i25[e78])) return !0;
                            if (tl(t119, i25, r46)) return !0;
                        }
                        return !1;
                    })(a12, n, o12);
                }
                isTileClipped() {
                    return !0;
                }
            },
            symbol: dd,
            background: class extends bo {
                constructor(t119){
                    super(t119, yd);
                }
                getProgramIds() {
                    return [
                        this.paint.get("background-pattern") ? "backgroundPattern" : "background"
                    ];
                }
            },
            raster: class extends bo {
                constructor(t120){
                    super(t120, md);
                }
                getProgramIds() {
                    return [
                        "raster"
                    ];
                }
            },
            sky: class extends bo {
                constructor(t121){
                    super(t121, xd), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t) {
                    "sky-gradient" === t ? this._updateColorRamp() : "sky-atmosphere-sun" !== t && "sky-atmosphere-halo-color" !== t && "sky-atmosphere-color" !== t && "sky-atmosphere-sun-intensity" !== t || (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                    this.colorRamp = vu({
                        expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                        evaluationKey: "skyRadialProgress"
                    }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
                }
                needsSkyboxCapture(t) {
                    if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                        const e77 = t.style.light.properties.get("position");
                        return this._lightPosition.azimuthal !== e77.azimuthal || this._lightPosition.polar !== e77.polar;
                    }
                    return !1;
                }
                getCenter(t, e) {
                    if ("atmosphere" === this.paint.get("sky-type")) {
                        const r46 = this.paint.get("sky-atmosphere-sun"), n32 = !r46, i25 = t.style.light, s18 = i25.properties.get("position");
                        return n32 && "viewport" === i25.properties.get("anchor") && $("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n32 ? vd(s18.azimuthal, 90 - s18.polar, e) : vd(r46[0], 90 - r46[1], e);
                    }
                    const r46 = this.paint.get("sky-gradient-center");
                    return vd(r46[0], 90 - r46[1], e);
                }
                is3D() {
                    return !1;
                }
                isSky() {
                    return !0;
                }
                markSkyboxValid(t) {
                    this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get("position");
                }
                hasOffscreenPass() {
                    return !0;
                }
                getProgramIds() {
                    const t122 = this.paint.get("sky-type");
                    return "atmosphere" === t122 ? [
                        "skyboxCapture",
                        "skybox"
                    ] : "gradient" === t122 ? [
                        "skyboxGradient"
                    ] : null;
                }
            }
        };
        class wd {
            constructor(t113, e77, r46, n32){
                this.context = t113, this.format = r46, this.texture = t113.gl.createTexture(), this.update(e77, n32);
            }
            update(t, r, n) {
                const { width: i25 , height: s18  } = t, { context: a12  } = this, { gl: o12  } = a12, { HTMLImageElement: l10 , HTMLCanvasElement: u9 , HTMLVideoElement: c7 , ImageData: h5 , ImageBitmap: p5  } = e2;
                if (o12.bindTexture(o12.TEXTURE_2D, this.texture), a12.pixelStoreUnpackFlipY.set(!1), a12.pixelStoreUnpack.set(1), a12.pixelStoreUnpackPremultiplyAlpha.set(this.format === o12.RGBA && (!r || !1 !== r.premultiply)), n || this.size && this.size[0] === i25 && this.size[1] === s18) {
                    const { x: e78 , y: r47  } = n || {
                        x: 0,
                        y: 0
                    };
                    t instanceof l10 || t instanceof u9 || t instanceof c7 || t instanceof h5 || p5 && t instanceof p5 ? o12.texSubImage2D(o12.TEXTURE_2D, 0, e78, r47, o12.RGBA, o12.UNSIGNED_BYTE, t) : o12.texSubImage2D(o12.TEXTURE_2D, 0, e78, r47, i25, s18, o12.RGBA, o12.UNSIGNED_BYTE, t.data);
                } else this.size = [
                    i25,
                    s18
                ], t instanceof l10 || t instanceof u9 || t instanceof c7 || t instanceof h5 || p5 && t instanceof p5 ? o12.texImage2D(o12.TEXTURE_2D, 0, this.format, this.format, o12.UNSIGNED_BYTE, t) : o12.texImage2D(o12.TEXTURE_2D, 0, this.format, i25, s18, 0, this.format, o12.UNSIGNED_BYTE, t.data);
                this.useMipmap = Boolean(r && r.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o12.generateMipmap(o12.TEXTURE_2D);
            }
            bind(t, e) {
                const { context: r47  } = this, { gl: n33  } = r47;
                n33.bindTexture(n33.TEXTURE_2D, this.texture), t !== this.filter && (n33.texParameteri(n33.TEXTURE_2D, n33.TEXTURE_MAG_FILTER, t), n33.texParameteri(n33.TEXTURE_2D, n33.TEXTURE_MIN_FILTER, this.useMipmap ? t === n33.NEAREST ? n33.NEAREST_MIPMAP_NEAREST : n33.LINEAR_MIPMAP_NEAREST : t), this.filter = t), e !== this.wrap && (n33.texParameteri(n33.TEXTURE_2D, n33.TEXTURE_WRAP_S, e), n33.texParameteri(n33.TEXTURE_2D, n33.TEXTURE_WRAP_T, e), this.wrap = e);
            }
            isSizePowerOfTwo() {
                return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
                const { gl: t114  } = this.context;
                t114.deleteTexture(this.texture), this.texture = null;
            }
        }
        class _d {
            constructor(t114){
                this._callback = t114, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = ()=>{
                    this._triggered = !1, this._callback();
                });
            }
            trigger() {
                this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(()=>{
                    this._triggered = !1, this._callback();
                }, 0));
            }
            remove() {
                this._channel = void 0, this._callback = ()=>{
                };
            }
        }
        class Ad {
            constructor(){
                this.tasks = {
                }, this.taskQueue = [], V([
                    "process"
                ], this), this.invoker = new _d(this.process), this.nextId = 0;
            }
            add(t, e) {
                const r47 = this.nextId++, n33 = function({ type: t115 , isSymbolTile: e78 , zoom: r48  }) {
                    return r48 = r48 || 0, "message" === t115 ? 0 : "maybePrepare" !== t115 || e78 ? "parseTile" !== t115 || e78 ? "parseTile" === t115 && e78 ? 300 - r48 : "maybePrepare" === t115 && e78 ? 400 - r48 : 500 : 200 - r48 : 100 - r48;
                }(e);
                if (0 === n33) {
                    N();
                    t();
                    return {
                        cancel: ()=>{
                        }
                    };
                }
                return this.tasks[r47] = {
                    fn: t,
                    metadata: e,
                    priority: n33,
                    id: r47
                }, this.taskQueue.push(r47), this.invoker.trigger(), {
                    cancel: ()=>{
                        delete this.tasks[r47];
                    }
                };
            }
            process() {
                N();
                {
                    if (this.taskQueue = this.taskQueue.filter((t115)=>!!this.tasks[t115]
                    ), !this.taskQueue.length) return;
                    const t115 = this.pick();
                    if (null === t115) return;
                    const e78 = this.tasks[t115];
                    if (delete this.tasks[t115], this.taskQueue.length && this.invoker.trigger(), !e78) return;
                    e78.fn();
                }
            }
            pick() {
                let t115 = null, e78 = 1 / 0;
                for(let r47 = 0; r47 < this.taskQueue.length; r47++){
                    const n33 = this.tasks[this.taskQueue[r47]];
                    n33.priority < e78 && (e78 = n33.priority, t115 = r47);
                }
                if (null === t115) return null;
                const r48 = this.taskQueue[t115];
                return this.taskQueue.splice(t115, 1), r48;
            }
            remove() {
                this.invoker.remove();
            }
        }
        class Sd {
            constructor(t115){
                this._stringToNumber = {
                }, this._numberToString = [];
                for(let e78 = 0; e78 < t115.length; e78++){
                    const r47 = t115[e78];
                    this._stringToNumber[r47] = e78, this._numberToString[e78] = r47;
                }
            }
            encode(t) {
                return this._stringToNumber[t];
            }
            decode(t) {
                return this._numberToString[t];
            }
        }
        const kd = [
            "tile",
            "layer",
            "source",
            "sourceLayer",
            "state"
        ];
        class Id {
            constructor(t116, e79, r47, n33, i25){
                this.type = "Feature", this._vectorTileFeature = t116, this._z = e79, this._x = r47, this._y = n33, this.properties = t116.properties, this.id = i25;
            }
            get geometry() {
                return (void 0) === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }
            set geometry(t) {
                this._geometry = t;
            }
            toJSON() {
                const t117 = {
                    type: "Feature",
                    geometry: this.geometry,
                    properties: this.properties
                };
                (void 0) !== this.id && (t117.id = this.id);
                for (const e80 of kd)(void 0) !== this[e80] && (t117[e80] = this[e80]);
                return t117;
            }
        }
        const Md = 32, Td = 33, zd = new Uint16Array(8184);
        for(let t117 = 0; t117 < 2046; t117++){
            let e80 = t117 + 2, r48 = 0, n34 = 0, i26 = 0, s18 = 0, a12 = 0, o12 = 0;
            for(1 & e80 ? i26 = s18 = a12 = Md : r48 = n34 = o12 = Md; (e80 >>= 1) > 1;){
                const t118 = r48 + i26 >> 1, l10 = n34 + s18 >> 1;
                1 & e80 ? (i26 = r48, s18 = n34, r48 = a12, n34 = o12) : (r48 = i26, n34 = s18, i26 = a12, s18 = o12), a12 = t118, o12 = l10;
            }
            const l10 = 4 * t117;
            zd[l10 + 0] = r48, zd[l10 + 1] = n34, zd[l10 + 2] = i26, zd[l10 + 3] = s18;
        }
        const Bd = new Uint16Array(2178), Ed = new Uint8Array(1089), Cd = new Uint16Array(1089);
        function Pd(t118) {
            return 0 === t118 ? -0.03125 : 32 === t118 ? 0.03125 : 0;
        }
        var Dd = na([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            },
            {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }
        ]);
        const Vd = {
            type: 2,
            extent: So,
            loadGeometry: ()=>[
                    [
                        new d2(0, 0),
                        new d2(8193, 0),
                        new d2(8193, 8193),
                        new d2(0, 8193),
                        new d2(0, 0)
                    ]
                ]
        };
        class Ld {
            constructor(t118, e80, r48, n34, i26){
                this.tileID = t118, this.uid = E(), this.uses = 0, this.tileSize = e80, this.tileZoom = r48, this.buckets = {
                }, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {
                }, this.isRaster = i26, this.expiredRequestCount = 0, this.state = "loading", n34 && n34.transform && (this.projection = n34.transform.projection);
            }
            registerFadeDuration(t) {
                const e81 = t + this.timeAdded;
                e81 < Nt.now() || this.fadeEndTime && e81 < this.fadeEndTime || (this.fadeEndTime = e81);
            }
            wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            get tileTransform() {
                return this._tileTransform || (this._tileTransform = Df(this.tileID.canonical, this.projection)), this._tileTransform;
            }
            loadVectorData(t, e, r) {
                if (this.unloadVectorData(), this.state = "loaded", t) {
                    t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = (function(t119, e81) {
                        const r49 = {
                        };
                        if (!e81) return r49;
                        for (const n35 of t119){
                            const t120 = n35.layerIds.map((t121)=>e81.getLayer(t121)
                            ).filter(Boolean);
                            if (0 !== t120.length) {
                                n35.layers = t120, n35.stateDependentLayerIds && (n35.stateDependentLayers = n35.stateDependentLayerIds.map((e82)=>t120.filter((t121)=>t121.id === e82
                                    )[0]
                                ));
                                for (const e82 of t120)r49[e82.id] = n35;
                            }
                        }
                        return r49;
                    })(t.buckets, e.style), this.hasSymbolBuckets = !1;
                    for(const t119 in this.buckets){
                        const e81 = this.buckets[t119];
                        if (e81 instanceof cd) {
                            if (this.hasSymbolBuckets = !0, !r) break;
                            e81.justReloaded = !0;
                        }
                    }
                    if (this.hasRTLText = !1, this.hasSymbolBuckets) for(const t120 in this.buckets){
                        const e81 = this.buckets[t120];
                        if (e81 instanceof cd && e81.hasRTLText) {
                            this.hasRTLText = !0, js.isLoading() || js.isLoaded() || "deferred" !== Fs() || Rs();
                            break;
                        }
                    }
                    this.queryPadding = 0;
                    for(const t121 in this.buckets){
                        const r49 = this.buckets[t121];
                        this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(t121).queryRadius(r49));
                    }
                    t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas);
                } else this.collisionBoxArray = new Ea;
            }
            unloadVectorData() {
                if (this.hasData()) {
                    for(const t119 in this.buckets)this.buckets[t119].destroy();
                    this.buckets = {
                    }, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
                }
            }
            getBucket(t) {
                return this.buckets[t.id];
            }
            upload(t) {
                for(const e81 in this.buckets){
                    const r49 = this.buckets[e81];
                    r49.uploadPending() && r49.upload(t);
                }
                const e82 = t.gl;
                this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new wd(t, this.imageAtlas.image, e82.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new wd(t, this.glyphAtlasImage, e82.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new wd(t, this.lineAtlas.image, e82.ALPHA), this.lineAtlas.uploaded = !0);
            }
            prepare(t) {
                this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t, e, r, n, i, s, a, o) {
                return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                    tileResult: n,
                    pixelPosMatrix: a,
                    transform: s,
                    params: i,
                    tileTransform: this.tileTransform
                }, t, e, r) : {
                };
            }
            querySourceFeatures(t, e) {
                const r49 = this.latestFeatureIndex;
                if (!r49 || !r49.rawTileData) return;
                const n35 = r49.loadVTLayers(), i27 = e ? e.sourceLayer : "", s18 = n35._geojsonTileLayer || n35[i27];
                if (!s18) return;
                const a12 = ai(e && e.filter), { z: o12 , x: l10 , y: u9  } = this.tileID.canonical, c7 = {
                    z: o12,
                    x: l10,
                    y: u9
                };
                for(let e81 = 0; e81 < s18.length; e81++){
                    const n36 = s18.feature(e81);
                    if (a12.needGeometry) {
                        const t119 = Zo(n36, !0);
                        if (!a12.filter(new Us(this.tileID.overscaledZ), t119, this.tileID.canonical)) continue;
                    } else if (!a12.filter(new Us(this.tileID.overscaledZ), n36)) continue;
                    const h5 = r49.getId(n36, i27), p5 = new Id(n36, o12, l10, u9, h5);
                    p5.tile = c7, t.push(p5);
                }
            }
            hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
                return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(t) {
                const e81 = this.expirationTime;
                if (t.cacheControl) {
                    const e82 = G(t.cacheControl);
                    e82["max-age"] && (this.expirationTime = Date.now() + 1000 * e82["max-age"]);
                } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
                if (this.expirationTime) {
                    const t119 = Date.now();
                    let r49 = !1;
                    if (this.expirationTime > t119) r49 = !1;
                    else if (e81) {
                        if (this.expirationTime < e81) r49 = !0;
                        else {
                            const n35 = this.expirationTime - e81;
                            n35 ? this.expirationTime = t119 + Math.max(n35, 30000) : r49 = !0;
                        }
                    } else r49 = !0;
                    r49 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                }
            }
            getExpiryTimeout() {
                if (this.expirationTime) return this.expiredRequestCount ? 1000 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t, e) {
                if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t).length || !e) return;
                const r49 = this.latestFeatureIndex.loadVTLayers(), n35 = e.style.listImages();
                for(const i27 in this.buckets){
                    if (!e.style.hasLayer(i27)) continue;
                    const s18 = this.buckets[i27], a12 = s18.layers[0].sourceLayer || "_geojsonTileLayer", o12 = r49[a12], l10 = t[a12];
                    if (!o12 || !l10 || 0 === Object.keys(l10).length) continue;
                    if (s18.update(l10, o12, n35, this.imageAtlas && this.imageAtlas.patternPositions || {
                    }), s18 instanceof nh || s18 instanceof ic) {
                        const t119 = e.style._getSourceCache(s18.layers[0].source);
                        e._terrain && e._terrain.enabled && t119 && s18.programConfigurations.needsUpload && e._terrain._clearRenderCacheForTile(t119.id, this.tileID);
                    }
                    const u9 = e && e.style && e.style.getLayer(i27);
                    u9 && (this.queryPadding = Math.max(this.queryPadding, u9.queryRadius(s18)));
                }
            }
            holdingForFade() {
                return (void 0) !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Nt.now();
            }
            clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t) {
                this.symbolFadeHoldUntil = Nt.now() + t;
            }
            setTexture(t, e) {
                const r49 = e.context, n35 = r49.gl;
                this.texture = this.texture || e.getTileTexture(t.width), this.texture ? this.texture.update(t, {
                    useMipmap: !0
                }) : (this.texture = new wd(r49, t, n35.RGBA, {
                    useMipmap: !0
                }), this.texture.bind(n35.LINEAR, n35.CLAMP_TO_EDGE), r49.extTextureFilterAnisotropic && n35.texParameterf(n35.TEXTURE_2D, r49.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r49.extTextureFilterAnisotropicMax));
            }
            setDependencies(t, e) {
                const r49 = {
                };
                for (const t119 of e)r49[t119] = !0;
                this.dependencies[t] = r49;
            }
            hasDependency(t, e) {
                for (const r49 of t){
                    const t119 = this.dependencies[r49];
                    if (t119) for (const r50 of e)if (t119[r50]) return !0;
                }
                return !1;
            }
            clearQueryDebugViz() {
            }
            _makeDebugTileBoundsBuffers(t, e) {
                if (!e || "mercator" === e.name || this._tileDebugBuffer) return;
                const r49 = Xo(Vd, this.tileID.canonical, this.tileTransform)[0], n35 = new sa, i27 = new Ta;
                for(let t119 = 0; t119 < r49.length; t119++){
                    const { x: e81 , y: s18  } = r49[t119];
                    n35.emplaceBack(e81, s18), i27.emplaceBack(t119);
                }
                i27.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(i27), this._tileDebugBuffer = t.createVertexBuffer(n35, tf.members), this._tileDebugSegments = Ao.simpleSegment(0, 0, n35.length, i27.length);
            }
            _makeTileBoundsBuffers(t, e) {
                if (this._tileBoundsBuffer || !e || "mercator" === e.name) return;
                const r49 = Xo(Vd, this.tileID.canonical, this.tileTransform)[0];
                let n35, i27;
                if (this.isRaster) {
                    const t119 = function(t120, e81) {
                        const r50 = Df(t120, e81), n36 = Math.pow(2, t120.z);
                        for(let i28 = 0; i28 < Td; i28++)for(let s18 = 0; s18 < Td; s18++){
                            const a12 = Po((t120.x + (s18 + Pd(s18)) / Md) / n36), o12 = Do((t120.y + (i28 + Pd(i28)) / Md) / n36), l10 = e81.project(a12, o12), u9 = i28 * Td + s18;
                            Bd[2 * u9 + 0] = Math.round((l10.x * r50.scale - r50.x) * So), Bd[2 * u9 + 1] = Math.round((l10.y * r50.scale - r50.y) * So);
                        }
                        Ed.fill(0), Cd.fill(0);
                        for(let t121 = 2045; t121 >= 0; t121--){
                            const e82 = 4 * t121, r51 = zd[e82 + 0], n37 = zd[e82 + 1], i29 = zd[e82 + 2], s19 = zd[e82 + 3], a12 = r51 + i29 >> 1, o12 = n37 + s19 >> 1, l10 = a12 + o12 - n37, u9 = o12 + r51 - a12, c7 = n37 * Td + r51, h5 = s19 * Td + i29, p5 = o12 * Td + a12, f4 = Math.hypot((Bd[2 * c7 + 0] + Bd[2 * h5 + 0]) / 2 - Bd[2 * p5 + 0], (Bd[2 * c7 + 1] + Bd[2 * h5 + 1]) / 2 - Bd[2 * p5 + 1]) >= 16;
                            if (Ed[p5] = Ed[p5] || (f4 ? 1 : 0), t121 < 1022) {
                                const t122 = (n37 + u9 >> 1) * Td + (r51 + l10 >> 1), e83 = (s19 + u9 >> 1) * Td + (i29 + l10 >> 1);
                                Ed[p5] = Ed[p5] || Ed[t122] || Ed[e83];
                            }
                        }
                        const i29 = new oa, s19 = new wa;
                        let a12 = 0;
                        function o12(t122, e82) {
                            const r51 = e82 * Td + t122;
                            return 0 === Cd[r51] && (i29.emplaceBack(Bd[2 * r51 + 0], Bd[2 * r51 + 1], t122 * So / Md, e82 * So / Md), Cd[r51] = ++a12), Cd[r51] - 1;
                        }
                        function l10(t122, e82, r51, n37, i30, a13) {
                            const u9 = t122 + r51 >> 1, c7 = e82 + n37 >> 1;
                            if (Math.abs(t122 - i30) + Math.abs(e82 - a13) > 1 && Ed[c7 * Td + u9]) l10(i30, a13, t122, e82, u9, c7), l10(r51, n37, i30, a13, u9, c7);
                            else {
                                const l11 = o12(t122, e82), u10 = o12(r51, n37), c8 = o12(i30, a13);
                                s19.emplaceBack(l11, u10, c8);
                            }
                        }
                        return l10(0, 0, Md, Md, Md, 0), l10(Md, Md, 0, 0, 0, Md), {
                            vertices: i29,
                            indices: s19
                        };
                    }(this.tileID.canonical, e);
                    n35 = t119.vertices, i27 = t119.indices;
                } else {
                    n35 = new oa, i27 = new wa;
                    for (const { x: t119 , y: e81  } of r49)n35.emplaceBack(t119, e81, 0, 0);
                    const t120 = Au.exports(n35.int16, void 0, 4);
                    for(let e82 = 0; e82 < t120.length; e82 += 3)i27.emplaceBack(t120[e82], t120[e82 + 1], t120[e82 + 2]);
                }
                this._tileBoundsBuffer = t.createVertexBuffer(n35, Dd.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(i27), this._tileBoundsSegments = Ao.simpleSegment(0, 0, n35.length, i27.length);
            }
            _makeGlobeTileDebugBuffers(t, e) {
                const r49 = e.projection;
                if (!r49 || "globe" !== r49.name || e.freezeTileCoverage) return;
                const n35 = this.tileID.canonical, i27 = Sf(df(n35, e)), s18 = Mf(e.zoom);
                let a12;
                s18 > 0 && (a12 = bl(new Float64Array(16), e.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, n35, e, i27, a12, s18), this._makeGlobeTileDebugTextBuffer(t, n35, e, i27, a12, s18);
            }
            _globePoint(t, e, r, n, i, s, a) {
                let o12 = wf(t, e, r);
                if (s) {
                    const i27 = 1 << r.z, l10 = Bo(n.center.lng), u9 = Eo(n.center.lat), c7 = (r.x + 0.5) / i27 - l10;
                    let h5 = 0;
                    c7 > 0.5 ? h5 = -1 : c7 < -0.5 && (h5 = 1);
                    let p5 = (t / So + r.x) / i27 + h5, f4 = (e / So + r.y) / i27;
                    p5 = (p5 - l10) * n._pixelsPerMercatorPixel + l10, f4 = (f4 - u9) * n._pixelsPerMercatorPixel + u9;
                    const d4 = [
                        p5 * n.worldSize,
                        f4 * n.worldSize,
                        0
                    ];
                    ql(d4, d4, s), o12 = ff(o12, d4, a);
                }
                return ql(o12, o12, i);
            }
            _makeGlobeTileDebugBorderBuffer(t, e, r, n, i, s) {
                const a12 = new sa, o12 = new Ta, l10 = new aa, u9 = (t119, u10, c7, h5, p5)=>{
                    const f4 = (c7 - t119) / (p5 - 1), d4 = (h5 - u10) / (p5 - 1), y2 = a12.length;
                    for(let c8 = 0; c8 < p5; c8++){
                        const h6 = t119 + c8 * f4, p6 = u10 + c8 * d4;
                        a12.emplaceBack(h6, p6);
                        const m2 = this._globePoint(h6, p6, e, r, n, i, s);
                        l10.emplaceBack(m2[0], m2[1], m2[2]), o12.emplaceBack(y2 + c8);
                    }
                }, c7 = So;
                u9(0, 0, c7, 0, 16), u9(c7, 0, c7, c7, 16), u9(c7, c7, 0, c7, 16), u9(0, c7, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(o12), this._tileDebugBuffer = t.createVertexBuffer(a12, tf.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(l10, Qp.members), this._tileDebugSegments = Ao.simpleSegment(0, 0, a12.length, o12.length);
            }
            _makeGlobeTileDebugTextBuffer(t, e, r, n, i, s) {
                const a12 = new sa, o12 = new wa, l10 = new aa, u9 = 25;
                o12.reserve(32), a12.reserve(u9), l10.reserve(u9);
                const c7 = (t119, e81)=>u9 * t119 + e81
                ;
                for(let t119 = 0; t119 < u9; t119++){
                    const o13 = 2048 * t119;
                    for(let t120 = 0; t120 < u9; t120++){
                        const u10 = 2048 * t120;
                        a12.emplaceBack(u10, o13);
                        const c8 = this._globePoint(u10, o13, e, r, n, i, s);
                        l10.emplaceBack(c8[0], c8[1], c8[2]);
                    }
                }
                for(let t120 = 0; t120 < 4; t120++)for(let e81 = 0; e81 < 4; e81++){
                    const r49 = c7(t120, e81), n35 = c7(t120, e81 + 1), i27 = c7(t120 + 1, e81), s18 = c7(t120 + 1, e81 + 1);
                    o12.emplaceBack(r49, n35, i27), o12.emplaceBack(i27, n35, s18);
                }
                this._tileDebugTextIndexBuffer = t.createIndexBuffer(o12), this._tileDebugTextBuffer = t.createVertexBuffer(a12, tf.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(l10, Qp.members), this._tileDebugTextSegments = Ao.simpleSegment(0, 0, u9, 32);
            }
        }
        class Fd {
            constructor(){
                this.state = {
                }, this.stateChanges = {
                }, this.deletedStates = {
                };
            }
            updateState(t, e, r) {
                const n35 = String(e);
                if (this.stateChanges[t] = this.stateChanges[t] || {
                }, this.stateChanges[t][n35] = this.stateChanges[t][n35] || {
                }, z1(this.stateChanges[t][n35], r), null === this.deletedStates[t]) {
                    this.deletedStates[t] = {
                    };
                    for(const e81 in this.state[t])e81 !== n35 && (this.deletedStates[t][e81] = null);
                } else if (this.deletedStates[t] && null === this.deletedStates[t][n35]) {
                    this.deletedStates[t][n35] = {
                    };
                    for(const e81 in this.state[t][n35])r[e81] || (this.deletedStates[t][n35][e81] = null);
                } else for(const e81 in r)this.deletedStates[t] && this.deletedStates[t][n35] && null === this.deletedStates[t][n35][e81] && delete this.deletedStates[t][n35][e81];
            }
            removeFeatureState(t, e, r) {
                if (null === this.deletedStates[t]) return;
                const n35 = String(e);
                if (this.deletedStates[t] = this.deletedStates[t] || {
                }, r && (void 0) !== e) null !== this.deletedStates[t][n35] && (this.deletedStates[t][n35] = this.deletedStates[t][n35] || {
                }, this.deletedStates[t][n35][r] = null);
                else if ((void 0) !== e) {
                    if (this.stateChanges[t] && this.stateChanges[t][n35]) for(r in this.deletedStates[t][n35] = {
                    }, this.stateChanges[t][n35])this.deletedStates[t][n35][r] = null;
                    else this.deletedStates[t][n35] = null;
                } else this.deletedStates[t] = null;
            }
            getState(t, e) {
                const r49 = String(e), n35 = z1({
                }, (this.state[t] || {
                })[r49], (this.stateChanges[t] || {
                })[r49]);
                if (null === this.deletedStates[t]) return {
                };
                if (this.deletedStates[t]) {
                    const r50 = this.deletedStates[t][e];
                    if (null === r50) return {
                    };
                    for(const t119 in r50)delete n35[t119];
                }
                return n35;
            }
            initializeTileState(t, e) {
                t.setFeatureState(this.state, e);
            }
            coalesceChanges(t, e) {
                const r49 = {
                };
                for(const t119 in this.stateChanges){
                    this.state[t119] = this.state[t119] || {
                    };
                    const e81 = {
                    };
                    for(const r50 in this.stateChanges[t119])this.state[t119][r50] || (this.state[t119][r50] = {
                    }), z1(this.state[t119][r50], this.stateChanges[t119][r50]), e81[r50] = this.state[t119][r50];
                    r49[t119] = e81;
                }
                for(const t120 in this.deletedStates){
                    this.state[t120] = this.state[t120] || {
                    };
                    const e81 = {
                    };
                    if (null === this.deletedStates[t120]) for(const r50 in this.state[t120])e81[r50] = {
                    }, this.state[t120][r50] = {
                    };
                    else for(const r51 in this.deletedStates[t120]){
                        if (null === this.deletedStates[t120][r51]) this.state[t120][r51] = {
                        };
                        else for (const e82 of Object.keys(this.deletedStates[t120][r51]))delete this.state[t120][r51][e82];
                        e81[r51] = this.state[t120][r51];
                    }
                    r49[t120] = r49[t120] || {
                    }, z1(r49[t120], e81);
                }
                if (this.stateChanges = {
                }, this.deletedStates = {
                }, 0 !== Object.keys(r49).length) for(const n35 in t)t[n35].setFeatureState(r49, e);
            }
        }
        class Rd {
            constructor(t119){
                this.size = t119, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t, e) {
                const r49 = this.toIdx(t, e);
                return {
                    min: this.minimums[r49],
                    max: this.maximums[r49]
                };
            }
            isLeaf(t, e) {
                return this.leaves[this.toIdx(t, e)];
            }
            toIdx(t, e) {
                return e * this.size + t;
            }
        }
        function jd(t120, e81, r49, n35) {
            let i27 = 0, s18 = Number.MAX_VALUE;
            for(let a12 = 0; a12 < 3; a12++)if (Math.abs(n35[a12]) < 0.000000000000001) {
                if (r49[a12] < t120[a12] || r49[a12] > e81[a12]) return null;
            } else {
                const o12 = 1 / n35[a12];
                let l10 = (t120[a12] - r49[a12]) * o12, u9 = (e81[a12] - r49[a12]) * o12;
                if (l10 > u9) {
                    const t121 = l10;
                    l10 = u9, u9 = t121;
                }
                if (l10 > i27 && (i27 = l10), u9 < s18 && (s18 = u9), i27 > s18) return null;
            }
            return i27;
        }
        function Ud(t120, e81, r49, n35, i27, s18, a12, o12, l10, u9, c7) {
            const h5 = n35 - t120, p5 = i27 - e81, f4 = s18 - r49, d4 = a12 - t120, y2 = o12 - e81, m2 = l10 - r49, g2 = c7[1] * m2 - c7[2] * y2, x2 = c7[2] * d4 - c7[0] * m2, v2 = c7[0] * y2 - c7[1] * d4, b2 = h5 * g2 + p5 * x2 + f4 * v2;
            if (Math.abs(b2) < 0.000000000000001) return null;
            const w2 = 1 / b2, _2 = u9[0] - t120, A2 = u9[1] - e81, S2 = u9[2] - r49, k2 = (_2 * g2 + A2 * x2 + S2 * v2) * w2;
            if (k2 < 0 || k2 > 1) return null;
            const I2 = A2 * f4 - S2 * p5, M2 = S2 * h5 - _2 * f4, T2 = _2 * p5 - A2 * h5, z2 = (c7[0] * I2 + c7[1] * M2 + c7[2] * T2) * w2;
            return z2 < 0 || k2 + z2 > 1 ? null : (d4 * I2 + y2 * M2 + m2 * T2) * w2;
        }
        function $d(t120, e81, r49) {
            return (t120 - e81) / (r49 - e81);
        }
        function Od(t120, e81, r49, n35, i27, s18, a12, o12, l10) {
            const u9 = 1 << r49, c7 = s18 - n35, h5 = a12 - i27, p5 = (t120 + 1) / u9 * c7 + n35, f4 = (e81 + 0) / u9 * h5 + i27, d4 = (e81 + 1) / u9 * h5 + i27;
            o12[0] = (t120 + 0) / u9 * c7 + n35, o12[1] = f4, l10[0] = p5, l10[1] = d4;
        }
        class qd {
            constructor(t120){
                if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t120, this._siblingOffset = [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        1
                    ]
                ], !this.dem) return;
                const e81 = function(t121) {
                    const e82 = Math.ceil(Math.log2(t121.dim / 8)), r49 = [];
                    let n35 = Math.ceil(Math.pow(2, e82));
                    const i27 = 1 / n35, s18 = (t122, e83, r50, n36, i28)=>{
                        const s19 = n36 ? 1 : 0, a12 = (t122 + 1) * r50 - s19, o12 = e83 * r50, l10 = (e83 + 1) * r50 - s19;
                        i28[0] = t122 * r50, i28[1] = o12, i28[2] = a12, i28[3] = l10;
                    };
                    let a12 = new Rd(n35);
                    const o12 = [];
                    for(let e83 = 0; e83 < n35 * n35; e83++){
                        s18(e83 % n35, Math.floor(e83 / n35), i27, !1, o12);
                        const r50 = Gd(o12[0], o12[1], t121), l10 = Gd(o12[2], o12[1], t121), u9 = Gd(o12[2], o12[3], t121), c7 = Gd(o12[0], o12[3], t121);
                        a12.minimums.push(Math.min(r50, l10, u9, c7)), a12.maximums.push(Math.max(r50, l10, u9, c7)), a12.leaves.push(1);
                    }
                    for(r49.push(a12), n35 /= 2; n35 >= 1; n35 /= 2){
                        const t122 = r49[r49.length - 1];
                        a12 = new Rd(n35);
                        for(let e84 = 0; e84 < n35 * n35; e84++){
                            s18(e84 % n35, Math.floor(e84 / n35), 2, !0, o12);
                            const r50 = t122.getElevation(o12[0], o12[1]), i28 = t122.getElevation(o12[2], o12[1]), l10 = t122.getElevation(o12[2], o12[3]), u9 = t122.getElevation(o12[0], o12[3]), c7 = t122.isLeaf(o12[0], o12[1]), h5 = t122.isLeaf(o12[2], o12[1]), p5 = t122.isLeaf(o12[2], o12[3]), f4 = t122.isLeaf(o12[0], o12[3]), d4 = Math.min(r50.min, i28.min, l10.min, u9.min), y2 = Math.max(r50.max, i28.max, l10.max, u9.max), m2 = c7 && h5 && p5 && f4;
                            a12.maximums.push(y2), a12.minimums.push(d4), a12.leaves.push(y2 - d4 <= 5 && m2 ? 1 : 0);
                        }
                        r49.push(a12);
                    }
                    return r49;
                }(this.dem), r49 = e81.length - 1, n35 = e81[r49];
                this._addNode(n35.minimums[0], n35.maximums[0], n35.leaves[0]), this._construct(e81, 0, 0, r49, 0);
            }
            raycastRoot(t, e, r, n, i, s, a = 1) {
                return jd([
                    t,
                    e,
                    -100
                ], [
                    r,
                    n,
                    this.maximums[0] * a
                ], i, s);
            }
            raycast(t, e, r, n, i, s, a = 1) {
                if (!this.nodeCount) return null;
                const o12 = this.raycastRoot(t, e, r, n, i, s, a);
                if (null == o12) return null;
                const l10 = [], u9 = [], c7 = [], h5 = [], p5 = [
                    {
                        idx: 0,
                        t: o12,
                        nodex: 0,
                        nodey: 0,
                        depth: 0
                    }
                ];
                for(; p5.length > 0;){
                    const { idx: o13 , t: f4 , nodex: d4 , nodey: y2 , depth: m2  } = p5.pop();
                    if (this.leaves[o13]) {
                        Od(d4, y2, m2, t, e, r, n, c7, h5);
                        const o14 = 1 << m2, l11 = (d4 + 0) / o14, u10 = (d4 + 1) / o14, p6 = (y2 + 0) / o14, g2 = (y2 + 1) / o14, x2 = Gd(l11, p6, this.dem) * a, v2 = Gd(u10, p6, this.dem) * a, b2 = Gd(u10, g2, this.dem) * a, w2 = Gd(l11, g2, this.dem) * a, _2 = Ud(c7[0], c7[1], x2, h5[0], c7[1], v2, h5[0], h5[1], b2, i, s), A2 = Ud(h5[0], h5[1], b2, c7[0], h5[1], w2, c7[0], c7[1], x2, i, s), S2 = Math.min(null !== _2 ? _2 : Number.MAX_VALUE, null !== A2 ? A2 : Number.MAX_VALUE);
                        if (S2 !== Number.MAX_VALUE) return S2;
                        {
                            const t121 = jl([], i, s, f4);
                            if (Nd(x2, v2, w2, b2, $d(t121[0], c7[0], h5[0]), $d(t121[1], c7[1], h5[1])) >= t121[2]) return f4;
                        }
                        continue;
                    }
                    let g2 = 0;
                    for(let p6 = 0; p6 < this._siblingOffset.length; p6++){
                        Od((d4 << 1) + this._siblingOffset[p6][0], (y2 << 1) + this._siblingOffset[p6][1], m2 + 1, t, e, r, n, c7, h5), c7[2] = -100, h5[2] = this.maximums[this.childOffsets[o13] + p6] * a;
                        const f5 = jd(c7, h5, i, s);
                        if (null != f5) {
                            const t121 = f5;
                            l10[p6] = t121;
                            let e82 = !1;
                            for(let r50 = 0; r50 < g2 && !e82; r50++)t121 >= l10[u9[r50]] && (u9.splice(r50, 0, p6), e82 = !0);
                            e82 || (u9[g2] = p6), g2++;
                        }
                    }
                    for(let t121 = 0; t121 < g2; t121++){
                        const e82 = u9[t121];
                        p5.push({
                            idx: this.childOffsets[o13] + e82,
                            t: l10[e82],
                            nodex: (d4 << 1) + this._siblingOffset[e82][0],
                            nodey: (y2 << 1) + this._siblingOffset[e82][1],
                            depth: m2 + 1
                        });
                    }
                }
                return null;
            }
            _addNode(t, e, r) {
                return this.minimums.push(t), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t, e, r, n, i) {
                if (1 === t[n].isLeaf(e, r)) return;
                this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
                const s18 = n - 1, a12 = t[s18];
                let o12 = 0, l10 = 0;
                for(let t121 = 0; t121 < this._siblingOffset.length; t121++){
                    const n36 = 2 * e + this._siblingOffset[t121][0], i27 = 2 * r + this._siblingOffset[t121][1], s19 = a12.getElevation(n36, i27), u9 = a12.isLeaf(n36, i27), c7 = this._addNode(s19.min, s19.max, u9);
                    u9 && (o12 |= 1 << t121), l10 || (l10 = c7);
                }
                for(let n36 = 0; n36 < this._siblingOffset.length; n36++)o12 & 1 << n36 || this._construct(t, 2 * e + this._siblingOffset[n36][0], 2 * r + this._siblingOffset[n36][1], s18, l10 + n36);
            }
        }
        function Nd(t121, e82, r50, n36, i27, s18) {
            return Mr(Mr(t121, r50, s18), Mr(e82, n36, s18), i27);
        }
        function Gd(t121, e82, r50) {
            const n36 = r50.dim, i27 = S1(t121 * n36 - 0.5, 0, n36 - 1), s18 = S1(e82 * n36 - 0.5, 0, n36 - 1), a12 = Math.floor(i27), o12 = Math.floor(s18), l10 = Math.min(a12 + 1, n36 - 1), u9 = Math.min(o12 + 1, n36 - 1);
            return Nd(r50.get(a12, o12), r50.get(l10, o12), r50.get(a12, u9), r50.get(l10, u9), i27 - a12, s18 - o12);
        }
        const Xd = {
            mapbox: [
                6553.6,
                25.6,
                0.1,
                10000
            ],
            terrarium: [
                256,
                1,
                1 / 256,
                32768
            ]
        };
        class Zd {
            get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t121, e82, r50, n36 = !1, i27 = !1){
                if (this.uid = t121, e82.height !== e82.width) throw new RangeError("DEM tiles must be square");
                if (r50 && "mapbox" !== r50 && "terrarium" !== r50) return $(`"${r50}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                this.stride = e82.height;
                const s18 = this.dim = e82.height - 2, a12 = new Uint32Array(e82.data.buffer);
                if (this.pixels = new Uint8Array(e82.data.buffer), this.encoding = r50 || "mapbox", this.borderReady = n36, !n36) {
                    for(let t122 = 0; t122 < s18; t122++)a12[this._idx(-1, t122)] = a12[this._idx(0, t122)], a12[this._idx(s18, t122)] = a12[this._idx(s18 - 1, t122)], a12[this._idx(t122, -1)] = a12[this._idx(t122, 0)], a12[this._idx(t122, s18)] = a12[this._idx(t122, s18 - 1)];
                    a12[this._idx(-1, -1)] = a12[this._idx(0, 0)], a12[this._idx(s18, -1)] = a12[this._idx(s18 - 1, 0)], a12[this._idx(-1, s18)] = a12[this._idx(0, s18 - 1)], a12[this._idx(s18, s18)] = a12[this._idx(s18 - 1, s18 - 1)], i27 && this._buildQuadTree();
                }
            }
            _buildQuadTree() {
                this._tree = new qd(this);
            }
            get(t, e, r = !1) {
                r && (t = S1(t, -1, this.dim), e = S1(e, -1, this.dim));
                const n37 = 4 * this._idx(t, e);
                return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[n37], this.pixels[n37 + 1], this.pixels[n37 + 2]);
            }
            static getUnpackVector(t) {
                return Xd[t];
            }
            get unpackVector() {
                return Xd[this.encoding];
            }
            _idx(t, e) {
                if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                return (e + 1) * this.stride + (t + 1);
            }
            _unpackMapbox(t, e, r) {
                return (256 * t * 256 + 256 * e + r) / 10 - 10000;
            }
            _unpackTerrarium(t, e, r) {
                return 256 * t + e + r / 256 - 32768;
            }
            static pack(t, e) {
                const r51 = [
                    0,
                    0,
                    0,
                    0
                ], n37 = Zd.getUnpackVector(e);
                let i28 = Math.floor((t + n37[3]) / n37[2]);
                return r51[2] = i28 % 256, i28 = Math.floor(i28 / 256), r51[1] = i28 % 256, i28 = Math.floor(i28 / 256), r51[0] = i28, r51;
            }
            getPixels() {
                return new gu({
                    width: this.stride,
                    height: this.stride
                }, this.pixels);
            }
            backfillBorder(t, e, r) {
                if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
                let n37 = e * this.dim, i28 = e * this.dim + this.dim, s19 = r * this.dim, a13 = r * this.dim + this.dim;
                switch(e){
                    case -1:
                        n37 = i28 - 1;
                        break;
                    case 1:
                        i28 = n37 + 1;
                }
                switch(r){
                    case -1:
                        s19 = a13 - 1;
                        break;
                    case 1:
                        a13 = s19 + 1;
                }
                const o12 = -e * this.dim, l10 = -r * this.dim;
                for(let e83 = s19; e83 < a13; e83++)for(let r51 = n37; r51 < i28; r51++){
                    const n38 = 4 * this._idx(r51, e83), i29 = 4 * this._idx(r51 + o12, e83 + l10);
                    this.pixels[n38 + 0] = t.pixels[i29 + 0], this.pixels[n38 + 1] = t.pixels[i29 + 1], this.pixels[n38 + 2] = t.pixels[i29 + 2], this.pixels[n38 + 3] = t.pixels[i29 + 3];
                }
            }
            onDeserialize() {
                this._tree && (this._tree.dem = this);
            }
        }
        Oi(Zd, "DEMData"), Oi(qd, "DemMinMaxQuadTree", {
            omit: [
                "dem"
            ]
        });
        class Kd {
            constructor(t122, e83){
                this.max = t122, this.onRemove = e83, this.reset();
            }
            reset() {
                for(const t123 in this.data)for (const e84 of this.data[t123])e84.timeout && clearTimeout(e84.timeout), this.onRemove(e84.value);
                return this.data = {
                }, this.order = [], this;
            }
            add(t, e, r) {
                const n37 = t.wrapped().key;
                (void 0) === this.data[n37] && (this.data[n37] = []);
                const i28 = {
                    value: e,
                    timeout: void 0
                };
                if ((void 0) !== r && (i28.timeout = setTimeout(()=>{
                    this.remove(t, i28);
                }, r)), this.data[n37].push(i28), this.order.push(n37), this.order.length > this.max) {
                    const t123 = this._getAndRemoveByKey(this.order[0]);
                    t123 && this.onRemove(t123);
                }
                return this;
            }
            has(t) {
                return t.wrapped().key in this.data;
            }
            getAndRemove(t) {
                return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
            }
            _getAndRemoveByKey(t) {
                const e84 = this.data[t].shift();
                return e84.timeout && clearTimeout(e84.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e84.value;
            }
            getByKey(t) {
                const e84 = this.data[t];
                return e84 ? e84[0].value : null;
            }
            get(t) {
                return this.has(t) ? this.data[t.wrapped().key][0].value : null;
            }
            remove(t, e) {
                if (!this.has(t)) return this;
                const r51 = t.wrapped().key, n37 = (void 0) === e ? 0 : this.data[r51].indexOf(e), i28 = this.data[r51][n37];
                return this.data[r51].splice(n37, 1), i28.timeout && clearTimeout(i28.timeout), 0 === this.data[r51].length && delete this.data[r51], this.onRemove(i28.value), this.order.splice(this.order.indexOf(r51), 1), this;
            }
            setMaxSize(t) {
                for(this.max = t; this.order.length > this.max;){
                    const t123 = this._getAndRemoveByKey(this.order[0]);
                    t123 && this.onRemove(t123);
                }
                return this;
            }
            filter(t) {
                const e84 = [];
                for(const r51 in this.data)for (const n37 of this.data[r51])t(n37.value) || e84.push(n37);
                for (const t123 of e84)this.remove(t123.value.tileID, t123);
            }
        }
        class Yd {
            constructor(t123, e84, r51){
                this.func = t123, this.mask = e84, this.range = r51;
            }
        }
        Yd.ReadOnly = !1, Yd.ReadWrite = !0, Yd.disabled = new Yd(519, Yd.ReadOnly, [
            0,
            1
        ]);
        const Hd = 7680;
        class Wd {
            constructor(t124, e85, r52, n37, i28, s19){
                this.test = t124, this.ref = e85, this.mask = r52, this.fail = n37, this.depthFail = i28, this.pass = s19;
            }
        }
        Wd.disabled = new Wd({
            func: 519,
            mask: 0
        }, 0, 0, Hd, Hd, Hd);
        class Jd {
            constructor(t125, e86, r53){
                this.blendFunction = t125, this.blendColor = e86, this.mask = r53;
            }
        }
        Jd.Replace = [
            1,
            0
        ], Jd.disabled = new Jd(Jd.Replace, Me.transparent, [
            !1,
            !1,
            !1,
            !1
        ]), Jd.unblended = new Jd(Jd.Replace, Me.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Jd.alphaBlended = new Jd([
            1,
            771
        ], Me.transparent, [
            !0,
            !0,
            !0,
            !0
        ]);
        const Qd = 1029, ty = 2305;
        class ey {
            constructor(t126, e87, r54){
                this.enable = t126, this.mode = e87, this.frontFace = r54;
            }
        }
        ey.disabled = new ey(!1, Qd, ty), ey.backCCW = new ey(!0, Qd, ty), ey.backCW = new ey(!0, Qd, 2304), ey.frontCW = new ey(!0, 1028, 2304), ey.frontCCW = new ey(!0, 1028, ty);
        class ry extends Yt {
            constructor(t127, e88, r55){
                super(), this.id = t127, this._onlySymbols = r55, e88.on("data", (t128)=>{
                    "source" === t128.dataType && "metadata" === t128.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === t128.dataType && "content" === t128.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
                }), e88.on("error", ()=>{
                    this._sourceErrored = !0;
                }), this._source = e88, this._tiles = {
                }, this._cache = new Kd(0, this._unloadTile.bind(this)), this._timers = {
                }, this._cacheTimers = {
                }, this._minTileCacheSize = e88.minTileCacheSize, this._maxTileCacheSize = e88.maxTileCacheSize, this._loadedParentTiles = {
                }, this._coveredTiles = {
                }, this._state = new Fd, this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(t) {
                this.map = t, this._minTileCacheSize = (void 0) === this._minTileCacheSize && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = (void 0) === this._maxTileCacheSize && t ? t._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded) return !1;
                if (!this._source.loaded()) return !1;
                for(const t128 in this._tiles){
                    const e89 = this._tiles[t128];
                    if ("loaded" !== e89.state && "errored" !== e89.state) return !1;
                }
                return !0;
            }
            getSource() {
                return this._source;
            }
            pause() {
                this._paused = !0;
            }
            resume() {
                if (!this._paused) return;
                const t128 = this._shouldReloadOnResume;
                this._paused = !1, this._shouldReloadOnResume = !1, t128 && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(t, e) {
                return t.isSymbolTile = this._onlySymbols, this._source.loadTile(t, e);
            }
            _unloadTile(t) {
                if (this._source.unloadTile) return this._source.unloadTile(t, ()=>{
                });
            }
            _abortTile(t) {
                if (this._source.abortTile) return this._source.abortTile(t, ()=>{
                });
            }
            serialize() {
                return this._source.serialize();
            }
            prepare(t) {
                this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                for(const e89 in this._tiles){
                    const r56 = this._tiles[e89];
                    r56.upload(t), r56.prepare(this.map.style.imageManager);
                }
            }
            getIds() {
                return T1(this._tiles).map((t128)=>t128.tileID
                ).sort(ny).map((t128)=>t128.key
                );
            }
            getRenderableIds(t) {
                const e89 = [];
                for(const r56 in this._tiles)this._isIdRenderable(+r56, t) && e89.push(this._tiles[r56]);
                return t ? e89.sort((t128, e90)=>{
                    const r57 = t128.tileID, n38 = e90.tileID, i29 = new d2(r57.canonical.x, r57.canonical.y)._rotate(this.transform.angle), s20 = new d2(n38.canonical.x, n38.canonical.y)._rotate(this.transform.angle);
                    return r57.overscaledZ - n38.overscaledZ || s20.y - i29.y || s20.x - i29.x;
                }).map((t128)=>t128.tileID.key
                ) : e89.map((t128)=>t128.tileID
                ).sort(ny).map((t128)=>t128.key
                );
            }
            hasRenderableParent(t) {
                const e89 = this.findLoadedParent(t, 0);
                return !!e89 && this._isIdRenderable(e89.tileID.key);
            }
            _isIdRenderable(t, e) {
                return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade());
            }
            reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for(const t128 in this._tiles)"errored" !== this._tiles[t128].state && this._reloadTile(+t128, "reloading");
                }
            }
            _reloadTile(t, e) {
                const r56 = this._tiles[t];
                r56 && ("loading" !== r56.state && (r56.state = e), this._loadTile(r56, this._tileLoaded.bind(this, r56, t, e)));
            }
            _tileLoaded(t, e, r, n) {
                if (n) {
                    if (t.state = "errored", 404 !== n.status) this._source.fire(new Kt(n, {
                        tile: t
                    }));
                    else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                        const t128 = this.map.painter.terrain;
                        this.update(this.transform, t128.getScaledDemTileSize(), !0), t128.resetTileLookupCache(this.id);
                    } else this.update(this.transform);
                } else t.timeAdded = Nt.now(), "expired" === r && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(e, t), "raster-dem" === this._source.type && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new Zt("data", {
                    dataType: "source",
                    tile: t,
                    coord: t.tileID,
                    sourceCacheId: this.id
                }));
            }
            _backfillDEM(t) {
                const e89 = this.getRenderableIds();
                for(let n38 = 0; n38 < e89.length; n38++){
                    const i29 = e89[n38];
                    if (t.neighboringTiles && t.neighboringTiles[i29]) {
                        const e90 = this.getTileByID(i29);
                        r56(t, e90), r56(e90, t);
                    }
                }
                function r56(t128, e90) {
                    if (!t128.dem || t128.dem.borderReady) return;
                    t128.needsHillshadePrepare = !0, t128.needsDEMTextureUpload = !0;
                    let r57 = e90.tileID.canonical.x - t128.tileID.canonical.x;
                    const n39 = e90.tileID.canonical.y - t128.tileID.canonical.y, i29 = Math.pow(2, t128.tileID.canonical.z), s20 = e90.tileID.key;
                    0 === r57 && 0 === n39 || Math.abs(n39) > 1 || (Math.abs(r57) > 1 && (1 === Math.abs(r57 + i29) ? r57 += i29 : 1 === Math.abs(r57 - i29) && (r57 -= i29)), e90.dem && t128.dem && (t128.dem.backfillBorder(e90.dem, r57, n39), t128.neighboringTiles && t128.neighboringTiles[s20] && (t128.neighboringTiles[s20].backfilled = !0)));
                }
            }
            getTile(t) {
                return this.getTileByID(t.key);
            }
            getTileByID(t) {
                return this._tiles[t];
            }
            _retainLoadedChildren(t, e, r, n) {
                for(const i29 in this._tiles){
                    let s20 = this._tiles[i29];
                    if (n[i29] || !s20.hasData() || s20.tileID.overscaledZ <= e || s20.tileID.overscaledZ > r) continue;
                    let a13 = s20.tileID;
                    for(; s20 && s20.tileID.overscaledZ > e + 1;){
                        const t128 = s20.tileID.scaledTo(s20.tileID.overscaledZ - 1);
                        s20 = this._tiles[t128.key], s20 && s20.hasData() && (a13 = t128);
                    }
                    let o12 = a13;
                    for(; o12.overscaledZ > e;)if (o12 = o12.scaledTo(o12.overscaledZ - 1), t[o12.key]) {
                        n[a13.key] = a13;
                        break;
                    }
                }
            }
            findLoadedParent(t, e) {
                if (t.key in this._loadedParentTiles) {
                    const r56 = this._loadedParentTiles[t.key];
                    return r56 && r56.tileID.overscaledZ >= e ? r56 : null;
                }
                for(let r56 = t.overscaledZ - 1; r56 >= e; r56--){
                    const e89 = t.scaledTo(r56), n38 = this._getLoadedTile(e89);
                    if (n38) return n38;
                }
            }
            _getLoadedTile(t) {
                const e89 = this._tiles[t.key];
                return e89 && e89.hasData() ? e89 : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);
            }
            updateCacheSize(t, e) {
                e = e || this._source.tileSize;
                const r56 = Math.ceil(t.width / e) + 1, n38 = Math.ceil(t.height / e) + 1, i29 = Math.floor(r56 * n38 * 5), s20 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i29) : i29, a13 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s20) : s20;
                this._cache.setMaxSize(a13);
            }
            handleWrapJump(t) {
                const e89 = Math.round((t - ((void 0) === this._prevLng ? t : this._prevLng)) / 360);
                if (this._prevLng = t, e89) {
                    const t128 = {
                    };
                    for(const r56 in this._tiles){
                        const n38 = this._tiles[r56];
                        n38.tileID = n38.tileID.unwrapTo(n38.tileID.wrap + e89), t128[n38.tileID.key] = n38;
                    }
                    this._tiles = t128;
                    for(const t129 in this._timers)clearTimeout(this._timers[t129]), delete this._timers[t129];
                    for(const t130 in this._tiles)this._setTileReloadTimer(+t130, this._tiles[t130]);
                }
            }
            update(t, e, r) {
                if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
                if (this.usedForTerrain && !r) return;
                let n38;
                this.updateCacheSize(t, e), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {
                }, this.used || this.usedForTerrain ? this._source.tileID ? n38 = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((t128)=>new Gc(t128.canonical.z, t128.wrap, t128.canonical.z, t128.canonical.x, t128.canonical.y)
                ) : (n38 = t.coveringTiles({
                    tileSize: e || this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom && !r,
                    reparseOverscaled: this._source.reparseOverscaled,
                    isTerrainDEM: this.usedForTerrain
                }), this._source.hasTile && (n38 = n38.filter((t128)=>this._source.hasTile(t128)
                ))) : n38 = [];
                const i29 = this._updateRetainedTiles(n38);
                if (iy(this._source.type) && 0 !== n38.length) {
                    const t128 = {
                    }, e89 = {
                    }, r56 = Object.keys(i29);
                    for (const n39 of r56){
                        const r57 = i29[n39], s20 = this._tiles[n39];
                        if (!s20 || s20.fadeEndTime && s20.fadeEndTime <= Nt.now()) continue;
                        const a13 = this.findLoadedParent(r57, Math.max(r57.overscaledZ - ry.maxOverzooming, this._source.minzoom));
                        a13 && (this._addTile(a13.tileID), t128[a13.tileID.key] = a13.tileID), e89[n39] = r57;
                    }
                    const s20 = n38[n38.length - 1].overscaledZ;
                    for(const t129 in this._tiles){
                        const r57 = this._tiles[t129];
                        if (i29[t129] || !r57.hasData()) continue;
                        let n40 = r57.tileID;
                        for(; n40.overscaledZ > s20;){
                            n40 = n40.scaledTo(n40.overscaledZ - 1);
                            const s21 = this._tiles[n40.key];
                            if (s21 && s21.hasData() && e89[n40.key]) {
                                i29[t129] = r57.tileID;
                                break;
                            }
                        }
                    }
                    for(const e90 in t128)i29[e90] || (this._coveredTiles[e90] = !0, i29[e90] = t128[e90]);
                }
                for(const t128 in i29)this._tiles[t128].clearFadeHold();
                const s20 = function(t129, e89) {
                    const r56 = [];
                    for(const n39 in t129)n39 in e89 || r56.push(n39);
                    return r56;
                }(this._tiles, i29);
                for (const t129 of s20){
                    const e89 = this._tiles[t129];
                    e89.hasSymbolBuckets && !e89.holdingForFade() ? e89.setHoldDuration(this.map._fadeDuration) : e89.hasSymbolBuckets && !e89.symbolFadeFinished() || this._removeTile(+t129);
                }
                this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
                for(const t128 in this._tiles)this._tiles[t128].holdingForFade() && this._removeTile(+t128);
            }
            _updateRetainedTiles(t) {
                const e89 = {
                };
                if (0 === t.length) return e89;
                const r56 = {
                }, n38 = t.reduce((t128, e90)=>Math.min(t128, e90.overscaledZ)
                , 1 / 0), i29 = t[0].overscaledZ, s20 = Math.max(i29 - ry.maxOverzooming, this._source.minzoom), a13 = Math.max(i29 + ry.maxUnderzooming, this._source.minzoom), o12 = {
                };
                for (const r57 of t){
                    const t128 = this._addTile(r57);
                    e89[r57.key] = r57, t128.hasData() || n38 < this._source.maxzoom && (o12[r57.key] = r57);
                }
                this._retainLoadedChildren(o12, n38, a13, e89);
                for (const n39 of t){
                    let t128 = this._tiles[n39.key];
                    if (t128.hasData()) continue;
                    if (n39.canonical.z >= this._source.maxzoom) {
                        const t129 = n39.children(this._source.maxzoom)[0], r58 = this.getTile(t129);
                        if (r58 && r58.hasData()) {
                            e89[t129.key] = t129;
                            continue;
                        }
                    } else {
                        const t129 = n39.children(this._source.maxzoom);
                        if (e89[t129[0].key] && e89[t129[1].key] && e89[t129[2].key] && e89[t129[3].key]) continue;
                    }
                    let i30 = t128.wasRequested();
                    for(let a14 = n39.overscaledZ - 1; a14 >= s20; --a14){
                        const s21 = n39.scaledTo(a14);
                        if (r56[s21.key]) break;
                        if (r56[s21.key] = !0, t128 = this.getTile(s21), !t128 && i30 && (t128 = this._addTile(s21)), t128 && (e89[s21.key] = s21, i30 = t128.wasRequested(), t128.hasData())) break;
                    }
                }
                return e89;
            }
            _updateLoadedParentTileCache() {
                this._loadedParentTiles = {
                };
                for(const t128 in this._tiles){
                    const e89 = [];
                    let r56, n38 = this._tiles[t128].tileID;
                    for(; n38.overscaledZ > 0;){
                        if (n38.key in this._loadedParentTiles) {
                            r56 = this._loadedParentTiles[n38.key];
                            break;
                        }
                        e89.push(n38.key);
                        const t129 = n38.scaledTo(n38.overscaledZ - 1);
                        if (r56 = this._getLoadedTile(t129), r56) break;
                        n38 = t129;
                    }
                    for (const t129 of e89)this._loadedParentTiles[t129] = r56;
                }
            }
            _addTile(t) {
                let e89 = this._tiles[t.key];
                if (e89) return e89;
                e89 = this._cache.getAndRemove(t), e89 && (this._setTileReloadTimer(t.key, e89), e89.tileID = t, this._state.initializeTileState(e89, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, e89)));
                const r56 = Boolean(e89);
                if (!r56) {
                    const r57 = this.map ? this.map.painter : null;
                    e89 = new Ld(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, r57, this._isRaster), this._loadTile(e89, this._tileLoaded.bind(this, e89, t.key, e89.state));
                }
                return e89 ? (e89.uses++, this._tiles[t.key] = e89, r56 || this._source.fire(new Zt("dataloading", {
                    tile: e89,
                    coord: e89.tileID,
                    dataType: "source"
                })), e89) : null;
            }
            _setTileReloadTimer(t, e) {
                t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
                const r56 = e.getExpiryTimeout();
                r56 && (this._timers[t] = setTimeout(()=>{
                    this._reloadTile(t, "expired"), delete this._timers[t];
                }, r56));
            }
            _removeTile(t) {
                const e89 = this._tiles[t];
                e89 && (e89.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e89.uses > 0 || (e89.hasData() && "reloading" !== e89.state ? this._cache.add(e89.tileID, e89, e89.getExpiryTimeout()) : (e89.aborted = !0, this._abortTile(e89), this._unloadTile(e89))));
            }
            clearTiles() {
                this._shouldReloadOnResume = !1, this._paused = !1;
                for(const t128 in this._tiles)this._removeTile(+t128);
                this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t, e, r) {
                const n38 = [], i29 = this.transform;
                if (!i29) return n38;
                const s20 = "globe" === i29.projection.name, a13 = Bo(i29.center.lng);
                for(const o12 in this._tiles){
                    const l10 = this._tiles[o12];
                    if (r && l10.clearQueryDebugViz(), l10.holdingForFade()) continue;
                    let u9;
                    if (s20) {
                        const t128 = l10.tileID.canonical;
                        if (0 === t128.z) {
                            const e89 = [
                                Math.abs(S1(a13, ...sy(t128, -1)) - a13),
                                Math.abs(S1(a13, ...sy(t128, 1)) - a13)
                            ];
                            u9 = [
                                0,
                                2 * e89.indexOf(Math.min(...e89)) - 1
                            ];
                        } else {
                            const e89 = [
                                Math.abs(S1(a13, ...sy(t128, -1)) - a13),
                                Math.abs(S1(a13, ...sy(t128, 0)) - a13),
                                Math.abs(S1(a13, ...sy(t128, 1)) - a13)
                            ];
                            u9 = [
                                e89.indexOf(Math.min(...e89)) - 1
                            ];
                        }
                    } else u9 = [
                        0
                    ];
                    for (const r56 of u9){
                        const s21 = t.containsTile(l10, i29, e, r56);
                        s21 && n38.push(s21);
                    }
                }
                return n38;
            }
            getVisibleCoordinates(t) {
                const e89 = this.getRenderableIds(t).map((t128)=>this._tiles[t128].tileID
                );
                for (const t128 of e89)t128.projMatrix = this.transform.calculateProjMatrix(t128.toUnwrapped());
                return e89;
            }
            hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (iy(this._source.type)) for(const t128 in this._tiles){
                    const e89 = this._tiles[t128];
                    if ((void 0) !== e89.fadeEndTime && e89.fadeEndTime >= Nt.now()) return !0;
                }
                return !1;
            }
            setFeatureState(t, e, r) {
                this._state.updateState(t = t || "_geojsonTileLayer", e, r);
            }
            removeFeatureState(t, e, r) {
                this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, r);
            }
            getFeatureState(t, e) {
                return this._state.getState(t = t || "_geojsonTileLayer", e);
            }
            setDependencies(t, e, r) {
                const n38 = this._tiles[t];
                n38 && n38.setDependencies(e, r);
            }
            reloadTilesForDependencies(t, e) {
                for(const r56 in this._tiles)this._tiles[r56].hasDependency(t, e) && this._reloadTile(+r56, "reloading");
                this._cache.filter((r57)=>!r57.hasDependency(t, e)
                );
            }
            _preloadTiles(t, e) {
                const r56 = new Map, n38 = Array.isArray(t) ? t : [
                    t
                ], i29 = this.map.painter.terrain, s20 = this.usedForTerrain && i29 ? i29.getScaledDemTileSize() : this._source.tileSize;
                for (const t128 of n38){
                    const e89 = t128.coveringTiles({
                        tileSize: s20,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !this.usedForTerrain,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    });
                    for (const t129 of e89)r56.set(t129.key, t129);
                    this.usedForTerrain && t128.updateElevation(!1);
                }
                M1(Array.from(r56.values()), (t129, e89)=>{
                    const r57 = new Ld(t129, this._source.tileSize * t129.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
                    this._loadTile(r57, (t130)=>{
                        "raster-dem" === this._source.type && r57.dem && this._backfillDEM(r57), e89(t130, r57);
                    });
                }, e);
            }
        }
        function ny(t128, e89) {
            const r56 = Math.abs(2 * t128.wrap) - +(t128.wrap < 0), n38 = Math.abs(2 * e89.wrap) - +(e89.wrap < 0);
            return t128.overscaledZ - e89.overscaledZ || n38 - r56 || e89.canonical.y - t128.canonical.y || e89.canonical.x - t128.canonical.x;
        }
        function iy(t128) {
            return "raster" === t128 || "image" === t128 || "video" === t128 || "custom" === t128;
        }
        function sy(t128, e89) {
            const r56 = 1 << t128.z;
            return [
                t128.x / r56 + e89,
                (t128.x + 1) / r56 + e89
            ];
        }
        ry.maxOverzooming = 10, ry.maxUnderzooming = 3;
        class ay {
            constructor(t128, e89, r56){
                this._demTile = t128, this._dem = this._demTile.dem, this._scale = e89, this._offset = r56;
            }
            static create(t, e, r) {
                const n38 = r || t.findDEMTileFor(e);
                if (!n38 || !n38.dem) return;
                const i29 = n38.dem, s20 = n38.tileID, a13 = 1 << e.canonical.z - s20.canonical.z;
                return new ay(n38, n38.tileSize / So / a13, [
                    (e.canonical.x / a13 - s20.canonical.x) * i29.dim,
                    (e.canonical.y / a13 - s20.canonical.y) * i29.dim
                ]);
            }
            tileCoordToPixel(t, e) {
                const r57 = e * this._scale + this._offset[1], n38 = Math.floor(t * this._scale + this._offset[0]), i29 = Math.floor(r57);
                return new d2(n38, i29);
            }
            getElevationAt(t, e, r, n) {
                const i29 = t * this._scale + this._offset[0], s20 = e * this._scale + this._offset[1], a13 = Math.floor(i29), o12 = Math.floor(s20), l10 = this._dem;
                return n = !!n, r ? Mr(Mr(l10.get(a13, o12, n), l10.get(a13, o12 + 1, n), s20 - o12), Mr(l10.get(a13 + 1, o12, n), l10.get(a13 + 1, o12 + 1, n), s20 - o12), i29 - a13) : l10.get(a13, o12, n);
            }
            getElevationAtPixel(t, e, r) {
                return this._dem.get(t, e, !!r);
            }
            getMeterToDEM(t) {
                return (1 << this._demTile.tileID.canonical.z) * Co(1, t) * this._dem.stride;
            }
        }
        class oy {
            constructor(t129, e90){
                this.tileID = t129, this.x = t129.canonical.x, this.y = t129.canonical.y, this.z = t129.canonical.z, this.grid = new ji(So, 16, 0), this.featureIndexArray = new ja, this.promoteId = e90;
            }
            insert(t, e, r, n, i, s = 0) {
                const a13 = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(r, n, i, s);
                const o12 = this.grid;
                for(let t130 = 0; t130 < e.length; t130++){
                    const r57 = e[t130], n38 = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ];
                    for(let t131 = 0; t131 < r57.length; t131++){
                        const e91 = r57[t131];
                        n38[0] = Math.min(n38[0], e91.x), n38[1] = Math.min(n38[1], e91.y), n38[2] = Math.max(n38[2], e91.x), n38[3] = Math.max(n38[3], e91.y);
                    }
                    n38[0] < So && n38[1] < So && n38[2] >= 0 && n38[3] >= 0 && o12.insert(a13, n38[0], n38[1], n38[2], n38[3]);
                }
            }
            loadVTLayers() {
                if (!this.vtLayers) {
                    this.vtLayers = new Ac(new kh(this.rawTileData)).layers, this.sourceLayerCoder = new Sd(this.vtLayers ? Object.keys(this.vtLayers).sort() : [
                        "_geojsonTileLayer"
                    ]), this.vtFeatures = {
                    };
                    for(const t130 in this.vtLayers)this.vtFeatures[t130] = [];
                }
                return this.vtLayers;
            }
            query(t, e, r, n) {
                this.loadVTLayers();
                const i29 = t.params || {
                }, s20 = ai(i29.filter), a13 = t.tileResult, o12 = t.transform, l10 = a13.bufferedTilespaceBounds, u9 = this.grid.query(l10.min.x, l10.min.y, l10.max.x, l10.max.y, (t130, e91, r57, n38)=>ol(a13.bufferedTilespaceGeometry, t130, e91, r57, n38)
                );
                u9.sort(uy);
                let c7 = null;
                o12.elevation && u9.length > 0 && (c7 = ay.create(o12.elevation, this.tileID));
                const h5 = {
                };
                let p5;
                for(let o13 = 0; o13 < u9.length; o13++){
                    const l11 = u9[o13];
                    if (l11 === p5) continue;
                    p5 = l11;
                    const f4 = this.featureIndexArray.get(l11);
                    let d4 = null;
                    this.loadMatchingFeature(h5, f4, s20, i29.layers, i29.availableImages, e, r, n, (e91, r57, n38, i30 = 0)=>(d4 || (d4 = Xo(e91, this.tileID.canonical, t.tileTransform)), r57.queryIntersectsFeature(a13, e91, n38, d4, this.z, t.transform, t.pixelPosMatrix, c7, i30))
                    );
                }
                return h5;
            }
            loadMatchingFeature(t, e, r, n, i, s, a, o, l) {
                const { featureIndex: u9 , bucketIndex: c7 , sourceLayerIndex: h5 , layoutVertexArrayOffset: p5  } = e, f4 = this.bucketLayerIDs[c7];
                if (n && !function(t130, e91) {
                    for(let r57 = 0; r57 < t130.length; r57++)if (e91.indexOf(t130[r57]) >= 0) return !0;
                    return !1;
                }(n, f4)) return;
                const d4 = this.sourceLayerCoder.decode(h5), y2 = this.vtLayers[d4].feature(u9);
                if (r.needGeometry) {
                    const t130 = Zo(y2, !0);
                    if (!r.filter(new Us(this.tileID.overscaledZ), t130, this.tileID.canonical)) return;
                } else if (!r.filter(new Us(this.tileID.overscaledZ), y2)) return;
                const m2 = this.getId(y2, d4);
                for(let e91 = 0; e91 < f4.length; e91++){
                    const r57 = f4[e91];
                    if (n && n.indexOf(r57) < 0) continue;
                    const c8 = s[r57];
                    if (!c8) continue;
                    let h6 = {
                    };
                    (void 0) !== m2 && o && (h6 = o.getState(c8.sourceLayer || "_geojsonTileLayer", m2));
                    const d5 = z1({
                    }, a[r57]);
                    d5.paint = ly(d5.paint, c8.paint, y2, h6, i), d5.layout = ly(d5.layout, c8.layout, y2, h6, i);
                    const g2 = !l || l(y2, c8, h6, p5);
                    if (!g2) continue;
                    const x2 = new Id(y2, this.z, this.x, this.y, m2);
                    x2.layer = d5;
                    let v2 = t[r57];
                    (void 0) === v2 && (v2 = t[r57] = []), v2.push({
                        featureIndex: u9,
                        feature: x2,
                        intersectionZ: g2
                    });
                }
            }
            lookupSymbolFeatures(t, e, r, n, i, s, a, o) {
                const l10 = {
                };
                this.loadVTLayers();
                const u9 = ai(i);
                for (const i29 of t)this.loadMatchingFeature(l10, {
                    bucketIndex: r,
                    sourceLayerIndex: n,
                    featureIndex: i29,
                    layoutVertexArrayOffset: 0
                }, u9, s, a, o, e);
                return l10;
            }
            loadFeature(t) {
                const { featureIndex: e91 , sourceLayerIndex: r57  } = t;
                this.loadVTLayers();
                const n38 = this.sourceLayerCoder.decode(r57), i29 = this.vtFeatures[n38];
                if (i29[e91]) return i29[e91];
                const s20 = this.vtLayers[n38].feature(e91);
                return i29[e91] = s20, s20;
            }
            hasLayer(t) {
                for (const e91 of this.bucketLayerIDs)for (const r57 of e91)if (t === r57) return !0;
                return !1;
            }
            getId(t, e) {
                let r57 = t.id;
                if (this.promoteId) {
                    const n38 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e];
                    null != n38 && (r57 = t.properties[n38]), "boolean" == typeof r57 && (r57 = Number(r57));
                }
                return r57;
            }
        }
        function ly(t130, e91, r57, n38, i29) {
            return F(t130, (t131, s20)=>{
                const a13 = e91 instanceof Ks ? e91.get(s20) : null;
                return a13 && a13.evaluate ? a13.evaluate(r57, n38, i29) : a13;
            });
        }
        function uy(t130, e91) {
            return e91 - t130;
        }
        Oi(oy, "FeatureIndex", {
            omit: [
                "rawTileData",
                "sourceLayerCoder"
            ]
        });
        class cy {
            constructor(t130, e91){
                this.width = t130, this.height = e91, this.nextRow = 0, this.image = new mu({
                    width: t130,
                    height: e91
                }), this.positions = {
                }, this.uploaded = !1;
            }
            getDash(t, e) {
                const r57 = this.getKey(t, e);
                return this.positions[r57];
            }
            trim() {
                const t131 = this.width, e92 = this.height = P(this.nextRow);
                this.image.resize({
                    width: t131,
                    height: e92
                });
            }
            getKey(t, e) {
                return t.join(",") + e;
            }
            getDashRanges(t, e, r) {
                const n38 = [];
                let i29 = t.length % 2 == 1 ? -t[t.length - 1] * r : 0, s20 = t[0] * r, a13 = !0;
                n38.push({
                    left: i29,
                    right: s20,
                    isDash: a13,
                    zeroLength: 0 === t[0]
                });
                let o12 = t[0];
                for(let e92 = 1; e92 < t.length; e92++){
                    a13 = !a13;
                    const l10 = t[e92];
                    i29 = o12 * r, o12 += l10, s20 = o12 * r, n38.push({
                        left: i29,
                        right: s20,
                        isDash: a13,
                        zeroLength: 0 === l10
                    });
                }
                return n38;
            }
            addRoundDash(t, e, r) {
                const n38 = e / 2;
                for(let e92 = -r; e92 <= r; e92++){
                    const i29 = this.width * (this.nextRow + r + e92);
                    let s20 = 0, a13 = t[s20];
                    for(let o12 = 0; o12 < this.width; o12++){
                        o12 / a13.right > 1 && (a13 = t[++s20]);
                        const l10 = Math.abs(o12 - a13.left), u9 = Math.abs(o12 - a13.right), c7 = Math.min(l10, u9);
                        let h5;
                        const p5 = e92 / r * (n38 + 1);
                        if (a13.isDash) {
                            const t131 = n38 - Math.abs(p5);
                            h5 = Math.sqrt(c7 * c7 + t131 * t131);
                        } else h5 = n38 - Math.sqrt(c7 * c7 + p5 * p5);
                        this.image.data[i29 + o12] = Math.max(0, Math.min(255, h5 + 128));
                    }
                }
            }
            addRegularDash(t, e) {
                for(let e92 = t.length - 1; e92 >= 0; --e92){
                    const r57 = t[e92], n38 = t[e92 + 1];
                    r57.zeroLength ? t.splice(e92, 1) : n38 && n38.isDash === r57.isDash && (n38.left = r57.left, t.splice(e92, 1));
                }
                const r57 = t[0], n38 = t[t.length - 1];
                r57.isDash === n38.isDash && (r57.left = n38.left - this.width, n38.right = r57.right + this.width);
                const i29 = this.width * this.nextRow;
                let s20 = 0, a13 = t[s20];
                for(let r58 = 0; r58 < this.width; r58++){
                    r58 / a13.right > 1 && (a13 = t[++s20]);
                    const n39 = Math.abs(r58 - a13.left), o12 = Math.abs(r58 - a13.right), l10 = Math.min(n39, o12);
                    this.image.data[i29 + r58] = Math.max(0, Math.min(255, (a13.isDash ? l10 : -l10) + e + 128));
                }
            }
            addDash(t, e) {
                const r57 = this.getKey(t, e);
                if (this.positions[r57]) return this.positions[r57];
                const n38 = "round" === e, i29 = n38 ? 7 : 0, s20 = 2 * i29 + 1;
                if (this.nextRow + s20 > this.height) return $("LineAtlas out of space"), null;
                0 === t.length && t.push(1);
                let a13 = 0;
                for(let e92 = 0; e92 < t.length; e92++)t[e92] < 0 && ($("Negative value is found in line dasharray, replacing values with 0"), t[e92] = 0), a13 += t[e92];
                if (0 !== a13) {
                    const r58 = this.width / a13, s21 = this.getDashRanges(t, this.width, r58);
                    n38 ? this.addRoundDash(s21, r58, i29) : this.addRegularDash(s21, "square" === e ? 0.5 * r58 : 0);
                }
                const o12 = this.nextRow + i29;
                this.nextRow += s20;
                const l10 = {
                    tl: [
                        o12,
                        i29
                    ],
                    br: [
                        a13,
                        0
                    ]
                };
                return this.positions[r57] = l10, l10;
            }
        }
        Oi(cy, "LineAtlas");
        class hy {
            constructor(t131){
                const e92 = {
                }, r57 = [];
                for(const n38 in t131){
                    const i29 = t131[n38], s20 = e92[n38] = {
                    };
                    for(const t132 in i29.glyphs){
                        const e93 = i29.glyphs[+t132];
                        if (!e93 || 0 === e93.bitmap.width || 0 === e93.bitmap.height) continue;
                        const n39 = e93.metrics.localGlyph ? 2 : 1, a13 = {
                            x: 0,
                            y: 0,
                            w: e93.bitmap.width + 2 * n39,
                            h: e93.bitmap.height + 2 * n39
                        };
                        r57.push(a13), s20[t132] = a13;
                    }
                }
                const { w: n39 , h: i29  } = Hh(r57), s20 = new mu({
                    width: n39 || 1,
                    height: i29 || 1
                });
                for(const r58 in t131){
                    const n40 = t131[r58];
                    for(const t132 in n40.glyphs){
                        const i30 = n40.glyphs[+t132];
                        if (!i30 || 0 === i30.bitmap.width || 0 === i30.bitmap.height) continue;
                        const a13 = e92[r58][t132], o12 = i30.metrics.localGlyph ? 2 : 1;
                        mu.copy(i30.bitmap, s20, {
                            x: 0,
                            y: 0
                        }, {
                            x: a13.x + o12,
                            y: a13.y + o12
                        }, i30.bitmap);
                    }
                }
                this.image = s20, this.positions = e92;
            }
        }
        Oi(hy, "GlyphAtlas");
        class py {
            constructor(t132){
                this.tileID = new Gc(t132.tileID.overscaledZ, t132.tileID.wrap, t132.tileID.canonical.z, t132.tileID.canonical.x, t132.tileID.canonical.y), this.tileZoom = t132.tileZoom, this.uid = t132.uid, this.zoom = t132.zoom, this.canonical = t132.tileID.canonical, this.pixelRatio = t132.pixelRatio, this.tileSize = t132.tileSize, this.source = t132.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t132.showCollisionBoxes, this.collectResourceTiming = !!t132.collectResourceTiming, this.returnDependencies = !!t132.returnDependencies, this.promoteId = t132.promoteId, this.enableTerrain = !!t132.enableTerrain, this.isSymbolTile = t132.isSymbolTile, this.tileTransform = Df(t132.tileID.canonical, t132.projection), this.projection = t132.projection;
            }
            parse(t, e, r, n, i) {
                this.status = "parsing", this.data = t, this.collisionBoxArray = new Ea;
                const s21 = new Sd(Object.keys(t.layers).sort()), a13 = new oy(this.tileID, this.promoteId);
                a13.bucketLayerIDs = [];
                const o12 = {
                }, l10 = new cy(256, 256), u9 = {
                    featureIndex: a13,
                    iconDependencies: {
                    },
                    patternDependencies: {
                    },
                    glyphDependencies: {
                    },
                    lineAtlas: l10,
                    availableImages: r
                }, c7 = e.familiesBySource[this.source];
                for(const e93 in c7){
                    const n40 = t.layers[e93];
                    if (!n40) continue;
                    let i30 = !1, l11 = !1;
                    for (const t133 of c7[e93])"symbol" === t133[0].type ? i30 = !0 : l11 = !0;
                    if (!0 === this.isSymbolTile && !i30) continue;
                    if (!1 === this.isSymbolTile && !l11) continue;
                    1 === n40.version && $(`Vector tile source "${this.source}" layer "${e93}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                    const h5 = s21.encode(e93), p5 = [];
                    for(let t134 = 0; t134 < n40.length; t134++){
                        const r59 = n40.feature(t134), i31 = a13.getId(r59, e93);
                        p5.push({
                            feature: r59,
                            id: i31,
                            index: t134,
                            sourceLayerIndex: h5
                        });
                    }
                    for (const t135 of c7[e93]){
                        const e94 = t135[0];
                        (void 0) !== this.isSymbolTile && "symbol" === e94.type !== this.isSymbolTile || e94.minzoom && this.zoom < Math.floor(e94.minzoom) || e94.maxzoom && this.zoom >= e94.maxzoom || "none" !== e94.visibility && (fy(t135, this.zoom, r), (o12[e94.id] = e94.createBucket({
                            index: a13.bucketLayerIDs.length,
                            layers: t135,
                            zoom: this.zoom,
                            canonical: this.canonical,
                            pixelRatio: this.pixelRatio,
                            overscaling: this.overscaling,
                            collisionBoxArray: this.collisionBoxArray,
                            sourceLayerIndex: h5,
                            sourceID: this.source,
                            enableTerrain: this.enableTerrain,
                            projection: this.projection.spec,
                            availableImages: r
                        })).populate(p5, u9, this.tileID.canonical, this.tileTransform), a13.bucketLayerIDs.push(t135.map((t136)=>t136.id
                        )));
                    }
                }
                let h5, p5, f4, d4;
                l10.trim();
                const y2 = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom
                }, m2 = F(u9.glyphDependencies, (t133)=>Object.keys(t133).map(Number)
                );
                Object.keys(m2).length ? n.send("getGlyphs", {
                    uid: this.uid,
                    stacks: m2
                }, (t133, e94)=>{
                    h5 || (h5 = t133, p5 = e94, v2.call(this));
                }, void 0, !1, y2) : p5 = {
                };
                const g2 = Object.keys(u9.iconDependencies);
                g2.length ? n.send("getImages", {
                    icons: g2,
                    source: this.source,
                    tileID: this.tileID,
                    type: "icons"
                }, (t133, e94)=>{
                    h5 || (h5 = t133, f4 = e94, v2.call(this));
                }, void 0, !1, y2) : f4 = {
                };
                const x2 = Object.keys(u9.patternDependencies);
                function v2() {
                    if (h5) return i(h5);
                    if (p5 && f4 && d4) {
                        const t133 = new hy(p5), e94 = new Jh(f4, d4);
                        for(const n40 in o12){
                            const i30 = o12[n40];
                            i30 instanceof cd ? (fy(i30.layers, this.zoom, r), Op(i30, p5, t133.positions, f4, e94.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection)) : i30.hasPattern && (i30 instanceof nh || i30 instanceof ic || i30 instanceof Ec) && (fy(i30.layers, this.zoom, r), i30.addFeatures(u9, this.tileID.canonical, e94.patternPositions, r, this.tileTransform));
                        }
                        this.status = "done", i(null, {
                            buckets: T1(o12).filter((t134)=>!t134.isEmpty()
                            ),
                            featureIndex: a13,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: t133.image,
                            lineAtlas: l10,
                            imageAtlas: e94,
                            glyphMap: this.returnDependencies ? p5 : null,
                            iconMap: this.returnDependencies ? f4 : null,
                            glyphPositions: this.returnDependencies ? t133.positions : null
                        });
                    }
                }
                x2.length ? n.send("getImages", {
                    icons: x2,
                    source: this.source,
                    tileID: this.tileID,
                    type: "patterns"
                }, (t133, e94)=>{
                    h5 || (h5 = t133, d4 = e94, v2.call(this));
                }, void 0, !1, y2) : d4 = {
                }, v2.call(this);
            }
        }
        function fy(t133, e93, r59) {
            const n40 = new Us(e93);
            for (const e94 of t133)e94.recalculate(n40, r59);
        }
        class dy {
            constructor(t133){
                this.entries = {
                }, this.scheduler = t133;
            }
            request(t, e, r, n) {
                const i30 = this.entries[t] = this.entries[t] || {
                    callbacks: []
                };
                if (i30.result) {
                    const [t134, r59] = i30.result;
                    return this.scheduler ? this.scheduler.add(()=>{
                        n(t134, r59);
                    }, e) : n(t134, r59), ()=>{
                    };
                }
                return i30.callbacks.push(n), i30.cancel || (i30.cancel = r((r59, n40)=>{
                    i30.result = [
                        r59,
                        n40
                    ];
                    for (const t134 of i30.callbacks)this.scheduler ? this.scheduler.add(()=>{
                        t134(r59, n40);
                    }, e) : t134(r59, n40);
                    setTimeout(()=>delete this.entries[t]
                    , 3000);
                })), ()=>{
                    i30.result || (i30.callbacks = i30.callbacks.filter((t134)=>t134 !== n
                    ), i30.callbacks.length || (i30.cancel(), delete this.entries[t]));
                };
            }
        }
        function yy(t134, e93, r59) {
            const n40 = JSON.stringify(t134.request);
            return t134.data && (this.deduped.entries[n40] = {
                result: [
                    null,
                    t134.data
                ]
            }), this.deduped.request(n40, {
                type: "parseTile",
                isSymbolTile: t134.isSymbolTile,
                zoom: t134.tileZoom
            }, (e94)=>{
                const n41 = ut(t134.request, (t135, n42, i30, s21)=>{
                    t135 ? e94(t135) : n42 && e94(null, {
                        vectorTile: r59 ? void 0 : new Ac(new kh(n42)),
                        rawData: n42,
                        cacheControl: i30,
                        expires: s21
                    });
                });
                return ()=>{
                    n41.cancel(), e94();
                };
            }, e93);
        }
        t3.ARRAY_TYPE = ml, t3.AUTH_ERR_MSG = yt, t3.Aabb = au, t3.Actor = class {
            constructor(t134, r59, n40){
                this.target = t134, this.parent = r59, this.mapId = n40, this.callbacks = {
                }, this.cancelCallbacks = {
                }, V([
                    "receive"
                ], this), this.target.addEventListener("message", this.receive, !1), this.globalScope = N() ? t134 : e2, this.scheduler = new Ad;
            }
            send(t, e, r, n, i = !1, s) {
                const a13 = Math.round(1000000000000000000 * Math.random()).toString(36).substring(0, 10);
                r && (r.metadata = s, this.callbacks[a13] = r);
                const o12 = Z(this.globalScope) ? void 0 : [];
                return this.target.postMessage({
                    id: a13,
                    type: t,
                    hasCallback: !!r,
                    targetMapId: n,
                    mustQueue: i,
                    sourceMapId: this.mapId,
                    data: Gi(e, o12)
                }, o12), {
                    cancel: ()=>{
                        r && delete this.callbacks[a13], this.target.postMessage({
                            id: a13,
                            type: "<cancel>",
                            targetMapId: n,
                            sourceMapId: this.mapId
                        });
                    }
                };
            }
            receive(t) {
                const e93 = t.data, r60 = e93.id;
                if (r60 && (!e93.targetMapId || this.mapId === e93.targetMapId)) {
                    if ("<cancel>" === e93.type) {
                        const t135 = this.cancelCallbacks[r60];
                        delete this.cancelCallbacks[r60], t135 && t135.cancel();
                    } else if (e93.mustQueue || N()) {
                        const t135 = this.callbacks[r60];
                        this.cancelCallbacks[r60] = this.scheduler.add(()=>this.processTask(r60, e93)
                        , t135 && t135.metadata || {
                            type: "message"
                        });
                    } else this.processTask(r60, e93);
                }
            }
            processTask(t, e) {
                if ("<response>" === e.type) {
                    const r60 = this.callbacks[t];
                    delete this.callbacks[t], r60 && (e.error ? r60(Xi(e.error)) : r60(null, Xi(e.data)));
                } else {
                    const r60 = Z(this.globalScope) ? void 0 : [], n41 = e.hasCallback ? (e93, n42)=>{
                        delete this.cancelCallbacks[t], this.target.postMessage({
                            id: t,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            error: e93 ? Gi(e93) : null,
                            data: Gi(n42, r60)
                        }, r60);
                    } : (t135)=>{
                    }, i30 = Xi(e.data);
                    if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i30, n41);
                    else if (this.parent.getWorkerSource) {
                        const t135 = e.type.split(".");
                        this.parent.getWorkerSource(e.sourceMapId, t135[0], i30.source)[t135[1]](i30, n41);
                    } else n41(new Error(`Could not find function ${e.type}`));
                }
            }
            remove() {
                this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
            }
        }, t3.CanonicalTileID = qc, t3.Color = Me, t3.ColorMode = Jd, t3.CullFaceMode = ey, t3.DEMData = Zd, t3.DataConstantProperty = Ys, t3.DedupedRequest = dy, t3.DepthMode = Yd, t3.EXTENT = So, t3.Elevation = class {
            isDataAvailableAtPoint(t) {
                const e93 = this._source();
                if (this.isUsingMockSource() || !e93 || t.y < 0 || t.y > 1) return !1;
                const r60 = e93.getSource().maxzoom, n41 = 1 << r60, i30 = Math.floor(t.x), s21 = Math.floor((t.x - i30) * n41), a13 = Math.floor(t.y * n41), o12 = this.findDEMTileFor(new Gc(r60, i30, r60, s21, a13));
                return !(!o12 || !o12.dem);
            }
            getAtPointOrZero(t, e = 0) {
                return this.getAtPoint(t, e) || 0;
            }
            getAtPoint(t, e, r = !0) {
                if (this.isUsingMockSource()) return null;
                null == e && (e = null);
                const n41 = this._source();
                if (!n41) return e;
                if (t.y < 0 || t.y > 1) return e;
                const i30 = n41.getSource().maxzoom, s21 = 1 << i30, a13 = Math.floor(t.x), o12 = t.x - a13, l10 = new Gc(i30, a13, i30, Math.floor(o12 * s21), Math.floor(t.y * s21)), u9 = this.findDEMTileFor(l10);
                if (!u9 || !u9.dem) return e;
                const c7 = u9.dem, h5 = 1 << u9.tileID.canonical.z, p5 = (o12 * h5 - u9.tileID.canonical.x) * c7.dim, f4 = (t.y * h5 - u9.tileID.canonical.y) * c7.dim, d4 = Math.floor(p5), y2 = Math.floor(f4);
                return (r ? this.exaggeration() : 1) * Mr(Mr(c7.get(d4, y2), c7.get(d4, y2 + 1), f4 - y2), Mr(c7.get(d4 + 1, y2), c7.get(d4 + 1, y2 + 1), f4 - y2), p5 - d4);
            }
            getAtTileOffset(t, e, r) {
                const n41 = 1 << t.canonical.z;
                return this.getAtPointOrZero(new Ro(t.wrap + (t.canonical.x + e / So) / n41, (t.canonical.y + r / So) / n41));
            }
            getAtTileOffsetFunc(t, e, r, n) {
                return (i30)=>{
                    const s21 = this.getAtTileOffset(t, i30.x, i30.y), a13 = n.upVector(t.canonical, i30.x, i30.y);
                    return Rl(a13, a13, s21 * n.upVectorScale(t.canonical, e, r).metersToTile), a13;
                };
            }
            getForTilePoints(t, e, r, n) {
                if (this.isUsingMockSource()) return !1;
                const i30 = ay.create(this, t, n);
                return !!i30 && (e.forEach((t135)=>{
                    t135[2] = this.exaggeration() * i30.getElevationAt(t135[0], t135[1], r);
                }), !0);
            }
            getMinMaxForTile(t) {
                if (this.isUsingMockSource()) return null;
                const e93 = this.findDEMTileFor(t);
                if (!e93 || !e93.dem) return null;
                const r60 = e93.dem.tree, n41 = e93.tileID, i30 = 1 << t.canonical.z - n41.canonical.z;
                let s21 = t.canonical.x / i30 - n41.canonical.x, a13 = t.canonical.y / i30 - n41.canonical.y, o12 = 0;
                for(let e94 = 0; e94 < t.canonical.z - n41.canonical.z && !r60.leaves[o12]; e94++){
                    s21 *= 2, a13 *= 2;
                    const t135 = 2 * Math.floor(a13) + Math.floor(s21);
                    o12 = r60.childOffsets[o12] + t135, s21 %= 1, a13 %= 1;
                }
                return {
                    min: this.exaggeration() * r60.minimums[o12],
                    max: this.exaggeration() * r60.maximums[o12]
                };
            }
            getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.");
            }
            raycast(t, e, r) {
                throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t) {
                throw new Error("Pure virtual method called.");
            }
            _source() {
                throw new Error("Pure virtual method called.");
            }
            isUsingMockSource() {
                throw new Error("Pure virtual method called.");
            }
            exaggeration() {
                throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t) {
                throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.");
            }
        }, t3.ErrorEvent = Kt, t3.EvaluationParameters = Us, t3.Event = Zt, t3.Evented = Yt, t3.FillExtrusionBucket = Ec, t3.Frustum = su, t3.FrustumCorners = iu, t3.GLOBE_METERS_TO_ECEF = rf, t3.GLOBE_RADIUS = ef, t3.GLOBE_SCALE_MATCH_LATITUDE = 45, t3.GLOBE_ZOOM_THRESHOLD_MAX = 6, t3.GLOBE_ZOOM_THRESHOLD_MIN = 5, t3.GlobeSharedBuffers = class {
            constructor(t135){
                this._createGrid(t135), this._createPoles(t135);
            }
            destroy() {
                this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
                for (const t136 of this._poleSegments)t136.destroy();
                for (const t137 of this._gridSegments)t137.destroy();
                if (this._wireframeIndexBuffer) {
                    this._wireframeIndexBuffer.destroy();
                    for (const t138 of this._wireframeSegments)t138.destroy();
                }
            }
            _createGrid(t) {
                const e93 = new sa, r60 = new wa, n41 = 65;
                for(let t136 = 0; t136 < n41; t136++)for(let r61 = 0; r61 < n41; r61++)e93.emplaceBack(r61, t136);
                this._gridSegments = [];
                for(let t137 = 0, e94 = 0; t137 < sf.length; t137++){
                    const i30 = sf[t137];
                    for(let t138 = 0; t138 < i30; t138++)for(let e95 = 0; e95 < 64; e95++){
                        const i31 = t138 * n41 + e95;
                        r60.emplaceBack(i31 + 1, i31, i31 + n41), r60.emplaceBack(i31 + n41, i31 + n41 + 1, i31 + 1);
                    }
                    const s21 = 64 * i30 * 2;
                    this._gridSegments.push(Ao.simpleSegment(0, e94, (i30 + 1) * n41, s21)), e94 += s21;
                }
                this._gridBuffer = t.createVertexBuffer(e93, tf.members), this._gridIndexBuffer = t.createIndexBuffer(r60, !0);
            }
            _createPoles(t) {
                const e93 = new wa;
                for(let t136 = 0; t136 <= nf; t136++)e93.emplaceBack(0, t136 + 1, t136 + 2);
                this._poleIndexBuffer = t.createIndexBuffer(e93, !0);
                const r60 = new ka, n41 = new ka;
                this._poleSegments = [];
                for(let t137 = 0, e94 = 0; t137 < 5; t137++){
                    const i30 = 360 / (1 << t137);
                    r60.emplaceBack(0, -ef, 0, 0.5, 0), n41.emplaceBack(0, -ef, 0, 0.5, 1);
                    for(let t138 = 0; t138 <= nf; t138++){
                        const e95 = t138 / nf, s21 = Mr(0, i30, e95), [a13, o12, l10] = vf(Ef, Cf, s21, ef);
                        r60.emplaceBack(a13, o12, l10, e95, 0), n41.emplaceBack(a13, o12, l10, e95, 1);
                    }
                    this._poleSegments.push(Ao.simpleSegment(e94, 0, 66, 64)), e94 += 66;
                }
                this._poleNorthVertexBuffer = t.createVertexBuffer(r60, Jp, !1), this._poleSouthVertexBuffer = t.createVertexBuffer(n41, Jp, !1);
            }
            getGridBuffers(t) {
                return [
                    this._gridBuffer,
                    this._gridIndexBuffer,
                    this._gridSegments[t]
                ];
            }
            getPoleBuffers(t) {
                return [
                    this._poleNorthVertexBuffer,
                    this._poleSouthVertexBuffer,
                    this._poleIndexBuffer,
                    this._poleSegments[t]
                ];
            }
            getWirefameBuffers(t, e) {
                if (!this._wireframeSegments) {
                    const e93 = new Ma, r60 = nf, n41 = r60 + 1;
                    this._wireframeSegments = [];
                    for(let t136 = 0, i30 = 0; t136 < sf.length; t136++){
                        const s21 = sf[t136];
                        for(let t137 = 0; t137 < s21; t137++)for(let i31 = 0; i31 < r60; i31++){
                            const r61 = t137 * n41 + i31;
                            e93.emplaceBack(r61, r61 + 1), e93.emplaceBack(r61, r61 + n41), e93.emplaceBack(r61, r61 + n41 + 1);
                        }
                        const a13 = s21 * r60 * 3;
                        this._wireframeSegments.push(Ao.simpleSegment(0, i30, (s21 + 1) * n41, a13)), i30 += a13;
                    }
                    this._wireframeIndexBuffer = t.createIndexBuffer(e93);
                }
                return [
                    this._gridBuffer,
                    this._wireframeIndexBuffer,
                    this._wireframeSegments[e]
                ];
            }
        }, t3.GlyphManager = Mp, t3.ImagePosition = Wh, t3.LivePerformanceUtils = Lt, t3.LngLat = Mo, t3.LngLatBounds = ko, t3.LocalGlyphMode = Ip, t3.MAX_MERCATOR_LATITUDE = Lo, t3.MercatorCoordinate = Ro, t3.ONE_EM = yh, t3.OverscaledTileID = Gc, t3.PerformanceMarkers = Vt, t3.Properties = Js, t3.RGBAImage = gu, t3.Ray = nu, t3.RequestManager = class {
            constructor(t136, e93, r60){
                this._transformRequestFn = t136, this._customAccessToken = e93, this._silenceAuthErrors = !!r60, this._createSkuToken();
            }
            _createSkuToken() {
                const t137 = function() {
                    let t138 = "";
                    for(let e94 = 0; e94 < 10; e94++)t138 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                    return {
                        token: [
                            "1",
                            h2,
                            t138
                        ].join(""),
                        tokenExpiresAt: Date.now() + 43200000
                    };
                }();
                this._skuToken = t137.token, this._skuTokenExpiresAt = t137.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(t, e) {
                return this._transformRequestFn && this._transformRequestFn(t, e) || {
                    url: t
                };
            }
            normalizeStyleURL(t, e) {
                if (!mt(t)) return t;
                const r61 = _t(t);
                return r61.path = `/styles/v1${r61.path}`, this._makeAPIURL(r61, this._customAccessToken || e);
            }
            normalizeGlyphsURL(t, e) {
                if (!mt(t)) return t;
                const r61 = _t(t);
                return r61.path = `/fonts/v1${r61.path}`, this._makeAPIURL(r61, this._customAccessToken || e);
            }
            normalizeSourceURL(t, e, r, n) {
                if (!mt(t)) return t;
                const i30 = _t(t);
                return i30.path = `/v4/${i30.authority}.json`, i30.params.push("secure"), r && i30.params.push(`language=${r}`), n && i30.params.push(`worldview=${n}`), this._makeAPIURL(i30, this._customAccessToken || e);
            }
            normalizeSpriteURL(t, e, r, n) {
                const i30 = _t(t);
                return mt(t) ? (i30.path = `/styles/v1${i30.path}/sprite${e}${r}`, this._makeAPIURL(i30, this._customAccessToken || n)) : (i30.path += `${e}${r}`, At(i30));
            }
            normalizeTileURL(t, e, r) {
                if (this._isSkuTokenExpired() && this._createSkuToken(), t && !mt(t)) return t;
                const n41 = _t(t);
                n41.path = n41.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e || r && "raster" !== n41.authority && 512 === r ? "@2x" : ""}${s3.supported ? ".webp" : "$1"}`), "raster" === n41.authority ? n41.path = `/${i3.RASTER_URL_PREFIX}${n41.path}` : (n41.path = n41.path.replace(/^.+\/v4\//, "/"), n41.path = `/${i3.TILE_URL_VERSION}${n41.path}`);
                const a13 = this._customAccessToken || function(t137) {
                    for (const e94 of t137){
                        const t138 = e94.match(/^access_token=(.*)$/);
                        if (t138) return t138[1];
                    }
                    return null;
                }(n41.params) || i3.ACCESS_TOKEN;
                return i3.REQUIRE_ACCESS_TOKEN && a13 && this._skuToken && n41.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n41, a13);
            }
            canonicalizeTileURL(t, e) {
                const r61 = _t(t);
                if (!r61.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r61.path.match(/\.[\w]+$/)) return t;
                let n41 = "mapbox://";
                r61.path.match(/^\/raster\/v1\//) ? n41 += `raster/${r61.path.replace(`/${i3.RASTER_URL_PREFIX}/`, "")}` : n41 += `tiles/${r61.path.replace(`/${i3.TILE_URL_VERSION}/`, "")}`;
                let s21 = r61.params;
                return e && (s21 = s21.filter((t137)=>!t137.match(/^access_token=/)
                )), s21.length && (n41 += `?${s21.join("&")}`), n41;
            }
            canonicalizeTileset(t, e) {
                const r61 = !!e && mt(e), n41 = [];
                for (const e94 of t.tiles || [])gt(e94) ? n41.push(this.canonicalizeTileURL(e94, r61)) : n41.push(e94);
                return n41;
            }
            _makeAPIURL(t, e) {
                const r61 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n41 = _t(i3.API_URL);
                if (t.protocol = n41.protocol, t.authority = n41.authority, "http" === t.protocol) {
                    const e94 = t.params.indexOf("secure");
                    e94 >= 0 && t.params.splice(e94, 1);
                }
                if ("/" !== n41.path && (t.path = `${n41.path}${t.path}`), !i3.REQUIRE_ACCESS_TOKEN) return At(t);
                if (e = e || i3.ACCESS_TOKEN, !this._silenceAuthErrors) {
                    if (!e) throw new Error(`An API access token is required to use Mapbox GL. ${r61}`);
                    if ("s" === e[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r61}`);
                }
                return t.params = t.params.filter((t137)=>-1 === t137.indexOf("access_token")
                ), t.params.push(`access_token=${e || ""}`), At(t);
            }
        }, t3.ResourceType = st, t3.SegmentVector = Ao, t3.SourceCache = ry, t3.StencilMode = Wd, t3.StructArrayLayout1ui2 = Ta, t3.StructArrayLayout2f1f2i16 = xa, t3.StructArrayLayout2i4 = sa, t3.StructArrayLayout2ui4 = Ma, t3.StructArrayLayout3f12 = ba, t3.StructArrayLayout3ui6 = wa, t3.StructArrayLayout4i8 = oa, t3.StructArrayLayout5f20 = ka, t3.Texture = wd, t3.Tile = Ld, t3.Transitionable = qs, t3.Uniform1f = Qa, t3.Uniform1i = class extends Ja {
            constructor(t137){
                super(t137), this.current = 0;
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
            }
        }, t3.Uniform2f = class extends Ja {
            constructor(t138){
                super(t138), this.current = [
                    0,
                    0
                ];
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));
            }
        }, t3.Uniform3f = class extends Ja {
            constructor(t139){
                super(t139), this.current = [
                    0,
                    0,
                    0
                ];
            }
            set(t, e, r) {
                this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));
            }
        }, t3.Uniform4f = to, t3.UniformColor = eo, t3.UniformMatrix2f = class extends Ja {
            constructor(t140){
                super(t140), this.current = io;
            }
            set(t, e, r) {
                if (this.fetchUniformLocation(t, e)) for(let t141 = 0; t141 < 4; t141++)if (r[t141] !== this.current[t141]) {
                    this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);
                    break;
                }
            }
        }, t3.UniformMatrix3f = class extends Ja {
            constructor(t141){
                super(t141), this.current = no;
            }
            set(t, e, r) {
                if (this.fetchUniformLocation(t, e)) for(let t142 = 0; t142 < 9; t142++)if (r[t142] !== this.current[t142]) {
                    this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);
                    break;
                }
            }
        }, t3.UniformMatrix4f = class extends Ja {
            constructor(t142){
                super(t142), this.current = ro;
            }
            set(t, e, r) {
                if (this.fetchUniformLocation(t, e)) {
                    if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);
                    for(let t143 = 1; t143 < 16; t143++)if (r[t143] !== this.current[t143]) {
                        this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t3.UnwrappedTileID = Nc, t3.ValidationError = Wn, t3.VectorTileFeature = Sc, t3.VectorTileWorkerSource = class extends Yt {
            constructor(t143, e94, r61, n41, i30){
                super(), this.actor = t143, this.layerIndex = e94, this.availableImages = r61, this.loadVectorData = i30 || yy, this.loading = {
                }, this.loaded = {
                }, this.deduped = new dy(t143.scheduler), this.isSpriteLoaded = n41, this.scheduler = t143.scheduler;
            }
            loadTile(t, e) {
                const r62 = t.uid, n42 = t && t.request, i31 = n42 && n42.collectResourceTiming, s21 = this.loading[r62] = new py(t);
                s21.abort = this.loadVectorData(t, (a13, o12)=>{
                    const l10 = !this.loading[r62];
                    if (delete this.loading[r62], l10 || a13 || !o12) return s21.status = "done", l10 || (this.loaded[r62] = s21), e(a13);
                    const u9 = o12.rawData, c7 = {
                    };
                    o12.expires && (c7.expires = o12.expires), o12.cacheControl && (c7.cacheControl = o12.cacheControl), s21.vectorTile = o12.vectorTile || new Ac(new kh(u9));
                    const h5 = ()=>{
                        s21.parse(s21.vectorTile, this.layerIndex, this.availableImages, this.actor, (t144, r63)=>{
                            if (t144 || !r63) return e(t144);
                            const s22 = {
                            };
                            if (i31) {
                                const t145 = jt(n42);
                                t145.length > 0 && (s22.resourceTiming = JSON.parse(JSON.stringify(t145)));
                            }
                            e(null, z1({
                                rawTileData: u9.slice(0)
                            }, r63, c7, s22));
                        });
                    };
                    this.isSpriteLoaded ? h5() : this.once("isSpriteLoaded", ()=>{
                        this.scheduler ? this.scheduler.add(h5, {
                            type: "parseTile",
                            isSymbolTile: t.isSymbolTile,
                            zoom: t.tileZoom
                        }) : h5();
                    }), this.loaded = this.loaded || {
                    }, this.loaded[r62] = s21;
                });
            }
            reloadTile(t, e) {
                const r62 = this.loaded, n42 = t.uid, i31 = this;
                if (r62 && r62[n42]) {
                    const s21 = r62[n42];
                    s21.showCollisionBoxes = t.showCollisionBoxes, s21.enableTerrain = !!t.enableTerrain, s21.projection = t.projection, s21.tileTransform = Df(t.tileID.canonical, t.projection);
                    const a13 = (t144, r63)=>{
                        const n43 = s21.reloadCallback;
                        n43 && (delete s21.reloadCallback, s21.parse(s21.vectorTile, i31.layerIndex, this.availableImages, i31.actor, n43)), e(t144, r63);
                    };
                    "parsing" === s21.status ? s21.reloadCallback = a13 : "done" === s21.status && (s21.vectorTile ? s21.parse(s21.vectorTile, this.layerIndex, this.availableImages, this.actor, a13) : a13());
                }
            }
            abortTile(t, e) {
                const r62 = t.uid, n42 = this.loading[r62];
                n42 && (n42.abort && n42.abort(), delete this.loading[r62]), e();
            }
            removeTile(t, e) {
                const r62 = this.loaded, n42 = t.uid;
                r62 && r62[n42] && delete r62[n42], e();
            }
        }, t3.WritingMode = Qh, t3.add = Pl, t3.addDynamicAttributes = ad, t3.adjoint = function(t144, e95) {
            var r62 = e95[0], n42 = e95[1], i31 = e95[2], s21 = e95[3], a13 = e95[4], o12 = e95[5], l10 = e95[6], u9 = e95[7], c7 = e95[8];
            return t144[0] = a13 * c7 - o12 * u9, t144[1] = i31 * u9 - n42 * c7, t144[2] = n42 * o12 - i31 * a13, t144[3] = o12 * l10 - s21 * c7, t144[4] = r62 * c7 - i31 * l10, t144[5] = i31 * s21 - r62 * o12, t144[6] = s21 * u9 - a13 * l10, t144[7] = n42 * l10 - r62 * u9, t144[8] = r62 * a13 - n42 * s21, t144;
        }, t3.asyncAll = M1, t3.bezier = _1, t3.bindAll = V, t3.boundsAttributes = Dd, t3.bufferConvexPolygon = function(t144, e95) {
            const r62 = [];
            for(let n42 = 0; n42 < t144.length; n42++){
                const i31 = I1(n42 - 1, -1, t144.length - 1), s21 = I1(n42 + 1, -1, t144.length - 1), a13 = t144[n42], o12 = t144[s21], l10 = t144[i31].sub(a13).unit(), u9 = o12.sub(a13).unit(), c7 = u9.angleWithSep(l10.x, l10.y), h5 = l10.add(u9).unit().mult(-1 * e95 / Math.sin(c7 / 2));
                r62.push(a13.add(h5));
            }
            return r62;
        }, t3.cacheEntryPossiblyAdded = function(t144) {
            it++, it > tt && (t144.getActor().send("enforceCacheSizeLimit", Q), it = 0);
        }, t3.calculateGlobeLabelMatrix = function(t144, e95) {
            const { x: r62 , y: n42  } = t144.point, i31 = If(r62, n42, t144.worldSize / t144._pixelsPerMercatorPixel, 0, 0);
            return wl(i31, i31, kf(pf(e95)));
        }, t3.calculateGlobeMatrix = function(t144) {
            const { x: e95 , y: r62  } = t144.point, { lng: n42 , lat: i31  } = t144._center;
            return If(e95, r62, t144.worldSize, n42, i31);
        }, t3.calculateGlobeMercatorMatrix = function(t144) {
            const e95 = t144.pixelsPerMeter, r62 = e95 / Co(1, t144.center.lat), n42 = vl(new Float64Array(16));
            return _l(n42, n42, [
                t144.point.x,
                t144.point.y,
                0
            ]), Al(n42, n42, [
                r62,
                r62,
                e95
            ]), Float32Array.from(n42);
        }, t3.circumferenceAtLatitude = zo, t3.clamp = S1, t3.clearTileCache = function(t144) {
            if (!et()) return;
            const r62 = e2.caches.delete(H);
            t144 && r62.catch(t144).then(()=>t144()
            );
        }, t3.clipLine = _p, t3.clone = function(t144) {
            var e95 = new ml(16);
            return e95[0] = t144[0], e95[1] = t144[1], e95[2] = t144[2], e95[3] = t144[3], e95[4] = t144[4], e95[5] = t144[5], e95[6] = t144[6], e95[7] = t144[7], e95[8] = t144[8], e95[9] = t144[9], e95[10] = t144[10], e95[11] = t144[11], e95[12] = t144[12], e95[13] = t144[13], e95[14] = t144[14], e95[15] = t144[15], e95;
        }, t3.clone$1 = j, t3.collisionCircleLayout = dh, t3.config = i3, t3.conjugate = function(t144, e95) {
            return t144[0] = -e95[0], t144[1] = -e95[1], t144[2] = -e95[2], t144[3] = e95[3], t144;
        }, t3.create = function() {
            var t144 = new ml(16);
            return ml != Float32Array && (t144[1] = 0, t144[2] = 0, t144[3] = 0, t144[4] = 0, t144[6] = 0, t144[7] = 0, t144[8] = 0, t144[9] = 0, t144[11] = 0, t144[12] = 0, t144[13] = 0, t144[14] = 0), t144[0] = 1, t144[5] = 1, t144[10] = 1, t144[15] = 1, t144;
        }, t3.create$1 = gl, t3.createExpression = Gn, t3.createLayout = na, t3.createStyleLayer = function(t144) {
            return "custom" === t144.type ? new gd(t144) : new bd[t144.type](t144);
        }, t3.cross = Ol, t3.degToRad = x1, t3.distance = function(t144, e95) {
            return Math.hypot(e95[0] - t144[0], e95[1] - t144[1], e95[2] - t144[2]);
        }, t3.div = function(t144, e95, r62) {
            return t144[0] = e95[0] / r62[0], t144[1] = e95[1] / r62[1], t144[2] = e95[2] / r62[2], t144;
        }, t3.dot = $l, t3.earthRadius = Io, t3.ease = A1, t3.easeCubicInOut = w1, t3.ecefToLatLng = function([t144, e95, r62]) {
            const n42 = Math.hypot(t144, e95, r62), i31 = Math.atan2(t144, r62), s21 = 0.5 * Math.PI - Math.acos(-e95 / n42);
            return new Mo(v1(i31), v1(s21));
        }, t3.emitValidationErrors = Ri, t3.endsWith = L, t3.enforceCacheSizeLimit = function(t144) {
            rt(), W && W.then((e95)=>{
                e95.keys().then((r62)=>{
                    for(let n42 = 0; n42 < r62.length - t144; n42++)e95.delete(r62[n42]);
                });
            });
        }, t3.evaluateSizeForFeature = xh, t3.evaluateSizeForZoom = vh, t3.evaluateVariableOffset = $p, t3.evented = Ls, t3.exactEquals = function(t144, e95) {
            return t144[0] === e95[0] && t144[1] === e95[1] && t144[2] === e95[2] && t144[3] === e95[3];
        }, t3.exactEquals$1 = function(t144, e95) {
            return t144[0] === e95[0] && t144[1] === e95[1] && t144[2] === e95[2];
        }, t3.exported = Nt, t3.exported$1 = s3, t3.extend = z1, t3.extend$1 = Wt, t3.fillExtrusionHeightLift = Rc, t3.filterObject = R, t3.fromMat4 = function(t144, e95) {
            return t144[0] = e95[0], t144[1] = e95[1], t144[2] = e95[2], t144[3] = e95[4], t144[4] = e95[5], t144[5] = e95[6], t144[6] = e95[8], t144[7] = e95[9], t144[8] = e95[10], t144;
        }, t3.fromQuat = function(t144, e95) {
            var r62 = e95[0], n42 = e95[1], i31 = e95[2], s21 = e95[3], a13 = r62 + r62, o12 = n42 + n42, l10 = i31 + i31, u9 = r62 * a13, c7 = n42 * a13, h5 = n42 * o12, p5 = i31 * a13, f4 = i31 * o12, d4 = i31 * l10, y2 = s21 * a13, m2 = s21 * o12, g2 = s21 * l10;
            return t144[0] = 1 - h5 - d4, t144[1] = c7 + g2, t144[2] = p5 - m2, t144[3] = 0, t144[4] = c7 - g2, t144[5] = 1 - u9 - d4, t144[6] = f4 + y2, t144[7] = 0, t144[8] = p5 + m2, t144[9] = f4 - y2, t144[10] = 1 - u9 - h5, t144[11] = 0, t144[12] = 0, t144[13] = 0, t144[14] = 0, t144[15] = 1, t144;
        }, t3.fromRotation = function(t144, e95) {
            var r62 = Math.sin(e95), n42 = Math.cos(e95);
            return t144[0] = n42, t144[1] = r62, t144[2] = 0, t144[3] = -r62, t144[4] = n42, t144[5] = 0, t144[6] = 0, t144[7] = 0, t144[8] = 1, t144;
        }, t3.fromScaling = Il, t3.furthestTileCorner = function(t144) {
            const e95 = Math.round((t144 + 45 + 360) % 360 / 90) % 4;
            return b1[e95];
        }, t3.getAABBPointSquareDist = function(t144, e95, r62) {
            let n42 = 0;
            for(let i31 = 0; i31 < 2; ++i31){
                const s21 = r62 ? r62[i31] : 0;
                t144[i31] > s21 && (n42 += (t144[i31] - s21) * (t144[i31] - s21)), e95[i31] < s21 && (n42 += (s21 - e95[i31]) * (s21 - e95[i31]));
            }
            return n42;
        }, t3.getAnchorAlignment = cp, t3.getAnchorJustification = qp, t3.getBounds = function(t144) {
            let e95 = 1 / 0, r62 = 1 / 0, n42 = -1 / 0, i31 = -1 / 0;
            for (const s21 of t144)e95 = Math.min(e95, s21.x), r62 = Math.min(r62, s21.y), n42 = Math.max(n42, s21.x), i31 = Math.max(i31, s21.y);
            return {
                min: new d2(e95, r62),
                max: new d2(n42, i31)
            };
        }, t3.getColumn = Y, t3.getGridMatrix = function(t144, e95, r62, n42) {
            const i31 = e95.getNorth(), s21 = e95.getSouth(), a13 = e95.getWest(), o12 = e95.getEast(), l10 = 1 << t144.z, u9 = o12 - a13, c7 = i31 - s21, h5 = u9 / nf, p5 = -c7 / sf[r62], f4 = [
                0,
                h5,
                0,
                p5,
                0,
                0,
                i31,
                a13,
                0
            ];
            if (t144.z > 0) {
                const t145 = 180 / n42;
                xl(f4, f4, [
                    t145 / u9 + 1,
                    0,
                    0,
                    0,
                    t145 / c7 + 1,
                    0,
                    -0.5 * t145 / h5,
                    0.5 * t145 / p5,
                    1
                ]);
            }
            return f4[2] = l10, f4[5] = t144.x, f4[8] = t144.y, f4;
        }, t3.getImage = dt, t3.getJSON = function(t144, e95) {
            return lt(z1(t144, {
                type: "json"
            }), e95);
        }, t3.getLatitudinalLod = function(t144) {
            const e95 = 80.051129;
            t144 = S1(t144, -80.051129, e95) / e95 * 90;
            const r62 = Math.pow(Math.abs(Math.sin(x1(t144))), 3);
            return Math.round(r62 * (sf.length - 1));
        }, t3.getMapSessionAPI = Pt, t3.getPerformanceMeasurement = jt, t3.getProjection = ed, t3.getRTLTextPluginStatus = Fs, t3.getReferrer = ot, t3.getTilePoint = function(t144, { x: e95 , y: r62  }, n42 = 0) {
            return new d2(((e95 - n42) * t144.scale - t144.x) * So, (r62 * t144.scale - t144.y) * So);
        }, t3.getTileVec3 = function(t144, e95, r62 = 0) {
            return Cl(((e95.x - r62) * t144.scale - t144.x) * So, (e95.y * t144.scale - t144.y) * So, Vo(e95.z, e95.y));
        }, t3.getVideo = function(t144, r62) {
            const n42 = e2.document.createElement("video");
            n42.muted = !0, n42.onloadstart = function() {
                r62(null, n42);
            };
            for(let r63 = 0; r63 < t144.length; r63++){
                const i31 = e2.document.createElement("source");
                ct(t144[r63]) || (n42.crossOrigin = "Anonymous"), i31.src = t144[r63], n42.appendChild(i31);
            }
            return {
                cancel: ()=>{
                }
            };
        }, t3.globeCenterToScreenPoint = function(t144) {
            const e95 = [
                0,
                0,
                0
            ], r62 = vl(new Float64Array(16));
            return wl(r62, t144.pixelMatrix, t144.globeMatrix), ql(e95, e95, r62), new d2(e95[0], e95[1]);
        }, t3.globeDenormalizeECEF = kf, t3.globeECEFOrigin = function(t144, e95) {
            const r62 = [
                0,
                0,
                0
            ];
            return ql(r62, r62, Sf(pf(e95.canonical))), ql(r62, r62, t144), r62;
        }, t3.globeNormalizeECEF = Sf, t3.globePixelsToTileUnits = function(t144, e95) {
            return So / (512 * Math.pow(2, t144)) * _f(pf(e95));
        }, t3.globePoleMatrixForTile = function(t144, e95, r62) {
            const n42 = vl(new Float64Array(16)), i31 = (e95 / (1 << t144) - 0.5) * Math.PI * 2;
            return kl(n42, r62.globeMatrix, i31), Float32Array.from(n42);
        }, t3.globeTileBounds = pf, t3.globeTiltAtLngLat = Tf, t3.globeToMercatorTransition = Mf, t3.globeUseCustomAntiAliasing = function(t144, e95, r62) {
            const n42 = Mf(r62.zoom), i31 = t144.style.map._antialias, s21 = !!e95.extStandardDerivatives, a13 = e95.extStandardDerivativesForceOff || t144.terrain && t144.terrain.exaggeration() > 0;
            return 0 === n42 && !i31 && !a13 && s21;
        }, t3.identity = vl, t3.identity$1 = Ql, t3.invert = bl, t3.isFullscreen = function() {
            return !!e2.document.fullscreenElement || !!e2.document.webkitFullscreenElement;
        }, t3.isLngLatBehindGlobe = zf, t3.isMapAuthenticated = function(t144) {
            return Dt.has(t144);
        }, t3.isMapboxURL = mt, t3.isSafariWithAntialiasingBug = function(t144) {
            const e95 = t144.navigator ? t144.navigator.userAgent : null;
            return !!Z(t144) && e95 && (e95.match("Version/15.4") || e95.match("Version/15.5") || e95.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t3.latFromMercatorY = Do, t3.latLngToECEF = bf, t3.len = Kl, t3.length = El, t3.length$1 = function(t144) {
            return Math.hypot(t144[0], t144[1], t144[2], t144[3]);
        }, t3.lngFromMercatorX = Po, t3.loadVectorTile = yy, t3.makeRequest = lt, t3.mapValue = function(t144, e95, r62, n42, i31) {
            return S1((t144 - e95) / (r62 - e95) * (i31 - n42) + n42, n42, i31);
        }, t3.mercatorScale = Fo, t3.mercatorXfromLng = Bo, t3.mercatorYfromLat = Eo, t3.mercatorZfromAltitude = Co, t3.mul = Tl, t3.mul$1 = Zl, t3.multiply = wl, t3.multiply$1 = xl, t3.multiply$2 = Vl, t3.nextPowerOfTwo = P, t3.normalize = Ul, t3.normalize$1 = ru, t3.normalize$2 = Hl, t3.number = Mr, t3.ortho = function(t144, e95, r62, n42, i31, s21, a13) {
            var o12 = 1 / (e95 - r62), l10 = 1 / (n42 - i31), u9 = 1 / (s21 - a13);
            return t144[0] = -2 * o12, t144[1] = 0, t144[2] = 0, t144[3] = 0, t144[4] = 0, t144[5] = -2 * l10, t144[6] = 0, t144[7] = 0, t144[8] = 0, t144[9] = 0, t144[10] = 2 * u9, t144[11] = 0, t144[12] = (e95 + r62) * o12, t144[13] = (i31 + n42) * l10, t144[14] = (a13 + s21) * u9, t144[15] = 1, t144;
        }, t3.pbf = kh, t3.perspective = function(t144, e95, r62, n42, i31) {
            var s21, a13 = 1 / Math.tan(e95 / 2);
            return t144[0] = a13 / r62, t144[1] = 0, t144[2] = 0, t144[3] = 0, t144[4] = 0, t144[5] = a13, t144[6] = 0, t144[7] = 0, t144[8] = 0, t144[9] = 0, t144[11] = -1, t144[12] = 0, t144[13] = 0, t144[15] = 0, null != i31 && i31 !== 1 / 0 ? (t144[10] = (i31 + n42) * (s21 = 1 / (n42 - i31)), t144[14] = 2 * i31 * n42 * s21) : (t144[10] = -1, t144[14] = -2 * n42), t144;
        }, t3.pick = function(t144, e95) {
            const r62 = {
            };
            for(let n42 = 0; n42 < e95.length; n42++){
                const i31 = e95[n42];
                i31 in t144 && (r62[i31] = t144[i31]);
            }
            return r62;
        }, t3.plugin = js, t3.pointGeometry = d2, t3.polesInViewport = function(t144) {
            const e95 = vl(new Float64Array(16));
            wl(e95, t144.pixelMatrix, t144.globeMatrix);
            const r62 = [
                0,
                af,
                0
            ], n42 = [
                0,
                of,
                0
            ];
            return ql(r62, r62, e95), ql(n42, n42, e95), [
                r62[0] > 0 && r62[0] <= t144.width && r62[1] > 0 && r62[1] <= t144.height && !zf(t144, new Mo(t144.center.lat, 90)),
                n42[0] > 0 && n42[0] <= t144.width && n42[1] > 0 && n42[1] <= t144.height && !zf(t144, new Mo(t144.center.lat, -90))
            ];
        }, t3.polygonContainsPoint = al, t3.polygonIntersectsBox = ol, t3.polygonIntersectsPolygon = Wo, t3.polygonizeBounds = function(t144, e95, r62 = 0, n42 = !0) {
            const i31 = new d2(r62, r62), s21 = t144.sub(i31), a13 = e95.add(i31), o12 = [
                s21,
                new d2(a13.x, s21.y),
                a13,
                new d2(s21.x, a13.y)
            ];
            return n42 && o12.push(s21.clone()), o12;
        }, t3.posAttributes = tf, t3.postMapLoadEvent = zt, t3.postPerformanceEvent = Et, t3.postTurnstileEvent = Mt, t3.potpack = Hh, t3.prevPowerOfTwo = function(t144) {
            return t144 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t144) / Math.LN2));
        }, t3.radToDeg = v1, t3.refProperties = [
            "type",
            "source",
            "source-layer",
            "minzoom",
            "maxzoom",
            "filter",
            "layout"
        ], t3.registerForPluginStateChange = function(t144) {
            return t144({
                pluginStatus: Cs,
                pluginURL: Ps
            }), Ls.on("pluginStateChange", t144), t144;
        }, t3.removeAuthState = function(t144) {
            Dt.delete(t144);
        }, t3.renderColorRamp = vu, t3.resample = Uo, t3.rotateX = Sl, t3.rotateX$1 = tu, t3.rotateY = kl, t3.rotateY$1 = eu, t3.rotateZ = function(t144, e95, r62) {
            var n42 = Math.sin(r62), i31 = Math.cos(r62), s21 = e95[0], a13 = e95[1], o12 = e95[2], l10 = e95[3], u9 = e95[4], c7 = e95[5], h5 = e95[6], p5 = e95[7];
            return e95 !== t144 && (t144[8] = e95[8], t144[9] = e95[9], t144[10] = e95[10], t144[11] = e95[11], t144[12] = e95[12], t144[13] = e95[13], t144[14] = e95[14], t144[15] = e95[15]), t144[0] = s21 * i31 + u9 * n42, t144[1] = a13 * i31 + c7 * n42, t144[2] = o12 * i31 + h5 * n42, t144[3] = l10 * i31 + p5 * n42, t144[4] = u9 * i31 - s21 * n42, t144[5] = c7 * i31 - a13 * n42, t144[6] = h5 * i31 - o12 * n42, t144[7] = p5 * i31 - l10 * n42, t144;
        }, t3.rotateZ$1 = function(t144, e95, r62) {
            r62 *= 0.5;
            var n42 = e95[0], i31 = e95[1], s21 = e95[2], a13 = e95[3], o12 = Math.sin(r62), l10 = Math.cos(r62);
            return t144[0] = n42 * l10 + i31 * o12, t144[1] = i31 * l10 - n42 * o12, t144[2] = s21 * l10 + a13 * o12, t144[3] = a13 * l10 - s21 * o12, t144;
        }, t3.scale = Al, t3.scale$1 = Yl, t3.scale$2 = Rl, t3.scaleAndAdd = jl, t3.set = function(t144, e95, r62, n42) {
            return t144[0] = e95, t144[1] = r62, t144[2] = n42, t144;
        }, t3.setCacheLimits = function(t144, e95) {
            Q = t144, tt = e95;
        }, t3.setColumn = function(t144, e95, r62) {
            t144[4 * e95 + 0] = r62[0], t144[4 * e95 + 1] = r62[1], t144[4 * e95 + 2] = r62[2], t144[4 * e95 + 3] = r62[3];
        }, t3.setRTLTextPlugin = function(t144, e95, r62 = !1) {
            if (Cs === Ts || Cs === zs || Cs === Bs) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Ps = Nt.resolveURL(t144), Cs = Ts, Es = e95, Vs(), r62 || Rs();
        }, t3.smoothstep = k1, t3.spec = Ht, t3.squaredLength = function(t144) {
            var e95 = t144[0], r62 = t144[1], n42 = t144[2];
            return e95 * e95 + r62 * r62 + n42 * n42;
        }, t3.storeAuthState = function(t144, e95) {
            e95 ? Dt.add(t144) : Dt.delete(t144);
        }, t3.sub = Xl, t3.subtract = Dl, t3.symbolSize = bh, t3.tileAABB = function(t144, e95, r62, n42, i31, s21, a13, o12, l10) {
            if ("globe" === l10.name) return mf(t144, e95, new qc(r62, n42, i31));
            const u9 = Df({
                z: r62,
                x: n42,
                y: i31
            }, l10);
            return new au([
                (s21 + u9.x / u9.scale) * e95,
                e95 * (u9.y / u9.scale),
                a13
            ], [
                (s21 + u9.x2 / u9.scale) * e95,
                e95 * (u9.y2 / u9.scale),
                o12
            ]);
        }, t3.tileCornersToBounds = gf, t3.tileTransform = Df, t3.transformMat3 = function(t144, e95, r62) {
            var n42 = e95[0], i31 = e95[1], s21 = e95[2];
            return t144[0] = n42 * r62[0] + i31 * r62[3] + s21 * r62[6], t144[1] = n42 * r62[1] + i31 * r62[4] + s21 * r62[7], t144[2] = n42 * r62[2] + i31 * r62[5] + s21 * r62[8], t144;
        }, t3.transformMat4 = ql, t3.transformMat4$1 = Wl, t3.transformQuat = Nl, t3.transitionTileAABBinECEF = df, t3.translate = _l, t3.transpose = function(t144, e95) {
            if (t144 === e95) {
                var r62 = e95[1], n42 = e95[2], i31 = e95[5];
                t144[1] = e95[3], t144[2] = e95[6], t144[3] = r62, t144[5] = e95[7], t144[6] = n42, t144[7] = i31;
            } else t144[0] = e95[0], t144[1] = e95[3], t144[2] = e95[6], t144[3] = e95[1], t144[4] = e95[4], t144[5] = e95[7], t144[6] = e95[2], t144[7] = e95[5], t144[8] = e95[8];
            return t144;
        }, t3.triggerPluginCompletionEvent = Ds, t3.uniqueId = E, t3.updateGlobeVertexNormal = function(t144, e95, r63, n43, i32) {
            const s21 = 5 * e95 + 2;
            t144.float32[s21 + 0] = r63, t144.float32[s21 + 1] = n43, t144.float32[s21 + 2] = i32;
        }, t3.validateCustomStyleLayer = function(t144) {
            const e95 = [], r63 = t144.id;
            return (void 0) === r63 && e95.push({
                message: `layers.${r63}: missing required property "id"`
            }), (void 0) === t144.render && e95.push({
                message: `layers.${r63}: missing required method "render"`
            }), t144.renderingMode && "2d" !== t144.renderingMode && "3d" !== t144.renderingMode && e95.push({
                message: `layers.${r63}: property "renderingMode" must be either "2d" or "3d"`
            }), e95;
        }, t3.validateFilter = (t144)=>Fi(xi(t144))
        , t3.validateFog = (t144)=>Fi(Bi(t144))
        , t3.validateLayer = (t144)=>Fi(Ai(t144))
        , t3.validateLight = (t144)=>Fi(Ti(t144))
        , t3.validateSource = (t144)=>Fi(Ii(t144))
        , t3.validateStyle = Di, t3.validateTerrain = (t144)=>Fi(zi(t144))
        , t3.values = T1, t3.vectorTile = hc, t3.version = r2, t3.warnOnce = $, t3.window = e2, t3.wrap = I1;
    });
    define([
        "./shared"
    ], function(e1) {
        function t1(e2) {
            if ("number" == typeof e2 || "boolean" == typeof e2 || "string" == typeof e2 || null == e2) return JSON.stringify(e2);
            if (Array.isArray(e2)) {
                let r1 = "[";
                for (const o2 of e2)r1 += `${t1(o2)},`;
                return `${r1}]`;
            }
            let r1 = "{";
            for (const o2 of Object.keys(e2).sort())r1 += `${o2}:${t1(e2[o2])},`;
            return `${r1}}`;
        }
        function r1(r2) {
            let o2 = "";
            for (const n1 of e1.refProperties)o2 += `/${t1(r2[n1])}`;
            return o2;
        }
        class o2 {
            constructor(e2){
                this.keyCache = {
                }, e2 && this.replace(e2);
            }
            replace(e) {
                this._layerConfigs = {
                }, this._layers = {
                }, this.update(e, []);
            }
            update(t, o) {
                for (const r2 of t)this._layerConfigs[r2.id] = r2, (this._layers[r2.id] = e1.createStyleLayer(r2)).compileFilter(), this.keyCache[r2.id] && delete this.keyCache[r2.id];
                for (const e3 of o)delete this.keyCache[e3], delete this._layerConfigs[e3], delete this._layers[e3];
                this.familiesBySource = {
                };
                const n1 = function(e4, t2) {
                    const o10 = {
                    };
                    for(let n2 = 0; n2 < e4.length; n2++){
                        const i2 = t2 && t2[e4[n2].id] || r1(e4[n2]);
                        t2 && (t2[e4[n2].id] = i2);
                        let s3 = o10[i2];
                        s3 || (s3 = o10[i2] = []), s3.push(e4[n2]);
                    }
                    const n3 = [];
                    for(const e5 in o10)n3.push(o10[e5]);
                    return n3;
                }(e1.values(this._layerConfigs), this.keyCache);
                for (const e4 of n1){
                    const t2 = e4.map((e5)=>this._layers[e5.id]
                    ), r3 = t2[0];
                    if ("none" === r3.visibility) continue;
                    const o10 = r3.source || "";
                    let n2 = this.familiesBySource[o10];
                    n2 || (n2 = this.familiesBySource[o10] = {
                    });
                    const i2 = r3.sourceLayer || "_geojsonTileLayer";
                    let s3 = n2[i2];
                    s3 || (s3 = n2[i2] = []), s3.push(t2);
                }
            }
        }
        class n1 {
            loadTile(t, r) {
                const { uid: o10 , encoding: n2 , rawImageData: i2 , padding: s3 , buildQuadTree: a2  } = t, l1 = e1.window.ImageBitmap && i2 instanceof e1.window.ImageBitmap ? this.getImageData(i2, s3) : i2;
                r(null, new e1.DEMData(o10, l1, n2, s3 < 1, a2));
            }
            getImageData(e, t) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                    willReadFrequently: !0
                })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);
                const r2 = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);
                return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r2;
            }
        }
        var i2 = function e3(t2, r2) {
            var o10, n2 = t2 && t2.type;
            if ("FeatureCollection" === n2) for(o10 = 0; o10 < t2.features.length; o10++)e3(t2.features[o10], r2);
            else if ("GeometryCollection" === n2) for(o10 = 0; o10 < t2.geometries.length; o10++)e3(t2.geometries[o10], r2);
            else if ("Feature" === n2) e3(t2.geometry, r2);
            else if ("Polygon" === n2) s3(t2.coordinates, r2);
            else if ("MultiPolygon" === n2) for(o10 = 0; o10 < t2.coordinates.length; o10++)s3(t2.coordinates[o10], r2);
            return t2;
        };
        function s3(e4, t2) {
            if (0 !== e4.length) {
                a2(e4[0], t2);
                for(var r2 = 1; r2 < e4.length; r2++)a2(e4[r2], !t2);
            }
        }
        function a2(e4, t2) {
            for(var r3 = 0, o10 = 0, n2 = 0, i3 = e4.length, s4 = i3 - 1; n2 < i3; s4 = n2++){
                var a4 = (e4[n2][0] - e4[s4][0]) * (e4[s4][1] + e4[n2][1]), l1 = r3 + a4;
                o10 += Math.abs(r3) >= Math.abs(a4) ? r3 - l1 + a4 : a4 - l1 + r3, r3 = l1;
            }
            r3 + o10 >= 0 != !!t2 && e4.reverse();
        }
        const l9 = e1.VectorTileFeature.prototype.toGeoJSON;
        class u3 {
            constructor(t2){
                this._feature = t2, this.extent = e1.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
            }
            loadGeometry() {
                if (1 === this._feature.type) {
                    const t3 = [];
                    for (const r3 of this._feature.geometry)t3.push([
                        new e1.pointGeometry(r3[0], r3[1])
                    ]);
                    return t3;
                }
                {
                    const t3 = [];
                    for (const r3 of this._feature.geometry){
                        const o10 = [];
                        for (const t4 of r3)o10.push(new e1.pointGeometry(t4[0], t4[1]));
                        t3.push(o10);
                    }
                    return t3;
                }
            }
            toGeoJSON(e, t, r) {
                return l9.call(this, e, t, r);
            }
        }
        class h2 {
            constructor(t3){
                this.layers = {
                    _geojsonTileLayer: this
                }, this.name = "_geojsonTileLayer", this.extent = e1.EXTENT, this.length = t3.length, this._features = t3;
            }
            feature(e) {
                return new u3(this._features[e]);
            }
        }
        var c1 = {
            exports: {
            }
        }, f2 = e1.pointGeometry, p2 = e1.vectorTile.VectorTileFeature, g = d2;
        function d2(e4, t4) {
            this.options = t4 || {
            }, this.features = e4, this.length = e4.length;
        }
        function m(e4, t4) {
            this.id = "number" == typeof e4.id ? e4.id : void 0, this.type = e4.type, this.rawGeometry = 1 === e4.type ? [
                e4.geometry
            ] : e4.geometry, this.properties = e4.tags, this.extent = t4 || 4096;
        }
        d2.prototype.feature = function(e4) {
            return new m(this.features[e4], this.options.extent);
        }, m.prototype.loadGeometry = function() {
            var e4 = this.rawGeometry;
            this.geometry = [];
            for(var t4 = 0; t4 < e4.length; t4++){
                for(var r3 = e4[t4], o10 = [], n2 = 0; n2 < r3.length; n2++)o10.push(new f2(r3[n2][0], r3[n2][1]));
                this.geometry.push(o10);
            }
            return this.geometry;
        }, m.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for(var e4 = this.geometry, t4 = 1 / 0, r4 = -1 / 0, o11 = 1 / 0, n3 = -1 / 0, i3 = 0; i3 < e4.length; i3++)for(var s4 = e4[i3], a9 = 0; a9 < s4.length; a9++){
                var l10 = s4[a9];
                t4 = Math.min(t4, l10.x), r4 = Math.max(r4, l10.x), o11 = Math.min(o11, l10.y), n3 = Math.max(n3, l10.y);
            }
            return [
                t4,
                o11,
                r4,
                n3
            ];
        }, m.prototype.toGeoJSON = p2.prototype.toGeoJSON;
        var y = e1.pbf, v = g;
        function x(e4) {
            var t4 = new y;
            return (function(e5, t5) {
                for(var r4 in e5.layers)t5.writeMessage(3, w, e5.layers[r4]);
            })(e4, t4), t4.finish();
        }
        function w(e4, t4) {
            var r4;
            t4.writeVarintField(15, e4.version || 1), t4.writeStringField(1, e4.name || ""), t4.writeVarintField(5, e4.extent || 4096);
            var o11 = {
                keys: [],
                values: [],
                keycache: {
                },
                valuecache: {
                }
            };
            for(r4 = 0; r4 < e4.length; r4++)o11.feature = e4.feature(r4), t4.writeMessage(2, S, o11);
            var n3 = o11.keys;
            for(r4 = 0; r4 < n3.length; r4++)t4.writeStringField(3, n3[r4]);
            var i3 = o11.values;
            for(r4 = 0; r4 < i3.length; r4++)t4.writeMessage(4, I, i3[r4]);
        }
        function S(e4, t4) {
            var r4 = e4.feature;
            (void 0) !== r4.id && t4.writeVarintField(1, r4.id), t4.writeMessage(2, M, e4), t4.writeVarintField(3, r4.type), t4.writeMessage(4, k, r4);
        }
        function M(e4, t4) {
            var r4 = e4.feature, o11 = e4.keys, n3 = e4.values, i3 = e4.keycache, s4 = e4.valuecache;
            for(var a9 in r4.properties){
                var l11 = r4.properties[a9], u8 = i3[a9];
                if (null !== l11) {
                    (void 0) === u8 && (o11.push(a9), i3[a9] = u8 = o11.length - 1), t4.writeVarint(u8);
                    var h5 = typeof l11;
                    "string" !== h5 && "boolean" !== h5 && "number" !== h5 && (l11 = JSON.stringify(l11));
                    var c7 = h5 + ":" + l11, f4 = s4[c7];
                    (void 0) === f4 && (n3.push(l11), s4[c7] = f4 = n3.length - 1), t4.writeVarint(f4);
                }
            }
        }
        function P(e4, t4) {
            return (t4 << 3) + (7 & e4);
        }
        function b(e4) {
            return e4 << 1 ^ e4 >> 31;
        }
        function k(e4, t4) {
            for(var r4 = e4.loadGeometry(), o11 = e4.type, n3 = 0, i3 = 0, s4 = r4.length, a9 = 0; a9 < s4; a9++){
                var l12 = r4[a9], u9 = 1;
                1 === o11 && (u9 = l12.length), t4.writeVarint(P(1, u9));
                for(var h6 = 3 === o11 ? l12.length - 1 : l12.length, c8 = 0; c8 < h6; c8++){
                    1 === c8 && 1 !== o11 && t4.writeVarint(P(2, h6 - 1));
                    var f5 = l12[c8].x - n3, p5 = l12[c8].y - i3;
                    t4.writeVarint(b(f5)), t4.writeVarint(b(p5)), n3 += f5, i3 += p5;
                }
                3 === o11 && t4.writeVarint(P(7, 1));
            }
        }
        function I(e4, t4) {
            var r4 = typeof e4;
            "string" === r4 ? t4.writeStringField(1, e4) : "boolean" === r4 ? t4.writeBooleanField(7, e4) : "number" === r4 && (e4 % 1 != 0 ? t4.writeDoubleField(3, e4) : e4 < 0 ? t4.writeSVarintField(6, e4) : t4.writeVarintField(5, e4));
        }
        function T(e4, t4, r4, o11, n3, i3) {
            if (n3 - o11 <= r4) return;
            const s4 = o11 + n3 >> 1;
            _(e4, t4, s4, o11, n3, i3 % 2), T(e4, t4, r4, o11, s4 - 1, i3 + 1), T(e4, t4, r4, s4 + 1, n3, i3 + 1);
        }
        function _(e4, t4, r4, o11, n3, i3) {
            for(; n3 > o11;){
                if (n3 - o11 > 600) {
                    const s4 = n3 - o11 + 1, a9 = r4 - o11 + 1, l13 = Math.log(s4), u10 = 0.5 * Math.exp(2 * l13 / 3), h7 = 0.5 * Math.sqrt(l13 * u10 * (s4 - u10) / s4) * (a9 - s4 / 2 < 0 ? -1 : 1);
                    _(e4, t4, r4, Math.max(o11, Math.floor(r4 - a9 * u10 / s4 + h7)), Math.min(n3, Math.floor(r4 + (s4 - a9) * u10 / s4 + h7)), i3);
                }
                const s4 = t4[2 * r4 + i3];
                let a9 = o11, l13 = n3;
                for(L(e4, t4, o11, r4), t4[2 * n3 + i3] > s4 && L(e4, t4, o11, n3); a9 < l13;){
                    for(L(e4, t4, a9, l13), a9++, l13--; t4[2 * a9 + i3] < s4;)a9++;
                    for(; t4[2 * l13 + i3] > s4;)l13--;
                }
                t4[2 * o11 + i3] === s4 ? L(e4, t4, o11, l13) : (l13++, L(e4, t4, l13, n3)), l13 <= r4 && (o11 = l13 + 1), r4 <= l13 && (n3 = l13 - 1);
            }
        }
        function L(e4, t4, r4, o11) {
            C(e4, r4, o11), C(t4, 2 * r4, 2 * o11), C(t4, 2 * r4 + 1, 2 * o11 + 1);
        }
        function C(e4, t4, r4) {
            const o11 = e4[t4];
            e4[t4] = e4[r4], e4[r4] = o11;
        }
        function O(e4, t4, r4, o11) {
            const n3 = e4 - r4, i3 = t4 - o11;
            return n3 * n3 + i3 * i3;
        }
        c1.exports = x, c1.exports.fromVectorTileJs = x, c1.exports.fromGeojsonVt = function(e4, t4) {
            t4 = t4 || {
            };
            var r4 = {
            };
            for(var o11 in e4)r4[o11] = new v(e4[o11].features, t4), r4[o11].name = o11, r4[o11].version = t4.version, r4[o11].extent = t4.extent;
            return x({
                layers: r4
            });
        }, c1.exports.GeoJSONWrapper = v;
        const z = (e4)=>e4[0]
        , E = (e4)=>e4[1]
        ;
        class F {
            constructor(e4, t4 = z, r4 = E, o11 = 64, n3 = Float64Array){
                this.nodeSize = o11, this.points = e4;
                const i3 = e4.length < 65536 ? Uint16Array : Uint32Array, s4 = this.ids = new i3(e4.length), a9 = this.coords = new n3(2 * e4.length);
                for(let o12 = 0; o12 < e4.length; o12++)s4[o12] = o12, a9[2 * o12] = t4(e4[o12]), a9[2 * o12 + 1] = r4(e4[o12]);
                T(s4, a9, o11, 0, s4.length - 1, 0);
            }
            range(e, t, r, o) {
                return (function(e5, t5, r5, o13, n4, i4, s5) {
                    const a10 = [
                        0,
                        e5.length - 1,
                        0
                    ], l13 = [];
                    let u10, h7;
                    for(; a10.length;){
                        const c9 = a10.pop(), f6 = a10.pop(), p6 = a10.pop();
                        if (f6 - p6 <= s5) {
                            for(let s7 = p6; s7 <= f6; s7++)u10 = t5[2 * s7], h7 = t5[2 * s7 + 1], u10 >= r5 && u10 <= n4 && h7 >= o13 && h7 <= i4 && l13.push(e5[s7]);
                            continue;
                        }
                        const g1 = Math.floor((p6 + f6) / 2);
                        u10 = t5[2 * g1], h7 = t5[2 * g1 + 1], u10 >= r5 && u10 <= n4 && h7 >= o13 && h7 <= i4 && l13.push(e5[g1]);
                        const d4 = (c9 + 1) % 2;
                        (0 === c9 ? r5 <= u10 : o13 <= h7) && (a10.push(p6), a10.push(g1 - 1), a10.push(d4)), (0 === c9 ? n4 >= u10 : i4 >= h7) && (a10.push(g1 + 1), a10.push(f6), a10.push(d4));
                    }
                    return l13;
                })(this.ids, this.coords, e, t, r, o, this.nodeSize);
            }
            within(e, t, r) {
                return (function(e5, t5, r5, o13, n4, i4) {
                    const s5 = [
                        0,
                        e5.length - 1,
                        0
                    ], a10 = [], l13 = n4 * n4;
                    for(; s5.length;){
                        const u10 = s5.pop(), h7 = s5.pop(), c9 = s5.pop();
                        if (h7 - c9 <= i4) {
                            for(let n5 = c9; n5 <= h7; n5++)O(t5[2 * n5], t5[2 * n5 + 1], r5, o13) <= l13 && a10.push(e5[n5]);
                            continue;
                        }
                        const f6 = Math.floor((c9 + h7) / 2), p6 = t5[2 * f6], g1 = t5[2 * f6 + 1];
                        O(p6, g1, r5, o13) <= l13 && a10.push(e5[f6]);
                        const d4 = (u10 + 1) % 2;
                        (0 === u10 ? r5 - n4 <= p6 : o13 - n4 <= g1) && (s5.push(c9), s5.push(f6 - 1), s5.push(d4)), (0 === u10 ? r5 + n4 >= p6 : o13 + n4 >= g1) && (s5.push(f6 + 1), s5.push(h7), s5.push(d4));
                    }
                    return a10;
                })(this.ids, this.coords, e, t, r, this.nodeSize);
            }
        }
        const N = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: (e5)=>e5
        }, j = Math.fround || (Z = new Float32Array(1), (e5)=>(Z[0] = +e5, Z[0])
        );
        var Z;
        class G {
            constructor(e5){
                this.options = $(Object.create(N), e5), this.trees = new Array(this.options.maxZoom + 1);
            }
            load(e) {
                const { log: t5 , minZoom: r5 , maxZoom: o13 , nodeSize: n4  } = this.options;
                t5 && console.time("total time");
                const i4 = `prepare ${e.length} points`;
                t5 && console.time(i4), this.points = e;
                let s5 = [];
                for(let t6 = 0; t6 < e.length; t6++)e[t6].geometry && s5.push(W(e[t6], t6));
                this.trees[o13 + 1] = new F(s5, B, R, n4, Float32Array), t5 && console.timeEnd(i4);
                for(let e6 = o13; e6 >= r5; e6--){
                    const r6 = +Date.now();
                    s5 = this._cluster(s5, e6), this.trees[e6] = new F(s5, B, R, n4, Float32Array), t5 && console.log("z%d: %d clusters in %dms", e6, s5.length, +Date.now() - r6);
                }
                return t5 && console.timeEnd("total time"), this;
            }
            getClusters(e, t) {
                let r5 = ((e[0] + 180) % 360 + 360) % 360 - 180;
                const o13 = Math.max(-90, Math.min(90, e[1]));
                let n4 = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
                const i4 = Math.max(-90, Math.min(90, e[3]));
                if (e[2] - e[0] >= 360) r5 = -180, n4 = 180;
                else if (r5 > n4) {
                    const e6 = this.getClusters([
                        r5,
                        o13,
                        180,
                        i4
                    ], t), s5 = this.getClusters([
                        -180,
                        o13,
                        n4,
                        i4
                    ], t);
                    return e6.concat(s5);
                }
                const s5 = this.trees[this._limitZoom(t)], a10 = s5.range(V(r5), A(i4), V(n4), A(o13)), l13 = [];
                for (const e6 of a10){
                    const t5 = s5.points[e6];
                    l13.push(t5.numPoints ? Y(t5) : this.points[t5.index]);
                }
                return l13;
            }
            getChildren(e) {
                const t5 = this._getOriginId(e), r5 = this._getOriginZoom(e), o13 = "No cluster with the specified id.", n4 = this.trees[r5];
                if (!n4) throw new Error(o13);
                const i4 = n4.points[t5];
                if (!i4) throw new Error(o13);
                const s5 = this.options.radius / (this.options.extent * Math.pow(2, r5 - 1)), a10 = n4.within(i4.x, i4.y, s5), l13 = [];
                for (const t6 of a10){
                    const r6 = n4.points[t6];
                    r6.parentId === e && l13.push(r6.numPoints ? Y(r6) : this.points[r6.index]);
                }
                if (0 === l13.length) throw new Error(o13);
                return l13;
            }
            getLeaves(e, t, r) {
                const o13 = [];
                return this._appendLeaves(o13, e, t = t || 10, r = r || 0, 0), o13;
            }
            getTile(e, t, r) {
                const o13 = this.trees[this._limitZoom(e)], n4 = Math.pow(2, e), { extent: i4 , radius: s5  } = this.options, a10 = s5 / i4, l13 = (r - a10) / n4, u10 = (r + 1 + a10) / n4, h7 = {
                    features: []
                };
                return this._addTileFeatures(o13.range((t - a10) / n4, l13, (t + 1 + a10) / n4, u10), o13.points, t, r, n4, h7), 0 === t && this._addTileFeatures(o13.range(1 - a10 / n4, l13, 1, u10), o13.points, n4, r, n4, h7), t === n4 - 1 && this._addTileFeatures(o13.range(0, l13, a10 / n4, u10), o13.points, -1, r, n4, h7), h7.features.length ? h7 : null;
            }
            getClusterExpansionZoom(e) {
                let t5 = this._getOriginZoom(e) - 1;
                for(; t5 <= this.options.maxZoom;){
                    const r5 = this.getChildren(e);
                    if (t5++, 1 !== r5.length) break;
                    e = r5[0].properties.cluster_id;
                }
                return t5;
            }
            _appendLeaves(e, t, r, o, n) {
                const i4 = this.getChildren(t);
                for (const t5 of i4){
                    const i5 = t5.properties;
                    if (i5 && i5.cluster ? n + i5.point_count <= o ? n += i5.point_count : n = this._appendLeaves(e, i5.cluster_id, r, o, n) : n < o ? n++ : e.push(t5), e.length === r) break;
                }
                return n;
            }
            _addTileFeatures(e, t, r, o, n, i) {
                for (const s5 of e){
                    const e6 = t[s5], a10 = e6.numPoints;
                    let l13, u10, h7;
                    if (a10) l13 = X(e6), u10 = e6.x, h7 = e6.y;
                    else {
                        const t5 = this.points[e6.index];
                        l13 = t5.properties, u10 = V(t5.geometry.coordinates[0]), h7 = A(t5.geometry.coordinates[1]);
                    }
                    const c9 = {
                        type: 1,
                        geometry: [
                            [
                                Math.round(this.options.extent * (u10 * n - r)),
                                Math.round(this.options.extent * (h7 * n - o))
                            ]
                        ],
                        tags: l13
                    };
                    let f6;
                    a10 ? f6 = e6.id : this.options.generateId ? f6 = e6.index : this.points[e6.index].id && (f6 = this.points[e6.index].id), (void 0) !== f6 && (c9.id = f6), i.features.push(c9);
                }
            }
            _limitZoom(e) {
                return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
            }
            _cluster(e, t) {
                const r5 = [], { radius: o13 , extent: n4 , reduce: i4 , minPoints: s5  } = this.options, a10 = o13 / (n4 * Math.pow(2, t));
                for(let o14 = 0; o14 < e.length; o14++){
                    const n5 = e[o14];
                    if (n5.zoom <= t) continue;
                    n5.zoom = t;
                    const l13 = this.trees[t + 1], u10 = l13.within(n5.x, n5.y, a10), h7 = n5.numPoints || 1;
                    let c9 = h7;
                    for (const e6 of u10){
                        const r6 = l13.points[e6];
                        r6.zoom > t && (c9 += r6.numPoints || 1);
                    }
                    if (c9 > h7 && c9 >= s5) {
                        let e7 = n5.x * h7, s7 = n5.y * h7, a11 = i4 && h7 > 1 ? this._map(n5, !0) : null;
                        const f6 = (o14 << 5) + (t + 1) + this.points.length;
                        for (const r6 of u10){
                            const o15 = l13.points[r6];
                            if (o15.zoom <= t) continue;
                            o15.zoom = t;
                            const u11 = o15.numPoints || 1;
                            e7 += o15.x * u11, s7 += o15.y * u11, o15.parentId = f6, i4 && (a11 || (a11 = this._map(n5, !0)), i4(a11, this._map(o15)));
                        }
                        n5.parentId = f6, r5.push(J(e7 / c9, s7 / c9, f6, c9, a11));
                    } else if (r5.push(n5), c9 > 1) for (const e7 of u10){
                        const o15 = l13.points[e7];
                        o15.zoom <= t || (o15.zoom = t, r5.push(o15));
                    }
                }
                return r5;
            }
            _getOriginId(e) {
                return e - this.points.length >> 5;
            }
            _getOriginZoom(e) {
                return (e - this.points.length) % 32;
            }
            _map(e, t) {
                if (e.numPoints) return t ? $({
                }, e.properties) : e.properties;
                const r5 = this.points[e.index].properties, o13 = this.options.map(r5);
                return t && o13 === r5 ? $({
                }, o13) : o13;
            }
        }
        function J(e6, t5, r5, o13, n4) {
            return {
                x: j(e6),
                y: j(t5),
                zoom: 1 / 0,
                id: r5,
                parentId: -1,
                numPoints: o13,
                properties: n4
            };
        }
        function W(e6, t5) {
            const [r5, o13] = e6.geometry.coordinates;
            return {
                x: j(V(r5)),
                y: j(A(o13)),
                zoom: 1 / 0,
                index: t5,
                parentId: -1
            };
        }
        function Y(e6) {
            var t5;
            return {
                type: "Feature",
                id: e6.id,
                properties: X(e6),
                geometry: {
                    type: "Point",
                    coordinates: [
                        (t5 = e6.x, 360 * (t5 - 0.5)),
                        D(e6.y)
                    ]
                }
            };
        }
        function X(e6) {
            const t5 = e6.numPoints, r5 = t5 >= 10000 ? `${Math.round(t5 / 1000)}k` : t5 >= 1000 ? Math.round(t5 / 100) / 10 + "k" : t5;
            return $($({
            }, e6.properties), {
                cluster: !0,
                cluster_id: e6.id,
                point_count: t5,
                point_count_abbreviated: r5
            });
        }
        function V(e6) {
            return e6 / 360 + 0.5;
        }
        function A(e6) {
            const t5 = Math.sin(e6 * Math.PI / 180), r5 = 0.5 - 0.25 * Math.log((1 + t5) / (1 - t5)) / Math.PI;
            return r5 < 0 ? 0 : r5 > 1 ? 1 : r5;
        }
        function D(e6) {
            const t5 = (180 - 360 * e6) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t5)) / Math.PI - 90;
        }
        function $(e6, t5) {
            for(const r5 in t5)e6[r5] = t5[r5];
            return e6;
        }
        function B(e6) {
            return e6.x;
        }
        function R(e6) {
            return e6.y;
        }
        function q(e6, t5, r5, o13) {
            for(var n4, i4 = o13, s5 = r5 - t5 >> 1, a10 = r5 - t5, l13 = e6[t5], u10 = e6[t5 + 1], h7 = e6[r5], c9 = e6[r5 + 1], f6 = t5 + 3; f6 < r5; f6 += 3){
                var p6 = U(e6[f6], e6[f6 + 1], l13, u10, h7, c9);
                if (p6 > i4) n4 = f6, i4 = p6;
                else if (p6 === i4) {
                    var g1 = Math.abs(f6 - s5);
                    g1 < a10 && (n4 = f6, a10 = g1);
                }
            }
            i4 > o13 && (n4 - t5 > 3 && q(e6, t5, n4, o13), e6[n4 + 2] = i4, r5 - n4 > 3 && q(e6, n4, r5, o13));
        }
        function U(e6, t5, r5, o13, n4, i4) {
            var s5 = n4 - r5, a10 = i4 - o13;
            if (0 !== s5 || 0 !== a10) {
                var l13 = ((e6 - r5) * s5 + (t5 - o13) * a10) / (s5 * s5 + a10 * a10);
                l13 > 1 ? (r5 = n4, o13 = i4) : l13 > 0 && (r5 += s5 * l13, o13 += a10 * l13);
            }
            return (s5 = e6 - r5) * s5 + (a10 = t5 - o13) * a10;
        }
        function Q(e6, t5, r5, o13) {
            var n4 = {
                id: (void 0) === e6 ? null : e6,
                type: t5,
                geometry: r5,
                tags: o13,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            return (function(e7) {
                var t6 = e7.geometry, r6 = e7.type;
                if ("Point" === r6 || "MultiPoint" === r6 || "LineString" === r6) H(e7, t6);
                else if ("Polygon" === r6 || "MultiLineString" === r6) for(var o14 = 0; o14 < t6.length; o14++)H(e7, t6[o14]);
                else if ("MultiPolygon" === r6) for(o14 = 0; o14 < t6.length; o14++)for(var n5 = 0; n5 < t6[o14].length; n5++)H(e7, t6[o14][n5]);
            })(n4), n4;
        }
        function H(e6, t5) {
            for(var r5 = 0; r5 < t5.length; r5 += 3)e6.minX = Math.min(e6.minX, t5[r5]), e6.minY = Math.min(e6.minY, t5[r5 + 1]), e6.maxX = Math.max(e6.maxX, t5[r5]), e6.maxY = Math.max(e6.maxY, t5[r5 + 1]);
        }
        function K(e6, t5, r5, o13) {
            if (t5.geometry) {
                var n4 = t5.geometry.coordinates, i4 = t5.geometry.type, s5 = Math.pow(r5.tolerance / ((1 << r5.maxZoom) * r5.extent), 2), a10 = [], l14 = t5.id;
                if (r5.promoteId ? l14 = t5.properties[r5.promoteId] : r5.generateId && (l14 = o13 || 0), "Point" === i4) ee(n4, a10);
                else if ("MultiPoint" === i4) for(var u10 = 0; u10 < n4.length; u10++)ee(n4[u10], a10);
                else if ("LineString" === i4) te(n4, a10, s5, !1);
                else if ("MultiLineString" === i4) {
                    if (r5.lineMetrics) {
                        for(u10 = 0; u10 < n4.length; u10++)te(n4[u10], a10 = [], s5, !1), e6.push(Q(l14, "LineString", a10, t5.properties));
                        return;
                    }
                    re(n4, a10, s5, !1);
                } else if ("Polygon" === i4) re(n4, a10, s5, !0);
                else {
                    if ("MultiPolygon" !== i4) {
                        if ("GeometryCollection" === i4) {
                            for(u10 = 0; u10 < t5.geometry.geometries.length; u10++)K(e6, {
                                id: l14,
                                geometry: t5.geometry.geometries[u10],
                                properties: t5.properties
                            }, r5, o13);
                            return;
                        }
                        throw new Error("Input data is not a valid GeoJSON object.");
                    }
                    for(u10 = 0; u10 < n4.length; u10++){
                        var h7 = [];
                        re(n4[u10], h7, s5, !0), a10.push(h7);
                    }
                }
                e6.push(Q(l14, i4, a10, t5.properties));
            }
        }
        function ee(e6, t5) {
            t5.push(oe(e6[0])), t5.push(ne(e6[1])), t5.push(0);
        }
        function te(e6, t5, r5, o13) {
            for(var n5, i5, s7 = 0, a11 = 0; a11 < e6.length; a11++){
                var l15 = oe(e6[a11][0]), u11 = ne(e6[a11][1]);
                t5.push(l15), t5.push(u11), t5.push(0), a11 > 0 && (s7 += o13 ? (n5 * u11 - l15 * i5) / 2 : Math.sqrt(Math.pow(l15 - n5, 2) + Math.pow(u11 - i5, 2))), n5 = l15, i5 = u11;
            }
            var h8 = t5.length - 3;
            t5[2] = 1, q(t5, 0, h8, r5), t5[h8 + 2] = 1, t5.size = Math.abs(s7), t5.start = 0, t5.end = t5.size;
        }
        function re(e6, t5, r5, o13) {
            for(var n5 = 0; n5 < e6.length; n5++){
                var i5 = [];
                te(e6[n5], i5, r5, o13), t5.push(i5);
            }
        }
        function oe(e6) {
            return e6 / 360 + 0.5;
        }
        function ne(e6) {
            var t5 = Math.sin(e6 * Math.PI / 180), r5 = 0.5 - 0.25 * Math.log((1 + t5) / (1 - t5)) / Math.PI;
            return r5 < 0 ? 0 : r5 > 1 ? 1 : r5;
        }
        function ie(e6, t5, r5, o13, n5, i6, s7, a11) {
            if (o13 /= t5, i6 >= (r5 /= t5) && s7 < o13) return e6;
            if (s7 < r5 || i6 >= o13) return null;
            for(var l16 = [], u12 = 0; u12 < e6.length; u12++){
                var h8 = e6[u12], c9 = h8.geometry, f6 = h8.type, p7 = 0 === n5 ? h8.minX : h8.minY, g2 = 0 === n5 ? h8.maxX : h8.maxY;
                if (p7 >= r5 && g2 < o13) l16.push(h8);
                else if (!(g2 < r5 || p7 >= o13)) {
                    var d4 = [];
                    if ("Point" === f6 || "MultiPoint" === f6) se(c9, d4, r5, o13, n5);
                    else if ("LineString" === f6) ae(c9, d4, r5, o13, n5, !1, a11.lineMetrics);
                    else if ("MultiLineString" === f6) ue(c9, d4, r5, o13, n5, !1);
                    else if ("Polygon" === f6) ue(c9, d4, r5, o13, n5, !0);
                    else if ("MultiPolygon" === f6) for(var m1 = 0; m1 < c9.length; m1++){
                        var y1 = [];
                        ue(c9[m1], y1, r5, o13, n5, !0), y1.length && d4.push(y1);
                    }
                    if (d4.length) {
                        if (a11.lineMetrics && "LineString" === f6) {
                            for(m1 = 0; m1 < d4.length; m1++)l16.push(Q(h8.id, f6, d4[m1], h8.tags));
                            continue;
                        }
                        "LineString" !== f6 && "MultiLineString" !== f6 || (1 === d4.length ? (f6 = "LineString", d4 = d4[0]) : f6 = "MultiLineString"), "Point" !== f6 && "MultiPoint" !== f6 || (f6 = 3 === d4.length ? "Point" : "MultiPoint"), l16.push(Q(h8.id, f6, d4, h8.tags));
                    }
                }
            }
            return l16.length ? l16 : null;
        }
        function se(e6, t5, r5, o13, n5) {
            for(var i6 = 0; i6 < e6.length; i6 += 3){
                var s7 = e6[i6 + n5];
                s7 >= r5 && s7 <= o13 && (t5.push(e6[i6]), t5.push(e6[i6 + 1]), t5.push(e6[i6 + 2]));
            }
        }
        function ae(e6, t5, r5, o13, n5, i6, s8) {
            for(var a11, l16, u12 = le(e6), h9 = 0 === n5 ? ce : fe, c10 = e6.start, f7 = 0; f7 < e6.length - 3; f7 += 3){
                var p8 = e6[f7], g3 = e6[f7 + 1], d5 = e6[f7 + 2], m2 = e6[f7 + 3], y2 = e6[f7 + 4], v1 = 0 === n5 ? p8 : g3, x1 = 0 === n5 ? m2 : y2, w1 = !1;
                s8 && (a11 = Math.sqrt(Math.pow(p8 - m2, 2) + Math.pow(g3 - y2, 2))), v1 < r5 ? x1 > r5 && (l16 = h9(u12, p8, g3, m2, y2, r5), s8 && (u12.start = c10 + a11 * l16)) : v1 > o13 ? x1 < o13 && (l16 = h9(u12, p8, g3, m2, y2, o13), s8 && (u12.start = c10 + a11 * l16)) : he(u12, p8, g3, d5), x1 < r5 && v1 >= r5 && (l16 = h9(u12, p8, g3, m2, y2, r5), w1 = !0), x1 > o13 && v1 <= o13 && (l16 = h9(u12, p8, g3, m2, y2, o13), w1 = !0), !i6 && w1 && (s8 && (u12.end = c10 + a11 * l16), t5.push(u12), u12 = le(e6)), s8 && (c10 += a11);
            }
            var S1 = e6.length - 3;
            p8 = e6[S1], g3 = e6[S1 + 1], d5 = e6[S1 + 2], (v1 = 0 === n5 ? p8 : g3) >= r5 && v1 <= o13 && he(u12, p8, g3, d5), S1 = u12.length - 3, i6 && S1 >= 3 && (u12[S1] !== u12[0] || u12[S1 + 1] !== u12[1]) && he(u12, u12[0], u12[1], u12[2]), u12.length && t5.push(u12);
        }
        function le(e6) {
            var t5 = [];
            return t5.size = e6.size, t5.start = e6.start, t5.end = e6.end, t5;
        }
        function ue(e6, t5, r5, o13, n5, i6) {
            for(var s8 = 0; s8 < e6.length; s8++)ae(e6[s8], t5, r5, o13, n5, i6, !1);
        }
        function he(e6, t5, r5, o13) {
            e6.push(t5), e6.push(r5), e6.push(o13);
        }
        function ce(e6, t5, r5, o13, n5, i6) {
            var s8 = (i6 - t5) / (o13 - t5);
            return e6.push(i6), e6.push(r5 + (n5 - r5) * s8), e6.push(1), s8;
        }
        function fe(e6, t5, r5, o13, n5, i6) {
            var s8 = (i6 - r5) / (n5 - r5);
            return e6.push(t5 + (o13 - t5) * s8), e6.push(i6), e6.push(1), s8;
        }
        function pe(e6, t5) {
            for(var r5 = [], o13 = 0; o13 < e6.length; o13++){
                var n5, i6 = e6[o13], s8 = i6.type;
                if ("Point" === s8 || "MultiPoint" === s8 || "LineString" === s8) n5 = ge(i6.geometry, t5);
                else if ("MultiLineString" === s8 || "Polygon" === s8) {
                    n5 = [];
                    for(var a11 = 0; a11 < i6.geometry.length; a11++)n5.push(ge(i6.geometry[a11], t5));
                } else if ("MultiPolygon" === s8) for(n5 = [], a11 = 0; a11 < i6.geometry.length; a11++){
                    for(var l16 = [], u12 = 0; u12 < i6.geometry[a11].length; u12++)l16.push(ge(i6.geometry[a11][u12], t5));
                    n5.push(l16);
                }
                r5.push(Q(i6.id, s8, n5, i6.tags));
            }
            return r5;
        }
        function ge(e6, t5) {
            var r5 = [];
            r5.size = e6.size, (void 0) !== e6.start && (r5.start = e6.start, r5.end = e6.end);
            for(var o13 = 0; o13 < e6.length; o13 += 3)r5.push(e6[o13] + t5, e6[o13 + 1], e6[o13 + 2]);
            return r5;
        }
        function de(e6, t5) {
            if (e6.transformed) return e6;
            var r5, o13, n6, i7 = 1 << e6.z, s14 = e6.x, a12 = e6.y;
            for(r5 = 0; r5 < e6.features.length; r5++){
                var l17 = e6.features[r5], u13 = l17.geometry, h9 = l17.type;
                if (l17.geometry = [], 1 === h9) for(o13 = 0; o13 < u13.length; o13 += 2)l17.geometry.push(me(u13[o13], u13[o13 + 1], t5, i7, s14, a12));
                else for(o13 = 0; o13 < u13.length; o13++){
                    var c10 = [];
                    for(n6 = 0; n6 < u13[o13].length; n6 += 2)c10.push(me(u13[o13][n6], u13[o13][n6 + 1], t5, i7, s14, a12));
                    l17.geometry.push(c10);
                }
            }
            return e6.transformed = !0, e6;
        }
        function me(e6, t5, r5, o13, n6, i7) {
            return [
                Math.round(r5 * (e6 * o13 - n6)),
                Math.round(r5 * (t5 * o13 - i7))
            ];
        }
        function ye(e6, t5, r5, o13, n6) {
            for(var i7 = t5 === n6.maxZoom ? 0 : n6.tolerance / ((1 << t5) * n6.extent), s14 = {
                features: [],
                numPoints: 0,
                numSimplified: 0,
                numFeatures: 0,
                source: null,
                x: r5,
                y: o13,
                z: t5,
                transformed: !1,
                minX: 2,
                minY: 1,
                maxX: -1,
                maxY: 0
            }, a12 = 0; a12 < e6.length; a12++){
                s14.numFeatures++, ve(s14, e6[a12], i7, n6);
                var l18 = e6[a12].minX, u14 = e6[a12].minY, h10 = e6[a12].maxX, c11 = e6[a12].maxY;
                l18 < s14.minX && (s14.minX = l18), u14 < s14.minY && (s14.minY = u14), h10 > s14.maxX && (s14.maxX = h10), c11 > s14.maxY && (s14.maxY = c11);
            }
            return s14;
        }
        function ve(e6, t5, r5, o13) {
            var n6 = t5.geometry, i7 = t5.type, s14 = [];
            if ("Point" === i7 || "MultiPoint" === i7) for(var a12 = 0; a12 < n6.length; a12 += 3)s14.push(n6[a12]), s14.push(n6[a12 + 1]), e6.numPoints++, e6.numSimplified++;
            else if ("LineString" === i7) xe(s14, n6, e6, r5, !1, !1);
            else if ("MultiLineString" === i7 || "Polygon" === i7) for(a12 = 0; a12 < n6.length; a12++)xe(s14, n6[a12], e6, r5, "Polygon" === i7, 0 === a12);
            else if ("MultiPolygon" === i7) for(var l19 = 0; l19 < n6.length; l19++){
                var u15 = n6[l19];
                for(a12 = 0; a12 < u15.length; a12++)xe(s14, u15[a12], e6, r5, !0, 0 === a12);
            }
            if (s14.length) {
                var h11 = t5.tags || null;
                if ("LineString" === i7 && o13.lineMetrics) {
                    for(var c12 in h11 = {
                    }, t5.tags)h11[c12] = t5.tags[c12];
                    h11.mapbox_clip_start = n6.start / n6.size, h11.mapbox_clip_end = n6.end / n6.size;
                }
                var f7 = {
                    geometry: s14,
                    type: "Polygon" === i7 || "MultiPolygon" === i7 ? 3 : "LineString" === i7 || "MultiLineString" === i7 ? 2 : 1,
                    tags: h11
                };
                null !== t5.id && (f7.id = t5.id), e6.features.push(f7);
            }
        }
        function xe(e6, t5, r5, o13, n6, i7) {
            var s14 = o13 * o13;
            if (o13 > 0 && t5.size < (n6 ? s14 : o13)) r5.numPoints += t5.length / 3;
            else {
                for(var a12 = [], l19 = 0; l19 < t5.length; l19 += 3)(0 === o13 || t5[l19 + 2] > s14) && (r5.numSimplified++, a12.push(t5[l19]), a12.push(t5[l19 + 1])), r5.numPoints++;
                n6 && (function(e7, t6) {
                    for(var r6 = 0, o14 = 0, n7 = e7.length, i9 = n7 - 2; o14 < n7; i9 = o14, o14 += 2)r6 += (e7[o14] - e7[i9]) * (e7[o14 + 1] + e7[i9 + 1]);
                    if (r6 > 0 === t6) for(o14 = 0, n7 = e7.length; o14 < n7 / 2; o14 += 2){
                        var s15 = e7[o14], a13 = e7[o14 + 1];
                        e7[o14] = e7[n7 - 2 - o14], e7[o14 + 1] = e7[n7 - 1 - o14], e7[n7 - 2 - o14] = s15, e7[n7 - 1 - o14] = a13;
                    }
                })(a12, i7), e6.push(a12);
            }
        }
        function we(e6, t5) {
            var r5 = (t5 = this.options = function(e7, t6) {
                for(var r6 in t6)e7[r6] = t6[r6];
                return e7;
            }(Object.create(this.options), t5)).debug;
            if (r5 && console.time("preprocess data"), t5.maxZoom < 0 || t5.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (t5.promoteId && t5.generateId) throw new Error("promoteId and generateId cannot be used together.");
            var o13 = function(e7, t6) {
                var r6 = [];
                if ("FeatureCollection" === e7.type) for(var o14 = 0; o14 < e7.features.length; o14++)K(r6, e7.features[o14], t6, o14);
                else K(r6, "Feature" === e7.type ? e7 : {
                    geometry: e7
                }, t6);
                return r6;
            }(e6, t5);
            this.tiles = {
            }, this.tileCoords = [], r5 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t5.indexMaxZoom, t5.indexMaxPoints), console.time("generate tiles"), this.stats = {
            }, this.total = 0), o13 = (function(e7, t6) {
                var r6 = t6.buffer / t6.extent, o14 = e7, n6 = ie(e7, 1, -1 - r6, r6, 0, -1, 2, t6), i7 = ie(e7, 1, 1 - r6, 2 + r6, 0, -1, 2, t6);
                return (n6 || i7) && (o14 = ie(e7, 1, -r6, 1 + r6, 0, -1, 2, t6) || [], n6 && (o14 = pe(n6, 1).concat(o14)), i7 && (o14 = o14.concat(pe(i7, -1)))), o14;
            })(o13, t5), o13.length && this.splitTile(o13, 0, 0, 0), r5 && (o13.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function Se(e6, t5, r5) {
            return 32 * ((1 << e6) * r5 + t5) + e6;
        }
        function Me(e6, t5) {
            const r5 = e6.tileID.canonical;
            if (!this._geoJSONIndex) return t5(null, null);
            const o13 = this._geoJSONIndex.getTile(r5.z, r5.x, r5.y);
            if (!o13) return t5(null, null);
            const n6 = new h2(o13.features);
            let i7 = c1.exports(n6);
            0 === i7.byteOffset && i7.byteLength === i7.buffer.byteLength || (i7 = new Uint8Array(i7)), t5(null, {
                vectorTile: n6,
                rawData: i7.buffer
            });
        }
        we.prototype.options = {
            maxZoom: 14,
            indexMaxZoom: 5,
            indexMaxPoints: 100000,
            tolerance: 3,
            extent: 4096,
            buffer: 64,
            lineMetrics: !1,
            promoteId: null,
            generateId: !1,
            debug: 0
        }, we.prototype.splitTile = function(e6, t5, r5, o13, n6, i7, s14) {
            for(var a14 = [
                e6,
                t5,
                r5,
                o13
            ], l20 = this.options, u16 = l20.debug; a14.length;){
                o13 = a14.pop(), r5 = a14.pop(), t5 = a14.pop(), e6 = a14.pop();
                var h12 = 1 << t5, c13 = Se(t5, r5, o13), f8 = this.tiles[c13];
                if (!f8 && (u16 > 1 && console.time("creation"), f8 = this.tiles[c13] = ye(e6, t5, r5, o13, l20), this.tileCoords.push({
                    z: t5,
                    x: r5,
                    y: o13
                }), u16)) {
                    u16 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t5, r5, o13, f8.numFeatures, f8.numPoints, f8.numSimplified), console.timeEnd("creation"));
                    var p9 = "z" + t5;
                    this.stats[p9] = (this.stats[p9] || 0) + 1, this.total++;
                }
                if (f8.source = e6, n6) {
                    if (t5 === l20.maxZoom || t5 === n6) continue;
                    var g4 = 1 << n6 - t5;
                    if (r5 !== Math.floor(i7 / g4) || o13 !== Math.floor(s14 / g4)) continue;
                } else if (t5 === l20.indexMaxZoom || f8.numPoints <= l20.indexMaxPoints) continue;
                if (f8.source = null, 0 !== e6.length) {
                    u16 > 1 && console.time("clipping");
                    var d6, m3, y3, v2, x2, w2, S1 = 0.5 * l20.buffer / l20.extent, M1 = 0.5 - S1, P1 = 0.5 + S1, b1 = 1 + S1;
                    d6 = m3 = y3 = v2 = null, x2 = ie(e6, h12, r5 - S1, r5 + P1, 0, f8.minX, f8.maxX, l20), w2 = ie(e6, h12, r5 + M1, r5 + b1, 0, f8.minX, f8.maxX, l20), e6 = null, x2 && (d6 = ie(x2, h12, o13 - S1, o13 + P1, 1, f8.minY, f8.maxY, l20), m3 = ie(x2, h12, o13 + M1, o13 + b1, 1, f8.minY, f8.maxY, l20), x2 = null), w2 && (y3 = ie(w2, h12, o13 - S1, o13 + P1, 1, f8.minY, f8.maxY, l20), v2 = ie(w2, h12, o13 + M1, o13 + b1, 1, f8.minY, f8.maxY, l20), w2 = null), u16 > 1 && console.timeEnd("clipping"), a14.push(d6 || [], t5 + 1, 2 * r5, 2 * o13), a14.push(m3 || [], t5 + 1, 2 * r5, 2 * o13 + 1), a14.push(y3 || [], t5 + 1, 2 * r5 + 1, 2 * o13), a14.push(v2 || [], t5 + 1, 2 * r5 + 1, 2 * o13 + 1);
                }
            }
        }, we.prototype.getTile = function(e6, t5, r5) {
            var o13 = this.options, n6 = o13.extent, i7 = o13.debug;
            if (e6 < 0 || e6 > 24) return null;
            var s14 = 1 << e6, a14 = Se(e6, t5 = (t5 % s14 + s14) % s14, r5);
            if (this.tiles[a14]) return de(this.tiles[a14], n6);
            i7 > 1 && console.log("drilling down to z%d-%d-%d", e6, t5, r5);
            for(var l20, u16 = e6, h13 = t5, c14 = r5; !l20 && u16 > 0;)u16--, h13 = Math.floor(h13 / 2), c14 = Math.floor(c14 / 2), l20 = this.tiles[Se(u16, h13, c14)];
            return l20 && l20.source ? (i7 > 1 && console.log("found parent tile z%d-%d-%d", u16, h13, c14), i7 > 1 && console.time("drilling down"), this.splitTile(l20.source, u16, h13, c14, e6, t5, r5), i7 > 1 && console.timeEnd("drilling down"), this.tiles[a14] ? de(this.tiles[a14], n6) : null) : null;
        };
        class Pe extends e1.VectorTileWorkerSource {
            constructor(e6, t5, r5, o13, n6){
                super(e6, t5, r5, o13, Me), n6 && (this.loadGeoJSON = n6);
            }
            loadData(t, r) {
                const o14 = t && t.request, n7 = o14 && o14.collectResourceTiming;
                this.loadGeoJSON(t, (s14, a14)=>{
                    if (s14 || !a14) return r(s14);
                    if ("object" != typeof a14) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
                    {
                        i2(a14, !0);
                        try {
                            if (t.filter) {
                                const r6 = e1.createExpression(t.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if ("error" === r6.result) throw new Error(r6.value.map((e7)=>`${e7.key}: ${e7.message}`
                                ).join(", "));
                                const o15 = a14.features.filter((e7)=>r6.value.evaluate({
                                        zoom: 0
                                    }, e7)
                                );
                                a14 = {
                                    type: "FeatureCollection",
                                    features: o15
                                };
                            }
                            this._geoJSONIndex = t.cluster ? new G(function({ superclusterOptions: t6 , clusterProperties: r6  }) {
                                if (!r6 || !t6) return t6;
                                const o15 = {
                                }, n8 = {
                                }, i7 = {
                                    accumulated: null,
                                    zoom: 0
                                }, s16 = {
                                    properties: null
                                }, a15 = Object.keys(r6);
                                for (const t7 of a15){
                                    const [i9, s17] = r6[t7], a16 = e1.createExpression(s17), l20 = e1.createExpression("string" == typeof i9 ? [
                                        i9,
                                        [
                                            "accumulated"
                                        ],
                                        [
                                            "get",
                                            t7
                                        ]
                                    ] : i9);
                                    o15[t7] = a16.value, n8[t7] = l20.value;
                                }
                                return t6.map = (e7)=>{
                                    s16.properties = e7;
                                    const t8 = {
                                    };
                                    for (const e8 of a15)t8[e8] = o15[e8].evaluate(i7, s16);
                                    return t8;
                                }, t6.reduce = (e7, t8)=>{
                                    s16.properties = t8;
                                    for (const t9 of a15)i7.accumulated = e7[t9], e7[t9] = n8[t9].evaluate(i7, s16);
                                }, t6;
                            }(t)).load(a14.features) : (function(e7, t6) {
                                return new we(e7, t6);
                            })(a14, t.geojsonVtOptions);
                        } catch (s16) {
                            return r(s16);
                        }
                        this.loaded = {
                        };
                        const l20 = {
                        };
                        if (n7) {
                            const r6 = e1.getPerformanceMeasurement(o14);
                            r6 && (l20.resourceTiming = {
                            }, l20.resourceTiming[t.source] = JSON.parse(JSON.stringify(r6)));
                        }
                        r(null, l20);
                    }
                });
            }
            reloadTile(e, t) {
                const r6 = this.loaded;
                return r6 && r6[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t);
            }
            loadGeoJSON(t, r) {
                if (t.request) e1.getJSON(t.request, r);
                else {
                    if ("string" != typeof t.data) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
                    try {
                        return r(null, JSON.parse(t.data));
                    } catch (e7) {
                        return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
                    }
                }
            }
            getClusterExpansionZoom(e, t) {
                try {
                    t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));
                } catch (e7) {
                    t(e7);
                }
            }
            getClusterChildren(e, t) {
                try {
                    t(null, this._geoJSONIndex.getChildren(e.clusterId));
                } catch (e7) {
                    t(e7);
                }
            }
            getClusterLeaves(e, t) {
                try {
                    t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));
                } catch (e7) {
                    t(e7);
                }
            }
        }
        class be {
            constructor(t6){
                this.self = t6, this.actor = new e1.Actor(t6, this), this.layerIndexes = {
                }, this.availableImages = {
                }, this.isSpriteLoaded = {
                }, this.projections = {
                }, this.defaultProjection = e1.getProjection({
                    name: "mercator"
                }), this.workerSourceTypes = {
                    vector: e1.VectorTileWorkerSource,
                    geojson: Pe
                }, this.workerSources = {
                }, this.demWorkerSources = {
                }, this.self.registerWorkerSource = (e7, t7)=>{
                    if (this.workerSourceTypes[e7]) throw new Error(`Worker source with name "${e7}" already registered.`);
                    this.workerSourceTypes[e7] = t7;
                }, this.self.registerRTLTextPlugin = (t7)=>{
                    if (e1.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
                    e1.plugin.applyArabicShaping = t7.applyArabicShaping, e1.plugin.processBidirectionalText = t7.processBidirectionalText, e1.plugin.processStyledBidirectionalText = t7.processStyledBidirectionalText;
                };
            }
            clearCaches(e, t, r) {
                delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], r();
            }
            checkIfReady(e, t, r) {
                r();
            }
            setReferrer(e, t) {
                this.referrer = t;
            }
            spriteLoaded(t, r) {
                this.isSpriteLoaded[t] = r;
                for(const o14 in this.workerSources[t]){
                    const n7 = this.workerSources[t][o14];
                    for(const t7 in n7)n7[t7] instanceof e1.VectorTileWorkerSource && (n7[t7].isSpriteLoaded = r, n7[t7].fire(new e1.Event("isSpriteLoaded")));
                }
            }
            setImages(e, t, r) {
                this.availableImages[e] = t;
                for(const r6 in this.workerSources[e]){
                    const o14 = this.workerSources[e][r6];
                    for(const e7 in o14)o14[e7].availableImages = t;
                }
                r();
            }
            enableTerrain(e, t, r) {
                this.terrain = t, r();
            }
            setProjection(t, r) {
                this.projections[t] = e1.getProjection(r);
            }
            setLayers(e, t, r) {
                this.getLayerIndex(e).replace(t), r();
            }
            updateLayers(e, t, r) {
                this.getLayerIndex(e).update(t.layers, t.removedIds), r();
            }
            loadTile(t, r, o) {
                const n7 = this.enableTerrain ? e1.extend({
                    enableTerrain: this.terrain
                }, r) : r;
                n7.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).loadTile(n7, o);
            }
            loadDEMTile(t, r, o) {
                const n7 = this.enableTerrain ? e1.extend({
                    buildQuadTree: this.terrain
                }, r) : r;
                this.getDEMWorkerSource(t, r.source).loadTile(n7, o);
            }
            reloadTile(t, r, o) {
                const n7 = this.enableTerrain ? e1.extend({
                    enableTerrain: this.terrain
                }, r) : r;
                n7.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).reloadTile(n7, o);
            }
            abortTile(e, t, r) {
                this.getWorkerSource(e, t.type, t.source).abortTile(t, r);
            }
            removeTile(e, t, r) {
                this.getWorkerSource(e, t.type, t.source).removeTile(t, r);
            }
            removeSource(e, t, r) {
                if (!this.workerSources[e] || !this.workerSources[e][t.type] || !this.workerSources[e][t.type][t.source]) return;
                const o14 = this.workerSources[e][t.type][t.source];
                delete this.workerSources[e][t.type][t.source], (void 0) !== o14.removeSource ? o14.removeSource(t, r) : r();
            }
            loadWorkerSource(e, t, r) {
                try {
                    this.self.importScripts(t.url), r();
                } catch (e7) {
                    r(e7.toString());
                }
            }
            syncRTLPluginState(t, r, o) {
                try {
                    e1.plugin.setState(r);
                    const t7 = e1.plugin.getPluginURL();
                    if (e1.plugin.isLoaded() && !e1.plugin.isParsed() && null != t7) {
                        this.self.importScripts(t7);
                        const r6 = e1.plugin.isParsed();
                        o(r6 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t7}`), r6);
                    }
                } catch (e7) {
                    o(e7.toString());
                }
            }
            getAvailableImages(e) {
                let t7 = this.availableImages[e];
                return t7 || (t7 = []), t7;
            }
            getLayerIndex(e) {
                let t7 = this.layerIndexes[e];
                return t7 || (t7 = this.layerIndexes[e] = new o2), t7;
            }
            getWorkerSource(e, t, r) {
                if (this.workerSources[e] || (this.workerSources[e] = {
                }), this.workerSources[e][t] || (this.workerSources[e][t] = {
                }), !this.workerSources[e][t][r]) {
                    const o14 = {
                        send: (t7, r6, o15, n7, i7, s14)=>{
                            this.actor.send(t7, r6, o15, e, i7, s14);
                        },
                        scheduler: this.actor.scheduler
                    };
                    this.workerSources[e][t][r] = new this.workerSourceTypes[t](o14, this.getLayerIndex(e), this.getAvailableImages(e), this.isSpriteLoaded[e]);
                }
                return this.workerSources[e][t][r];
            }
            getDEMWorkerSource(e, t) {
                return this.demWorkerSources[e] || (this.demWorkerSources[e] = {
                }), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new n1), this.demWorkerSources[e][t];
            }
            enforceCacheSizeLimit(t, r) {
                e1.enforceCacheSizeLimit(r);
            }
            getWorkerPerformanceMetrics(e, t, r) {
                r(void 0, void 0);
            }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new be(self)), be;
    });
    define([
        "./shared"
    ], function(e1) {
        function t1(e2, i2) {
            if (Array.isArray(e2)) {
                if (!Array.isArray(i2) || e2.length !== i2.length) return !1;
                for(let o2 = 0; o2 < e2.length; o2++)if (!t1(e2[o2], i2[o2])) return !1;
                return !0;
            }
            if ("object" == typeof e2 && null !== e2 && null !== i2) {
                if ("object" != typeof i2) return !1;
                if (Object.keys(e2).length !== Object.keys(i2).length) return !1;
                for(const o2 in e2)if (!t1(e2[o2], i2[o2])) return !1;
                return !0;
            }
            return e2 === i2;
        }
        var i2 = o2;
        function o2(e2) {
            return !function(e3) {
                var t1;
                return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? (function() {
                    if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
                    var e4, t2, i3 = new Blob([
                        ""
                    ], {
                        type: "text/javascript"
                    }), o11 = URL.createObjectURL(i3);
                    try {
                        t2 = new Worker(o11), e4 = !0;
                    } catch (t3) {
                        e4 = !1;
                    }
                    return t2 && t2.terminate(), URL.revokeObjectURL(o11), e4;
                })() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? (function() {
                    var e4 = document.createElement("canvas");
                    e4.width = e4.height = 1;
                    var t2 = e4.getContext("2d");
                    if (!t2) return !1;
                    var i3 = t2.getImageData(0, 0, 1, 1);
                    return i3 && i3.width === e4.width;
                })() ? ((void 0) === r1[t1 = e3 && e3.failIfMajorPerformanceCaveat] && (r1[t1] = (function(e4) {
                    var t2, i3 = function(e5) {
                        var t3 = document.createElement("canvas"), i7 = Object.create(o2.webGLContextAttributes);
                        return i7.failIfMajorPerformanceCaveat = e5, t3.getContext("webgl", i7) || t3.getContext("experimental-webgl", i7);
                    }(e4);
                    if (!i3) return !1;
                    try {
                        t2 = i3.createShader(i3.VERTEX_SHADER);
                    } catch (e5) {
                        return !1;
                    }
                    return !(!t2 || i3.isContextLost()) && (i3.shaderSource(t2, "void main() {}"), i3.compileShader(t2), !0 === i3.getShaderParameter(t2, i3.COMPILE_STATUS));
                })(t1)), r1[t1] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            }(e2);
        }
        var r1 = {
        };
        function n1(t1, i3, o11) {
            const r4 = e1.window.document.createElement(t1);
            return (void 0) !== i3 && (r4.className = i3), o11 && o11.appendChild(r4), r4;
        }
        function s3(t1, i3, o11) {
            const r4 = e1.window.document.createElementNS("http://www.w3.org/2000/svg", t1);
            for (const e2 of Object.keys(i3))r4.setAttributeNS(null, e2, i3[e2]);
            return o11 && o11.appendChild(r4), r4;
        }
        o2.webGLContextAttributes = {
            antialias: !1,
            alpha: !0,
            stencil: !0,
            depth: !0
        };
        const a2 = e1.window.document && e1.window.document.documentElement.style, l9 = a2 && (void 0) !== a2.userSelect ? "userSelect" : "WebkitUserSelect";
        let c1;
        function h2() {
            a2 && l9 && (c1 = a2[l9], a2[l9] = "none");
        }
        function u3() {
            a2 && l9 && (a2[l9] = c1);
        }
        function _1(t1) {
            t1.preventDefault(), t1.stopPropagation(), e1.window.removeEventListener("click", _1, !0);
        }
        function d2() {
            e1.window.addEventListener("click", _1, !0), e1.window.setTimeout(()=>{
                e1.window.removeEventListener("click", _1, !0);
            }, 0);
        }
        function p2(e2, t1) {
            const i3 = e2.getBoundingClientRect();
            return g5(e2, i3, t1);
        }
        function m4(e2, t1) {
            const i3 = e2.getBoundingClientRect(), o11 = [];
            for(let r4 = 0; r4 < t1.length; r4++)o11.push(g5(e2, i3, t1[r4]));
            return o11;
        }
        function f2(t1) {
            return (void 0) !== e1.window.InstallTrigger && 2 === t1.button && t1.ctrlKey && e1.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t1.button;
        }
        function g5(t1, i3, o11) {
            const r4 = t1.offsetWidth === i3.width ? 1 : t1.offsetWidth / i3.width;
            return new e1.pointGeometry((o11.clientX - i3.left) * r4, (o11.clientY - i3.top) * r4);
        }
        function v3(e2, t1) {
            var i3 = t1[0], o11 = t1[1], r4 = t1[2], n3 = t1[3], s4 = i3 * n3 - r4 * o11;
            return s4 ? (e2[0] = n3 * (s4 = 1 / s4), e2[1] = -o11 * s4, e2[2] = -r4 * s4, e2[3] = i3 * s4, e2) : null;
        }
        function x3(e2) {
            const { userImage: t1  } = e2;
            return !!(t1 && t1.render && t1.render()) && (e2.data.replace(new Uint8Array(t1.data.buffer)), !0);
        }
        class y4 extends e1.Evented {
            constructor(){
                super(), this.images = {
                }, this.updatedImages = {
                }, this.callbackDispatchedThisFrame = {
                }, this.loaded = !1, this.requestors = [], this.patterns = {
                }, this.atlasImage = new e1.RGBAImage({
                    width: 1,
                    height: 1
                }), this.dirty = !0;
            }
            isLoaded() {
                return this.loaded;
            }
            setLoaded(e) {
                if (this.loaded !== e && (this.loaded = e, e)) {
                    for (const { ids: e2 , callback: t1  } of this.requestors)this._notify(e2, t1);
                    this.requestors = [];
                }
            }
            hasImage(e) {
                return !!this.getImage(e);
            }
            getImage(e) {
                return this.images[e];
            }
            addImage(e, t) {
                this._validate(e, t) && (this.images[e] = t);
            }
            _validate(t, i) {
                let o11 = !0;
                return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e1.ErrorEvent(new Error(`Image "${t}" has invalid "stretchX" value`))), o11 = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e1.ErrorEvent(new Error(`Image "${t}" has invalid "stretchY" value`))), o11 = !1), this._validateContent(i.content, i) || (this.fire(new e1.ErrorEvent(new Error(`Image "${t}" has invalid "content" value`))), o11 = !1), o11;
            }
            _validateStretch(e, t) {
                if (!e) return !0;
                let i3 = 0;
                for (const o11 of e){
                    if (o11[0] < i3 || o11[1] < o11[0] || t < o11[1]) return !1;
                    i3 = o11[1];
                }
                return !0;
            }
            _validateContent(e, t) {
                return !(e && (4 !== e.length || e[0] < 0 || t.data.width < e[0] || e[1] < 0 || t.data.height < e[1] || e[2] < 0 || t.data.width < e[2] || e[3] < 0 || t.data.height < e[3] || e[2] < e[0] || e[3] < e[1]));
            }
            updateImage(e, t) {
                t.version = this.images[e].version + 1, this.images[e] = t, this.updatedImages[e] = !0;
            }
            removeImage(e) {
                const t2 = this.images[e];
                delete this.images[e], delete this.patterns[e], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
            }
            listImages() {
                return Object.keys(this.images);
            }
            getImages(e, t) {
                let i3 = !0;
                if (!this.isLoaded()) for (const t2 of e)this.images[t2] || (i3 = !1);
                this.isLoaded() || i3 ? this._notify(e, t) : this.requestors.push({
                    ids: e,
                    callback: t
                });
            }
            _notify(t, i) {
                const o11 = {
                };
                for (const i3 of t){
                    this.images[i3] || this.fire(new e1.Event("styleimagemissing", {
                        id: i3
                    }));
                    const t2 = this.images[i3];
                    t2 ? o11[i3] = {
                        data: t2.data.clone(),
                        pixelRatio: t2.pixelRatio,
                        sdf: t2.sdf,
                        version: t2.version,
                        stretchX: t2.stretchX,
                        stretchY: t2.stretchY,
                        content: t2.content,
                        hasRenderCallback: Boolean(t2.userImage && t2.userImage.render)
                    } : e1.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                }
                i(null, o11);
            }
            getPixelSize() {
                const { width: e2 , height: t2  } = this.atlasImage;
                return {
                    width: e2,
                    height: t2
                };
            }
            getPattern(t) {
                const i3 = this.patterns[t], o11 = this.getImage(t);
                if (!o11) return null;
                if (i3 && i3.position.version === o11.version) return i3.position;
                if (i3) i3.position.version = o11.version;
                else {
                    const i7 = {
                        w: o11.data.width + 2,
                        h: o11.data.height + 2,
                        x: 0,
                        y: 0
                    }, r4 = new e1.ImagePosition(i7, o11);
                    this.patterns[t] = {
                        bin: i7,
                        position: r4
                    };
                }
                return this._updatePatternAtlas(), this.patterns[t].position;
            }
            bind(t) {
                const i3 = t.gl;
                this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new e1.Texture(t, this.atlasImage, i3.RGBA), this.atlasTexture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
                const t2 = [];
                for(const e2 in this.patterns)t2.push(this.patterns[e2].bin);
                const { w: i3 , h: o11  } = e1.potpack(t2), r4 = this.atlasImage;
                r4.resize({
                    width: i3 || 1,
                    height: o11 || 1
                });
                for(const t3 in this.patterns){
                    const { bin: i7  } = this.patterns[t3], o12 = i7.x + 1, n3 = i7.y + 1, s4 = this.images[t3].data, a9 = s4.width, l20 = s4.height;
                    e1.RGBAImage.copy(s4, r4, {
                        x: 0,
                        y: 0
                    }, {
                        x: o12,
                        y: n3
                    }, {
                        width: a9,
                        height: l20
                    }), e1.RGBAImage.copy(s4, r4, {
                        x: 0,
                        y: l20 - 1
                    }, {
                        x: o12,
                        y: n3 - 1
                    }, {
                        width: a9,
                        height: 1
                    }), e1.RGBAImage.copy(s4, r4, {
                        x: 0,
                        y: 0
                    }, {
                        x: o12,
                        y: n3 + l20
                    }, {
                        width: a9,
                        height: 1
                    }), e1.RGBAImage.copy(s4, r4, {
                        x: a9 - 1,
                        y: 0
                    }, {
                        x: o12 - 1,
                        y: n3
                    }, {
                        width: 1,
                        height: l20
                    }), e1.RGBAImage.copy(s4, r4, {
                        x: 0,
                        y: 0
                    }, {
                        x: o12 + a9,
                        y: n3
                    }, {
                        width: 1,
                        height: l20
                    });
                }
                this.dirty = !0;
            }
            beginFrame() {
                this.callbackDispatchedThisFrame = {
                };
            }
            dispatchRenderCallbacks(e) {
                for (const t2 of e){
                    if (this.callbackDispatchedThisFrame[t2]) continue;
                    this.callbackDispatchedThisFrame[t2] = !0;
                    const e2 = this.images[t2];
                    x3(e2) && this.updateImage(t2, e2);
                }
            }
        }
        const b2 = new e1.Properties({
            anchor: new e1.DataConstantProperty(e1.spec.light.anchor),
            position: new class {
                constructor(){
                    this.specification = e1.spec.light.position;
                }
                possiblyEvaluate(t, i) {
                    return (function([t2, i3, o11]) {
                        const r4 = e1.degToRad(i3 + 90), n3 = e1.degToRad(o11);
                        return {
                            x: t2 * Math.cos(r4) * Math.sin(n3),
                            y: t2 * Math.sin(r4) * Math.sin(n3),
                            z: t2 * Math.cos(n3),
                            azimuthal: i3,
                            polar: o11
                        };
                    })(t.expression.evaluate(i));
                }
                interpolate(t, i, o) {
                    return {
                        x: e1.number(t.x, i.x, o),
                        y: e1.number(t.y, i.y, o),
                        z: e1.number(t.z, i.z, o),
                        azimuthal: e1.number(t.azimuthal, i.azimuthal, o),
                        polar: e1.number(t.polar, i.polar, o)
                    };
                }
            },
            color: new e1.DataConstantProperty(e1.spec.light.color),
            intensity: new e1.DataConstantProperty(e1.spec.light.intensity)
        }), w3 = "-transition";
        class T extends e1.Evented {
            constructor(t2){
                super(), this._transitionable = new e1.Transitionable(b2), this.setLight(t2), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
                return this._transitionable.serialize();
            }
            setLight(t, i = {
            }) {
                if (!this._validate(e1.validateLight, t, i)) for(const i3 in t){
                    const o11 = t[i3];
                    e1.endsWith(i3, w3) ? this._transitionable.setTransition(i3.slice(0, -w3.length), o11) : this._transitionable.setValue(i3, o11);
                }
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t, i, o) {
                return (!o || !1 !== o.validate) && e1.emitValidationErrors(this, t.call(e1.validateStyle, e1.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e1.spec
                })));
            }
        }
        const E = new e1.Properties({
            source: new e1.DataConstantProperty(e1.spec.terrain.source),
            exaggeration: new e1.DataConstantProperty(e1.spec.terrain.exaggeration)
        }), C = "-transition";
        class I extends e1.Evented {
            constructor(t3, i3){
                super(), this._transitionable = new e1.Transitionable(E), this.set(t3), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i3;
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t) {
                for(const i7 in t){
                    const o11 = t[i7];
                    e1.endsWith(i7, C) ? this._transitionable.setTransition(i7.slice(0, -C.length), o11) : this._transitionable.setValue(i7, o11);
                }
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
        }
        function M2(t4, i7, o11, r4) {
            const n3 = e1.smoothstep(45, 65, o11), [s4, a9] = S2(t4, r4), l20 = e1.length(i7);
            let c14 = 1 - Math.min(1, Math.exp((l20 - s4) / (a9 - s4) * -6));
            return c14 *= c14 * c14, c14 = Math.min(1, 1.00747 * c14), c14 * n3 * t4.alpha;
        }
        function S2(e2, t4) {
            const i7 = 0.5 / Math.tan(0.5 * t4);
            return [
                e2.range[0] + i7,
                e2.range[1] + i7
            ];
        }
        const D = new e1.Properties({
            range: new e1.DataConstantProperty(e1.spec.fog.range),
            color: new e1.DataConstantProperty(e1.spec.fog.color),
            "high-color": new e1.DataConstantProperty(e1.spec.fog["high-color"]),
            "space-color": new e1.DataConstantProperty(e1.spec.fog["space-color"]),
            "horizon-blend": new e1.DataConstantProperty(e1.spec.fog["horizon-blend"]),
            "star-intensity": new e1.DataConstantProperty(e1.spec.fog["star-intensity"])
        }), A = "-transition";
        class L1 extends e1.Evented {
            constructor(t4, i7){
                super(), this._transitionable = new e1.Transitionable(D), this.set(t4), this._transitioning = this._transitionable.untransitioned(), this._transform = i7;
            }
            get state() {
                const t5 = this._transform, i9 = "globe" === t5.projection.name, o11 = e1.globeToMercatorTransition(t5.zoom), r4 = this.properties.get("range"), n3 = [
                    0.5,
                    3
                ];
                return {
                    range: i9 ? [
                        e1.number(n3[0], r4[0], o11),
                        e1.number(n3[1], r4[1], o11)
                    ] : r4,
                    horizonBlend: this.properties.get("horizon-blend"),
                    alpha: this.properties.get("color").a
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t, i = {
            }) {
                if (!this._validate(e1.validateFog, t, i)) {
                    for (const i9 of Object.keys(e1.spec.fog))t && (void 0) === t[i9] && (t[i9] = e1.spec.fog[i9].default);
                    for(const i10 in t){
                        const o11 = t[i10];
                        e1.endsWith(i10, A) ? this._transitionable.setTransition(i10.slice(0, -A.length), o11) : this._transitionable.setValue(i10, o11);
                    }
                }
            }
            getOpacity(t) {
                if (!this._transform.projection.supportsFog) return 0;
                const i9 = this.properties && this.properties.get("color") || 1;
                return ("globe" === this._transform.projection.name ? 1 : e1.smoothstep(45, 65, t)) * i9.a;
            }
            getOpacityAtLatLng(t, i) {
                return this._transform.projection.supportsFog ? (function(t5, i9, o11) {
                    const r4 = e1.MercatorCoordinate.fromLngLat(i9), n3 = o11.elevation ? o11.elevation.getAtPointOrZero(r4) : 0, s4 = [
                        r4.x,
                        r4.y,
                        n3
                    ];
                    return e1.transformMat4(s4, s4, o11.mercatorFogMatrix), M2(t5, s4, o11.pitch, o11._fov);
                })(this.state, t, i) : 0;
            }
            getFovAdjustedRange(e) {
                return this._transform.projection.supportsFog ? S2(this.state, e) : [
                    0,
                    1
                ];
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t, i, o) {
                return (!o || !1 !== o.validate) && e1.emitValidationErrors(this, t.call(e1.validateStyle, e1.extend({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e1.spec
                })));
            }
        }
        class z {
            constructor(t5, i9){
                this.workerPool = t5, this.actors = [], this.currentActor = 0, this.id = e1.uniqueId();
                const o11 = this.workerPool.acquire(this.id);
                for(let e2 = 0; e2 < o11.length; e2++){
                    const t6 = new z.Actor(o11[e2], i9, this.id);
                    t6.name = `Worker ${e2}`, this.actors.push(t6);
                }
                this.ready = !1, this.broadcast("checkIfReady", null, ()=>{
                    this.ready = !0;
                });
            }
            broadcast(t, i, o) {
                e1.asyncAll(this.actors, (e3, o12)=>{
                    e3.send(t, i, o12);
                }, o = o || function() {
                });
            }
            getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
                this.actors.forEach((e3)=>{
                    e3.remove();
                }), this.actors = [], this.workerPool.release(this.id);
            }
        }
        function P2(t6, i10, o12) {
            return i10 * (e1.EXTENT / (t6.tileSize * Math.pow(2, o12 - t6.tileID.overscaledZ)));
        }
        z.Actor = e1.Actor;
        class R {
            constructor(e3, t6, i10, o12){
                this.screenBounds = e3, this.cameraPoint = t6, this._screenRaycastCache = {
                }, this._cameraRaycastCache = {
                }, this.isAboveHorizon = i10, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o12);
            }
            static createFromScreenPoints(t, i) {
                let o13, r4;
                if (t instanceof e1.pointGeometry || "number" == typeof t[0]) {
                    const n3 = e1.pointGeometry.convert(t);
                    o13 = [
                        n3
                    ], r4 = i.isPointAboveHorizon(n3);
                } else {
                    const n3 = e1.pointGeometry.convert(t[0]), s4 = e1.pointGeometry.convert(t[1]);
                    o13 = [
                        n3,
                        s4
                    ], r4 = e1.polygonizeBounds(n3, s4).every((e4)=>i.isPointAboveHorizon(e4)
                    );
                }
                return new R(o13, i.getCameraPoint(), r4, i);
            }
            isPointQuery() {
                return 1 === this.screenBounds.length;
            }
            bufferedScreenGeometry(t) {
                return e1.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t);
            }
            bufferedCameraGeometry(t) {
                const i11 = this.screenBounds[0], o13 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e1.pointGeometry(1, 1)) : this.screenBounds[1], r4 = e1.polygonizeBounds(i11, o13, 0, !1);
                return this.cameraPoint.y > o13.y && (this.cameraPoint.x > i11.x && this.cameraPoint.x < o13.x ? r4.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o13.x ? r4[2] = this.cameraPoint : this.cameraPoint.x <= i11.x && (r4[3] = this.cameraPoint)), e1.bufferConvexPolygon(r4, t);
            }
            bufferedCameraGeometryGlobe(t) {
                const i11 = this.screenBounds[0], o13 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e1.pointGeometry(1, 1)) : this.screenBounds[1], r4 = e1.polygonizeBounds(i11, o13, t), n3 = this.cameraPoint.clone();
                switch(3 * ((n3.y > i11.y) + (n3.y > o13.y)) + ((n3.x > i11.x) + (n3.x > o13.x))){
                    case 0:
                        r4[0] = n3, r4[4] = n3.clone();
                        break;
                    case 1:
                        r4.splice(1, 0, n3);
                        break;
                    case 2:
                        r4[1] = n3;
                        break;
                    case 3:
                        r4.splice(4, 0, n3);
                        break;
                    case 5:
                        r4.splice(2, 0, n3);
                        break;
                    case 6:
                        r4[3] = n3;
                        break;
                    case 7:
                        r4.splice(3, 0, n3);
                        break;
                    case 8:
                        r4[2] = n3;
                }
                return r4;
            }
            containsTile(t, i, o, r = 0) {
                const n3 = t.queryPadding / i._pixelsPerMercatorPixel + 1, s4 = o ? this._bufferedCameraMercator(n3, i) : this._bufferedScreenMercator(n3, i);
                let a9 = t.tileID.wrap + (s4.unwrapped ? r : 0);
                const l20 = s4.polygon.map((i11)=>e1.getTilePoint(t.tileTransform, i11, a9)
                );
                if (!e1.polygonIntersectsBox(l20, 0, 0, e1.EXTENT, e1.EXTENT)) return;
                a9 = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);
                const c14 = this.screenGeometryMercator.polygon.map((i11)=>e1.getTileVec3(t.tileTransform, i11, a9)
                ), h13 = c14.map((t7)=>new e1.pointGeometry(t7[0], t7[1])
                ), u16 = i.getFreeCameraOptions().position || new e1.MercatorCoordinate(0, 0, 0), _1 = e1.getTileVec3(t.tileTransform, u16, a9), d7 = c14.map((t7)=>{
                    const i11 = e1.sub(t7, t7, _1);
                    return e1.normalize(i11, i11), new e1.Ray(_1, i11);
                }), p10 = P2(t, 1, i.zoom) * i._pixelsPerMercatorPixel;
                var m5;
                return {
                    queryGeometry: this,
                    tilespaceGeometry: h13,
                    tilespaceRays: d7,
                    bufferedTilespaceGeometry: l20,
                    bufferedTilespaceBounds: (m5 = e1.getBounds(l20), m5.min.x = e1.clamp(m5.min.x, 0, e1.EXTENT), m5.min.y = e1.clamp(m5.min.y, 0, e1.EXTENT), m5.max.x = e1.clamp(m5.max.x, 0, e1.EXTENT), m5.max.y = e1.clamp(m5.max.y, 0, e1.EXTENT), m5),
                    tile: t,
                    tileID: t.tileID,
                    pixelToTileUnitsFactor: p10
                };
            }
            _bufferedScreenMercator(e, t) {
                const i11 = k(e);
                if (this._screenRaycastCache[i11]) return this._screenRaycastCache[i11];
                {
                    let o13;
                    return o13 = "globe" === t.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t) : {
                        polygon: this.bufferedScreenGeometry(e).map((e4)=>t.pointCoordinate3D(e4)
                        ),
                        unwrapped: !0
                    }, this._screenRaycastCache[i11] = o13, o13;
                }
            }
            _bufferedCameraMercator(e, t) {
                const i11 = k(e);
                if (this._cameraRaycastCache[i11]) return this._cameraRaycastCache[i11];
                {
                    let o13;
                    return o13 = "globe" === t.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t) : {
                        polygon: this.bufferedCameraGeometry(e).map((e4)=>t.pointCoordinate3D(e4)
                        ),
                        unwrapped: !0
                    }, this._cameraRaycastCache[i11] = o13, o13;
                }
            }
            _projectAndResample(t, i) {
                const o13 = function(t7, i11) {
                    const o14 = e1.multiply([], i11.pixelMatrix, i11.globeMatrix), r4 = [
                        0,
                        -e1.GLOBE_RADIUS,
                        0,
                        1
                    ], n3 = [
                        0,
                        e1.GLOBE_RADIUS,
                        0,
                        1
                    ], s4 = [
                        0,
                        0,
                        0,
                        1
                    ];
                    e1.transformMat4$1(r4, r4, o14), e1.transformMat4$1(n3, n3, o14), e1.transformMat4$1(s4, s4, o14);
                    const a9 = new e1.pointGeometry(r4[0] / r4[3], r4[1] / r4[3]), l20 = new e1.pointGeometry(n3[0] / n3[3], n3[1] / n3[3]), c14 = e1.polygonContainsPoint(t7, a9) && r4[3] < s4[3], h13 = e1.polygonContainsPoint(t7, l20) && n3[3] < s4[3];
                    if (!c14 && !h13) return null;
                    const u16 = function(e4, t8, i12) {
                        for(let o15 = 1; o15 < e4.length; o15++){
                            const r5 = B(t8.pointCoordinate3D(e4[o15 - 1]).x), n6 = B(t8.pointCoordinate3D(e4[o15]).x);
                            if (i12 < 0) {
                                if (r5 < n6) return {
                                    idx: o15,
                                    t: -r5 / (n6 - 1 - r5)
                                };
                            } else if (n6 < r5) return {
                                idx: o15,
                                t: (1 - r5) / (n6 + 1 - r5)
                            };
                        }
                        return null;
                    }(t7, i11, c14 ? -1 : 1);
                    if (!u16) return null;
                    const { idx: _1 , t: d7  } = u16;
                    let p10 = _1 > 1 ? O(t7.slice(0, _1), i11) : [], m6 = _1 < t7.length ? O(t7.slice(_1), i11) : [];
                    p10 = p10.map((t8)=>new e1.pointGeometry(B(t8.x), t8.y)
                    ), m6 = m6.map((t8)=>new e1.pointGeometry(B(t8.x), t8.y)
                    );
                    const f9 = [
                        ...p10
                    ];
                    0 === f9.length && f9.push(m6[m6.length - 1]);
                    const g6 = e1.number(f9[f9.length - 1].y, (0 === m6.length ? p10[0] : m6[0]).y, d7);
                    let v4;
                    return v4 = c14 ? [
                        new e1.pointGeometry(0, g6),
                        new e1.pointGeometry(0, 0),
                        new e1.pointGeometry(1, 0),
                        new e1.pointGeometry(1, g6)
                    ] : [
                        new e1.pointGeometry(1, g6),
                        new e1.pointGeometry(1, 1),
                        new e1.pointGeometry(0, 1),
                        new e1.pointGeometry(0, g6)
                    ], f9.push(...v4), 0 === m6.length ? f9.push(p10[0]) : f9.push(...m6), {
                        polygon: f9.map((t8)=>new e1.MercatorCoordinate(t8.x, t8.y)
                        ),
                        unwrapped: !1
                    };
                }(t, i);
                if (o13) return o13;
                const r4 = function(t7, i11) {
                    let o14 = !1, r5 = -1 / 0, n3 = 0;
                    for(let e4 = 0; e4 < t7.length - 1; e4++)t7[e4].x > r5 && (r5 = t7[e4].x, n3 = e4);
                    for(let e5 = 0; e5 < t7.length - 1; e5++){
                        const i12 = (n3 + e5) % (t7.length - 1), r6 = t7[i12], s4 = t7[i12 + 1];
                        Math.abs(r6.x - s4.x) > 0.5 && (r6.x < s4.x ? (r6.x += 1, 0 === i12 && (t7[t7.length - 1].x += 1)) : (s4.x += 1, i12 + 1 === t7.length - 1 && (t7[0].x += 1)), o14 = !0);
                    }
                    const s4 = e1.mercatorXfromLng(i11.center.lng);
                    return o14 && s4 < Math.abs(s4 - 1) && t7.forEach((e6)=>{
                        e6.x -= 1;
                    }), {
                        polygon: t7,
                        unwrapped: o14
                    };
                }(O(t, i).map((t7)=>new e1.pointGeometry(B(t7.x), t7.y)
                ), i);
                return {
                    polygon: r4.polygon.map((t7)=>new e1.MercatorCoordinate(t7.x, t7.y)
                    ),
                    unwrapped: r4.unwrapped
                };
            }
        }
        function O(t7, i11) {
            return e1.resample(t7, (e4)=>{
                const t8 = i11.pointCoordinate3D(e4);
                e4.x = t8.x, e4.y = t8.y;
            }, 1 / 256);
        }
        function B(e4) {
            return e4 < 0 ? 1 + e4 % 1 : e4 % 1;
        }
        function k(e4) {
            return 100 * e4 | 0;
        }
        function F(t7, i11, o13, r4, n3) {
            const s4 = function(o14, r5) {
                if (o14) return n3(o14);
                if (r5) {
                    t7.url && r5.tiles && t7.tiles && delete t7.tiles;
                    const o15 = e1.pick(e1.extend(r5, t7), [
                        "tiles",
                        "minzoom",
                        "maxzoom",
                        "attribution",
                        "mapbox_logo",
                        "bounds",
                        "scheme",
                        "tileSize",
                        "encoding"
                    ]);
                    r5.vector_layers && (o15.vectorLayers = r5.vector_layers, o15.vectorLayerIds = o15.vectorLayers.map((e4)=>e4.id
                    )), o15.tiles = i11.canonicalizeTileset(o15, t7.url), n3(null, o15);
                }
            };
            return t7.url ? e1.getJSON(i11.transformRequest(i11.normalizeSourceURL(t7.url, null, o13, r4), e1.ResourceType.Source), s4) : e1.exported.frame(()=>s4(null, t7)
            );
        }
        class U {
            constructor(t7, i11, o13){
                this.bounds = e1.LngLatBounds.convert(this.validateBounds(t7)), this.minzoom = i11 || 0, this.maxzoom = o13 || 24;
            }
            validateBounds(e) {
                return Array.isArray(e) && 4 === e.length ? [
                    Math.max(-180, e[0]),
                    Math.max(-90, e[1]),
                    Math.min(180, e[2]),
                    Math.min(90, e[3])
                ] : [
                    -180,
                    -90,
                    180,
                    90
                ];
            }
            contains(t) {
                const i12 = Math.pow(2, t.z), o14 = Math.floor(e1.mercatorXfromLng(this.bounds.getWest()) * i12), r4 = Math.floor(e1.mercatorYfromLat(this.bounds.getNorth()) * i12), n3 = Math.ceil(e1.mercatorXfromLng(this.bounds.getEast()) * i12), s4 = Math.ceil(e1.mercatorYfromLat(this.bounds.getSouth()) * i12);
                return t.x >= o14 && t.x < n3 && t.y >= r4 && t.y < s4;
            }
        }
        class N {
            constructor(e4, t8, i12){
                this.context = e4;
                const o14 = e4.gl;
                this.buffer = o14.createBuffer(), this.dynamicDraw = Boolean(i12), this.context.unbindVAO(), e4.bindElementBuffer.set(this.buffer), o14.bufferData(o14.ELEMENT_ARRAY_BUFFER, t8.arrayBuffer, this.dynamicDraw ? o14.DYNAMIC_DRAW : o14.STATIC_DRAW), this.dynamicDraw || t8.destroy();
            }
            bind() {
                this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e) {
                const t9 = this.context.gl;
                this.context.unbindVAO(), this.bind(), t9.bufferSubData(t9.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        const G = {
            Int8: "BYTE",
            Uint8: "UNSIGNED_BYTE",
            Int16: "SHORT",
            Uint16: "UNSIGNED_SHORT",
            Int32: "INT",
            Uint32: "UNSIGNED_INT",
            Float32: "FLOAT"
        };
        class j {
            constructor(e5, t9, i13, o15){
                this.length = t9.length, this.attributes = i13, this.itemSize = t9.bytesPerElement, this.dynamicDraw = o15, this.context = e5;
                const r4 = e5.gl;
                this.buffer = r4.createBuffer(), e5.bindVertexBuffer.set(this.buffer), r4.bufferData(r4.ARRAY_BUFFER, t9.arrayBuffer, this.dynamicDraw ? r4.DYNAMIC_DRAW : r4.STATIC_DRAW), this.dynamicDraw || t9.destroy();
            }
            bind() {
                this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e) {
                const t10 = this.context.gl;
                this.bind(), t10.bufferSubData(t10.ARRAY_BUFFER, 0, e.arrayBuffer);
            }
            enableAttributes(e, t) {
                for(let i16 = 0; i16 < this.attributes.length; i16++){
                    const o16 = t.attributes[this.attributes[i16].name];
                    (void 0) !== o16 && e.enableVertexAttribArray(o16);
                }
            }
            setVertexAttribPointers(e, t, i) {
                for(let o16 = 0; o16 < this.attributes.length; o16++){
                    const r5 = this.attributes[o16], n3 = t.attributes[r5.name];
                    (void 0) !== n3 && e.vertexAttribPointer(n3, r5.components, e[G[r5.type]], !1, this.itemSize, r5.offset + this.itemSize * (i || 0));
                }
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        class Z {
            constructor(e6){
                this.gl = e6.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
            }
            get() {
                return this.current;
            }
            set(e) {
            }
            getDefault() {
                return this.default;
            }
            setDefault() {
                this.set(this.default);
            }
        }
        class V extends Z {
            getDefault() {
                return e1.Color.transparent;
            }
            set(e) {
                const t10 = this.current;
                (e.r !== t10.r || e.g !== t10.g || e.b !== t10.b || e.a !== t10.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }
        class W extends Z {
            getDefault() {
                return 1;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
            }
        }
        class X extends Z {
            getDefault() {
                return 0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
            }
        }
        class q extends Z {
            getDefault() {
                return [
                    !0,
                    !0,
                    !0,
                    !0
                ];
            }
            set(e) {
                const t10 = this.current;
                (e[0] !== t10[0] || e[1] !== t10[1] || e[2] !== t10[2] || e[3] !== t10[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class $ extends Z {
            getDefault() {
                return !0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
            }
        }
        class H extends Z {
            getDefault() {
                return 255;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
            }
        }
        class Y extends Z {
            getDefault() {
                return {
                    func: this.gl.ALWAYS,
                    ref: 0,
                    mask: 255
                };
            }
            set(e) {
                const t10 = this.current;
                (e.func !== t10.func || e.ref !== t10.ref || e.mask !== t10.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
            }
        }
        class K extends Z {
            getDefault() {
                const e7 = this.gl;
                return [
                    e7.KEEP,
                    e7.KEEP,
                    e7.KEEP
                ];
            }
            set(e) {
                const t10 = this.current;
                (e[0] !== t10[0] || e[1] !== t10[1] || e[2] !== t10[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
            }
        }
        class J extends Z {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                e ? t10.enable(t10.STENCIL_TEST) : t10.disable(t10.STENCIL_TEST), this.current = e, this.dirty = !1;
            }
        }
        class Q extends Z {
            getDefault() {
                return [
                    0,
                    1
                ];
            }
            set(e) {
                const t10 = this.current;
                (e[0] !== t10[0] || e[1] !== t10[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
            }
        }
        class ee extends Z {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                e ? t10.enable(t10.DEPTH_TEST) : t10.disable(t10.DEPTH_TEST), this.current = e, this.dirty = !1;
            }
        }
        class te extends Z {
            getDefault() {
                return this.gl.LESS;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
            }
        }
        class ie extends Z {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                e ? t10.enable(t10.BLEND) : t10.disable(t10.BLEND), this.current = e, this.dirty = !1;
            }
        }
        class oe extends Z {
            getDefault() {
                const e7 = this.gl;
                return [
                    e7.ONE,
                    e7.ZERO
                ];
            }
            set(e) {
                const t10 = this.current;
                (e[0] !== t10[0] || e[1] !== t10[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
            }
        }
        class re extends Z {
            getDefault() {
                return e1.Color.transparent;
            }
            set(e) {
                const t10 = this.current;
                (e.r !== t10.r || e.g !== t10.g || e.b !== t10.b || e.a !== t10.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }
        class ne extends Z {
            getDefault() {
                return this.gl.FUNC_ADD;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
            }
        }
        class se extends Z {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                e ? t10.enable(t10.CULL_FACE) : t10.disable(t10.CULL_FACE), this.current = e, this.dirty = !1;
            }
        }
        class ae extends Z {
            getDefault() {
                return this.gl.BACK;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
            }
        }
        class le extends Z {
            getDefault() {
                return this.gl.CCW;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
            }
        }
        class ce extends Z {
            getDefault() {
                return null;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
            }
        }
        class he extends Z {
            getDefault() {
                return this.gl.TEXTURE0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
            }
        }
        class ue extends Z {
            getDefault() {
                const e7 = this.gl;
                return [
                    0,
                    0,
                    e7.drawingBufferWidth,
                    e7.drawingBufferHeight
                ];
            }
            set(e) {
                const t10 = this.current;
                (e[0] !== t10[0] || e[1] !== t10[1] || e[2] !== t10[2] || e[3] !== t10[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class _e extends Z {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                t10.bindFramebuffer(t10.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class de extends Z {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                t10.bindRenderbuffer(t10.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class pe extends Z {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                t10.bindTexture(t10.TEXTURE_2D, e), this.current = e, this.dirty = !1;
            }
        }
        class me extends Z {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                t10.bindBuffer(t10.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class fe extends Z {
            getDefault() {
                return null;
            }
            set(e) {
                const t10 = this.gl;
                t10.bindBuffer(t10.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class ge extends Z {
            constructor(e7){
                super(e7), this.vao = e7.extVertexArrayObject;
            }
            getDefault() {
                return null;
            }
            set(e) {
                this.vao && (e !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e), this.current = e, this.dirty = !1);
            }
        }
        class ve extends Z {
            getDefault() {
                return 4;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                t10.pixelStorei(t10.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
            }
        }
        class xe extends Z {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                t10.pixelStorei(t10.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }
        class ye extends Z {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t10 = this.gl;
                t10.pixelStorei(t10.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }
        class be extends Z {
            constructor(e8, t10){
                super(e8), this.context = e8, this.parent = t10;
            }
            getDefault() {
                return null;
            }
        }
        class we extends be {
            setDirty() {
                this.dirty = !0;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t11 = this.gl;
                t11.framebufferTexture2D(t11.FRAMEBUFFER, t11.COLOR_ATTACHMENT0, t11.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
            }
        }
        class Te extends be {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t11 = this.gl;
                t11.framebufferRenderbuffer(t11.FRAMEBUFFER, this.attachment(), t11.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class Ee extends Te {
            attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
        }
        class Ce {
            constructor(e9, t11, i16, o16){
                this.context = e9, this.width = t11, this.height = i16;
                const r5 = this.framebuffer = e9.gl.createFramebuffer();
                this.colorAttachment = new we(e9, r5), o16 && (this.depthAttachment = new Te(e9, r5));
            }
            destroy() {
                const e10 = this.context.gl, t12 = this.colorAttachment.get();
                if (t12 && e10.deleteTexture(t12), this.depthAttachment) {
                    const t13 = this.depthAttachment.get();
                    t13 && e10.deleteRenderbuffer(t13);
                }
                e10.deleteFramebuffer(this.framebuffer);
            }
        }
        class Ie {
            constructor(e10){
                this.gl = e10, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new V(this), this.clearDepth = new W(this), this.clearStencil = new X(this), this.colorMask = new q(this), this.depthMask = new $(this), this.stencilMask = new H(this), this.stencilFunc = new Y(this), this.stencilOp = new K(this), this.stencilTest = new J(this), this.depthRange = new Q(this), this.depthTest = new ee(this), this.depthFunc = new te(this), this.blend = new ie(this), this.blendFunc = new oe(this), this.blendColor = new re(this), this.blendEquation = new ne(this), this.cullFace = new se(this), this.cullFaceSide = new ae(this), this.frontFace = new le(this), this.program = new ce(this), this.activeTexture = new he(this), this.viewport = new ue(this), this.bindFramebuffer = new _e(this), this.bindRenderbuffer = new de(this), this.bindTexture = new pe(this), this.bindVertexBuffer = new me(this), this.bindElementBuffer = new fe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ge(this), this.pixelStoreUnpack = new ve(this), this.pixelStoreUnpackPremultiplyAlpha = new xe(this), this.pixelStoreUnpackFlipY = new ye(this), this.extTextureFilterAnisotropic = e10.getExtension("EXT_texture_filter_anisotropic") || e10.getExtension("MOZ_EXT_texture_filter_anisotropic") || e10.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e10.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extStandardDerivativesForceOff = !1, this.extDebugRendererInfo = e10.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e10.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e10.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.extTextureHalfFloat = e10.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (e10.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = e10.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = e10.getExtension("OES_standard_derivatives"), this.extTimerQuery = e10.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e10.getParameter(e10.MAX_TEXTURE_SIZE);
            }
            setDefault() {
                this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
                this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
            }
            createIndexBuffer(e, t) {
                return new N(this, e, t);
            }
            createVertexBuffer(e, t, i) {
                return new j(this, e, t, i);
            }
            createRenderbuffer(e, t, i) {
                const o17 = this.gl, r6 = o17.createRenderbuffer();
                return this.bindRenderbuffer.set(r6), o17.renderbufferStorage(o17.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), r6;
            }
            createFramebuffer(e, t, i) {
                return new Ce(this, e, t, i);
            }
            clear({ color: e , depth: t , stencil: i  }) {
                const o17 = this.gl;
                let r6 = 0;
                e && (r6 |= o17.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([
                    !0,
                    !0,
                    !0,
                    !0
                ])), (void 0) !== t && (r6 |= o17.DEPTH_BUFFER_BIT, this.depthRange.set([
                    0,
                    1
                ]), this.clearDepth.set(t), this.depthMask.set(!0)), (void 0) !== i && (r6 |= o17.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), o17.clear(r6);
            }
            setCullFace(e) {
                !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
            }
            setDepthMode(e) {
                e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
            }
            setStencilMode(e) {
                e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([
                    e.fail,
                    e.depthFail,
                    e.pass
                ]), this.stencilFunc.set({
                    func: e.test.func,
                    ref: e.ref,
                    mask: e.test.mask
                })) : this.stencilTest.set(!1);
            }
            setColorMode(i) {
                t1(i.blendFunction, e1.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(i.blendFunction), this.blendColor.set(i.blendColor)), this.colorMask.set(i.mask);
            }
            unbindVAO() {
                this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
            }
        }
        class Me extends e1.Evented {
            constructor(t12, i18, o17, r6){
                super(), this.id = t12, this.dispatcher = o17, this.setEventedParent(r6), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e1.extend({
                    type: "raster"
                }, i18), e1.extend(this, e1.pick(i18, [
                    "url",
                    "scheme",
                    "tileSize"
                ]));
            }
            load() {
                this._loaded = !1, this.fire(new e1.Event("dataloading", {
                    dataType: "source"
                })), this._tileJSONRequest = F(this._options, this.map._requestManager, null, null, (t13, i19)=>{
                    this._tileJSONRequest = null, this._loaded = !0, t13 ? this.fire(new e1.ErrorEvent(t13)) : i19 && (e1.extend(this, i19), i19.bounds && (this.tileBounds = new U(i19.bounds, this.minzoom, this.maxzoom)), e1.postTurnstileEvent(i19.tiles), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    })));
                });
            }
            loaded() {
                return this._loaded;
            }
            onAdd(e) {
                this.map = e, this.load();
            }
            onRemove() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            serialize() {
                return e1.extend({
                }, this._options);
            }
            hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            loadTile(t, i) {
                const o18 = e1.exported.devicePixelRatio >= 2, r7 = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), o18, this.tileSize);
                t.request = e1.getImage(this.map._requestManager.transformRequest(r7, e1.ResourceType.Tile), (o19, r8, n3, s4)=>(delete t.request, t.aborted ? (t.state = "unloaded", i(null)) : o19 ? (t.state = "errored", i(o19)) : r8 ? (this.map._refreshExpiredTiles && t.setExpiryData({
                        cacheControl: n3,
                        expires: s4
                    }), t.setTexture(r8, this.map.painter), t.state = "loaded", e1.cacheEntryPossiblyAdded(this.dispatcher), void i(null)) : i(null))
                );
            }
            static loadTileData(e, t, i) {
                e.setTexture(t, i);
            }
            static unloadTileData(e, t) {
                e.texture && t.saveTileTexture(e.texture);
            }
            abortTile(e, t) {
                e.request && (e.request.cancel(), delete e.request), t();
            }
            unloadTile(e, t) {
                e.texture && this.map.painter.saveTileTexture(e.texture), t();
            }
            hasTransition() {
                return !1;
            }
        }
        let Se;
        function De(t13, i19, o18, r7, n3, s4, a9, l20) {
            const c14 = [
                t13,
                o18,
                n3,
                i19,
                r7,
                s4,
                1,
                1,
                1
            ], h13 = [
                a9,
                l20,
                1
            ], u16 = e1.adjoint([], c14), [_1, d7, p10] = e1.transformMat3(h13, h13, e1.transpose(u16, u16));
            return e1.multiply$1(c14, [
                _1,
                0,
                0,
                0,
                d7,
                0,
                0,
                0,
                p10
            ], c14);
        }
        class Ae extends e1.Evented {
            constructor(e11, t13, i19, o18){
                super(), this.id = e11, this.dispatcher = i19, this.coordinates = t13.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {
                }, this._loaded = !1, this.setEventedParent(o18), this.options = t13, this._dirty = !1;
            }
            load(t, i) {
                this._loaded = i || !1, this.fire(new e1.Event("dataloading", {
                    dataType: "source"
                })), this.url = this.options.url, this._imageRequest = e1.getImage(this.map._requestManager.transformRequest(this.url, e1.ResourceType.Image), (i20, o19)=>{
                    if (this._imageRequest = null, this._loaded = !0, i20) this.fire(new e1.ErrorEvent(i20));
                    else if (o19) {
                        const { HTMLImageElement: i21  } = e1.window;
                        this.image = o19 instanceof i21 ? e1.exported.getImageData(o19) : o19, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), this._finishLoading();
                    }
                });
            }
            loaded() {
                return this._loaded;
            }
            updateImage(e) {
                return this.image && e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this;
            }
            _finishLoading() {
                this.map && (this.setCoordinates(this.coordinates), this.fire(new e1.Event("data", {
                    dataType: "source",
                    sourceDataType: "metadata"
                })));
            }
            onAdd(e) {
                this.map = e, this.load();
            }
            onRemove() {
                this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
            }
            setCoordinates(t) {
                this.coordinates = t, this._boundsArray = void 0;
                const i20 = t.map(e1.MercatorCoordinate.fromLngLat);
                return this.tileID = (function(t14) {
                    let i21 = 1 / 0, o19 = 1 / 0, r7 = -1 / 0, n3 = -1 / 0;
                    for (const e12 of t14)i21 = Math.min(i21, e12.x), o19 = Math.min(o19, e12.y), r7 = Math.max(r7, e12.x), n3 = Math.max(n3, e12.y);
                    const s4 = Math.max(r7 - i21, n3 - o19), a9 = Math.max(0, Math.floor(-Math.log(s4) / Math.LN2)), l20 = Math.pow(2, a9);
                    return new e1.CanonicalTileID(a9, Math.floor((i21 + r7) / 2 * l20), Math.floor((o19 + n3) / 2 * l20));
                })(i20), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e1.Event("data", {
                    dataType: "source",
                    sourceDataType: "content"
                })), this;
            }
            _clear() {
                this._boundsArray = void 0;
            }
            _prepareData(t) {
                for(const e12 in this.tiles){
                    const t14 = this.tiles[e12];
                    "loaded" !== t14.state && (t14.state = "loaded", t14.texture = this.texture);
                }
                if (this._boundsArray) return;
                const i20 = e1.tileTransform(this.tileID, this.map.transform.projection), [o19, r7, n3, s4] = this.coordinates.map((t14)=>{
                    const o20 = i20.projection.project(t14[0], t14[1]);
                    return e1.getTilePoint(i20, o20)._round();
                });
                this.perspectiveTransform = (function(t14, i21, o20, r8, n6, s14, a9, l20, c14, h13) {
                    const u16 = De(0, 0, t14, 0, 0, i21, t14, i21), _1 = De(o20, r8, n6, s14, a9, l20, c14, h13);
                    return e1.multiply$1(_1, e1.adjoint(u16, u16), _1), [
                        _1[6] / _1[8] * t14 / e1.EXTENT,
                        _1[7] / _1[8] * i21 / e1.EXTENT
                    ];
                })(this.width, this.height, o19.x, o19.y, r7.x, r7.y, s4.x, s4.y, n3.x, n3.y);
                const a9 = this._boundsArray = new e1.StructArrayLayout4i8;
                a9.emplaceBack(o19.x, o19.y, 0, 0), a9.emplaceBack(r7.x, r7.y, e1.EXTENT, 0), a9.emplaceBack(s4.x, s4.y, 0, e1.EXTENT), a9.emplaceBack(n3.x, n3.y, e1.EXTENT, e1.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t.createVertexBuffer(a9, e1.boundsAttributes.members), this.boundsSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
            }
            prepare() {
                if (0 === Object.keys(this.tiles).length || !this.image) return;
                const t14 = this.map.painter.context, i20 = t14.gl;
                this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e1.Texture(t14, this.image, i20.RGBA), this.texture.bind(i20.LINEAR, i20.CLAMP_TO_EDGE)), this._dirty = !1), this._prepareData(t14);
            }
            loadTile(e, t) {
                this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {
                }, t(null)) : (e.state = "errored", t(null));
            }
            serialize() {
                return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates
                };
            }
            hasTransition() {
                return !1;
            }
        }
        const Le = {
            vector: class extends e1.Evented {
                constructor(t14, i20, o19, r7){
                    if (super(), this.id = t14, this.dispatcher = o19, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e1.extend(this, e1.pick(i20, [
                        "url",
                        "scheme",
                        "tileSize",
                        "promoteId"
                    ])), this._options = e1.extend({
                        type: "vector"
                    }, i20), this._collectResourceTiming = i20.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
                    this.setEventedParent(r7), this._tileWorkers = {
                    }, this._deduped = new e1.DedupedRequest;
                }
                load(t) {
                    this._loaded = !1, this.fire(new e1.Event("dataloading", {
                        dataType: "source"
                    }));
                    const i21 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o20 = this.map._worldview;
                    this._tileJSONRequest = F(this._options, this.map._requestManager, i21, o20, (r8, n3)=>{
                        this._tileJSONRequest = null, this._loaded = !0, r8 ? (i21 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i21}`), o20 && 2 !== o20.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o20}`), this.fire(new e1.ErrorEvent(r8))) : n3 && (e1.extend(this, n3), n3.bounds && (this.tileBounds = new U(n3.bounds, this.minzoom, this.maxzoom)), e1.postTurnstileEvent(n3.tiles, this.map._requestManager._customAccessToken), this.fire(new e1.Event("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new e1.Event("data", {
                            dataType: "source",
                            sourceDataType: "content"
                        }))), t && t(r8);
                    });
                }
                loaded() {
                    return this._loaded;
                }
                hasTile(e) {
                    return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }
                onAdd(e) {
                    this.map = e, this.load();
                }
                reload() {
                    this.cancelTileJSONRequest(), this.load(()=>{
                        const e12 = this.map.style._getSourceCaches(this.id);
                        for (const t15 of e12)t15.clearTiles();
                    });
                }
                setSourceProperty(e) {
                    e(), this.reload();
                }
                setTiles(e) {
                    return this._options.tiles = e, this.reload(), this;
                }
                setUrl(e) {
                    return this.url = e, this._options.url = e, this.reload(), this;
                }
                onRemove() {
                    this.cancelTileJSONRequest();
                }
                serialize() {
                    return e1.extend({
                    }, this._options);
                }
                loadTile(t, i) {
                    const o20 = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)), r8 = {
                        request: this.map._requestManager.transformRequest(o20, e1.ResourceType.Tile),
                        data: void 0,
                        uid: t.uid,
                        tileID: t.tileID,
                        tileZoom: t.tileZoom,
                        zoom: t.tileID.overscaledZ,
                        tileSize: this.tileSize * t.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        pixelRatio: e1.exported.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId,
                        isSymbolTile: t.isSymbolTile
                    };
                    if (r8.request.collectResourceTiming = this._collectResourceTiming, t.actor && "expired" !== t.state) "loading" === t.state ? t.reloadCallback = i : t.request = t.actor.send("reloadTile", r8, n3.bind(this));
                    else if (t.actor = this._tileWorkers[o20] = this._tileWorkers[o20] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send("loadTile", r8, n3.bind(this), void 0, !0);
                    else {
                        const i21 = e1.loadVectorTile.call({
                            deduped: this._deduped
                        }, r8, (e12, i22)=>{
                            e12 || !i22 ? n3.call(this, e12) : (r8.data = {
                                cacheControl: i22.cacheControl,
                                expires: i22.expires,
                                rawData: i22.rawData.slice(0)
                            }, t.actor && t.actor.send("loadTile", r8, n3.bind(this), void 0, !0));
                        }, !0);
                        t.request = {
                            cancel: i21
                        };
                    }
                    function n3(o21, r9) {
                        return delete t.request, t.aborted ? i(null) : o21 && 404 !== o21.status ? i(o21) : (r9 && r9.resourceTiming && (t.resourceTiming = r9.resourceTiming), this.map._refreshExpiredTiles && r9 && t.setExpiryData(r9), t.loadVectorData(r9, this.map.painter), e1.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));
                    }
                }
                abortTile(e) {
                    e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
                        uid: e.uid,
                        type: this.type,
                        source: this.id
                    });
                }
                unloadTile(e) {
                    e.unloadVectorData(), e.actor && e.actor.send("removeTile", {
                        uid: e.uid,
                        type: this.type,
                        source: this.id
                    });
                }
                hasTransition() {
                    return !1;
                }
                afterUpdate() {
                    this._tileWorkers = {
                    };
                }
                cancelTileJSONRequest() {
                    this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
                }
            },
            raster: Me,
            "raster-dem": class extends Me {
                constructor(t15, i21, o20, r8){
                    super(t15, i21, o20, r8), this.type = "raster-dem", this.maxzoom = 22, this._options = e1.extend({
                        type: "raster-dem"
                    }, i21), this.encoding = i21.encoding || "mapbox";
                }
                loadTile(t, i) {
                    const o21 = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                    function r9(e12, o22) {
                        e12 && (t.state = "errored", i(e12)), o22 && (t.dem = o22, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = "loaded", i(null));
                    }
                    t.request = e1.getImage(this.map._requestManager.transformRequest(o21, e1.ResourceType.Tile), (function(o22, n3, s4, a9) {
                        if (delete t.request, t.aborted) t.state = "unloaded", i(null);
                        else if (o22) t.state = "errored", i(o22);
                        else if (n3) {
                            this.map._refreshExpiredTiles && t.setExpiryData({
                                cacheControl: s4,
                                expires: a9
                            });
                            const i22 = e1.window.ImageBitmap && n3 instanceof e1.window.ImageBitmap && (null == Se && (Se = e1.window.OffscreenCanvas && new e1.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e1.window.createImageBitmap), Se), o23 = 1 - (n3.width - e1.prevPowerOfTwo(n3.width)) / 2;
                            o23 < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID));
                            const l20 = i22 ? n3 : e1.exported.getImageData(n3, o23), c14 = {
                                uid: t.uid,
                                coord: t.tileID,
                                source: this.id,
                                rawImageData: l20,
                                encoding: this.encoding,
                                padding: o23
                            };
                            t.actor && "expired" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send("loadDEMTile", c14, r9.bind(this), void 0, !0));
                        }
                    }).bind(this));
                }
                _getNeighboringTiles(t) {
                    const i22 = t.canonical, o21 = Math.pow(2, i22.z), r9 = (i22.x - 1 + o21) % o21, n3 = 0 === i22.x ? t.wrap - 1 : t.wrap, s4 = (i22.x + 1 + o21) % o21, a9 = i22.x + 1 === o21 ? t.wrap + 1 : t.wrap, l20 = {
                    };
                    return l20[new e1.OverscaledTileID(t.overscaledZ, n3, i22.z, r9, i22.y).key] = {
                        backfilled: !1
                    }, l20[new e1.OverscaledTileID(t.overscaledZ, a9, i22.z, s4, i22.y).key] = {
                        backfilled: !1
                    }, i22.y > 0 && (l20[new e1.OverscaledTileID(t.overscaledZ, n3, i22.z, r9, i22.y - 1).key] = {
                        backfilled: !1
                    }, l20[new e1.OverscaledTileID(t.overscaledZ, t.wrap, i22.z, i22.x, i22.y - 1).key] = {
                        backfilled: !1
                    }, l20[new e1.OverscaledTileID(t.overscaledZ, a9, i22.z, s4, i22.y - 1).key] = {
                        backfilled: !1
                    }), i22.y + 1 < o21 && (l20[new e1.OverscaledTileID(t.overscaledZ, n3, i22.z, r9, i22.y + 1).key] = {
                        backfilled: !1
                    }, l20[new e1.OverscaledTileID(t.overscaledZ, t.wrap, i22.z, i22.x, i22.y + 1).key] = {
                        backfilled: !1
                    }, l20[new e1.OverscaledTileID(t.overscaledZ, a9, i22.z, s4, i22.y + 1).key] = {
                        backfilled: !1
                    }), l20;
                }
                unloadTile(e) {
                    e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded";
                }
            },
            geojson: class extends e1.Evented {
                constructor(t16, i22, o21, r9){
                    super(), this.id = t16, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o21.getActor(), this.setEventedParent(r9), this._data = i22.data, this._options = e1.extend({
                    }, i22), this._collectResourceTiming = i22.collectResourceTiming, (void 0) !== i22.maxzoom && (this.maxzoom = i22.maxzoom), i22.type && (this.type = i22.type), i22.attribution && (this.attribution = i22.attribution), this.promoteId = i22.promoteId;
                    const n3 = e1.EXTENT / this.tileSize;
                    this.workerOptions = e1.extend({
                        source: this.id,
                        cluster: i22.cluster || !1,
                        geojsonVtOptions: {
                            buffer: ((void 0) !== i22.buffer ? i22.buffer : 128) * n3,
                            tolerance: ((void 0) !== i22.tolerance ? i22.tolerance : 0.375) * n3,
                            extent: e1.EXTENT,
                            maxZoom: this.maxzoom,
                            lineMetrics: i22.lineMetrics || !1,
                            generateId: i22.generateId || !1
                        },
                        superclusterOptions: {
                            maxZoom: (void 0) !== i22.clusterMaxZoom ? i22.clusterMaxZoom : this.maxzoom - 1,
                            minPoints: Math.max(2, i22.clusterMinPoints || 2),
                            extent: e1.EXTENT,
                            radius: ((void 0) !== i22.clusterRadius ? i22.clusterRadius : 50) * n3,
                            log: !1,
                            generateId: i22.generateId || !1
                        },
                        clusterProperties: i22.clusterProperties,
                        filter: i22.filter
                    }, i22.workerOptions);
                }
                onAdd(e) {
                    this.map = e, this.setData(this._data);
                }
                setData(e) {
                    return this._data = e, this._updateWorkerData(), this;
                }
                getClusterExpansionZoom(e, t) {
                    return this.actor.send("geojson.getClusterExpansionZoom", {
                        clusterId: e,
                        source: this.id
                    }, t), this;
                }
                getClusterChildren(e, t) {
                    return this.actor.send("geojson.getClusterChildren", {
                        clusterId: e,
                        source: this.id
                    }, t), this;
                }
                getClusterLeaves(e, t, i, o) {
                    return this.actor.send("geojson.getClusterLeaves", {
                        source: this.id,
                        clusterId: e,
                        limit: t,
                        offset: i
                    }, o), this;
                }
                _updateWorkerData() {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(new e1.Event("dataloading", {
                        dataType: "source"
                    })), this._loaded = !1;
                    const t17 = e1.extend({
                    }, this.workerOptions), i23 = this._data;
                    "string" == typeof i23 ? (t17.request = this.map._requestManager.transformRequest(e1.exported.resolveURL(i23), e1.ResourceType.Source), t17.request.collectResourceTiming = this._collectResourceTiming) : t17.data = JSON.stringify(i23), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t17, (t18, i24)=>{
                        if (this._loaded = !0, this._pendingLoad = null, t18) this.fire(new e1.ErrorEvent(t18));
                        else {
                            const t19 = {
                                dataType: "source",
                                sourceDataType: this._metadataFired ? "content" : "metadata"
                            };
                            this._collectResourceTiming && i24 && i24.resourceTiming && i24.resourceTiming[this.id] && (t19.resourceTiming = i24.resourceTiming[this.id]), this.fire(new e1.Event("data", t19)), this._metadataFired = !0;
                        }
                        this._coalesce && (this._updateWorkerData(), this._coalesce = !1);
                    });
                }
                loaded() {
                    return this._loaded;
                }
                loadTile(t, i) {
                    const o22 = t.actor ? "reloadTile" : "loadTile";
                    t.actor = this.actor, t.request = this.actor.send(o22, {
                        type: this.type,
                        uid: t.uid,
                        tileID: t.tileID,
                        tileZoom: t.tileZoom,
                        zoom: t.tileID.overscaledZ,
                        maxZoom: this.maxzoom,
                        tileSize: this.tileSize,
                        source: this.id,
                        pixelRatio: e1.exported.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId
                    }, (e12, r10)=>(delete t.request, t.unloadVectorData(), t.aborted ? i(null) : e12 ? i(e12) : (t.loadVectorData(r10, this.map.painter, "reloadTile" === o22), i(null)))
                    , void 0, "loadTile" === o22);
                }
                abortTile(e) {
                    e.request && (e.request.cancel(), delete e.request), e.aborted = !0;
                }
                unloadTile(e) {
                    e.unloadVectorData(), this.actor.send("removeTile", {
                        uid: e.uid,
                        type: this.type,
                        source: this.id
                    });
                }
                onRemove() {
                    this._pendingLoad && this._pendingLoad.cancel();
                }
                serialize() {
                    return e1.extend({
                    }, this._options, {
                        type: this.type,
                        data: this._data
                    });
                }
                hasTransition() {
                    return !1;
                }
            },
            video: class extends Ae {
                constructor(e12, t17, i23, o22){
                    super(e12, t17, i23, o22), this.roundZoom = !0, this.type = "video", this.options = t17;
                }
                load() {
                    this._loaded = !1;
                    const t18 = this.options;
                    this.urls = [];
                    for (const i24 of t18.urls)this.urls.push(this.map._requestManager.transformRequest(i24, e1.ResourceType.Source).url);
                    e1.getVideo(this.urls, (t19, i25)=>{
                        this._loaded = !0, t19 ? this.fire(new e1.ErrorEvent(t19)) : i25 && (this.video = i25, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", ()=>{
                            this.map.triggerRepaint();
                        }), this.map && this.video.play(), this._finishLoading());
                    });
                }
                pause() {
                    this.video && this.video.pause();
                }
                play() {
                    this.video && this.video.play();
                }
                seek(t) {
                    if (this.video) {
                        const i24 = this.video.seekable;
                        t < i24.start(0) || t > i24.end(0) ? this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i24.start(0)} and ${i24.end(0)}-second mark.`))) : this.video.currentTime = t;
                    }
                }
                getVideo() {
                    return this.video;
                }
                onAdd(e) {
                    this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
                }
                prepare() {
                    if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
                    const t18 = this.map.painter.context, i24 = t18.gl;
                    this.texture ? this.video.paused || (this.texture.bind(i24.LINEAR, i24.CLAMP_TO_EDGE), i24.texSubImage2D(i24.TEXTURE_2D, 0, 0, 0, i24.RGBA, i24.UNSIGNED_BYTE, this.video)) : (this.texture = new e1.Texture(t18, this.video, i24.RGBA), this.texture.bind(i24.LINEAR, i24.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t18);
                }
                serialize() {
                    return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this.video && !this.video.paused;
                }
            },
            image: Ae,
            canvas: class extends Ae {
                constructor(t18, i24, o23, r10){
                    super(t18, i24, o23, r10), i24.coordinates ? Array.isArray(i24.coordinates) && 4 === i24.coordinates.length && !i24.coordinates.some((e13)=>!Array.isArray(e13) || 2 !== e13.length || e13.some((e15)=>"number" != typeof e15
                        )
                    ) || this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t18}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t18}`, null, 'missing required property "coordinates"'))), i24.animate && "boolean" != typeof i24.animate && this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t18}`, null, 'optional "animate" property must be a boolean value'))), i24.canvas ? "string" == typeof i24.canvas || i24.canvas instanceof e1.window.HTMLCanvasElement || this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t18}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e1.ErrorEvent(new e1.ValidationError(`sources.${t18}`, null, 'missing required property "canvas"'))), this.options = i24, this.animate = (void 0) === i24.animate || i24.animate;
                }
                load() {
                    this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof e1.window.HTMLCanvasElement ? this.options.canvas : e1.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e1.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                        this._playing = !0, this.map.triggerRepaint();
                    }, this.pause = function() {
                        this._playing && (this.prepare(), this._playing = !1);
                    }, this._finishLoading());
                }
                getCanvas() {
                    return this.canvas;
                }
                onAdd(e) {
                    this.map = e, this.load(), this.canvas && this.animate && this.play();
                }
                onRemove() {
                    this.pause();
                }
                prepare() {
                    let t19 = !1;
                    if (this.canvas.width !== this.width && (this.width = this.canvas.width, t19 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t19 = !0), this._hasInvalidDimensions()) return;
                    if (0 === Object.keys(this.tiles).length) return;
                    const i25 = this.map.painter.context;
                    this.texture ? (t19 || this._playing) && this.texture.update(this.canvas, {
                        premultiply: !0
                    }) : this.texture = new e1.Texture(i25, this.canvas, i25.gl.RGBA, {
                        premultiply: !0
                    }), this._prepareData(i25);
                }
                serialize() {
                    return {
                        type: "canvas",
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this._playing;
                }
                _hasInvalidDimensions() {
                    for (const e13 of [
                        this.canvas.width,
                        this.canvas.height
                    ])if (isNaN(e13) || e13 <= 0) return !0;
                    return !1;
                }
            },
            custom: class extends e1.Evented {
                constructor(t19, i25, o24, r11){
                    super(), this.id = t19, this.type = "custom", this._dataType = "raster", this._dispatcher = o24, this._implementation = i25, this.setEventedParent(r11), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e1.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e1.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new U(this._implementation.bounds, this.minzoom, this.maxzoom)), i25.update = this._update.bind(this), i25.clearTiles = this._clearTiles.bind(this), i25.coveringTiles = this._coveringTiles.bind(this), e1.extend(this, e1.pick(i25, [
                        "dataType",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution",
                        "minTileCacheSize",
                        "maxTileCacheSize"
                    ]));
                }
                serialize() {
                    return e1.pick(this, [
                        "type",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution"
                    ]);
                }
                load() {
                    this._loaded = !0, this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
                loaded() {
                    return this._loaded;
                }
                onAdd(t) {
                    this._map = t, this._loaded = !1, this.fire(new e1.Event("dataloading", {
                        dataType: "source"
                    })), this._implementation.onAdd && this._implementation.onAdd(t), this.load();
                }
                onRemove(e) {
                    this._implementation.onRemove && this._implementation.onRemove(e);
                }
                hasTile(e) {
                    if (this._implementation.hasTile) {
                        const { x: t20 , y: i26 , z: o25  } = e.canonical;
                        return this._implementation.hasTile({
                            x: t20,
                            y: i26,
                            z: o25
                        });
                    }
                    return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }
                loadTile(t, i) {
                    const { x: o25 , y: r12 , z: n6  } = t.tileID.canonical, s4 = new e1.window.AbortController;
                    t.request = Promise.resolve(this._implementation.loadTile({
                        x: o25,
                        y: r12,
                        z: n6
                    }, {
                        signal: s4.signal
                    })).then((function(o26) {
                        return delete t.request, t.aborted ? (t.state = "unloaded", i(null)) : (void 0) === o26 ? (t.state = "errored", i(null)) : null === o26 ? (this.loadTileData(t, {
                            width: this.tileSize,
                            height: this.tileSize,
                            data: null
                        }), t.state = "loaded", i(null)) : (function(t20) {
                            return t20 instanceof e1.window.ImageData || t20 instanceof e1.window.HTMLCanvasElement || t20 instanceof e1.window.ImageBitmap || t20 instanceof e1.window.HTMLImageElement;
                        })(o26) ? (this.loadTileData(t, o26), t.state = "loaded", void i(null)) : (t.state = "errored", i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
                    }).bind(this)).catch((e13)=>{
                        20 !== e13.code && (t.state = "errored", i(e13));
                    }), t.request.cancel = ()=>s4.abort()
                    ;
                }
                loadTileData(e, t) {
                    Me.loadTileData(e, t, this._map.painter);
                }
                unloadTileData(e) {
                    Me.unloadTileData(e, this._map.painter);
                }
                unloadTile(e, t) {
                    if (this.unloadTileData(e), this._implementation.unloadTile) {
                        const { x: t20 , y: i26 , z: o25  } = e.tileID.canonical;
                        this._implementation.unloadTile({
                            x: t20,
                            y: i26,
                            z: o25
                        });
                    }
                    t();
                }
                abortTile(e, t) {
                    e.request && e.request.cancel && (e.request.cancel(), delete e.request), t();
                }
                hasTransition() {
                    return !1;
                }
                _coveringTiles() {
                    return this._map.transform.coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom
                    }).map((e13)=>({
                            x: e13.canonical.x,
                            y: e13.canonical.y,
                            z: e13.canonical.z
                        })
                    );
                }
                _clearTiles() {
                    this._map.style._clearSource(this.id);
                }
                _update() {
                    this.fire(new e1.Event("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
            }
        }, ze = function(t14, i20, o19, r7) {
            const n3 = new Le[i20.type](t14, i20, o19, r7);
            if (n3.id !== t14) throw new Error(`Expected Source id to be ${t14} instead of ${n3.id}`);
            return e1.bindAll([
                "load",
                "abort",
                "unload",
                "serialize",
                "prepare"
            ], n3), n3;
        };
        function Pe(t14, i20) {
            const o19 = e1.identity([]);
            return e1.scale(o19, o19, [
                0.5 * t14.width,
                0.5 * -t14.height,
                1
            ]), e1.translate(o19, o19, [
                1,
                -1,
                0
            ]), e1.multiply(o19, o19, t14.calculateProjMatrix(i20.toUnwrapped())), Float32Array.from(o19);
        }
        function Re(e12, t14, i20, o19, r7, n3, s4, a9 = !1) {
            const l20 = e12.tilesIn(o19, s4, a9);
            l20.sort(Be);
            const c14 = [];
            for (const o20 of l20)c14.push({
                wrappedTileID: o20.tile.tileID.wrapped().key,
                queryResults: o20.tile.queryRenderedFeatures(t14, i20, e12._state, o20, r7, n3, Pe(e12.transform, o20.tile.tileID), a9)
            });
            const h13 = function(e13) {
                const t15 = {
                }, i21 = {
                };
                for (const o21 of e13){
                    const e15 = o21.queryResults, r8 = o21.wrappedTileID, n6 = i21[r8] = i21[r8] || {
                    };
                    for(const i22 in e15){
                        const o22 = e15[i22], r9 = n6[i22] = n6[i22] || {
                        }, s14 = t15[i22] = t15[i22] || [];
                        for (const e16 of o22)r9[e16.featureIndex] || (r9[e16.featureIndex] = !0, s14.push(e16));
                    }
                }
                return t15;
            }(c14);
            for(const t15 in h13)h13[t15].forEach((t16)=>{
                const i21 = t16.feature, o21 = i21.layer;
                o21 && "background" !== o21.type && "sky" !== o21.type && (i21.source = o21.source, o21["source-layer"] && (i21.sourceLayer = o21["source-layer"]), i21.state = (void 0) !== i21.id ? e12.getFeatureState(o21["source-layer"], i21.id) : {
                });
            });
            return h13;
        }
        function Oe(e12, t14) {
            const i20 = e12.getRenderableIds().map((t15)=>e12.getTileByID(t15)
            ), o19 = [], r7 = {
            };
            for(let e13 = 0; e13 < i20.length; e13++){
                const n3 = i20[e13], s4 = n3.tileID.canonical.key;
                r7[s4] || (r7[s4] = !0, n3.querySourceFeatures(o19, t14));
            }
            return o19;
        }
        function Be(e12, t14) {
            const i20 = e12.tileID, o19 = t14.tileID;
            return i20.overscaledZ - o19.overscaledZ || i20.canonical.y - o19.canonical.y || i20.wrap - o19.wrap || i20.canonical.x - o19.canonical.x;
        }
        function ke() {
            return null != pn.workerClass ? new pn.workerClass : new e1.window.Worker(pn.workerUrl);
        }
        const Fe = "mapboxgl_preloaded_worker_pool";
        class Ue {
            constructor(){
                this.active = {
                };
            }
            acquire(e) {
                if (!this.workers) for(this.workers = []; this.workers.length < Ue.workerCount;)this.workers.push(new ke);
                return this.active[e] = !0, this.workers.slice();
            }
            release(e) {
                delete this.active[e], 0 === this.numActive() && (this.workers.forEach((e12)=>{
                    e12.terminate();
                }), this.workers = null);
            }
            isPreloaded() {
                return !!this.active[Fe];
            }
            numActive() {
                return Object.keys(this.active).length;
            }
        }
        let Ne;
        function Ge() {
            return Ne || (Ne = new Ue), Ne;
        }
        function je(t14, i20) {
            const o19 = {
            };
            for(const e12 in t14)"ref" !== e12 && (o19[e12] = t14[e12]);
            return e1.refProperties.forEach((e13)=>{
                e13 in i20 && (o19[e13] = i20[e13]);
            }), o19;
        }
        function Ze(e12) {
            e12 = e12.slice();
            const t14 = Object.create(null);
            for(let i20 = 0; i20 < e12.length; i20++)t14[e12[i20].id] = e12[i20];
            for(let i21 = 0; i21 < e12.length; i21++)"ref" in e12[i21] && (e12[i21] = je(e12[i21], t14[e12[i21].ref]));
            return e12;
        }
        Ue.workerCount = 2;
        const Ve = {
            setStyle: "setStyle",
            addLayer: "addLayer",
            removeLayer: "removeLayer",
            setPaintProperty: "setPaintProperty",
            setLayoutProperty: "setLayoutProperty",
            setFilter: "setFilter",
            addSource: "addSource",
            removeSource: "removeSource",
            setGeoJSONSourceData: "setGeoJSONSourceData",
            setLayerZoomRange: "setLayerZoomRange",
            setLayerProperty: "setLayerProperty",
            setCenter: "setCenter",
            setZoom: "setZoom",
            setBearing: "setBearing",
            setPitch: "setPitch",
            setSprite: "setSprite",
            setGlyphs: "setGlyphs",
            setTransition: "setTransition",
            setLight: "setLight",
            setTerrain: "setTerrain",
            setFog: "setFog",
            setProjection: "setProjection"
        };
        function We(e12, t14, i20) {
            i20.push({
                command: Ve.addSource,
                args: [
                    e12,
                    t14[e12]
                ]
            });
        }
        function Xe(e12, t14, i20) {
            t14.push({
                command: Ve.removeSource,
                args: [
                    e12
                ]
            }), i20[e12] = !0;
        }
        function qe(e12, t14, i20, o19) {
            Xe(e12, i20, o19), We(e12, t14, i20);
        }
        function $e(e12, i20, o19) {
            let r7;
            for(r7 in e12[o19])if (e12[o19].hasOwnProperty(r7) && "data" !== r7 && !t1(e12[o19][r7], i20[o19][r7])) return !1;
            for(r7 in i20[o19])if (i20[o19].hasOwnProperty(r7) && "data" !== r7 && !t1(e12[o19][r7], i20[o19][r7])) return !1;
            return !0;
        }
        function He(e12, i20, o19, r7, n3, s4) {
            let a9;
            for(a9 in i20 = i20 || {
            }, e12 = e12 || {
            })e12.hasOwnProperty(a9) && (t1(e12[a9], i20[a9]) || o19.push({
                command: s4,
                args: [
                    r7,
                    a9,
                    i20[a9],
                    n3
                ]
            }));
            for(a9 in i20)i20.hasOwnProperty(a9) && !e12.hasOwnProperty(a9) && (t1(e12[a9], i20[a9]) || o19.push({
                command: s4,
                args: [
                    r7,
                    a9,
                    i20[a9],
                    n3
                ]
            }));
        }
        function Ye(e12) {
            return e12.id;
        }
        function Ke(e12, t14) {
            return e12[t14.id] = t14, e12;
        }
        class Je {
            constructor(e12, t14){
                this.reset(e12, t14);
            }
            reset(e, t) {
                this.points = e || [], this._distances = [
                    0
                ];
                for(let e13 = 1; e13 < this.points.length; e13++)this._distances[e13] = this._distances[e13 - 1] + this.points[e13].dist(this.points[e13 - 1]);
                this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(t) {
                if (1 === this.points.length) return this.points[0];
                t = e1.clamp(t, 0, 1);
                let i20 = 1, o19 = this._distances[i20];
                const r7 = t * this.paddedLength + this.padding;
                for(; o19 < r7 && i20 < this._distances.length;)o19 = this._distances[++i20];
                const n3 = i20 - 1, s4 = this._distances[n3], a9 = o19 - s4, l20 = a9 > 0 ? (r7 - s4) / a9 : 0;
                return this.points[n3].mult(1 - l20).add(this.points[i20].mult(l20));
            }
        }
        class Qe {
            constructor(e13, t15, i20){
                const o19 = this.boxCells = [], r7 = this.circleCells = [];
                this.xCellCount = Math.ceil(e13 / i20), this.yCellCount = Math.ceil(t15 / i20);
                for(let e15 = 0; e15 < this.xCellCount * this.yCellCount; e15++)o19.push([]), r7.push([]);
                this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e13, this.height = t15, this.xScale = this.xCellCount / e13, this.yScale = this.yCellCount / t15, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e, t, i, o, r) {
                this._forEachCell(t, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);
            }
            insertCircle(e, t, i, o) {
                this._forEachCell(t - o, i - o, t + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(o);
            }
            _insertBoxCell(e, t, i, o, r, n) {
                this.boxCells[r].push(n);
            }
            _insertCircleCell(e, t, i, o, r, n) {
                this.circleCells[r].push(n);
            }
            _query(e, t, i, o, r, n) {
                if (i < 0 || e > this.width || o < 0 || t > this.height) return !r && [];
                const s4 = [];
                if (e <= 0 && t <= 0 && this.width <= i && this.height <= o) {
                    if (r) return !0;
                    for(let e16 = 0; e16 < this.boxKeys.length; e16++)s4.push({
                        key: this.boxKeys[e16],
                        x1: this.bboxes[4 * e16],
                        y1: this.bboxes[4 * e16 + 1],
                        x2: this.bboxes[4 * e16 + 2],
                        y2: this.bboxes[4 * e16 + 3]
                    });
                    for(let e17 = 0; e17 < this.circleKeys.length; e17++){
                        const t16 = this.circles[3 * e17], i21 = this.circles[3 * e17 + 1], o20 = this.circles[3 * e17 + 2];
                        s4.push({
                            key: this.circleKeys[e17],
                            x1: t16 - o20,
                            y1: i21 - o20,
                            x2: t16 + o20,
                            y2: i21 + o20
                        });
                    }
                    return n ? s4.filter(n) : s4;
                }
                return this._forEachCell(e, t, i, o, this._queryCell, s4, {
                    hitTest: r,
                    seenUids: {
                        box: {
                        },
                        circle: {
                        }
                    }
                }, n), r ? s4.length > 0 : s4;
            }
            _queryCircle(e, t, i, o, r) {
                const n3 = e - i, s4 = e + i, a9 = t - i, l20 = t + i;
                if (s4 < 0 || n3 > this.width || l20 < 0 || a9 > this.height) return !o && [];
                const c14 = [];
                return this._forEachCell(n3, a9, s4, l20, this._queryCellCircle, c14, {
                    hitTest: o,
                    circle: {
                        x: e,
                        y: t,
                        radius: i
                    },
                    seenUids: {
                        box: {
                        },
                        circle: {
                        }
                    }
                }, r), o ? c14.length > 0 : c14;
            }
            query(e, t, i, o, r) {
                return this._query(e, t, i, o, !1, r);
            }
            hitTest(e, t, i, o, r) {
                return this._query(e, t, i, o, !0, r);
            }
            hitTestCircle(e, t, i, o) {
                return this._queryCircle(e, t, i, !0, o);
            }
            _queryCell(e, t, i, o, r, n, s, a) {
                const l20 = s.seenUids, c14 = this.boxCells[r];
                if (null !== c14) {
                    const r8 = this.bboxes;
                    for (const h13 of c14)if (!l20.box[h13]) {
                        l20.box[h13] = !0;
                        const c15 = 4 * h13;
                        if (e <= r8[c15 + 2] && t <= r8[c15 + 3] && i >= r8[c15 + 0] && o >= r8[c15 + 1] && (!a || a(this.boxKeys[h13]))) {
                            if (s.hitTest) return n.push(!0), !0;
                            n.push({
                                key: this.boxKeys[h13],
                                x1: r8[c15],
                                y1: r8[c15 + 1],
                                x2: r8[c15 + 2],
                                y2: r8[c15 + 3]
                            });
                        }
                    }
                }
                const h13 = this.circleCells[r];
                if (null !== h13) {
                    const r8 = this.circles;
                    for (const c15 of h13)if (!l20.circle[c15]) {
                        l20.circle[c15] = !0;
                        const h14 = 3 * c15;
                        if (this._circleAndRectCollide(r8[h14], r8[h14 + 1], r8[h14 + 2], e, t, i, o) && (!a || a(this.circleKeys[c15]))) {
                            if (s.hitTest) return n.push(!0), !0;
                            {
                                const e16 = r8[h14], t16 = r8[h14 + 1], i21 = r8[h14 + 2];
                                n.push({
                                    key: this.circleKeys[c15],
                                    x1: e16 - i21,
                                    y1: t16 - i21,
                                    x2: e16 + i21,
                                    y2: t16 + i21
                                });
                            }
                        }
                    }
                }
            }
            _queryCellCircle(e, t, i, o, r, n, s, a) {
                const l20 = s.circle, c14 = s.seenUids, h13 = this.boxCells[r];
                if (null !== h13) {
                    const e16 = this.bboxes;
                    for (const t16 of h13)if (!c14.box[t16]) {
                        c14.box[t16] = !0;
                        const i21 = 4 * t16;
                        if (this._circleAndRectCollide(l20.x, l20.y, l20.radius, e16[i21 + 0], e16[i21 + 1], e16[i21 + 2], e16[i21 + 3]) && (!a || a(this.boxKeys[t16]))) return n.push(!0), !0;
                    }
                }
                const u16 = this.circleCells[r];
                if (null !== u16) {
                    const e16 = this.circles;
                    for (const t16 of u16)if (!c14.circle[t16]) {
                        c14.circle[t16] = !0;
                        const i21 = 3 * t16;
                        if (this._circlesCollide(e16[i21], e16[i21 + 1], e16[i21 + 2], l20.x, l20.y, l20.radius) && (!a || a(this.circleKeys[t16]))) return n.push(!0), !0;
                    }
                }
            }
            _forEachCell(e, t, i, o, r, n, s, a) {
                const l20 = this._convertToXCellCoord(e), c14 = this._convertToYCellCoord(t), h13 = this._convertToXCellCoord(i), u16 = this._convertToYCellCoord(o);
                for(let _1 = l20; _1 <= h13; _1++)for(let l21 = c14; l21 <= u16; l21++)if (r.call(this, e, t, i, o, this.xCellCount * l21 + _1, n, s, a)) return;
            }
            _convertToXCellCoord(e) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
            }
            _convertToYCellCoord(e) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
            }
            _circlesCollide(e, t, i, o, r, n) {
                const s4 = o - e, a9 = r - t, l20 = i + n;
                return l20 * l20 > s4 * s4 + a9 * a9;
            }
            _circleAndRectCollide(e, t, i, o, r, n, s) {
                const a9 = (n - o) / 2, l20 = Math.abs(e - (o + a9));
                if (l20 > a9 + i) return !1;
                const c14 = (s - r) / 2, h13 = Math.abs(t - (r + c14));
                if (h13 > c14 + i) return !1;
                if (l20 <= a9 || h13 <= c14) return !0;
                const u16 = l20 - a9, _1 = h13 - c14;
                return u16 * u16 + _1 * _1 <= i * i;
            }
        }
        const et = Math.tan(85 * Math.PI / 180);
        function tt(t16, i21, o20, r8, n3, s4, a9) {
            const l20 = e1.create();
            if (o20) {
                if ("globe" === s4.name) {
                    const t17 = e1.calculateGlobeLabelMatrix(n3, i21);
                    e1.multiply(l20, l20, t17);
                } else {
                    const t17 = v3([], a9);
                    l20[0] = t17[0], l20[1] = t17[1], l20[4] = t17[2], l20[5] = t17[3], r8 || e1.rotateZ(l20, l20, n3.angle);
                }
            } else e1.multiply(l20, n3.labelPlaneMatrix, t16);
            return l20;
        }
        function it(e16, t16, i21, o20, r8, n3, s4) {
            const a9 = tt(e16, t16, i21, o20, r8, n3, s4);
            return "globe" === n3.name && i21 || (a9[2] = a9[6] = a9[10] = a9[14] = 0), a9;
        }
        function ot(t16, i21, o20, r8, n3, s4, a9) {
            if (o20) {
                if ("globe" === s4.name) {
                    const l20 = tt(t16, i21, o20, r8, n3, s4, a9);
                    return e1.invert(l20, l20), e1.multiply(l20, t16, l20), l20;
                }
                {
                    const i22 = e1.clone(t16), o21 = e1.identity([]);
                    return o21[0] = a9[0], o21[1] = a9[1], o21[4] = a9[2], o21[5] = a9[3], e1.multiply(i22, i22, o21), r8 || e1.rotateZ(i22, i22, -n3.angle), i22;
                }
            }
            return n3.glCoordMatrix;
        }
        function rt(t16, i21, o20, r8) {
            const n3 = [
                t16,
                i21,
                o20,
                1
            ];
            o20 ? e1.transformMat4$1(n3, n3, r8) : mt(n3, n3, r8);
            const s4 = n3[3];
            return n3[0] /= s4, n3[1] /= s4, n3[2] /= s4, n3;
        }
        function nt(e16, t16) {
            return Math.min(0.5 + e16 / t16 * 0.5, 1.5);
        }
        function st(e16, t16) {
            const i21 = e16[0] / e16[3], o20 = e16[1] / e16[3];
            return i21 >= -t16[0] && i21 <= t16[0] && o20 >= -t16[1] && o20 <= t16[1];
        }
        function at(t16, i21, o20, r8, n3, s4, a9, l20, c14, h13) {
            const u16 = o20.transform, _1 = r8 ? t16.textSizeData : t16.iconSizeData, d7 = e1.evaluateSizeForZoom(_1, o20.transform.zoom), p10 = "globe" === u16.projection.name, m6 = [
                256 / o20.width * 2 + 1,
                256 / o20.height * 2 + 1
            ], f9 = r8 ? t16.text.dynamicLayoutVertexArray : t16.icon.dynamicLayoutVertexArray;
            f9.clear();
            let g6 = null;
            p10 && (g6 = r8 ? t16.text.globeExtVertexArray : t16.icon.globeExtVertexArray);
            const v4 = t16.lineVertexArray, x4 = r8 ? t16.text.placedSymbolArray : t16.icon.placedSymbolArray, y5 = o20.transform.width / o20.transform.height;
            let b3, w4 = !1;
            for(let r9 = 0; r9 < x4.length; r9++){
                const p11 = x4.get(r9), { numGlyphs: T1 , writingMode: E1  } = p11;
                if (E1 !== e1.WritingMode.vertical || w4 || b3 === e1.WritingMode.horizontal || (w4 = !0), b3 = E1, (p11.hidden || E1 === e1.WritingMode.vertical) && !w4) {
                    pt(T1, f9);
                    continue;
                }
                w4 = !1;
                const C1 = new e1.pointGeometry(p11.tileAnchorX, p11.tileAnchorY);
                let { x: I1 , y: M3 , z: S3  } = u16.projection.projectTilePoint(C1.x, C1.y, h13.canonical);
                if (c14) {
                    const [e16, t17, i22] = c14(C1);
                    I1 += e16, M3 += t17, S3 += i22;
                }
                const D1 = [
                    I1,
                    M3,
                    S3,
                    1
                ];
                if (e1.transformMat4$1(D1, D1, i21), !st(D1, m6)) {
                    pt(T1, f9);
                    continue;
                }
                const A1 = nt(o20.transform.cameraToCenterDistance, D1[3]), L1 = e1.evaluateSizeForFeature(_1, d7, p11), z1 = a9 ? L1 / A1 : L1 * A1, P3 = rt(I1, M3, S3, n3);
                if (P3[3] <= 0) {
                    pt(T1, f9);
                    continue;
                }
                let R1 = {
                };
                const O1 = a9 ? null : c14, B1 = ht(p11, z1, !1, l20, i21, n3, s4, t16.glyphOffsetArray, v4, f9, g6, P3, C1, R1, y5, O1, u16.projection, h13, a9);
                w4 = B1.useVertical, O1 && B1.needsFlipping && (R1 = {
                }), (B1.notEnoughRoom || w4 || B1.needsFlipping && ht(p11, z1, !0, l20, i21, n3, s4, t16.glyphOffsetArray, v4, f9, g6, P3, C1, R1, y5, O1, u16.projection, h13, a9).notEnoughRoom) && pt(T1, f9);
            }
            r8 ? (t16.text.dynamicLayoutVertexBuffer.updateData(f9), g6 && t16.text.globeExtVertexBuffer.updateData(g6)) : (t16.icon.dynamicLayoutVertexBuffer.updateData(f9), g6 && t16.icon.globeExtVertexBuffer.updateData(g6));
        }
        function lt(e16, t16, i21, o20, r8, n3, s4, a9, l20, c14, h13, u16, _1, d7, p10, m6) {
            const { lineStartIndex: f9 , glyphStartIndex: g6 , segment: v4  } = a9, x4 = g6 + a9.numGlyphs, y5 = f9 + a9.lineLength, b3 = t16.getoffsetX(g6), w4 = t16.getoffsetX(x4 - 1), T1 = dt(e16 * b3, i21, o20, r8, n3, s4, v4, f9, y5, l20, c14, h13, u16, _1, !0, d7, p10, m6);
            if (!T1) return null;
            const E1 = dt(e16 * w4, i21, o20, r8, n3, s4, v4, f9, y5, l20, c14, h13, u16, _1, !0, d7, p10, m6);
            return E1 ? {
                first: T1,
                last: E1
            } : null;
        }
        function ct(t16, i21, o20, r8) {
            return t16 === e1.WritingMode.horizontal && Math.abs(r8) > Math.abs(o20) ? {
                useVertical: !0
            } : t16 === e1.WritingMode.vertical ? r8 > 0 ? {
                needsFlipping: !0
            } : null : 0 !== i21 && (function(e16, t17) {
                return 0 === e16 || Math.abs(t17 / e16) > et;
            })(o20, r8) ? 1 === i21 ? {
                needsFlipping: !0
            } : null : o20 < 0 ? {
                needsFlipping: !0
            } : null;
        }
        function ht(t16, i21, o20, r8, n3, s4, a9, l20, c14, h13, u16, _1, d7, p10, m6, f9, g6, v4, x4) {
            const y5 = i21 / 24, b3 = t16.lineOffsetX * y5, w4 = t16.lineOffsetY * y5, { lineStartIndex: T1 , glyphStartIndex: E1 , numGlyphs: C1 , segment: I1 , writingMode: M3 , flipState: S3  } = t16, D1 = T1 + t16.lineLength, A1 = (t17)=>{
                if (u16) {
                    const [i22, o21, r9] = t17.up, n6 = h13.length;
                    e1.updateGlobeVertexNormal(u16, n6 + 0, i22, o21, r9), e1.updateGlobeVertexNormal(u16, n6 + 1, i22, o21, r9), e1.updateGlobeVertexNormal(u16, n6 + 2, i22, o21, r9), e1.updateGlobeVertexNormal(u16, n6 + 3, i22, o21, r9);
                }
                const [i22, o21, r9] = t17.point;
                e1.addDynamicAttributes(h13, i22, o21, r9, t17.angle);
            };
            if (C1 > 1) {
                const e16 = lt(y5, l20, b3, w4, o20, _1, d7, t16, c14, s4, p10, f9, !1, g6, v4, x4);
                if (!e16) return {
                    notEnoughRoom: !0
                };
                if (r8 && !o20) {
                    let [i22, o21, r9] = e16.first.point, [n6, s14, l21] = e16.last.point;
                    [i22, o21] = rt(i22, o21, r9, a9), [n6, s14] = rt(n6, s14, l21, a9);
                    const c15 = ct(M3, S3, (n6 - i22) * m6, s14 - o21);
                    if (t16.flipState = c15 && c15.needsFlipping ? 1 : 2, c15) return c15;
                }
                A1(e16.first);
                for(let e17 = E1 + 1; e17 < E1 + C1 - 1; e17++){
                    const t17 = dt(y5 * l20.getoffsetX(e17), b3, w4, o20, _1, d7, I1, T1, D1, c14, s4, p10, f9, !1, !1, g6, v4, x4);
                    if (!t17) return h13.length -= 4 * (e17 - E1), {
                        notEnoughRoom: !0
                    };
                    A1(t17);
                }
                A1(e16.last);
            } else {
                if (r8 && !o20) {
                    const i22 = rt(d7.x, d7.y, 0, n3), o21 = T1 + I1 + 1, r9 = new e1.pointGeometry(c14.getx(o21), c14.gety(o21)), s14 = rt(r9.x, r9.y, 0, n3), a14 = s14[3] > 0 ? s14 : _t(d7, r9, i22, 1, n3, void 0, g6, v4.canonical), l21 = ct(M3, S3, (a14[0] - i22[0]) * m6, a14[1] - i22[1]);
                    if (t16.flipState = l21 && l21.needsFlipping ? 1 : 2, l21) return l21;
                }
                const i22 = dt(y5 * l20.getoffsetX(E1), b3, w4, o20, _1, d7, I1, T1, D1, c14, s4, p10, f9, !1, !1, g6, v4, x4);
                if (!i22) return {
                    notEnoughRoom: !0
                };
                A1(i22);
            }
            return {
            };
        }
        function ut(e16, t16, i21, o20, r8) {
            const { x: n3 , y: s4 , z: a9  } = o20.projectTilePoint(e16.x, e16.y, t16);
            if (!r8) return rt(n3, s4, a9, i21);
            const [l20, c14, h13] = r8(e16);
            return rt(n3 + l20, s4 + c14, a9 + h13, i21);
        }
        function _t(t16, i21, o20, r8, n3, s4, a9, l20) {
            const c14 = ut(t16.sub(i21)._unit()._add(t16), l20, n3, a9, s4);
            return e1.sub(c14, o20, c14), e1.normalize(c14, c14), e1.scaleAndAdd(c14, o20, c14, r8);
        }
        function dt(t16, i21, o20, r8, n3, s4, a9, l20, c14, h13, u16, _1, d7, p10, m6, f9, g6, v4) {
            const x4 = r8 ? t16 - i21 : t16 + i21;
            let y5 = x4 > 0 ? 1 : -1, b3 = 0;
            r8 && (y5 *= -1, b3 = Math.PI), y5 < 0 && (b3 += Math.PI);
            let w4 = l20 + a9 + (y5 > 0 ? 0 : 1) | 0, T1 = n3, E1 = n3, C1 = 0, I1 = 0;
            const M3 = Math.abs(x4), S3 = [], D1 = [];
            let A1 = s4, L1 = A1;
            const z1 = ()=>_t(L1, A1, E1, M3 - C1 + 1, u16, d7, f9, g6.canonical)
            ;
            for(; C1 + I1 <= M3;){
                if (w4 += y5, w4 < l20 || w4 >= c14) return null;
                if (E1 = T1, L1 = A1, S3.push(E1), p10 && D1.push(L1), A1 = new e1.pointGeometry(h13.getx(w4), h13.gety(w4)), T1 = _1[w4], !T1) {
                    const e16 = ut(A1, g6.canonical, u16, f9, d7);
                    T1 = e16[3] > 0 ? _1[w4] = e16 : z1();
                }
                C1 += I1, I1 = e1.distance(E1, T1);
            }
            m6 && d7 && (_1[w4] && (T1 = z1(), I1 = e1.distance(E1, T1)), _1[w4] = T1);
            const P3 = (M3 - C1) / I1, R1 = A1.sub(L1)._mult(P3)._add(L1), O1 = e1.sub([], T1, E1), B1 = e1.scaleAndAdd([], E1, O1, P3);
            let k1 = [
                0,
                0,
                1
            ], F1 = O1[0], U1 = O1[1];
            if (v4 && (k1 = f9.upVector(g6.canonical, R1.x, R1.y), 0 !== k1[0] || 0 !== k1[1] || 1 !== k1[2])) {
                const t17 = [
                    k1[2],
                    0,
                    -k1[0]
                ], i22 = e1.cross([], k1, t17);
                e1.normalize(t17, t17), e1.normalize(i22, i22), F1 = e1.dot(O1, t17), U1 = e1.dot(O1, i22);
            }
            if (o20) {
                const t17 = e1.cross([], k1, O1);
                e1.normalize(t17, t17), e1.scaleAndAdd(B1, B1, t17, o20 * y5);
            }
            const N1 = b3 + Math.atan2(U1, F1);
            return S3.push(B1), p10 && D1.push(R1), {
                point: B1,
                angle: N1,
                path: S3,
                tilePath: D1,
                up: k1
            };
        }
        function pt(e16, t16) {
            const i21 = t16.length, o20 = i21 + 4 * e16;
            t16.resize(o20), t16.float32.fill(-1 / 0, 4 * i21, 4 * o20);
        }
        function mt(e16, t16, i21) {
            const o20 = t16[0], r8 = t16[1];
            return e16[0] = i21[0] * o20 + i21[4] * r8 + i21[12], e16[1] = i21[1] * o20 + i21[5] * r8 + i21[13], e16[3] = i21[3] * o20 + i21[7] * r8 + i21[15], e16;
        }
        const ft = 100;
        class gt {
            constructor(e16, t16, i21 = new Qe(e16.width + 200, e16.height + 200, 25), o20 = new Qe(e16.width + 200, e16.height + 200, 25)){
                this.transform = e16, this.grid = i21, this.ignoredGrid = o20, this.pitchfactor = Math.cos(e16._pitch) * e16.cameraToCenterDistance, this.screenRightBoundary = e16.width + ft, this.screenBottomBoundary = e16.height + ft, this.gridRightBoundary = e16.width + 200, this.gridBottomBoundary = e16.height + 200, this.fogState = t16;
            }
            placeCollisionBox(e, t, i, o, r, n, s, a) {
                let l20 = i.projectedAnchorX, c14 = i.projectedAnchorY, h13 = i.projectedAnchorZ;
                const u16 = i.elevation, _1 = i.tileID, d7 = e.getProjection();
                if (u16 && _1) {
                    const [e17, t17, o21] = d7.upVector(_1.canonical, i.tileAnchorX, i.tileAnchorY), r8 = d7.upVectorScale(_1.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                    l20 += e17 * u16 * r8, c14 += t17 * u16 * r8, h13 += o21 * u16 * r8;
                }
                const p10 = this.projectAndGetPerspectiveRatio(s, l20, c14, h13, i.tileID, "globe" === d7.name || !!u16 || this.transform.pitch > 0, d7), m6 = n * p10.perspectiveRatio, f9 = (i.x1 * t + o.x - i.padding) * m6 + p10.point.x, g6 = (i.y1 * t + o.y - i.padding) * m6 + p10.point.y, v4 = (i.x2 * t + o.x + i.padding) * m6 + p10.point.x, x4 = (i.y2 * t + o.y + i.padding) * m6 + p10.point.y, y5 = p10.perspectiveRatio <= 0.55 || p10.occluded;
                return !this.isInsideGrid(f9, g6, v4, x4) || !r && this.grid.hitTest(f9, g6, v4, x4, a) || y5 ? {
                    box: [],
                    offscreen: !1,
                    occluded: p10.occluded
                } : {
                    box: [
                        f9,
                        g6,
                        v4,
                        x4
                    ],
                    offscreen: this.isOffscreen(f9, g6, v4, x4),
                    occluded: !1
                };
            }
            placeCollisionCircles(t, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {
                const f9 = [], g6 = this.transform.elevation, v4 = t.getProjection(), x4 = g6 ? g6.getAtTileOffsetFunc(m, this.transform.center.lat, this.transform.worldSize, v4) : null, y5 = new e1.pointGeometry(o.tileAnchorX, o.tileAnchorY);
                let { x: b3 , y: w4 , z: T1  } = v4.projectTilePoint(y5.x, y5.y, m.canonical);
                if (x4) {
                    const [e17, t17, i22] = x4(y5);
                    b3 += e17, w4 += t17, T1 += i22;
                }
                const E1 = "globe" === v4.name, C1 = this.projectAndGetPerspectiveRatio(a, b3, w4, T1, m, E1 || !!g6 || this.transform.pitch > 0, v4), { perspectiveRatio: I1  } = C1, M3 = (u ? s / I1 : s * I1) / e1.ONE_EM, S3 = rt(b3, w4, T1, l), D1 = C1.signedDistanceFromCamera > 0 ? lt(M3, n, o.lineOffsetX * M3, o.lineOffsetY * M3, !1, S3, y5, o, r, l, {
                }, g6 && !u ? x4 : null, u && !!g6, v4, m, u) : null;
                let A1 = !1, L1 = !1, z1 = !0;
                if (D1 && !C1.occluded) {
                    const t17 = 0.5 * d * I1 + p, o21 = new e1.pointGeometry(-100, -100), r8 = new e1.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), n3 = new Je, { first: s4 , last: a9  } = D1, l20 = s4.path.length;
                    let u16 = [];
                    for(let e17 = l20 - 1; e17 >= 1; e17--)u16.push(s4.path[e17]);
                    for(let e18 = 1; e18 < a9.path.length; e18++)u16.push(a9.path[e18]);
                    const m6 = 2.5 * t17;
                    c && (u16 = u16.map(([e19, t18, i22], o22)=>(x4 && !E1 && (i22 = x4(o22 < l20 - 1 ? s4.tilePath[l20 - 1 - o22] : a9.tilePath[o22 - l20 + 2])[2]), rt(e19, t18, i22, c))
                    ), u16.some((e19)=>e19[3] <= 0
                    ) && (u16 = []));
                    let g7 = [];
                    if (u16.length > 0) {
                        let t18 = 1 / 0, i22 = -1 / 0, n6 = 1 / 0, s14 = -1 / 0;
                        for (const e19 of u16)t18 = Math.min(t18, e19[0]), n6 = Math.min(n6, e19[1]), i22 = Math.max(i22, e19[0]), s14 = Math.max(s14, e19[1]);
                        i22 >= o21.x && t18 <= r8.x && s14 >= o21.y && n6 <= r8.y && (g7 = [
                            u16.map((t19)=>new e1.pointGeometry(t19[0], t19[1])
                            )
                        ], (t18 < o21.x || i22 > r8.x || n6 < o21.y || s14 > r8.y) && (g7 = e1.clipLine(g7, o21.x, o21.y, r8.x, r8.y)));
                    }
                    for (const e19 of g7){
                        n3.reset(e19, 0.25 * t17);
                        let o22 = 0;
                        o22 = n3.length <= 0.5 * t17 ? 1 : Math.ceil(n3.paddedLength / m6) + 1;
                        for(let e20 = 0; e20 < o22; e20++){
                            const r9 = e20 / Math.max(o22 - 1, 1), s14 = n3.lerp(r9), a14 = s14.x + ft, l21 = s14.y + ft;
                            f9.push(a14, l21, t17, 0);
                            const c14 = a14 - t17, u17 = l21 - t17, d7 = a14 + t17, p10 = l21 + t17;
                            if (z1 = z1 && this.isOffscreen(c14, u17, d7, p10), L1 = L1 || this.isInsideGrid(c14, u17, d7, p10), !i && this.grid.hitTestCircle(a14, l21, t17, _) && (A1 = !0, !h)) return {
                                circles: [],
                                offscreen: !1,
                                collisionDetected: A1,
                                occluded: !1
                            };
                        }
                    }
                }
                return {
                    circles: !h && A1 || !L1 ? [] : f9,
                    offscreen: z1,
                    collisionDetected: A1,
                    occluded: C1.occluded
                };
            }
            queryRenderedSymbols(t) {
                if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {
                };
                const i22 = [];
                let o21 = 1 / 0, r8 = 1 / 0, n3 = -1 / 0, s4 = -1 / 0;
                for (const a9 of t){
                    const t17 = new e1.pointGeometry(a9.x + ft, a9.y + ft);
                    o21 = Math.min(o21, t17.x), r8 = Math.min(r8, t17.y), n3 = Math.max(n3, t17.x), s4 = Math.max(s4, t17.y), i22.push(t17);
                }
                const a14 = this.grid.query(o21, r8, n3, s4).concat(this.ignoredGrid.query(o21, r8, n3, s4)), l20 = {
                }, c14 = {
                };
                for (const t17 of a14){
                    const o22 = t17.key;
                    if ((void 0) === l20[o22.bucketInstanceId] && (l20[o22.bucketInstanceId] = {
                    }), l20[o22.bucketInstanceId][o22.featureIndex]) continue;
                    const r9 = [
                        new e1.pointGeometry(t17.x1, t17.y1),
                        new e1.pointGeometry(t17.x2, t17.y1),
                        new e1.pointGeometry(t17.x2, t17.y2),
                        new e1.pointGeometry(t17.x1, t17.y2)
                    ];
                    e1.polygonIntersectsPolygon(i22, r9) && (l20[o22.bucketInstanceId][o22.featureIndex] = !0, (void 0) === c14[o22.bucketInstanceId] && (c14[o22.bucketInstanceId] = []), c14[o22.bucketInstanceId].push(o22.featureIndex));
                }
                return c14;
            }
            insertCollisionBox(e, t, i, o, r) {
                (t ? this.ignoredGrid : this.grid).insert({
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: r
                }, e[0], e[1], e[2], e[3]);
            }
            insertCollisionCircles(e, t, i, o, r) {
                const n3 = t ? this.ignoredGrid : this.grid, s4 = {
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: r
                };
                for(let t17 = 0; t17 < e.length; t17 += 4)n3.insertCircle(s4, e[t17], e[t17 + 1], e[t17 + 2]);
            }
            projectAndGetPerspectiveRatio(t, i, o, r, n, s, a) {
                const l20 = [
                    i,
                    o,
                    r,
                    1
                ];
                let c14 = !1;
                if (r || this.transform.pitch > 0) {
                    e1.transformMat4$1(l20, l20, t);
                    const s4 = "globe" === a.name;
                    if (this.fogState && n && !s4) {
                        const t17 = function(t18, i22, o21, r8, n3, s14) {
                            const a9 = s14.calculateFogTileMatrix(n3), l21 = [
                                i22,
                                o21,
                                r8
                            ];
                            return e1.transformMat4(l21, l21, a9), M2(t18, l21, s14.pitch, s14._fov);
                        }(this.fogState, i, o, r, n.toUnwrapped(), this.transform);
                        c14 = t17 > 0.9;
                    }
                } else mt(l20, l20, t);
                const h13 = l20[3];
                return {
                    point: new e1.pointGeometry((l20[0] / h13 + 1) / 2 * this.transform.width + ft, (-l20[1] / h13 + 1) / 2 * this.transform.height + ft),
                    perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a) / h13 * 0.5, 1.5),
                    signedDistanceFromCamera: h13,
                    occluded: s && l20[2] > h13 || c14
                };
            }
            isOffscreen(e, t, i, o) {
                return i < ft || e >= this.screenRightBoundary || o < ft || t > this.screenBottomBoundary;
            }
            isInsideGrid(e, t, i, o) {
                return i >= 0 && e < this.gridRightBoundary && o >= 0 && t < this.gridBottomBoundary;
            }
            getViewportMatrix() {
                const t17 = e1.identity([]);
                return e1.translate(t17, t17, [
                    -100,
                    -100,
                    0
                ]), t17;
            }
        }
        function vt(t17, i22, o21) {
            const r8 = i22.createTileMatrix(t17, t17.worldSize, o21.toUnwrapped());
            return e1.multiply(new Float32Array(16), t17.projMatrix, r8);
        }
        function xt(e17, t17, i22) {
            if (t17.projection.name === i22.projection.name) return e17.projMatrix;
            const o21 = i22.clone();
            return o21.setProjection(t17.projection), vt(o21, t17.getProjection(), e17);
        }
        function yt(e17, t17, i22) {
            return t17.name === i22.projection.name ? e17.projMatrix : vt(i22, t17, e17);
        }
        class bt {
            constructor(e17, t17, i22, o21){
                this.opacity = e17 ? Math.max(0, Math.min(1, e17.opacity + (e17.placed ? t17 : -t17))) : o21 && i22 ? 1 : 0, this.placed = i22;
            }
            isHidden() {
                return 0 === this.opacity && !this.placed;
            }
        }
        class wt {
            constructor(e18, t18, i23, o22, r8, n3 = !1){
                this.text = new bt(e18 ? e18.text : null, t18, i23, r8), this.icon = new bt(e18 ? e18.icon : null, t18, o22, r8), this.clipped = n3;
            }
            isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
            }
        }
        class Tt {
            constructor(e19, t19, i24, o23 = !1){
                this.text = e19, this.icon = t19, this.skipFade = i24, this.clipped = o23;
            }
        }
        class Et {
            constructor(){
                this.invProjMatrix = e1.create(), this.viewportMatrix = e1.create(), this.circles = [];
            }
        }
        class Ct {
            constructor(e20, t20, i25, o24, r9){
                this.bucketInstanceId = e20, this.featureIndex = t20, this.sourceLayerIndex = i25, this.bucketIndex = o24, this.tileID = r9;
            }
        }
        class It {
            constructor(e21){
                this.crossSourceCollisions = e21, this.maxGroupID = 0, this.collisionGroups = {
                };
            }
            get(e) {
                if (this.crossSourceCollisions) return {
                    ID: 0,
                    predicate: null
                };
                if (!this.collisionGroups[e]) {
                    const t21 = ++this.maxGroupID;
                    this.collisionGroups[e] = {
                        ID: t21,
                        predicate: (e22)=>e22.collisionGroupID === t21
                    };
                }
                return this.collisionGroups[e];
            }
        }
        function Mt(t21, i26, o25, r10, n6) {
            const { horizontalAlign: s4 , verticalAlign: a9  } = e1.getAnchorAlignment(t21), l20 = -(s4 - 0.5) * i26, c14 = -(a9 - 0.5) * o25, h13 = e1.evaluateVariableOffset(t21, r10);
            return new e1.pointGeometry(l20 + h13[0] * n6, c14 + h13[1] * n6);
        }
        function St(t21, i26, o25, r10, n6) {
            const s4 = new e1.pointGeometry(t21, i26);
            return o25 && s4._rotate(r10 ? n6 : -n6), s4;
        }
        class Dt {
            constructor(e22, t21, i26, o25, r10){
                this.transform = e22.clone(), this.projection = e22.projection.name, this.collisionIndex = new gt(this.transform, r10), this.placements = {
                }, this.opacities = {
                }, this.variableOffsets = {
                }, this.stale = !1, this.commitTime = 0, this.fadeDuration = t21, this.retainedQueryData = {
                }, this.collisionGroups = new It(i26), this.collisionCircleArrays = {
                }, this.prevPlacement = o25, o25 && (o25.prevPlacement = void 0), this.placedOrientations = {
                };
            }
            getBucketParts(t, i, o, r) {
                const n6 = o.getBucket(i), s4 = o.latestFeatureIndex;
                if (!n6 || !s4 || i.id !== n6.layerIds[0]) return;
                const a9 = n6.layers[0].layout, l20 = o.collisionBoxArray, c14 = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), h13 = o.tileSize / e1.EXTENT, u16 = o.tileID.toUnwrapped();
                this.transform.setProjection(n6.projection);
                const _2 = (d7 = o.tileID, p10 = n6.getProjection(), m6 = this.transform, p10.name === this.projection ? m6.calculateProjMatrix(d7.toUnwrapped()) : vt(m6, p10, d7));
                var d7, p10, m6;
                const f9 = "map" === a9.get("text-pitch-alignment"), g6 = "map" === a9.get("text-rotation-alignment");
                i.compileFilter();
                const v4 = i.dynamicFilter(), x4 = i.dynamicFilterNeedsFeature(), y5 = this.transform.calculatePixelsToTileUnitsMatrix(o), b3 = it(_2, o.tileID.canonical, f9, g6, this.transform, n6.getProjection(), y5);
                let w4 = null;
                if (f9) {
                    const t22 = ot(_2, o.tileID.canonical, f9, g6, this.transform, n6.getProjection(), y5);
                    w4 = e1.multiply([], this.transform.labelPlaneMatrix, t22);
                }
                let T1 = null;
                v4 && o.latestFeatureIndex && (T1 = {
                    unwrappedTileID: u16,
                    dynamicFilter: v4,
                    dynamicFilterNeedsFeature: x4,
                    featureIndex: o.latestFeatureIndex
                }), this.retainedQueryData[n6.bucketInstanceId] = new Ct(n6.bucketInstanceId, s4, n6.sourceLayerIndex, n6.index, o.tileID);
                const E1 = {
                    bucket: n6,
                    layout: a9,
                    posMatrix: _2,
                    textLabelPlaneMatrix: b3,
                    labelToScreenMatrix: w4,
                    clippingData: T1,
                    scale: c14,
                    textPixelRatio: h13,
                    holdingForFade: o.holdingForFade(),
                    collisionBoxArray: l20,
                    partiallyEvaluatedTextSize: e1.evaluateSizeForZoom(n6.textSizeData, this.transform.zoom),
                    partiallyEvaluatedIconSize: e1.evaluateSizeForZoom(n6.iconSizeData, this.transform.zoom),
                    collisionGroup: this.collisionGroups.get(n6.sourceID)
                };
                if (r) for (const e23 of n6.sortKeyRanges){
                    const { sortKey: i27 , symbolInstanceStart: o26 , symbolInstanceEnd: r11  } = e23;
                    t.push({
                        sortKey: i27,
                        symbolInstanceStart: o26,
                        symbolInstanceEnd: r11,
                        parameters: E1
                    });
                }
                else t.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: n6.symbolInstances.length,
                    parameters: E1
                });
            }
            attemptAnchorPlacement(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g) {
                const { textOffset0: v4 , textOffset1: x4 , crossTileID: y5  } = u, b3 = [
                    v4,
                    x4
                ], w4 = Mt(e, i, o, b3, r), T1 = this.collisionIndex.placeCollisionBox(d, r, t, St(w4.x, w4.y, n, s, this.transform.angle), h, a, l, c.predicate);
                if (m) {
                    const e23 = d.getSymbolInstanceIconSize(g, this.transform.zoom, u.placedIconSymbolIndex);
                    if (0 === this.collisionIndex.placeCollisionBox(d, e23, m, St(w4.x, w4.y, n, s, this.transform.angle), h, a, l, c.predicate).box.length) return;
                }
                if (T1.box.length > 0) {
                    let t22;
                    return this.prevPlacement && this.prevPlacement.variableOffsets[y5] && this.prevPlacement.placements[y5] && this.prevPlacement.placements[y5].text && (t22 = this.prevPlacement.variableOffsets[y5].anchor), this.variableOffsets[y5] = {
                        textOffset: b3,
                        width: i,
                        height: o,
                        anchor: e,
                        textScale: r,
                        prevAnchor: t22
                    }, this.markUsedJustification(d, e, u, p), d.allowVerticalPlacement && (this.markUsedOrientation(d, p, u), this.placedOrientations[y5] = p), {
                        shift: w4,
                        placedGlyphBoxes: T1
                    };
                }
            }
            placeLayerBucketPart(t, i, o, r) {
                const { bucket: n6 , layout: s4 , posMatrix: a9 , textLabelPlaneMatrix: l20 , labelToScreenMatrix: c14 , clippingData: h13 , textPixelRatio: u16 , holdingForFade: _2 , collisionBoxArray: d8 , partiallyEvaluatedTextSize: p11 , partiallyEvaluatedIconSize: m7 , collisionGroup: f9  } = t.parameters, g6 = s4.get("text-optional"), v4 = s4.get("icon-optional"), x4 = s4.get("text-allow-overlap"), y5 = s4.get("icon-allow-overlap"), b3 = "map" === s4.get("text-rotation-alignment"), w4 = "map" === s4.get("text-pitch-alignment"), T1 = "none" !== s4.get("icon-text-fit"), E1 = "viewport-y" === s4.get("symbol-z-order");
                this.transform.setProjection(n6.projection);
                let C1 = x4 && (y5 || !n6.hasIconData() || v4), I1 = y5 && (x4 || !n6.hasTextData() || g6);
                !n6.collisionArrays && d8 && n6.deserializeCollisionBoxes(d8), o && r && n6.updateCollisionDebugBuffers(this.transform.zoom, d8);
                const M3 = (t22, r11, d9)=>{
                    const { crossTileID: E2 , numVerticalGlyphVertices: M4  } = t22;
                    if (h13) {
                        const o26 = {
                            zoom: this.transform.zoom,
                            pitch: this.transform.pitch
                        };
                        let r12 = null;
                        if (h13.dynamicFilterNeedsFeature) {
                            const e23 = this.retainedQueryData[n6.bucketInstanceId];
                            r12 = h13.featureIndex.loadFeature({
                                featureIndex: t22.featureIndex,
                                bucketIndex: e23.bucketIndex,
                                sourceLayerIndex: e23.sourceLayerIndex,
                                layoutVertexArrayOffset: 0
                            });
                        }
                        if (!h13.dynamicFilter(o26, r12, this.retainedQueryData[n6.bucketInstanceId].tileID.canonical, new e1.pointGeometry(t22.tileAnchorX, t22.tileAnchorY), this.transform.calculateDistanceTileData(h13.unwrappedTileID))) return this.placements[E2] = new Tt(!1, !1, !1, !0), void (i[E2] = !0);
                    }
                    if (i[E2]) return;
                    if (_2) return void (this.placements[E2] = new Tt(!1, !1, !1));
                    let S3 = !1, D1 = !1, A1 = !0, L1 = !1, z1 = !1, P3 = null, R1 = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, O1 = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, B1 = null, k1 = null, F1 = null, U1 = 0, N1 = 0, G1 = 0;
                    d9.textFeatureIndex ? U1 = d9.textFeatureIndex : t22.useRuntimeCollisionCircles && (U1 = t22.featureIndex), d9.verticalTextFeatureIndex && (N1 = d9.verticalTextFeatureIndex);
                    const j1 = (e23)=>{
                        e23.tileID = this.retainedQueryData[n6.bucketInstanceId].tileID;
                        const t23 = this.transform.elevation;
                        (t23 || e23.elevation) && (e23.elevation = t23 ? t23.getAtTileOffset(e23.tileID, e23.tileAnchorX, e23.tileAnchorY) : 0);
                    }, Z1 = d9.textBox;
                    if (Z1) {
                        j1(Z1);
                        const i27 = (i28)=>{
                            let o26 = e1.WritingMode.horizontal;
                            if (n6.allowVerticalPlacement && !i28 && this.prevPlacement) {
                                const e23 = this.prevPlacement.placedOrientations[E2];
                                e23 && (this.placedOrientations[E2] = e23, o26 = e23, this.markUsedOrientation(n6, o26, t22));
                            }
                            return o26;
                        }, o26 = (t23, i28)=>{
                            if (n6.allowVerticalPlacement && M4 > 0 && d9.verticalTextBox) {
                                for (const o27 of n6.writingModes)if (o27 === e1.WritingMode.vertical ? (R1 = i28(), O1 = R1) : R1 = t23(), R1 && R1.box && R1.box.length) break;
                            } else R1 = t23();
                        };
                        if (s4.get("text-variable-anchor")) {
                            let l21 = s4.get("text-variable-anchor");
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[E2]) {
                                const e23 = this.prevPlacement.variableOffsets[E2];
                                l21.indexOf(e23.anchor) > 0 && (l21 = l21.filter((t23)=>t23 !== e23.anchor
                                ), l21.unshift(e23.anchor));
                            }
                            const c15 = (e23, i28, o27)=>{
                                const s14 = n6.getSymbolInstanceTextSize(p11, t22, this.transform.zoom, r11), c16 = (e23.x2 - e23.x1) * s14 + 2 * e23.padding, h14 = (e23.y2 - e23.y1) * s14 + 2 * e23.padding, _3 = T1 && !y5 ? i28 : null;
                                _3 && j1(_3);
                                let d10 = {
                                    box: [],
                                    offscreen: !1,
                                    occluded: !1
                                };
                                const g7 = x4 ? 2 * l21.length : l21.length;
                                for(let i29 = 0; i29 < g7; ++i29){
                                    const g8 = this.attemptAnchorPlacement(l21[i29 % l21.length], e23, c16, h14, s14, b3, w4, u16, a9, f9, i29 >= l21.length, t22, r11, n6, o27, _3, p11, m7);
                                    if (g8 && (d10 = g8.placedGlyphBoxes, d10 && d10.box && d10.box.length)) {
                                        S3 = !0, P3 = g8.shift;
                                        break;
                                    }
                                }
                                return d10;
                            };
                            o26(()=>c15(Z1, d9.iconBox, e1.WritingMode.horizontal)
                            , ()=>{
                                const t23 = d9.verticalTextBox;
                                return t23 && j1(t23), n6.allowVerticalPlacement && !(R1 && R1.box && R1.box.length) && M4 > 0 && t23 ? c15(t23, d9.verticalIconBox, e1.WritingMode.vertical) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), R1 && (S3 = R1.box, A1 = R1.offscreen, L1 = R1.occluded);
                            const h14 = i27(R1 && R1.box);
                            if (!S3 && this.prevPlacement) {
                                const e23 = this.prevPlacement.variableOffsets[E2];
                                e23 && (this.variableOffsets[E2] = e23, this.markUsedJustification(n6, e23.anchor, t22, h14));
                            }
                        } else {
                            const s14 = (i28, o27)=>{
                                const s16 = n6.getSymbolInstanceTextSize(p11, t22, this.transform.zoom, r11), l21 = this.collisionIndex.placeCollisionBox(n6, s16, i28, new e1.pointGeometry(0, 0), x4, u16, a9, f9.predicate);
                                return l21 && l21.box && l21.box.length && (this.markUsedOrientation(n6, o27, t22), this.placedOrientations[E2] = o27), l21;
                            };
                            o26(()=>s14(Z1, e1.WritingMode.horizontal)
                            , ()=>{
                                const t23 = d9.verticalTextBox;
                                return n6.allowVerticalPlacement && M4 > 0 && t23 ? (j1(t23), s14(t23, e1.WritingMode.vertical)) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), i27(R1 && R1.box && R1.box.length);
                        }
                    }
                    if (B1 = R1, S3 = B1 && B1.box && B1.box.length > 0, A1 = B1 && B1.offscreen, L1 = B1 && B1.occluded, t22.useRuntimeCollisionCircles) {
                        const i27 = n6.text.placedSymbolArray.get(t22.centerJustifiedTextSymbolIndex >= 0 ? t22.centerJustifiedTextSymbolIndex : t22.verticalPlacedTextSymbolIndex), r12 = e1.evaluateSizeForFeature(n6.textSizeData, p11, i27), h14 = s4.get("text-padding");
                        k1 = this.collisionIndex.placeCollisionCircles(n6, x4, i27, n6.lineVertexArray, n6.glyphOffsetArray, r12, a9, l20, c14, o, w4, f9.predicate, t22.collisionCircleDiameter * r12 / e1.ONE_EM, h14, this.retainedQueryData[n6.bucketInstanceId].tileID), S3 = x4 || k1.circles.length > 0 && !k1.collisionDetected, A1 = A1 && k1.offscreen, L1 = k1.occluded;
                    }
                    if (d9.iconFeatureIndex && (G1 = d9.iconFeatureIndex), d9.iconBox) {
                        const i27 = (i28)=>{
                            j1(i28);
                            const o26 = T1 && P3 ? St(P3.x, P3.y, b3, w4, this.transform.angle) : new e1.pointGeometry(0, 0), r12 = n6.getSymbolInstanceIconSize(m7, this.transform.zoom, t22.placedIconSymbolIndex);
                            return this.collisionIndex.placeCollisionBox(n6, r12, i28, o26, y5, u16, a9, f9.predicate);
                        };
                        O1 && O1.box && O1.box.length && d9.verticalIconBox ? (F1 = i27(d9.verticalIconBox), D1 = F1.box.length > 0) : (F1 = i27(d9.iconBox), D1 = F1.box.length > 0), A1 = A1 && F1.offscreen, z1 = F1.occluded;
                    }
                    const V1 = g6 || 0 === t22.numHorizontalGlyphVertices && 0 === M4, W1 = v4 || 0 === t22.numIconVertices;
                    if (V1 || W1 ? W1 ? V1 || (D1 = D1 && S3) : S3 = D1 && S3 : D1 = S3 = D1 && S3, S3 && B1 && B1.box && this.collisionIndex.insertCollisionBox(B1.box, s4.get("text-ignore-placement"), n6.bucketInstanceId, O1 && O1.box && N1 ? N1 : U1, f9.ID), D1 && F1 && this.collisionIndex.insertCollisionBox(F1.box, s4.get("icon-ignore-placement"), n6.bucketInstanceId, G1, f9.ID), k1 && (S3 && this.collisionIndex.insertCollisionCircles(k1.circles, s4.get("text-ignore-placement"), n6.bucketInstanceId, U1, f9.ID), o)) {
                        const e23 = n6.bucketInstanceId;
                        let t23 = this.collisionCircleArrays[e23];
                        (void 0) === t23 && (t23 = this.collisionCircleArrays[e23] = new Et);
                        for(let e24 = 0; e24 < k1.circles.length; e24 += 4)t23.circles.push(k1.circles[e24 + 0]), t23.circles.push(k1.circles[e24 + 1]), t23.circles.push(k1.circles[e24 + 2]), t23.circles.push(k1.collisionDetected ? 1 : 0);
                    }
                    const X1 = "globe" !== n6.projection.name;
                    C1 = C1 && (X1 || !L1), I1 = I1 && (X1 || !z1), this.placements[E2] = new Tt(S3 || C1, D1 || I1, A1 || n6.justReloaded), i[E2] = !0;
                };
                if (E1) {
                    const e23 = n6.getSortedSymbolIndexes(this.transform.angle);
                    for(let t22 = e23.length - 1; t22 >= 0; --t22){
                        const i27 = e23[t22];
                        M3(n6.symbolInstances.get(i27), i27, n6.collisionArrays[i27]);
                    }
                } else for(let e23 = t.symbolInstanceStart; e23 < t.symbolInstanceEnd; e23++)M3(n6.symbolInstances.get(e23), e23, n6.collisionArrays[e23]);
                if (o && n6.bucketInstanceId in this.collisionCircleArrays) {
                    const t22 = this.collisionCircleArrays[n6.bucketInstanceId];
                    e1.invert(t22.invProjMatrix, a9), t22.viewportMatrix = this.collisionIndex.getViewportMatrix();
                }
                n6.justReloaded = !1;
            }
            markUsedJustification(t, i, o, r) {
                const { leftJustifiedTextSymbolIndex: n6 , centerJustifiedTextSymbolIndex: s4 , rightJustifiedTextSymbolIndex: a9 , verticalPlacedTextSymbolIndex: l20 , crossTileID: c14  } = o, h13 = e1.getAnchorJustification(i), u16 = r === e1.WritingMode.vertical ? l20 : "left" === h13 ? n6 : "center" === h13 ? s4 : "right" === h13 ? a9 : -1;
                n6 >= 0 && (t.text.placedSymbolArray.get(n6).crossTileID = u16 >= 0 && n6 !== u16 ? 0 : c14), s4 >= 0 && (t.text.placedSymbolArray.get(s4).crossTileID = u16 >= 0 && s4 !== u16 ? 0 : c14), a9 >= 0 && (t.text.placedSymbolArray.get(a9).crossTileID = u16 >= 0 && a9 !== u16 ? 0 : c14), l20 >= 0 && (t.text.placedSymbolArray.get(l20).crossTileID = u16 >= 0 && l20 !== u16 ? 0 : c14);
            }
            markUsedOrientation(t, i, o) {
                const r11 = i === e1.WritingMode.horizontal || i === e1.WritingMode.horizontalOnly ? i : 0, n6 = i === e1.WritingMode.vertical ? i : 0, { leftJustifiedTextSymbolIndex: s4 , centerJustifiedTextSymbolIndex: a9 , rightJustifiedTextSymbolIndex: l20 , verticalPlacedTextSymbolIndex: c14  } = o, h13 = t.text.placedSymbolArray;
                s4 >= 0 && (h13.get(s4).placedOrientation = r11), a9 >= 0 && (h13.get(a9).placedOrientation = r11), l20 >= 0 && (h13.get(l20).placedOrientation = r11), c14 >= 0 && (h13.get(c14).placedOrientation = n6);
            }
            commit(e) {
                this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
                const t22 = this.prevPlacement;
                let i27 = !1;
                this.prevZoomAdjustment = t22 ? t22.zoomAdjustment(this.transform.zoom) : 0;
                const o26 = t22 ? t22.symbolFadeChange(e) : 1, r11 = t22 ? t22.opacities : {
                }, n6 = t22 ? t22.variableOffsets : {
                }, s4 = t22 ? t22.placedOrientations : {
                };
                for(const e23 in this.placements){
                    const t23 = this.placements[e23], n7 = r11[e23];
                    n7 ? (this.opacities[e23] = new wt(n7, o26, t23.text, t23.icon, null, t23.clipped), i27 = i27 || t23.text !== n7.text.placed || t23.icon !== n7.icon.placed) : (this.opacities[e23] = new wt(null, o26, t23.text, t23.icon, t23.skipFade, t23.clipped), i27 = i27 || t23.text || t23.icon);
                }
                for(const e24 in r11){
                    const t23 = r11[e24];
                    if (!this.opacities[e24]) {
                        const r12 = new wt(t23, o26, !1, !1);
                        r12.isHidden() || (this.opacities[e24] = r12, i27 = i27 || t23.text.placed || t23.icon.placed);
                    }
                }
                for(const e25 in n6)this.variableOffsets[e25] || !this.opacities[e25] || this.opacities[e25].isHidden() || (this.variableOffsets[e25] = n6[e25]);
                for(const e26 in s4)this.placedOrientations[e26] || !this.opacities[e26] || this.opacities[e26].isHidden() || (this.placedOrientations[e26] = s4[e26]);
                i27 ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t22 ? t22.lastPlacementChangeTime : e);
            }
            updateLayerOpacities(e, t) {
                const i27 = {
                };
                for (const o26 of t){
                    const t22 = o26.getBucket(e);
                    t22 && o26.latestFeatureIndex && e.id === t22.layerIds[0] && this.updateBucketOpacities(t22, i27, o26.collisionBoxArray);
                }
            }
            updateBucketOpacities(t, i, o) {
                t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
                const r11 = t.layers[0].layout, n6 = !!t.layers[0].dynamicFilter(), s4 = new wt(null, 0, !1, !1, !0), a9 = r11.get("text-allow-overlap"), l20 = r11.get("icon-allow-overlap"), c14 = r11.get("text-variable-anchor"), h13 = "map" === r11.get("text-rotation-alignment"), u16 = "map" === r11.get("text-pitch-alignment"), _2 = "none" !== r11.get("icon-text-fit"), d8 = new wt(null, 0, a9 && (l20 || !t.hasIconData() || r11.get("icon-optional")), l20 && (a9 || !t.hasTextData() || r11.get("text-optional")), !0);
                !t.collisionArrays && o && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(o);
                const p11 = (e23, t22, i27)=>{
                    for(let o26 = 0; o26 < t22 / 4; o26++)e23.opacityVertexArray.emplaceBack(i27);
                };
                let m7 = 0;
                for(let o26 = 0; o26 < t.symbolInstances.length; o26++){
                    const r12 = t.symbolInstances.get(o26), { numHorizontalGlyphVertices: a14 , numVerticalGlyphVertices: l21 , crossTileID: f9 , numIconVertices: g6  } = r12;
                    let v4 = this.opacities[f9];
                    i[f9] ? v4 = s4 : v4 || (v4 = d8, this.opacities[f9] = v4), i[f9] = !0;
                    const x4 = a14 > 0 || l21 > 0, y5 = g6 > 0, b3 = this.placedOrientations[f9], w4 = b3 === e1.WritingMode.vertical, T1 = b3 === e1.WritingMode.horizontal || b3 === e1.WritingMode.horizontalOnly;
                    if (!x4 && !y5 || v4.isHidden() || m7++, x4) {
                        const e23 = Ft(v4.text);
                        p11(t.text, a14, w4 ? Ut : e23), p11(t.text, l21, T1 ? Ut : e23);
                        const i27 = v4.text.isHidden(), { leftJustifiedTextSymbolIndex: o27 , centerJustifiedTextSymbolIndex: n7 , rightJustifiedTextSymbolIndex: s14 , verticalPlacedTextSymbolIndex: c15  } = r12, h14 = t.text.placedSymbolArray, u17 = i27 || w4 ? 1 : 0;
                        o27 >= 0 && (h14.get(o27).hidden = u17), n7 >= 0 && (h14.get(n7).hidden = u17), s14 >= 0 && (h14.get(s14).hidden = u17), c15 >= 0 && (h14.get(c15).hidden = i27 || T1 ? 1 : 0);
                        const _3 = this.variableOffsets[f9];
                        _3 && this.markUsedJustification(t, _3.anchor, r12, b3);
                        const d9 = this.placedOrientations[f9];
                        d9 && (this.markUsedJustification(t, "left", r12, d9), this.markUsedOrientation(t, d9, r12));
                    }
                    if (y5) {
                        const e23 = Ft(v4.icon), { placedIconSymbolIndex: i27 , verticalPlacedIconSymbolIndex: o27  } = r12, n7 = t.icon.placedSymbolArray, s14 = v4.icon.isHidden() ? 1 : 0;
                        i27 >= 0 && (p11(t.icon, g6, w4 ? Ut : e23), n7.get(i27).hidden = s14), o27 >= 0 && (p11(t.icon, r12.numVerticalIconVertices, T1 ? Ut : e23), n7.get(o27).hidden = s14);
                    }
                    if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                        const i27 = t.collisionArrays[o26];
                        if (i27) {
                            let o27 = new e1.pointGeometry(0, 0), r13 = !0;
                            if (i27.textBox || i27.verticalTextBox) {
                                if (c14) {
                                    const e23 = this.variableOffsets[f9];
                                    e23 ? (o27 = Mt(e23.anchor, e23.width, e23.height, e23.textOffset, e23.textScale), h13 && o27._rotate(u16 ? this.transform.angle : -this.transform.angle)) : r13 = !1;
                                }
                                n6 && (r13 = !v4.clipped), i27.textBox && At(t.textCollisionBox.collisionVertexArray, v4.text.placed, !r13 || w4, o27.x, o27.y), i27.verticalTextBox && At(t.textCollisionBox.collisionVertexArray, v4.text.placed, !r13 || T1, o27.x, o27.y);
                            }
                            const s14 = r13 && Boolean(!T1 && i27.verticalIconBox);
                            i27.iconBox && At(t.iconCollisionBox.collisionVertexArray, v4.icon.placed, s14, _2 ? o27.x : 0, _2 ? o27.y : 0), i27.verticalIconBox && At(t.iconCollisionBox.collisionVertexArray, v4.icon.placed, !s14, _2 ? o27.x : 0, _2 ? o27.y : 0);
                        }
                    }
                }
                if (t.fullyClipped = 0 === m7, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {
                    const e23 = this.collisionCircleArrays[t.bucketInstanceId];
                    t.placementInvProjMatrix = e23.invProjMatrix, t.placementViewportMatrix = e23.viewportMatrix, t.collisionCircleArray = e23.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
                }
            }
            symbolFadeChange(e) {
                return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e) {
                return Math.max(0, (this.transform.zoom - e) / 1.5);
            }
            hasTransitions(e) {
                return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e, t) {
                const i27 = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;
                return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i27 > e;
            }
            setStale() {
                this.stale = !0;
            }
        }
        function At(e23, t22, i27, o26, r11) {
            e23.emplaceBack(t22 ? 1 : 0, i27 ? 1 : 0, o26 || 0, r11 || 0), e23.emplaceBack(t22 ? 1 : 0, i27 ? 1 : 0, o26 || 0, r11 || 0), e23.emplaceBack(t22 ? 1 : 0, i27 ? 1 : 0, o26 || 0, r11 || 0), e23.emplaceBack(t22 ? 1 : 0, i27 ? 1 : 0, o26 || 0, r11 || 0);
        }
        const Lt = Math.pow(2, 25), zt = Math.pow(2, 24), Pt = Math.pow(2, 17), Rt = Math.pow(2, 16), Ot = Math.pow(2, 9), Bt = Math.pow(2, 8), kt = Math.pow(2, 1);
        function Ft(e23) {
            if (0 === e23.opacity && !e23.placed) return 0;
            if (1 === e23.opacity && e23.placed) return 4294967295;
            const t22 = e23.placed ? 1 : 0, i27 = Math.floor(127 * e23.opacity);
            return i27 * Lt + t22 * zt + i27 * Pt + t22 * Rt + i27 * Ot + t22 * Bt + i27 * kt + t22;
        }
        const Ut = 0;
        class Nt {
            constructor(e23){
                this._sortAcrossTiles = "viewport-y" !== e23.layout.get("symbol-z-order") && (void 0) !== e23.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {
                }, this._bucketParts = [];
            }
            continuePlacement(e, t, i, o, r) {
                const n6 = this._bucketParts;
                for(; this._currentTileIndex < e.length;)if (t.getBucketParts(n6, o, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;
                for(this._sortAcrossTiles && (this._sortAcrossTiles = !1, n6.sort((e24, t22)=>e24.sortKey - t22.sortKey
                )); this._currentPartIndex < n6.length;){
                    const e24 = n6[this._currentPartIndex];
                    if (t.placeLayerBucketPart(e24, this._seenCrossTileIDs, i, 0 === e24.symbolInstanceStart), this._currentPartIndex++, r()) return !0;
                }
                return !1;
            }
        }
        class Gt {
            constructor(e24, t22, i27, o26, r11, n6, s4, a9){
                this.placement = new Dt(e24, r11, n6, s4, a9), this._currentPlacementIndex = t22.length - 1, this._forceFullPlacement = i27, this._showCollisionBoxes = o26, this._done = !1;
            }
            isDone() {
                return this._done;
            }
            continuePlacement(t, i, o) {
                const r12 = e1.exported.now(), n7 = ()=>{
                    const t23 = e1.exported.now() - r12;
                    return !this._forceFullPlacement && t23 > 2;
                };
                for(; this._currentPlacementIndex >= 0;){
                    const e25 = i[t[this._currentPlacementIndex]], r13 = this.placement.collisionIndex.transform.zoom;
                    if ("symbol" === e25.type && (!e25.minzoom || e25.minzoom <= r13) && (!e25.maxzoom || e25.maxzoom > r13)) {
                        if (this._inProgressLayer || (this._inProgressLayer = new Nt(e25)), this._inProgressLayer.continuePlacement(o[e25.source], this.placement, this._showCollisionBoxes, e25, n7)) return;
                        delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                }
                this._done = !0;
            }
            commit(e) {
                return this.placement.commit(e), this.placement;
            }
        }
        const jt = 512 / e1.EXTENT / 2;
        class Zt {
            constructor(e25, t23, i28){
                this.tileID = e25, this.indexedSymbolInstances = {
                }, this.bucketInstanceId = i28;
                for(let i29 = 0; i29 < t23.length; i29++){
                    const o27 = t23.get(i29), r12 = o27.key;
                    this.indexedSymbolInstances[r12] || (this.indexedSymbolInstances[r12] = []), this.indexedSymbolInstances[r12].push({
                        crossTileID: o27.crossTileID,
                        coord: this.getScaledCoordinates(o27, e25)
                    });
                }
            }
            getScaledCoordinates(t, i) {
                const o27 = jt / Math.pow(2, i.canonical.z - this.tileID.canonical.z);
                return {
                    x: Math.floor((i.canonical.x * e1.EXTENT + t.tileAnchorX) * o27),
                    y: Math.floor((i.canonical.y * e1.EXTENT + t.tileAnchorY) * o27)
                };
            }
            findMatches(e, t, i) {
                const o27 = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z);
                for(let r12 = 0; r12 < e.length; r12++){
                    const n7 = e.get(r12);
                    if (n7.crossTileID) continue;
                    const s14 = this.indexedSymbolInstances[n7.key];
                    if (!s14) continue;
                    const a14 = this.getScaledCoordinates(n7, t);
                    for (const e26 of s14)if (Math.abs(e26.coord.x - a14.x) <= o27 && Math.abs(e26.coord.y - a14.y) <= o27 && !i[e26.crossTileID]) {
                        i[e26.crossTileID] = !0, n7.crossTileID = e26.crossTileID;
                        break;
                    }
                }
            }
        }
        class Vt {
            constructor(){
                this.maxCrossTileID = 0;
            }
            generate() {
                return ++this.maxCrossTileID;
            }
        }
        class Wt {
            constructor(){
                this.indexes = {
                }, this.usedCrossTileIDs = {
                }, this.lng = 0;
            }
            handleWrapJump(e) {
                const t24 = Math.round((e - this.lng) / 360);
                if (0 !== t24) for(const e26 in this.indexes){
                    const i30 = this.indexes[e26], o27 = {
                    };
                    for(const e27 in i30){
                        const r12 = i30[e27];
                        r12.tileID = r12.tileID.unwrapTo(r12.tileID.wrap + t24), o27[r12.tileID.key] = r12;
                    }
                    this.indexes[e26] = o27;
                }
                this.lng = e;
            }
            addBucket(e, t, i) {
                if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                    if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;
                    this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
                }
                for(let e26 = 0; e26 < t.symbolInstances.length; e26++)t.symbolInstances.get(e26).crossTileID = 0;
                this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {
                });
                const o27 = this.usedCrossTileIDs[e.overscaledZ];
                for(const i30 in this.indexes){
                    const r12 = this.indexes[i30];
                    if (Number(i30) > e.overscaledZ) for(const i32 in r12){
                        const n7 = r12[i32];
                        n7.tileID.isChildOf(e) && n7.findMatches(t.symbolInstances, e, o27);
                    }
                    else {
                        const n7 = r12[e.scaledTo(Number(i30)).key];
                        n7 && n7.findMatches(t.symbolInstances, e, o27);
                    }
                }
                for(let e27 = 0; e27 < t.symbolInstances.length; e27++){
                    const r12 = t.symbolInstances.get(e27);
                    r12.crossTileID || (r12.crossTileID = i.generate(), o27[r12.crossTileID] = !0);
                }
                return (void 0) === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {
                }), this.indexes[e.overscaledZ][e.key] = new Zt(e, t.symbolInstances, t.bucketInstanceId), !0;
            }
            removeBucketCrossTileIDs(e, t) {
                for(const i30 in t.indexedSymbolInstances)for (const o27 of t.indexedSymbolInstances[i30])delete this.usedCrossTileIDs[e][o27.crossTileID];
            }
            removeStaleBuckets(e) {
                let t24 = !1;
                for(const i30 in this.indexes){
                    const o27 = this.indexes[i30];
                    for(const r12 in o27)e[o27[r12].bucketInstanceId] || (this.removeBucketCrossTileIDs(i30, o27[r12]), delete o27[r12], t24 = !0);
                }
                return t24;
            }
        }
        class Xt {
            constructor(){
                this.layerIndexes = {
                }, this.crossTileIDs = new Vt, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {
                };
            }
            addLayer(e, t, i, o) {
                let r12 = this.layerIndexes[e.id];
                (void 0) === r12 && (r12 = this.layerIndexes[e.id] = new Wt);
                let n7 = !1;
                const s14 = {
                };
                "globe" !== o.name && r12.handleWrapJump(i);
                for (const i30 of t){
                    const t24 = i30.getBucket(e);
                    t24 && e.id === t24.layerIds[0] && (t24.bucketInstanceId || (t24.bucketInstanceId = ++this.maxBucketInstanceId), r12.addBucket(i30.tileID, t24, this.crossTileIDs) && (n7 = !0), s14[t24.bucketInstanceId] = !0);
                }
                return r12.removeStaleBuckets(s14) && (n7 = !0), n7;
            }
            pruneUnusedLayers(e) {
                const t24 = {
                };
                e.forEach((e26)=>{
                    t24[e26] = !0;
                });
                for(const e26 in this.layerIndexes)t24[e26] || delete this.layerIndexes[e26];
            }
        }
        const qt = (t24, i30)=>e1.emitValidationErrors(t24, i30 && i30.filter((e26)=>"source.canvas" !== e26.identifier
            ))
        , $t = e1.pick(Ve, [
            "addLayer",
            "removeLayer",
            "setPaintProperty",
            "setLayoutProperty",
            "setFilter",
            "addSource",
            "removeSource",
            "setLayerZoomRange",
            "setLight",
            "setTransition",
            "setGeoJSONSourceData",
            "setTerrain",
            "setFog",
            "setProjection"
        ]), Ht = e1.pick(Ve, [
            "setCenter",
            "setZoom",
            "setBearing",
            "setPitch"
        ]), Yt = {
            version: 8,
            layers: [],
            sources: {
            }
        }, Kt = {
            fill: !0,
            line: !0,
            background: !0,
            hillshade: !0,
            raster: !0
        };
        class Jt extends e1.Evented {
            constructor(t24, i30 = {
            }){
                super(), this.map = t24, this.dispatcher = new z(Ge(), this), this.imageManager = new y4, this.imageManager.setEventedParent(this), this.glyphManager = new e1.GlyphManager(t24._requestManager, i30.localFontFamily ? e1.LocalGlyphMode.all : i30.localIdeographFontFamily ? e1.LocalGlyphMode.ideographs : e1.LocalGlyphMode.none, i30.localFontFamily || i30.localIdeographFontFamily), this.crossTileSymbolIndex = new Xt, this._layers = {
                }, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {
                }, this._sourceCaches = {
                }, this._otherSourceCaches = {
                }, this._symbolSourceCaches = {
                }, this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e1.getReferrer());
                const o27 = this;
                this._rtlTextPluginCallback = Jt.registerForPluginStateChange((t25)=>{
                    o27.dispatcher.broadcast("syncRTLPluginState", {
                        pluginStatus: t25.pluginStatus,
                        pluginURL: t25.pluginURL
                    }, (t26, i32)=>{
                        if (e1.triggerPluginCompletionEvent(t26), i32 && i32.every((e26)=>e26
                        )) for(const e26 in o27._sourceCaches){
                            const t27 = o27._sourceCaches[e26], i33 = t27.getSource().type;
                            "vector" !== i33 && "geojson" !== i33 || t27.reload();
                        }
                    });
                }), this.on("data", (e26)=>{
                    if ("source" !== e26.dataType || "metadata" !== e26.sourceDataType) return;
                    const t25 = this.getSource(e26.sourceId);
                    if (t25 && t25.vectorLayerIds) for(const e27 in this._layers){
                        const i32 = this._layers[e27];
                        i32.source === t25.id && this._validateLayer(i32);
                    }
                });
            }
            loadURL(t, i = {
            }) {
                this.fire(new e1.Event("dataloading", {
                    dataType: "style"
                }));
                const o28 = "boolean" == typeof i.validate ? i.validate : !e1.isMapboxURL(t);
                t = this.map._requestManager.normalizeStyleURL(t, i.accessToken);
                const r12 = this.map._requestManager.transformRequest(t, e1.ResourceType.Style);
                this._request = e1.getJSON(r12, (t25, i32)=>{
                    this._request = null, t25 ? this.fire(new e1.ErrorEvent(t25)) : i32 && this._load(i32, o28);
                });
            }
            loadJSON(t, i = {
            }) {
                this.fire(new e1.Event("dataloading", {
                    dataType: "style"
                })), this._request = e1.exported.frame(()=>{
                    this._request = null, this._load(t, !1 !== i.validate);
                });
            }
            loadEmpty() {
                this.fire(new e1.Event("dataloading", {
                    dataType: "style"
                })), this._load(Yt, !1);
            }
            _updateLayerCount(e, t) {
                const i32 = t ? 1 : -1;
                e.is3D() && (this._num3DLayers += i32), "circle" === e.type && (this._numCircleLayers += i32), "symbol" === e.type && (this._numSymbolLayers += i32);
            }
            _load(t, i) {
                if (i && qt(this, e1.validateStyle(t))) return;
                this._loaded = !0, this.stylesheet = e1.clone$1(t), this._updateMapProjection();
                for(const e26 in t.sources)this.addSource(e26, t.sources[e26], {
                    validate: !1
                });
                this._changed = !1, t.sprite ? this._loadSprite(t.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast("spriteLoaded", !0)), this.glyphManager.setURL(t.glyphs);
                const o28 = Ze(this.stylesheet.layers);
                this._order = o28.map((e27)=>e27.id
                ), this._layers = {
                }, this._serializedLayers = {
                };
                for (let t25 of o28)t25 = e1.createStyleLayer(t25), t25.setEventedParent(this, {
                    layer: {
                        id: t25.id
                    }
                }), this._layers[t25.id] = t25, this._serializedLayers[t25.id] = t25.serialize(), this._updateLayerCount(t25, !0);
                this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new T(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e1.Event("data", {
                    dataType: "style"
                })), this.fire(new e1.Event("style.load"));
            }
            terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }
            setProjection(e) {
                e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this._updateMapProjection();
            }
            applyProjectionUpdate() {
                this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
            }
            _updateMapProjection() {
                this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
            }
            _loadSprite(t) {
                this._spriteRequest = (function(t25, i32, o28) {
                    let r12, n7, s14;
                    const a14 = e1.exported.devicePixelRatio > 1 ? "@2x" : "";
                    let l20 = e1.getJSON(i32.transformRequest(i32.normalizeSpriteURL(t25, a14, ".json"), e1.ResourceType.SpriteJSON), (e26, t26)=>{
                        l20 = null, s14 || (s14 = e26, r12 = t26, h13());
                    }), c14 = e1.getImage(i32.transformRequest(i32.normalizeSpriteURL(t25, a14, ".png"), e1.ResourceType.SpriteImage), (e26, t26)=>{
                        c14 = null, s14 || (s14 = e26, n7 = t26, h13());
                    });
                    function h13() {
                        if (s14) o28(s14);
                        else if (r12 && n7) {
                            const t26 = e1.exported.getImageData(n7), i33 = {
                            };
                            for(const o29 in r12){
                                const { width: n8 , height: s16 , x: a15 , y: l21 , sdf: c15 , pixelRatio: h14 , stretchX: u16 , stretchY: _2 , content: d8  } = r12[o29], p11 = new e1.RGBAImage({
                                    width: n8,
                                    height: s16
                                });
                                e1.RGBAImage.copy(t26, p11, {
                                    x: a15,
                                    y: l21
                                }, {
                                    x: 0,
                                    y: 0
                                }, {
                                    width: n8,
                                    height: s16
                                }), i33[o29] = {
                                    data: p11,
                                    pixelRatio: h14,
                                    sdf: c15,
                                    stretchX: u16,
                                    stretchY: _2,
                                    content: d8
                                };
                            }
                            o28(null, i33);
                        }
                    }
                    return {
                        cancel () {
                            l20 && (l20.cancel(), l20 = null), c14 && (c14.cancel(), c14 = null);
                        }
                    };
                })(t, this.map._requestManager, (t25, i32)=>{
                    if (this._spriteRequest = null, t25) this.fire(new e1.ErrorEvent(t25));
                    else if (i32) for(const e26 in i32)this.imageManager.addImage(e26, i32[e26]);
                    this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", !0), this.fire(new e1.Event("data", {
                        dataType: "style"
                    }));
                });
            }
            _validateLayer(t) {
                const i32 = this.getSource(t.source);
                if (!i32) return;
                const o28 = t.sourceLayer;
                o28 && ("geojson" === i32.type || i32.vectorLayerIds && -1 === i32.vectorLayerIds.indexOf(o28)) && this.fire(new e1.ErrorEvent(new Error(`Source layer "${o28}" does not exist on source "${i32.id}" as specified by style layer "${t.id}"`)));
            }
            loaded() {
                if (!this._loaded) return !1;
                if (Object.keys(this._updatedSources).length) return !1;
                for(const e26 in this._sourceCaches)if (!this._sourceCaches[e26].loaded()) return !1;
                return !!this.imageManager.isLoaded();
            }
            _serializeLayers(e) {
                const t25 = [];
                for (const i32 of e){
                    const e26 = this._layers[i32];
                    "custom" !== e26.type && t25.push(e26.serialize());
                }
                return t25;
            }
            hasTransitions() {
                if (this.light && this.light.hasTransition()) return !0;
                if (this.fog && this.fog.hasTransition()) return !0;
                for(const e26 in this._sourceCaches)if (this._sourceCaches[e26].hasTransition()) return !0;
                for(const e27 in this._layers)if (this._layers[e27].hasTransition()) return !0;
                return !1;
            }
            get order() {
                return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
            }
            isLayerDraped(e) {
                return !!this.terrain && Kt[e.type];
            }
            _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
            }
            update(t) {
                if (!this._loaded) return;
                const i32 = this._changed;
                if (this._changed) {
                    const e26 = Object.keys(this._updatedLayers), i33 = Object.keys(this._removedLayers);
                    (e26.length || i33.length) && this._updateWorkerLayers(e26, i33);
                    for(const e27 in this._updatedSources){
                        const t25 = this._updatedSources[e27];
                        "reload" === t25 ? this._reloadSource(e27) : "clear" === t25 && this._clearSource(e27);
                    }
                    this._updateTilesForChangedImages();
                    for(const e28 in this._updatedPaintProps)this._layers[e28].updateTransitions(t);
                    this.light.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this._resetUpdates();
                }
                const o28 = {
                };
                for(const e26 in this._sourceCaches){
                    const t25 = this._sourceCaches[e26];
                    o28[e26] = t25.used, t25.used = !1;
                }
                for (const e27 of this._order){
                    const i33 = this._layers[e27];
                    if (i33.recalculate(t, this._availableImages), !i33.isHidden(t.zoom)) {
                        const e28 = this._getLayerSourceCache(i33);
                        e28 && (e28.used = !0);
                    }
                    const o29 = this.map.painter;
                    if (o29) {
                        const e28 = i33.getProgramIds();
                        if (!e28) continue;
                        const r12 = i33.getProgramConfiguration(t.zoom);
                        for (const t25 of e28)o29.useProgram(t25, r12);
                    }
                }
                for(const t25 in o28){
                    const i33 = this._sourceCaches[t25];
                    o28[t25] !== i33.used && i33.getSource().fire(new e1.Event("data", {
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: i33.getSource().id
                    }));
                }
                this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), i32 && this.fire(new e1.Event("data", {
                    dataType: "style"
                }));
            }
            _updateTilesForChangedImages() {
                const e26 = Object.keys(this._changedImages);
                if (e26.length) {
                    for(const t25 in this._sourceCaches)this._sourceCaches[t25].reloadTilesForDependencies([
                        "icons",
                        "patterns"
                    ], e26);
                    this._changedImages = {
                    };
                }
            }
            _updateWorkerLayers(e, t) {
                this.dispatcher.broadcast("updateLayers", {
                    layers: this._serializeLayers(e),
                    removedIds: t
                });
            }
            _resetUpdates() {
                this._changed = !1, this._updatedLayers = {
                }, this._removedLayers = {
                }, this._updatedSources = {
                }, this._updatedPaintProps = {
                }, this._changedImages = {
                };
            }
            setState(i) {
                if (this._checkLoaded(), qt(this, e1.validateStyle(i))) return !1;
                (i = e1.clone$1(i)).layers = Ze(i.layers);
                const o28 = (function(e26, i32) {
                    if (!e26) return [
                        {
                            command: Ve.setStyle,
                            args: [
                                i32
                            ]
                        }
                    ];
                    let o29 = [];
                    try {
                        if (!t1(e26.version, i32.version)) return [
                            {
                                command: Ve.setStyle,
                                args: [
                                    i32
                                ]
                            }
                        ];
                        t1(e26.center, i32.center) || o29.push({
                            command: Ve.setCenter,
                            args: [
                                i32.center
                            ]
                        }), t1(e26.zoom, i32.zoom) || o29.push({
                            command: Ve.setZoom,
                            args: [
                                i32.zoom
                            ]
                        }), t1(e26.bearing, i32.bearing) || o29.push({
                            command: Ve.setBearing,
                            args: [
                                i32.bearing
                            ]
                        }), t1(e26.pitch, i32.pitch) || o29.push({
                            command: Ve.setPitch,
                            args: [
                                i32.pitch
                            ]
                        }), t1(e26.sprite, i32.sprite) || o29.push({
                            command: Ve.setSprite,
                            args: [
                                i32.sprite
                            ]
                        }), t1(e26.glyphs, i32.glyphs) || o29.push({
                            command: Ve.setGlyphs,
                            args: [
                                i32.glyphs
                            ]
                        }), t1(e26.transition, i32.transition) || o29.push({
                            command: Ve.setTransition,
                            args: [
                                i32.transition
                            ]
                        }), t1(e26.light, i32.light) || o29.push({
                            command: Ve.setLight,
                            args: [
                                i32.light
                            ]
                        }), t1(e26.fog, i32.fog) || o29.push({
                            command: Ve.setFog,
                            args: [
                                i32.fog
                            ]
                        }), t1(e26.projection, i32.projection) || o29.push({
                            command: Ve.setProjection,
                            args: [
                                i32.projection
                            ]
                        });
                        const r12 = {
                        }, n7 = [];
                        !function(e27, i33, o30, r13) {
                            let n8;
                            for(n8 in i33 = i33 || {
                            }, e27 = e27 || {
                            })e27.hasOwnProperty(n8) && (i33.hasOwnProperty(n8) || Xe(n8, o30, r13));
                            for(n8 in i33)i33.hasOwnProperty(n8) && (e27.hasOwnProperty(n8) ? t1(e27[n8], i33[n8]) || ("geojson" === e27[n8].type && "geojson" === i33[n8].type && $e(e27, i33, n8) ? o30.push({
                                command: Ve.setGeoJSONSourceData,
                                args: [
                                    n8,
                                    i33[n8].data
                                ]
                            }) : qe(n8, i33, o30, r13)) : We(n8, i33, o30));
                        }(e26.sources, i32.sources, n7, r12);
                        const s14 = [];
                        e26.layers && e26.layers.forEach((e27)=>{
                            e27.source && r12[e27.source] ? o29.push({
                                command: Ve.removeLayer,
                                args: [
                                    e27.id
                                ]
                            }) : s14.push(e27);
                        });
                        let a14 = e26.terrain;
                        a14 && r12[a14.source] && (o29.push({
                            command: Ve.setTerrain,
                            args: [
                                void 0
                            ]
                        }), a14 = void 0), o29 = o29.concat(n7), t1(a14, i32.terrain) || o29.push({
                            command: Ve.setTerrain,
                            args: [
                                i32.terrain
                            ]
                        }), (function(e27, i33, o30) {
                            i33 = i33 || [];
                            const r13 = (e27 = e27 || []).map(Ye), n8 = i33.map(Ye), s16 = e27.reduce(Ke, {
                            }), a15 = i33.reduce(Ke, {
                            }), l20 = r13.slice(), c14 = Object.create(null);
                            let h13, u16, _2, d8, p11, m7, f9;
                            for(h13 = 0, u16 = 0; h13 < r13.length; h13++)_2 = r13[h13], a15.hasOwnProperty(_2) ? u16++ : (o30.push({
                                command: Ve.removeLayer,
                                args: [
                                    _2
                                ]
                            }), l20.splice(l20.indexOf(_2, u16), 1));
                            for(h13 = 0, u16 = 0; h13 < n8.length; h13++)_2 = n8[n8.length - 1 - h13], l20[l20.length - 1 - h13] !== _2 && (s16.hasOwnProperty(_2) ? (o30.push({
                                command: Ve.removeLayer,
                                args: [
                                    _2
                                ]
                            }), l20.splice(l20.lastIndexOf(_2, l20.length - u16), 1)) : u16++, m7 = l20[l20.length - h13], o30.push({
                                command: Ve.addLayer,
                                args: [
                                    a15[_2],
                                    m7
                                ]
                            }), l20.splice(l20.length - h13, 0, _2), c14[_2] = !0);
                            for(h13 = 0; h13 < n8.length; h13++)if (_2 = n8[h13], d8 = s16[_2], p11 = a15[_2], !c14[_2] && !t1(d8, p11)) {
                                if (t1(d8.source, p11.source) && t1(d8["source-layer"], p11["source-layer"]) && t1(d8.type, p11.type)) {
                                    for(f9 in He(d8.layout, p11.layout, o30, _2, null, Ve.setLayoutProperty), He(d8.paint, p11.paint, o30, _2, null, Ve.setPaintProperty), t1(d8.filter, p11.filter) || o30.push({
                                        command: Ve.setFilter,
                                        args: [
                                            _2,
                                            p11.filter
                                        ]
                                    }), t1(d8.minzoom, p11.minzoom) && t1(d8.maxzoom, p11.maxzoom) || o30.push({
                                        command: Ve.setLayerZoomRange,
                                        args: [
                                            _2,
                                            p11.minzoom,
                                            p11.maxzoom
                                        ]
                                    }), d8)d8.hasOwnProperty(f9) && "layout" !== f9 && "paint" !== f9 && "filter" !== f9 && "metadata" !== f9 && "minzoom" !== f9 && "maxzoom" !== f9 && (0 === f9.indexOf("paint.") ? He(d8[f9], p11[f9], o30, _2, f9.slice(6), Ve.setPaintProperty) : t1(d8[f9], p11[f9]) || o30.push({
                                        command: Ve.setLayerProperty,
                                        args: [
                                            _2,
                                            f9,
                                            p11[f9]
                                        ]
                                    }));
                                    for(f9 in p11)p11.hasOwnProperty(f9) && !d8.hasOwnProperty(f9) && "layout" !== f9 && "paint" !== f9 && "filter" !== f9 && "metadata" !== f9 && "minzoom" !== f9 && "maxzoom" !== f9 && (0 === f9.indexOf("paint.") ? He(d8[f9], p11[f9], o30, _2, f9.slice(6), Ve.setPaintProperty) : t1(d8[f9], p11[f9]) || o30.push({
                                        command: Ve.setLayerProperty,
                                        args: [
                                            _2,
                                            f9,
                                            p11[f9]
                                        ]
                                    }));
                                } else o30.push({
                                    command: Ve.removeLayer,
                                    args: [
                                        _2
                                    ]
                                }), m7 = l20[l20.lastIndexOf(_2) + 1], o30.push({
                                    command: Ve.addLayer,
                                    args: [
                                        p11,
                                        m7
                                    ]
                                });
                            }
                        })(s14, i32.layers, o29);
                    } catch (e27) {
                        console.warn("Unable to compute style diff:", e27), o29 = [
                            {
                                command: Ve.setStyle,
                                args: [
                                    i32
                                ]
                            }
                        ];
                    }
                    return o29;
                })(this.serialize(), i).filter((e26)=>!(e26.command in Ht)
                );
                if (0 === o28.length) return !1;
                const r12 = o28.filter((e26)=>!(e26.command in $t)
                );
                if (r12.length > 0) throw new Error(`Unimplemented: ${r12.map((e26)=>e26.command
                ).join(", ")}.`);
                return o28.forEach((e26)=>{
                    "setTransition" !== e26.command && "setProjection" !== e26.command && this[e26.command].apply(this, e26.args);
                }), this.stylesheet = i, this._updateMapProjection(), !0;
            }
            addImage(t, i) {
                return this.getImage(t) ? this.fire(new e1.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t, i), this._afterImageUpdated(t), this);
            }
            updateImage(e, t) {
                this.imageManager.updateImage(e, t);
            }
            getImage(e) {
                return this.imageManager.getImage(e);
            }
            removeImage(t) {
                return this.getImage(t) ? (this.imageManager.removeImage(t), this._afterImageUpdated(t), this) : this.fire(new e1.ErrorEvent(new Error("No image with this name exists.")));
            }
            _afterImageUpdated(t) {
                this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e1.Event("data", {
                    dataType: "style"
                }));
            }
            listImages() {
                return this._checkLoaded(), this._availableImages.slice();
            }
            addSource(t, i, o = {
            }) {
                if (this._checkLoaded(), (void 0) !== this.getSource(t)) throw new Error("There is already a source with this ID");
                if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                if ([
                    "vector",
                    "raster",
                    "geojson",
                    "video",
                    "image"
                ].indexOf(i.type) >= 0 && this._validate(e1.validateSource, `sources.${t}`, i, null, o)) return;
                this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                const r12 = ze(t, i, this.dispatcher, this);
                r12.setEventedParent(this, ()=>({
                        isSourceLoaded: this._isSourceCacheLoaded(t),
                        source: r12.serialize(),
                        sourceId: t
                    })
                );
                const n7 = (i32)=>{
                    const o28 = (i32 ? "symbol:" : "other:") + t, n8 = this._sourceCaches[o28] = new e1.SourceCache(o28, r12, i32);
                    (i32 ? this._symbolSourceCaches : this._otherSourceCaches)[t] = n8, n8.style = this, n8.onAdd(this.map);
                };
                n7(!1), "vector" !== i.type && "geojson" !== i.type || n7(!0), r12.onAdd && r12.onAdd(this.map), this._changed = !0;
            }
            removeSource(t) {
                this._checkLoaded();
                const i32 = this.getSource(t);
                if (!i32) throw new Error("There is no source with this ID");
                for(const i33 in this._layers)if (this._layers[i33].source === t) return this.fire(new e1.ErrorEvent(new Error(`Source "${t}" cannot be removed while layer "${i33}" is using it.`)));
                if (this.terrain && this.terrain.get().source === t) return this.fire(new e1.ErrorEvent(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));
                const o28 = this._getSourceCaches(t);
                for (const t25 of o28)delete this._sourceCaches[t25.id], delete this._updatedSources[t25.id], t25.fire(new e1.Event("data", {
                    sourceDataType: "metadata",
                    dataType: "source",
                    sourceId: t25.getSource().id
                })), t25.setEventedParent(null), t25.clearTiles();
                return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], i32.setEventedParent(null), i32.onRemove && i32.onRemove(this.map), this._changed = !0, this;
            }
            setGeoJSONSourceData(e, t) {
                this._checkLoaded(), this.getSource(e).setData(t), this._changed = !0;
            }
            getSource(e) {
                const t25 = this._getSourceCache(e);
                return t25 && t25.getSource();
            }
            _getSources() {
                const e26 = [];
                for(const t25 in this._otherSourceCaches){
                    const i32 = this._getSourceCache(t25);
                    i32 && e26.push(i32.getSource());
                }
                return e26;
            }
            addLayer(t, i, o = {
            }) {
                this._checkLoaded();
                const r12 = t.id;
                if (this.getLayer(r12)) return void this.fire(new e1.ErrorEvent(new Error(`Layer with id "${r12}" already exists on this map`)));
                let n7;
                if ("custom" === t.type) {
                    if (qt(this, e1.validateCustomStyleLayer(t))) return;
                    n7 = e1.createStyleLayer(t);
                } else {
                    if ("object" == typeof t.source && (this.addSource(r12, t.source), t = e1.clone$1(t), t = e1.extend(t, {
                        source: r12
                    })), this._validate(e1.validateLayer, `layers.${r12}`, t, {
                        arrayIndex: -1
                    }, o)) return;
                    n7 = e1.createStyleLayer(t), this._validateLayer(n7), n7.setEventedParent(this, {
                        layer: {
                            id: r12
                        }
                    }), this._serializedLayers[n7.id] = n7.serialize(), this._updateLayerCount(n7, !0);
                }
                const s14 = i ? this._order.indexOf(i) : this._order.length;
                if (i && -1 === s14) return void this.fire(new e1.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));
                this._order.splice(s14, 0, r12), this._layerOrderChanged = !0, this._layers[r12] = n7;
                const a14 = this._getLayerSourceCache(n7);
                if (this._removedLayers[r12] && n7.source && a14 && "custom" !== n7.type) {
                    const e26 = this._removedLayers[r12];
                    delete this._removedLayers[r12], e26.type !== n7.type ? this._updatedSources[n7.source] = "clear" : (this._updatedSources[n7.source] = "reload", a14.pause());
                }
                this._updateLayer(n7), n7.onAdd && n7.onAdd(this.map), this._updateDrapeFirstLayers();
            }
            moveLayer(t, i) {
                if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new e1.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));
                if (t === i) return;
                const o28 = this._order.indexOf(t);
                this._order.splice(o28, 1);
                const r12 = i ? this._order.indexOf(i) : this._order.length;
                i && -1 === r12 ? this.fire(new e1.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`))) : (this._order.splice(r12, 0, t), this._layerOrderChanged = !0, this._updateDrapeFirstLayers());
            }
            removeLayer(t) {
                this._checkLoaded();
                const i32 = this._layers[t];
                if (!i32) return void this.fire(new e1.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be removed.`)));
                i32.setEventedParent(null), this._updateLayerCount(i32, !1);
                const o28 = this._order.indexOf(t);
                this._order.splice(o28, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = i32, delete this._layers[t], delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], i32.onRemove && i32.onRemove(this.map), this._updateDrapeFirstLayers();
            }
            getLayer(e) {
                return this._layers[e];
            }
            hasLayer(e) {
                return e in this._layers;
            }
            hasLayerType(e) {
                for(const t25 in this._layers)if (this._layers[t25].type === e) return !0;
                return !1;
            }
            setLayerZoomRange(t, i, o) {
                this._checkLoaded();
                const r12 = this.getLayer(t);
                r12 ? r12.minzoom === i && r12.maxzoom === o || (null != i && (r12.minzoom = i), null != o && (r12.maxzoom = o), this._updateLayer(r12)) : this.fire(new e1.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot have zoom extent.`)));
            }
            setFilter(i, o, r = {
            }) {
                this._checkLoaded();
                const n7 = this.getLayer(i);
                if (n7) {
                    if (!t1(n7.filter, o)) return null == o ? (n7.filter = void 0, void this._updateLayer(n7)) : void (this._validate(e1.validateFilter, `layers.${n7.id}.filter`, o, {
                        layerType: n7.type
                    }, r) || (n7.filter = e1.clone$1(o), this._updateLayer(n7)));
                } else this.fire(new e1.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be filtered.`)));
            }
            getFilter(t) {
                const i32 = this.getLayer(t);
                return i32 && e1.clone$1(i32.filter);
            }
            setLayoutProperty(i, o, r, n = {
            }) {
                this._checkLoaded();
                const s14 = this.getLayer(i);
                s14 ? t1(s14.getLayoutProperty(o), r) || (s14.setLayoutProperty(o, r, n), this._updateLayer(s14)) : this.fire(new e1.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));
            }
            getLayoutProperty(t, i) {
                const o28 = this.getLayer(t);
                if (o28) return o28.getLayoutProperty(i);
                this.fire(new e1.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style.`)));
            }
            setPaintProperty(i, o, r, n = {
            }) {
                this._checkLoaded();
                const s14 = this.getLayer(i);
                s14 ? t1(s14.getPaintProperty(o), r) || (s14.setPaintProperty(o, r, n) && this._updateLayer(s14), this._changed = !0, this._updatedPaintProps[i] = !0) : this.fire(new e1.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));
            }
            getPaintProperty(e, t) {
                const i32 = this.getLayer(e);
                return i32 && i32.getPaintProperty(t);
            }
            setFeatureState(t, i) {
                this._checkLoaded();
                const o28 = t.source, r12 = t.sourceLayer, n7 = this.getSource(o28);
                if (!n7) return void this.fire(new e1.ErrorEvent(new Error(`The source '${o28}' does not exist in the map's style.`)));
                const s14 = n7.type;
                if ("geojson" === s14 && r12) return void this.fire(new e1.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                if ("vector" === s14 && !r12) return void this.fire(new e1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                (void 0) === t.id && this.fire(new e1.ErrorEvent(new Error("The feature id parameter must be provided.")));
                const a14 = this._getSourceCaches(o28);
                for (const e26 of a14)e26.setFeatureState(r12, t.id, i);
            }
            removeFeatureState(t, i) {
                this._checkLoaded();
                const o28 = t.source, r12 = this.getSource(o28);
                if (!r12) return void this.fire(new e1.ErrorEvent(new Error(`The source '${o28}' does not exist in the map's style.`)));
                const n7 = r12.type, s14 = "vector" === n7 ? t.sourceLayer : void 0;
                if ("vector" === n7 && !s14) return void this.fire(new e1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                if (i && "string" != typeof t.id && "number" != typeof t.id) return void this.fire(new e1.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
                const a14 = this._getSourceCaches(o28);
                for (const e26 of a14)e26.removeFeatureState(s14, t.id, i);
            }
            getFeatureState(t) {
                this._checkLoaded();
                const i32 = t.source, o28 = t.sourceLayer, r12 = this.getSource(i32);
                if (r12) {
                    if ("vector" !== r12.type || o28) return (void 0) === t.id && this.fire(new e1.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i32)[0].getFeatureState(o28, t.id);
                    this.fire(new e1.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                } else this.fire(new e1.ErrorEvent(new Error(`The source '${i32}' does not exist in the map's style.`)));
            }
            getTransition() {
                return e1.extend({
                    duration: 300,
                    delay: 0
                }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
                const t25 = {
                };
                for(const e26 in this._sourceCaches){
                    const i32 = this._sourceCaches[e26].getSource();
                    t25[i32.id] || (t25[i32.id] = i32.serialize());
                }
                return e1.filterObject({
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    light: this.stylesheet.light,
                    terrain: this.getTerrain() || void 0,
                    fog: this.stylesheet.fog,
                    center: this.stylesheet.center,
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: t25,
                    layers: this._serializeLayers(this._order)
                }, (e27)=>(void 0) !== e27
                );
            }
            _updateLayer(e) {
                this._updatedLayers[e.id] = !0;
                const t25 = this._getLayerSourceCache(e);
                e.source && !this._updatedSources[e.source] && t25 && "raster" !== t25.getSource().type && (this._updatedSources[e.source] = "reload", t25.pause()), this._changed = !0, e.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(e) {
                const t25 = (e26)=>"fill-extrusion" === this._layers[e26].type
                , i32 = {
                }, o28 = [];
                for(let r12 = this._order.length - 1; r12 >= 0; r12--){
                    const n7 = this._order[r12];
                    if (t25(n7)) {
                        i32[n7] = r12;
                        for (const t26 of e){
                            const e26 = t26[n7];
                            if (e26) for (const t27 of e26)o28.push(t27);
                        }
                    }
                }
                o28.sort((e26, t26)=>t26.intersectionZ - e26.intersectionZ
                );
                const r13 = [];
                for(let n7 = this._order.length - 1; n7 >= 0; n7--){
                    const s14 = this._order[n7];
                    if (t25(s14)) for(let e26 = o28.length - 1; e26 >= 0; e26--){
                        const t26 = o28[e26].feature;
                        if (i32[t26.layer.id] < n7) break;
                        r13.push(t26), o28.pop();
                    }
                    else for (const t26 of e){
                        const e27 = t26[s14];
                        if (e27) for (const t27 of e27)r13.push(t27.feature);
                    }
                }
                return r13;
            }
            queryRenderedFeatures(t, i, o) {
                i && i.filter && this._validate(e1.validateFilter, "queryRenderedFeatures.filter", i.filter, null, i);
                const r12 = {
                };
                if (i && i.layers) {
                    if (!Array.isArray(i.layers)) return this.fire(new e1.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                    for (const t25 of i.layers){
                        const i32 = this._layers[t25];
                        if (!i32) return this.fire(new e1.ErrorEvent(new Error(`The layer '${t25}' does not exist in the map's style and cannot be queried for features.`))), [];
                        r12[i32.source] = !0;
                    }
                }
                const n7 = [];
                i.availableImages = this._availableImages;
                const s14 = i && i.layers ? i.layers.some((e26)=>{
                    const t25 = this.getLayer(e26);
                    return t25 && t25.is3D();
                }) : this.has3DLayers(), a14 = R.createFromScreenPoints(t, o);
                for(const e26 in this._sourceCaches){
                    const t25 = this._sourceCaches[e26].getSource().id;
                    i.layers && !r12[t25] || n7.push(Re(this._sourceCaches[e26], this._layers, this._serializedLayers, a14, i, o, s14, !!this.map._showQueryGeometry));
                }
                return this.placement && n7.push(function(e27, t25, i32, o28, r13, n8, s16) {
                    const a15 = {
                    }, l20 = n8.queryRenderedSymbols(o28), c14 = [];
                    for (const e28 of Object.keys(l20).map(Number))c14.push(s16[e28]);
                    c14.sort(Be);
                    for (const i33 of c14){
                        const o29 = i33.featureIndex.lookupSymbolFeatures(l20[i33.bucketInstanceId], t25, i33.bucketIndex, i33.sourceLayerIndex, r13.filter, r13.layers, r13.availableImages, e27);
                        for(const e29 in o29){
                            const t26 = a15[e29] = a15[e29] || [], r14 = o29[e29];
                            r14.sort((e30, t27)=>{
                                const o30 = i33.featureSortOrder;
                                if (o30) {
                                    const i34 = o30.indexOf(e30.featureIndex);
                                    return o30.indexOf(t27.featureIndex) - i34;
                                }
                                return t27.featureIndex - e30.featureIndex;
                            });
                            for (const e30 of r14)t26.push(e30);
                        }
                    }
                    for(const t26 in a15)a15[t26].forEach((o29)=>{
                        const r14 = o29.feature, n9 = i32(e27[t26]).getFeatureState(r14.layer["source-layer"], r14.id);
                        r14.source = r14.layer.source, r14.layer["source-layer"] && (r14.sourceLayer = r14.layer["source-layer"]), r14.state = n9;
                    });
                    return a15;
                }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a14.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n7);
            }
            querySourceFeatures(t, i) {
                i && i.filter && this._validate(e1.validateFilter, "querySourceFeatures.filter", i.filter, null, i);
                const o28 = this._getSourceCaches(t);
                let r12 = [];
                for (const e26 of o28)r12 = r12.concat(Oe(e26, i));
                return r12;
            }
            addSourceType(e, t, i) {
                return Jt.getSourceType(e) ? i(new Error(`A source type called "${e}" already exists.`)) : (Jt.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                    name: e,
                    url: t.workerSourceURL
                }, i) : i(null, null));
            }
            getLight() {
                return this.light.getLight();
            }
            setLight(e, i = {
            }) {
                this._checkLoaded();
                const o28 = this.light.getLight();
                let r12 = !1;
                for(const i32 in e)if (!t1(e[i32], o28[i32])) {
                    r12 = !0;
                    break;
                }
                if (!r12) return;
                const n7 = this._setTransitionParameters({
                    duration: 300,
                    delay: 0
                });
                this.light.setLight(e, i), this.light.updateTransitions(n7);
            }
            getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }
            setTerrainForDraping() {
                this.setTerrain({
                    source: "",
                    exaggeration: 0
                }, 0);
            }
            setTerrain(i, o = 1) {
                if (this._checkLoaded(), !i) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
                if (1 === o) {
                    if ("object" == typeof i.source) {
                        const t25 = "terrain-dem-src";
                        this.addSource(t25, i.source), i = e1.clone$1(i), i = e1.extend(i, {
                            source: t25
                        });
                    }
                    if (this._validate(e1.validateTerrain, "terrain", i)) return;
                }
                if (!this.terrain || this.terrain && o !== this.terrain.drapeRenderMode) this._createTerrain(i, o);
                else {
                    const o28 = this.terrain, r12 = o28.get();
                    for (const t25 of Object.keys(e1.spec.terrain))!i.hasOwnProperty(t25) && e1.spec.terrain[t25].default && (i[t25] = e1.spec.terrain[t25].default);
                    for(const e26 in i)if (!t1(i[e26], r12[e26])) {
                        o28.set(i), this.stylesheet.terrain = i;
                        const e27 = this._setTransitionParameters({
                            duration: 0
                        });
                        o28.updateTransitions(e27);
                        break;
                    }
                }
                this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
            }
            _createFog(e) {
                const t25 = this.fog = new L1(e, this.map.transform);
                this.stylesheet.fog = e;
                const i32 = this._setTransitionParameters({
                    duration: 0
                });
                t25.updateTransitions(i32);
            }
            _updateMarkersOpacity() {
                0 !== this.map._markers.length && this.map._requestDomTask(()=>{
                    for (const e26 of this.map._markers)e26._evaluateOpacity();
                });
            }
            getFog() {
                return this.fog ? this.fog.get() : null;
            }
            setFog(e) {
                if (this._checkLoaded(), !e) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
                if (this.fog) {
                    const i32 = this.fog, o28 = i32.get();
                    0 === Object.keys(e).length && i32.set(e);
                    for(const r12 in e)if (!t1(e[r12], o28[r12])) {
                        i32.set(e), this.stylesheet.fog = e;
                        const t25 = this._setTransitionParameters({
                            duration: 0
                        });
                        i32.updateTransitions(t25);
                        break;
                    }
                } else this._createFog(e);
                this._markersNeedUpdate = !0;
            }
            _setTransitionParameters(t) {
                return {
                    now: e1.exported.now(),
                    transition: e1.extend(t, this.stylesheet.transition)
                };
            }
            _updateDrapeFirstLayers() {
                if (!this.map._optimizeForTerrain || !this.terrain) return;
                const e26 = this._order.filter((e27)=>this.isLayerDraped(this._layers[e27])
                ), t25 = this._order.filter((e27)=>!this.isLayerDraped(this._layers[e27])
                );
                this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e26), this._drapedFirstOrder.push(...t25);
            }
            _createTerrain(e, t) {
                const i32 = this.terrain = new I(e, t);
                this.stylesheet.terrain = e, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
                const o28 = this._setTransitionParameters({
                    duration: 0
                });
                i32.updateTransitions(o28);
            }
            _force3DLayerUpdate() {
                for(const e26 in this._layers){
                    const t25 = this._layers[e26];
                    "fill-extrusion" === t25.type && this._updateLayer(t25);
                }
            }
            _forceSymbolLayerUpdate() {
                for(const e26 in this._layers){
                    const t25 = this._layers[e26];
                    "symbol" === t25.type && this._updateLayer(t25);
                }
            }
            _validate(t, i, o, r, n = {
            }) {
                return (!n || !1 !== n.validate) && qt(this, t.call(e1.validateStyle, e1.extend({
                    key: i,
                    style: this.serialize(),
                    value: o,
                    styleSpec: e1.spec
                }, r)));
            }
            _remove() {
                this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e1.evented.off("pluginStateChange", this._rtlTextPluginCallback);
                for(const e26 in this._layers)this._layers[e26].setEventedParent(null);
                for(const e27 in this._sourceCaches)this._sourceCaches[e27].clearTiles(), this._sourceCaches[e27].setEventedParent(null);
                this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
            }
            _clearSource(e) {
                const t25 = this._getSourceCaches(e);
                for (const e26 of t25)e26.clearTiles();
            }
            _reloadSource(e) {
                const t25 = this._getSourceCaches(e);
                for (const e26 of t25)e26.resume(), e26.reload();
            }
            _reloadSources() {
                for (const e26 of this._getSources())e26.reload && e26.reload();
            }
            _updateSources(e) {
                for(const t25 in this._sourceCaches)this._sourceCaches[t25].update(e);
            }
            _generateCollisionBoxes() {
                for(const e26 in this._sourceCaches){
                    const t25 = this._sourceCaches[e26];
                    t25.resume(), t25.reload();
                }
            }
            _updatePlacement(t, i, o, r, n = !1) {
                let s14 = !1, a14 = !1;
                const l20 = {
                };
                for (const e26 of this._order){
                    const i32 = this._layers[e26];
                    if ("symbol" !== i32.type) continue;
                    if (!l20[i32.source]) {
                        const e27 = this._getLayerSourceCache(i32);
                        if (!e27) continue;
                        l20[i32.source] = e27.getRenderableIds(!0).map((t25)=>e27.getTileByID(t25)
                        ).sort((e28, t25)=>t25.tileID.overscaledZ - e28.tileID.overscaledZ || (e28.tileID.isLessThan(t25.tileID) ? -1 : 1)
                        );
                    }
                    const o28 = this.crossTileSymbolIndex.addLayer(i32, l20[i32.source], t.center.lng, t.projection);
                    s14 = s14 || o28;
                }
                if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n = n || this._layerOrderChanged || 0 === o, this._layerOrderChanged && this.fire(new e1.Event("neworder")), (n || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e1.exported.now(), t.zoom)) && (this.pauseablePlacement = new Gt(t, this._order, n, i, o, r, this.placement, this.fog && t.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l20), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e1.exported.now()), a14 = !0), s14 && this.pauseablePlacement.placement.setStale()), a14 || s14) for (const e27 of this._order){
                    const t25 = this._layers[e27];
                    "symbol" === t25.type && this.placement.updateLayerOpacities(t25, l20[t25.source]);
                }
                return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e1.exported.now());
            }
            _releaseSymbolFadeTiles() {
                for(const e26 in this._sourceCaches)this._sourceCaches[e26].releaseSymbolFadeTiles();
            }
            getImages(e, t, i) {
                this.imageManager.getImages(t.icons, i), this._updateTilesForChangedImages();
                const o28 = (e26)=>{
                    e26 && e26.setDependencies(t.tileID.key, t.type, t.icons);
                };
                o28(this._otherSourceCaches[t.source]), o28(this._symbolSourceCaches[t.source]);
            }
            getGlyphs(e, t, i) {
                this.glyphManager.getGlyphs(t.stacks, i);
            }
            getResource(t, i, o) {
                return e1.makeRequest(i, o);
            }
            _getSourceCache(e) {
                return this._otherSourceCaches[e];
            }
            _getLayerSourceCache(e) {
                return "symbol" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];
            }
            _getSourceCaches(e) {
                const t25 = [];
                return this._otherSourceCaches[e] && t25.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t25.push(this._symbolSourceCaches[e]), t25;
            }
            _isSourceCacheLoaded(t) {
                const i32 = this._getSourceCaches(t);
                return 0 === i32.length ? (this.fire(new e1.ErrorEvent(new Error(`There is no source with ID '${t}'`))), !1) : i32.every((e26)=>e26.loaded()
                );
            }
            has3DLayers() {
                return this._num3DLayers > 0;
            }
            hasSymbolLayers() {
                return this._numSymbolLayers > 0;
            }
            hasCircleLayers() {
                return this._numCircleLayers > 0;
            }
            _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
                this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
        }
        Jt.getSourceType = function(e26) {
            return Le[e26];
        }, Jt.setSourceType = function(e26, t25) {
            Le[e26] = t25;
        }, Jt.registerForPluginStateChange = e1.registerForPluginStateChange;
        var Qt = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0", ei = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ti = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", ii = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", oi = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
        let ri = {
        }, ni = {
        };
        const si = [];
        ui(Qt, si), ui(ti, si), ui(ii, si), ui(oi, si), ri = _i("", ti), ni = _i(oi, ii);
        const ai = _i("\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), li = Qt, ci = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
        var hi = {
            background: _i("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            backgroundPattern: _i("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            circle: _i("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),
            clippingMask: _i("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            heatmap: _i("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            heatmapTexture: _i("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
            collisionBox: _i("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
            collisionCircle: _i("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
            debug: _i("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),
            fill: _i("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillOutline: _i("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillOutlinePattern: _i("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillPattern: _i("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            fillExtrusion: _i("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            fillExtrusionPattern: _i("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"),
            hillshadePrepare: _i("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
            hillshade: _i("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            line: _i("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            linePattern: _i("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
            raster: _i("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
            symbolIcon: _i("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"),
            symbolSDF: _i("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"),
            symbolTextAndIcon: _i("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"),
            terrainRaster: _i("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"),
            terrainDepth: _i("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
            skybox: _i("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ei),
            skyboxGradient: _i("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ei),
            skyboxCapture: _i("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
            globeRaster: _i("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 latLng=u_grid_matrix*vec3(a_pos,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;\n#ifdef GLOBE_POLES\nvec3 up_vector=normalize(globe_pos)*u_tile_up_scale;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"),
            globeAtmosphere: _i("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}")
        };
        function ui(e26, t25) {
            const i32 = e26.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let e27 of i32)if (e27 = e27.trim(), "#" === e27[0] && e27.includes("if") && !e27.includes("endif")) {
                e27 = e27.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                const i33 = e27.split(" ");
                for (const e28 of i33)t25.includes(e28) || t25.push(e28);
            }
        }
        function _i(e26, t25) {
            const i32 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o28 = t25.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), r12 = {
            }, n7 = [
                ...si
            ];
            return ui(e26, n7), ui(t25, n7), {
                fragmentSource: e26 = e26.replace(i32, (e27, t26, i33, o29, n8)=>(r12[n8] = !0, "define" === t26 ? `\n#ifndef HAS_UNIFORM_u_${n8}\nvarying ${i33} ${o29} ${n8};\n#else\nuniform ${i33} ${o29} u_${n8};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${n8}\n    ${i33} ${o29} ${n8} = u_${n8};\n#endif\n`)
                ),
                vertexSource: t25 = t25.replace(i32, (e27, t26, i33, o29, n8)=>{
                    const s14 = "float" === o29 ? "vec2" : "vec4", a14 = n8.match(/color/) ? "color" : s14;
                    return r12[n8] ? "define" === t26 ? `\n#ifndef HAS_UNIFORM_u_${n8}\nuniform lowp float u_${n8}_t;\nattribute ${i33} ${s14} a_${n8};\nvarying ${i33} ${o29} ${n8};\n#else\nuniform ${i33} ${o29} u_${n8};\n#endif\n` : "vec4" === a14 ? `\n#ifndef HAS_UNIFORM_u_${n8}\n    ${n8} = a_${n8};\n#else\n    ${i33} ${o29} ${n8} = u_${n8};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${n8}\n    ${n8} = unpack_mix_${a14}(a_${n8}, u_${n8}_t);\n#else\n    ${i33} ${o29} ${n8} = u_${n8};\n#endif\n` : "define" === t26 ? `\n#ifndef HAS_UNIFORM_u_${n8}\nuniform lowp float u_${n8}_t;\nattribute ${i33} ${s14} a_${n8};\n#else\nuniform ${i33} ${o29} u_${n8};\n#endif\n` : "vec4" === a14 ? `\n#ifndef HAS_UNIFORM_u_${n8}\n    ${i33} ${o29} ${n8} = a_${n8};\n#else\n    ${i33} ${o29} ${n8} = u_${n8};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${n8}\n    ${i33} ${o29} ${n8} = unpack_mix_${a14}(a_${n8}, u_${n8}_t);\n#else\n    ${i33} ${o29} ${n8} = u_${n8};\n#endif\n`;
                }),
                staticAttributes: o28,
                usedDefines: n7
            };
        }
        class di {
            constructor(){
                this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }
            bind(e, t, i, o, r, n, s) {
                this.context = e;
                let a14 = this.boundPaintVertexBuffers.length !== o.length;
                for(let e26 = 0; !a14 && e26 < o.length; e26++)this.boundPaintVertexBuffers[e26] !== o[e26] && (a14 = !0);
                let l20 = this.boundDynamicVertexBuffers.length !== s.length;
                for(let e27 = 0; !l20 && e27 < s.length; e27++)this.boundDynamicVertexBuffers[e27] !== s[e27] && (l20 = !0);
                if (!e.extVertexArrayObject || !this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== i || a14 || l20 || this.boundIndexBuffer !== r || this.boundVertexOffset !== n) this.freshBind(t, i, o, r, n, s);
                else {
                    e.bindVertexArrayOES.set(this.vao);
                    for (const e28 of s)e28 && e28.bind();
                    r && r.dynamicDraw && r.bind();
                }
            }
            freshBind(e, t, i, o, r, n) {
                let s14;
                const a14 = e.numAttributes, l20 = this.context, c14 = l20.gl;
                if (l20.extVertexArrayObject) this.vao && this.destroy(), this.vao = l20.extVertexArrayObject.createVertexArrayOES(), l20.bindVertexArrayOES.set(this.vao), s14 = 0, this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffers = n;
                else {
                    s14 = l20.currentNumAttributes || 0;
                    for(let e26 = a14; e26 < s14; e26++)c14.disableVertexAttribArray(e26);
                }
                t.enableAttributes(c14, e), t.bind(), t.setVertexAttribPointers(c14, e, r);
                for (const t25 of i)t25.enableAttributes(c14, e), t25.bind(), t25.setVertexAttribPointers(c14, e, r);
                for (const t26 of n)t26 && (t26.enableAttributes(c14, e), t26.bind(), t26.setVertexAttribPointers(c14, e, r));
                o && o.bind(), l20.currentNumAttributes = a14;
            }
            destroy() {
                this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
            }
        }
        function pi(t25, i32) {
            const o28 = Math.pow(2, i32.canonical.z), r12 = i32.canonical.y;
            return [
                new e1.MercatorCoordinate(0, r12 / o28).toLngLat().lat,
                new e1.MercatorCoordinate(0, (r12 + 1) / o28).toLngLat().lat
            ];
        }
        function mi(t25, i32, o28, r12, n7, s14, a14) {
            const l20 = t25.context, c14 = l20.gl, h13 = o28.fbo;
            if (!h13) return;
            t25.prepareDrawTile();
            const u16 = t25.useProgram("hillshade");
            l20.activeTexture.set(c14.TEXTURE0), c14.bindTexture(c14.TEXTURE_2D, h13.colorAttachment.get());
            const _2 = ((e26, t26, i33, o29)=>{
                const r13 = i33.paint.get("hillshade-shadow-color"), n8 = i33.paint.get("hillshade-highlight-color"), s16 = i33.paint.get("hillshade-accent-color");
                let a15 = i33.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                "viewport" === i33.paint.get("hillshade-illumination-anchor") && (a15 -= e26.transform.angle);
                const l21 = !e26.options.moving;
                return {
                    u_matrix: o29 || e26.transform.calculateProjMatrix(t26.tileID.toUnwrapped(), l21),
                    u_image: 0,
                    u_latrange: pi(0, t26.tileID),
                    u_light: [
                        i33.paint.get("hillshade-exaggeration"),
                        a15
                    ],
                    u_shadow: r13,
                    u_highlight: n8,
                    u_accent: s16
                };
            })(t25, o28, r12, t25.terrain ? i32.projMatrix : null);
            t25.prepareDrawProgram(l20, u16, i32.toUnwrapped());
            const { tileBoundsBuffer: d8 , tileBoundsIndexBuffer: p11 , tileBoundsSegments: m7  } = t25.getTileBoundsBuffers(o28);
            u16.draw(l20, c14.TRIANGLES, n7, s14, a14, e1.CullFaceMode.disabled, _2, r12.id, d8, p11, m7);
        }
        function fi(t25, i32, o28) {
            if (!i32.needsDEMTextureUpload) return;
            const r12 = t25.context, n7 = r12.gl;
            r12.pixelStoreUnpackPremultiplyAlpha.set(!1), i32.demTexture = i32.demTexture || t25.getTileTexture(o28.stride);
            const s14 = o28.getPixels();
            i32.demTexture ? i32.demTexture.update(s14, {
                premultiply: !1
            }) : i32.demTexture = new e1.Texture(r12, s14, n7.RGBA, {
                premultiply: !1
            }), i32.needsDEMTextureUpload = !1;
        }
        function gi(t25, i32, o28, r12, n7, s14) {
            const a14 = t25.context, l20 = a14.gl;
            if (!i32.dem) return;
            const c14 = i32.dem;
            if (a14.activeTexture.set(l20.TEXTURE1), fi(t25, i32, c14), !i32.demTexture) return;
            i32.demTexture.bind(l20.NEAREST, l20.CLAMP_TO_EDGE);
            const h13 = c14.dim;
            a14.activeTexture.set(l20.TEXTURE0);
            let u16 = i32.fbo;
            if (!u16) {
                const t26 = new e1.Texture(a14, {
                    width: h13,
                    height: h13,
                    data: null
                }, l20.RGBA);
                t26.bind(l20.LINEAR, l20.CLAMP_TO_EDGE), u16 = i32.fbo = a14.createFramebuffer(h13, h13, !0), u16.colorAttachment.set(t26.texture);
            }
            a14.bindFramebuffer.set(u16.framebuffer), a14.viewport.set([
                0,
                0,
                h13,
                h13
            ]);
            const { tileBoundsBuffer: _2 , tileBoundsIndexBuffer: d8 , tileBoundsSegments: p11  } = t25.getMercatorTileBoundsBuffers();
            t25.useProgram("hillshadePrepare").draw(a14, l20.TRIANGLES, r12, n7, s14, e1.CullFaceMode.disabled, ((t26, i33)=>{
                const o29 = i33.stride, r13 = e1.create();
                return e1.ortho(r13, 0, e1.EXTENT, -e1.EXTENT, 0, 0, 1), e1.translate(r13, r13, [
                    0,
                    -e1.EXTENT,
                    0
                ]), {
                    u_matrix: r13,
                    u_image: 1,
                    u_dimension: [
                        o29,
                        o29
                    ],
                    u_zoom: t26.overscaledZ,
                    u_unpack: i33.unpackVector
                };
            })(i32.tileID, c14), o28.id, _2, d8, p11), i32.needsHillshadePrepare = !1;
        }
        const vi = (t25)=>({
                u_matrix: new e1.UniformMatrix4f(t25),
                u_image0: new e1.Uniform1i(t25),
                u_skirt_height: new e1.Uniform1f(t25)
            })
        , xi = (e26, t25)=>({
                u_matrix: e26,
                u_image0: 0,
                u_skirt_height: t25
            })
        , yi = (e26, t25, i32, o28, r12, n7, s14, a14, l20, c14, h13, u16, _2, d8)=>({
                u_proj_matrix: Float32Array.from(e26),
                u_globe_matrix: t25,
                u_normalize_matrix: Float32Array.from(o28),
                u_merc_matrix: i32,
                u_zoom_transition: r12,
                u_merc_center: n7,
                u_image0: 0,
                u_frustum_tl: s14,
                u_frustum_tr: a14,
                u_frustum_br: l20,
                u_frustum_bl: c14,
                u_globe_pos: h13,
                u_globe_radius: u16,
                u_viewport: _2,
                u_grid_matrix: d8 ? Float32Array.from(d8) : new Float32Array(9)
            })
        ;
        function bi(e26, t25) {
            return null != e26 && null != t25 && !(!e26.hasData() || !t25.hasData()) && null != e26.demTexture && null != t25.demTexture && e26.tileID.key !== t25.tileID.key;
        }
        const wi = new class {
            constructor(){
                this.operations = {
                };
            }
            newMorphing(e, t, i, o, r) {
                if (e in this.operations) {
                    const t25 = this.operations[e];
                    t25.to.tileID.key !== i.tileID.key && (t25.queued = i);
                } else this.operations[e] = {
                    startTime: o,
                    phase: 0,
                    duration: r,
                    from: t,
                    to: i,
                    queued: null
                };
            }
            getMorphValuesForProxy(e) {
                if (!(e in this.operations)) return null;
                const t25 = this.operations[e];
                return {
                    from: t25.from,
                    to: t25.to,
                    phase: t25.phase
                };
            }
            update(e) {
                for(const t25 in this.operations){
                    const i32 = this.operations[t25];
                    for(i32.phase = (e - i32.startTime) / i32.duration; i32.phase >= 1 || !this._validOp(i32);)if (!this._nextOp(i32, e)) {
                        delete this.operations[t25];
                        break;
                    }
                }
            }
            _nextOp(e, t) {
                return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0);
            }
            _validOp(e) {
                return e.from.hasData() && e.to.hasData();
            }
        }, Ti = {
            0: null,
            1: "TERRAIN_VERTEX_MORPHING",
            2: "TERRAIN_WIREFRAME"
        };
        function Ei(e26, t25) {
            const i32 = 1 << e26.z;
            return !t25 && (0 === e26.x || e26.x === i32 - 1) || 0 === e26.y || e26.y === i32 - 1;
        }
        const Ci = (e26)=>({
                u_matrix: e26
            })
        ;
        function Ii(t25, i32, o28, r12, n7) {
            if (n7 > 0) {
                const s14 = e1.exported.now(), a14 = (s14 - t25.timeAdded) / n7, l20 = i32 ? (s14 - i32.timeAdded) / n7 : -1, c14 = o28.getSource(), h13 = r12.coveringZoomLevel({
                    tileSize: c14.tileSize,
                    roundZoom: c14.roundZoom
                }), u16 = !i32 || Math.abs(i32.tileID.overscaledZ - h13) > Math.abs(t25.tileID.overscaledZ - h13), _2 = u16 && t25.refreshedUponExpiration ? 1 : e1.clamp(u16 ? a14 : 1 - l20, 0, 1);
                return t25.refreshedUponExpiration && a14 >= 1 && (t25.refreshedUponExpiration = !1), i32 ? {
                    opacity: 1,
                    mix: 1 - _2
                } : {
                    opacity: _2,
                    mix: 0
                };
            }
            return {
                opacity: 1,
                mix: 0
            };
        }
        class Mi extends e1.SourceCache {
            constructor(e26){
                const t25 = {
                    type: "raster-dem",
                    maxzoom: e26.transform.maxZoom
                }, i32 = new z(Ge(), null), o28 = ze("mock-dem", t25, i32, e26.style);
                super("mock-dem", o28, !1), o28.setEventedParent(this), this._sourceLoaded = !0;
            }
            _loadTile(e, t) {
                e.state = "loaded", t(null);
            }
        }
        class Si extends e1.SourceCache {
            constructor(e27){
                const t26 = ze("proxy", {
                    type: "geojson",
                    maxzoom: e27.transform.maxZoom
                }, new z(Ge(), null), e27.style);
                super("proxy", t26, !1), t26.setEventedParent(this), this.map = this.getSource().map = e27, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {
                };
            }
            update(t, i, o) {
                if (t.freezeTileCoverage) return;
                this.transform = t;
                const r12 = t.coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled
                }).reduce((i33, o29)=>{
                    if (i33[o29.key] = "", !this._tiles[o29.key]) {
                        const i34 = new e1.Tile(o29, this._source.tileSize * o29.overscaleFactor(), t.tileZoom);
                        i34.state = "loaded", this._tiles[o29.key] = i34;
                    }
                    return i33;
                }, {
                });
                for(const e28 in this._tiles)e28 in r12 || (this.freeFBO(e28), this._tiles[e28].unloadVectorData(), delete this._tiles[e28]);
            }
            freeFBO(e) {
                const t27 = this.proxyCachedFBO[e];
                if ((void 0) !== t27) {
                    const i33 = Object.values(t27);
                    this.renderCachePool.push(...i33), delete this.proxyCachedFBO[e];
                }
            }
            deallocRenderCache() {
                this.renderCache.forEach((e28)=>e28.fb.destroy()
                ), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {
                };
            }
        }
        class Di extends e1.OverscaledTileID {
            constructor(e28, t27, i33){
                super(e28.overscaledZ, e28.wrap, e28.canonical.z, e28.canonical.x, e28.canonical.y), this.proxyTileKey = t27, this.projMatrix = i33;
            }
        }
        class Ai extends e1.Elevation {
            constructor(t28, i34){
                super(), this.painter = t28, this.terrainTileForTile = {
                }, this.prevTerrainTileForTile = {
                };
                const [o29, r12, n7] = function(t29) {
                    const i35 = new e1.StructArrayLayout4i8, o30 = new e1.StructArrayLayout3ui6, r13 = 131;
                    i35.reserve(17161), o30.reserve(33800);
                    const n8 = e1.EXTENT / 128, s14 = e1.EXTENT + n8 / 2, a14 = s14 + n8;
                    for(let t30 = -n8; t30 < a14; t30 += n8)for(let o31 = -n8; o31 < a14; o31 += n8){
                        const r14 = o31 < 0 || o31 > s14 || t30 < 0 || t30 > s14 ? 24575 : 0, n9 = e1.clamp(Math.round(o31), 0, e1.EXTENT), a15 = e1.clamp(Math.round(t30), 0, e1.EXTENT);
                        i35.emplaceBack(n9 + r14, a15, n9, a15);
                    }
                    const l20 = (e29, t31)=>{
                        const i36 = t31 * r13 + e29;
                        o30.emplaceBack(i36 + 1, i36, i36 + r13), o30.emplaceBack(i36 + r13, i36 + r13 + 1, i36 + 1);
                    };
                    for(let e29 = 1; e29 < 129; e29++)for(let t31 = 1; t31 < 129; t31++)l20(t31, e29);
                    return [
                        0,
                        129
                    ].forEach((e30)=>{
                        for(let t32 = 0; t32 < 130; t32++)l20(t32, e30), l20(e30, t32);
                    }), [
                        i35,
                        o30,
                        32768
                    ];
                }(), s14 = t28.context;
                this.gridBuffer = s14.createVertexBuffer(o29, e1.boundsAttributes.members), this.gridIndexBuffer = s14.createIndexBuffer(r12), this.gridSegments = e1.SegmentVector.simpleSegment(0, 0, o29.length, r12.length), this.gridNoSkirtSegments = e1.SegmentVector.simpleSegment(0, 0, o29.length, n7), this.proxyCoords = [], this.proxiedCoords = {
                }, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {
                }, this.proxySourceCache = new Si(i34.map), this.orthoMatrix = e1.create(), e1.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e1.EXTENT, 0, e1.EXTENT, 0, 1);
                const a14 = s14.gl;
                this._overlapStencilMode = new e1.StencilMode({
                    func: a14.GEQUAL,
                    mask: 255
                }, 0, 255, a14.KEEP, a14.KEEP, a14.REPLACE), this._previousZoom = t28.transform.zoom, this.pool = [], this._findCoveringTileCache = {
                }, this._tilesDirty = {
                }, this.style = i34, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Mi(i34.map);
            }
            set style(e) {
                e.on("data", this._onStyleDataEvent.bind(this)), e.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e, this._checkRenderCacheEfficiency();
            }
            update(t, i, o) {
                if (t && t.terrain) {
                    this._style !== t && (this.style = t), this.enabled = !0;
                    const r13 = t.terrain.properties;
                    this.sourceCache = 0 === t.terrain.drapeRenderMode ? this._mockSourceCache : t._getSourceCache(r13.get("source")), this._exaggeration = r13.get("exaggeration");
                    const n8 = ()=>{
                        this.sourceCache.used && e1.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                        const t29 = this.getScaledDemTileSize();
                        this.sourceCache.update(i, t29, !0), this.resetTileLookupCache(this.sourceCache.id);
                    };
                    this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, n8(), this._initializing = !0), n8(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0;
                } else this._disable();
            }
            resetTileLookupCache(e) {
                this._findCoveringTileCache[e] = {
                };
            }
            getScaledDemTileSize() {
                return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }
            _checkRenderCacheEfficiency() {
                const t29 = this.renderCacheEfficiency(this._style);
                this._style.map._optimizeForTerrain || 100 !== t29.efficiency && e1.warnOnce(`Terrain render cache efficiency is not optimal (${t29.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${t29.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
            }
            _onStyleDataEvent(e) {
                e.coord && "source" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : "style" === e.dataType && (this._invalidateRenderCache = !0);
            }
            _disable() {
                if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for(const e29 in this._style._sourceCaches)this._style._sourceCaches[e29].usedForTerrain = !1;
            }
            destroy() {
                this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e29)=>e29.fb.destroy()
                ), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
            }
            _source() {
                return this.enabled ? this.sourceCache : null;
            }
            isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
            }
            exaggeration() {
                return this._exaggeration;
            }
            get visibleDemTiles() {
                return this._visibleDemTiles;
            }
            get drapeBufferSize() {
                const e29 = 2 * this.proxySourceCache.getSource().tileSize;
                return [
                    e29,
                    e29
                ];
            }
            set useVertexMorphing(e) {
                this._useVertexMorphing = e;
            }
            updateTileBinding(t) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const i35 = this.proxySourceCache, o30 = this.painter.transform;
                this._initializing && (this._initializing = 0 === o30._centerAltitude && -1 === this.getAtPointOrZero(e1.MercatorCoordinate.fromLngLat(o30.center), -1), this._emptyDEMTextureDirty = !this._initializing);
                const r13 = this.proxyCoords = i35.getIds().map((e29)=>{
                    const t29 = i35.getTileByID(e29).tileID;
                    return t29.projMatrix = o30.calculateProjMatrix(t29.toUnwrapped()), t29;
                });
                !function(t29, i36) {
                    const o31 = i36.transform.pointCoordinate(i36.transform.getCameraPoint()), r14 = new e1.pointGeometry(o31.x, o31.y);
                    t29.sort((t30, i37)=>{
                        if (i37.overscaledZ - t30.overscaledZ) return i37.overscaledZ - t30.overscaledZ;
                        const o32 = new e1.pointGeometry(t30.canonical.x + (1 << t30.canonical.z) * t30.wrap, t30.canonical.y), n8 = new e1.pointGeometry(i37.canonical.x + (1 << i37.canonical.z) * i37.wrap, i37.canonical.y), s16 = r14.mult(1 << t30.canonical.z);
                        return s16.x -= 0.5, s16.y -= 0.5, s16.distSqr(o32) - s16.distSqr(n8);
                    });
                }(r13, this.painter), this._previousZoom = o30.zoom;
                const n8 = this.proxyToSource || {
                };
                this.proxyToSource = {
                }, r13.forEach((e29)=>{
                    this.proxyToSource[e29.key] = {
                    };
                }), this.terrainTileForTile = {
                };
                const s16 = this._style._sourceCaches;
                for(const e29 in s16){
                    const i36 = s16[e29];
                    if (!i36.used) continue;
                    if (i36 !== this.sourceCache && this.resetTileLookupCache(i36.id), this._setupProxiedCoordsForOrtho(i36, t[e29], n8), i36.usedForTerrain) continue;
                    const o31 = t[e29];
                    i36.getSource().reparseOverscaled && this._assignTerrainTiles(o31);
                }
                this.proxiedCoords[i35.id] = r13.map((e30)=>new Di(e30, e30.key, this.orthoMatrix)
                ), this._assignTerrainTiles(r13), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n8), this.renderingToTexture = !1, this._updateTimestamp = e1.exported.now();
                const a15 = {
                };
                this._visibleDemTiles = [];
                for (const e30 of this.proxyCoords){
                    const t29 = this.terrainTileForTile[e30.key];
                    if (!t29) continue;
                    const i36 = t29.tileID.key;
                    i36 in a15 || (this._visibleDemTiles.push(t29), a15[i36] = i36);
                }
            }
            _assignTerrainTiles(e) {
                this._initializing || e.forEach((e29)=>{
                    if (this.terrainTileForTile[e29.key]) return;
                    const t29 = this._findTileCoveringTileID(e29, this.sourceCache);
                    t29 && (this.terrainTileForTile[e29.key] = t29);
                });
            }
            _prepareDEMTextures() {
                const e29 = this.painter.context, t29 = e29.gl;
                for(const i35 in this.terrainTileForTile){
                    const o30 = this.terrainTileForTile[i35], r13 = o30.dem;
                    !r13 || o30.demTexture && !o30.needsDEMTextureUpload || (e29.activeTexture.set(t29.TEXTURE1), fi(this.painter, o30, r13));
                }
            }
            _prepareDemTileUniforms(e, t, i, o) {
                if (!t || null == t.demTexture) return !1;
                const r13 = e.tileID.canonical, n8 = Math.pow(2, t.tileID.canonical.z - r13.z), s16 = o || "";
                return i[`u_dem_tl${s16}`] = [
                    r13.x * n8 % 1,
                    r13.y * n8 % 1
                ], i[`u_dem_scale${s16}`] = n8, !0;
            }
            get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            get emptyDepthBufferTexture() {
                const t29 = this.painter.context, i35 = t29.gl;
                if (!this._emptyDepthBufferTexture) {
                    const o30 = new e1.RGBAImage({
                        width: 1,
                        height: 1
                    }, Uint8Array.of(255, 255, 255, 255));
                    this._emptyDepthBufferTexture = new e1.Texture(t29, o30, i35.RGBA, {
                        premultiply: !1
                    });
                }
                return this._emptyDepthBufferTexture;
            }
            _getLoadedAreaMinimum() {
                let e29 = 0;
                const t29 = this._visibleDemTiles.reduce((t30, i35)=>{
                    if (!i35.dem) return t30;
                    const o30 = i35.dem.tree.minimums[0];
                    return o30 > 0 && e29++, t30 + o30;
                }, 0);
                return e29 ? t29 / e29 : 0;
            }
            _updateEmptyDEMTexture() {
                const t29 = this.painter.context, i35 = t29.gl;
                t29.activeTexture.set(i35.TEXTURE2);
                const o30 = this._getLoadedAreaMinimum(), r13 = new e1.RGBAImage({
                    width: 1,
                    height: 1
                }, new Uint8Array(e1.DEMData.pack(o30, this.sourceCache.getSource().encoding)));
                this._emptyDEMTextureDirty = !1;
                let n8 = this._emptyDEMTexture;
                return n8 ? n8.update(r13, {
                    premultiply: !1
                }) : n8 = this._emptyDEMTexture = new e1.Texture(t29, r13, i35.RGBA, {
                    premultiply: !1
                }), n8;
            }
            setupElevationDraw(t, i, o) {
                const r13 = this.painter.context, n8 = r13.gl, s16 = (a15 = this.sourceCache.getSource().encoding, {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_unpack: e1.DEMData.getUnpackVector(a15),
                    u_dem_tl: [
                        0,
                        0
                    ],
                    u_dem_tl_prev: [
                        0,
                        0
                    ],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [
                        0,
                        0
                    ],
                    u_exaggeration: 0
                });
                var a15;
                s16.u_dem_size = this.sourceCache.getSource().tileSize, s16.u_exaggeration = this.exaggeration();
                let l20 = null, c14 = null, h13 = 1;
                if (o && o.morphing && this._useVertexMorphing) {
                    const e29 = o.morphing.srcDemTile, i35 = o.morphing.dstDemTile;
                    h13 = o.morphing.phase, e29 && i35 && (this._prepareDemTileUniforms(t, e29, s16, "_prev") && (c14 = e29), this._prepareDemTileUniforms(t, i35, s16) && (l20 = i35));
                }
                if (c14 && l20 ? (r13.activeTexture.set(n8.TEXTURE2), l20.demTexture.bind(n8.NEAREST, n8.CLAMP_TO_EDGE, n8.NEAREST), r13.activeTexture.set(n8.TEXTURE4), c14.demTexture.bind(n8.NEAREST, n8.CLAMP_TO_EDGE, n8.NEAREST), s16.u_dem_lerp = h13) : (l20 = this.terrainTileForTile[t.tileID.key], r13.activeTexture.set(n8.TEXTURE2), (this._prepareDemTileUniforms(t, l20, s16) ? l20.demTexture : this.emptyDEMTexture).bind(n8.NEAREST, n8.CLAMP_TO_EDGE)), r13.activeTexture.set(n8.TEXTURE3), o && o.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n8.NEAREST, n8.CLAMP_TO_EDGE), this._depthFBO && (s16.u_depth_size_inv = [
                    1 / this._depthFBO.width,
                    1 / this._depthFBO.height
                ])) : (this.emptyDepthBufferTexture.bind(n8.NEAREST, n8.CLAMP_TO_EDGE), s16.u_depth_size_inv = [
                    1,
                    1
                ]), o && o.useMeterToDem && l20) {
                    const t29 = (1 << l20.tileID.canonical.z) * e1.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                    s16.u_meter_to_dem = t29;
                }
                if (o && o.labelPlaneMatrixInv && (s16.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r13, s16), "globe" === this.painter.transform.projection.name) {
                    const e29 = this.globeUniformValues(this.painter.transform, t.tileID.canonical, o && o.useDenormalizedUpVectorScale);
                    i.setGlobeUniformValues(r13, e29);
                }
            }
            globeUniformValues(t, i, o) {
                const r13 = t.projection;
                return {
                    u_tile_tl_up: r13.upVector(i, 0, 0),
                    u_tile_tr_up: r13.upVector(i, e1.EXTENT, 0),
                    u_tile_br_up: r13.upVector(i, e1.EXTENT, e1.EXTENT),
                    u_tile_bl_up: r13.upVector(i, 0, e1.EXTENT),
                    u_tile_up_scale: o ? e1.GLOBE_METERS_TO_ECEF : r13.upVectorScale(i, t.center.lat, t.worldSize).metersToTile
                };
            }
            renderToBackBuffer(t) {
                const i35 = this.painter, o30 = this.painter.context;
                0 !== t.length && (o30.bindFramebuffer.set(null), o30.viewport.set([
                    0,
                    0,
                    i35.width,
                    i35.height
                ]), i35.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, (function(t29, i36, o31, r13, n8) {
                    if ("globe" === t29.transform.projection.name) !function(t30, i37, o32, r14, n9) {
                        const s16 = t30.context, a16 = s16.gl;
                        let l20, c14;
                        const h13 = t30.options.showTerrainWireframe ? 2 : 0, u16 = t30.transform, _2 = e1.globeUseCustomAntiAliasing(t30, s16, u16), d8 = (e29, i38)=>{
                            if (c14 === e29) return;
                            const o33 = [
                                Ti[e29],
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            _2 && o33.push("CUSTOM_ANTIALIASING"), i38 && o33.push(Ti[h13]), l20 = t30.useProgram("globeRaster", null, o33), c14 = e29;
                        }, p11 = t30.colorModeForRenderPass(), m7 = new e1.DepthMode(a16.LEQUAL, e1.DepthMode.ReadWrite, t30.depthRangeFor3D);
                        wi.update(n9);
                        const f9 = e1.calculateGlobeMercatorMatrix(u16), g6 = [
                            e1.mercatorXfromLng(u16.center.lng),
                            e1.mercatorYfromLat(u16.center.lat)
                        ], v4 = h13 ? [
                            !1,
                            !0
                        ] : [
                            !1
                        ], x4 = t30.globeSharedBuffers, y5 = [
                            u16.width * e1.exported.devicePixelRatio,
                            u16.height * e1.exported.devicePixelRatio
                        ], b3 = Float32Array.from(u16.globeMatrix), w4 = {
                            useDenormalizedUpVectorScale: !0
                        };
                        if (v4.forEach((h14)=>{
                            c14 = -1;
                            const _3 = h14 ? a16.LINES : a16.TRIANGLES;
                            for (const c15 of r14){
                                const r15 = o32.getTile(c15), v5 = e1.StencilMode.disabled, T1 = i37.prevTerrainTileForTile[c15.key], E1 = i37.terrainTileForTile[c15.key];
                                bi(T1, E1) && wi.newMorphing(c15.key, T1, E1, n9, 250), s16.activeTexture.set(a16.TEXTURE0), r15.texture.bind(a16.LINEAR, a16.CLAMP_TO_EDGE);
                                const C1 = wi.getMorphValuesForProxy(c15.key), I1 = C1 ? 1 : 0;
                                C1 && e1.extend$1(w4, {
                                    morphing: {
                                        srcDemTile: C1.from,
                                        dstDemTile: C1.to,
                                        phase: e1.easeCubicInOut(C1.phase)
                                    }
                                });
                                const M3 = e1.tileCornersToBounds(c15.canonical), S3 = e1.getLatitudinalLod(M3.getCenter().lat), D1 = e1.getGridMatrix(c15.canonical, M3, S3, u16.worldSize / u16._pixelsPerMercatorPixel), A1 = e1.globeNormalizeECEF(e1.globeTileBounds(c15.canonical)), L1 = yi(u16.projMatrix, b3, f9, A1, e1.globeToMercatorTransition(u16.zoom), g6, u16.frustumCorners.TL, u16.frustumCorners.TR, u16.frustumCorners.BR, u16.frustumCorners.BL, u16.globeCenterInViewSpace, u16.globeRadius, y5, D1);
                                if (d8(I1, h14), i37.setupElevationDraw(r15, l20, w4), t30.prepareDrawProgram(s16, l20, c15.toUnwrapped()), x4) {
                                    const [i38, o33, r16] = h14 ? x4.getWirefameBuffers(t30.context, S3) : x4.getGridBuffers(S3);
                                    l20.draw(s16, _3, m7, v5, p11, e1.CullFaceMode.backCCW, L1, "globe_raster", i38, o33, r16);
                                }
                            }
                        }), x4) {
                            const n10 = [
                                "GLOBE_POLES",
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            _2 && n10.push("CUSTOM_ANTIALIASING"), l20 = t30.useProgram("globeRaster", null, n10);
                            for (const n11 of r14){
                                const { x: r15 , y: c15 , z: h14  } = n11.canonical, _3 = 0 === c15, d9 = c15 === (1 << h14) - 1, [f10, v5, b4, T1] = x4.getPoleBuffers(h14);
                                if (T1 && (_3 || d9)) {
                                    const c16 = o32.getTile(n11);
                                    s16.activeTexture.set(a16.TEXTURE0), c16.texture.bind(a16.LINEAR, a16.CLAMP_TO_EDGE);
                                    let x5 = e1.globePoleMatrixForTile(h14, r15, u16);
                                    const E1 = e1.globeNormalizeECEF(e1.globeTileBounds(n11.canonical)), C1 = (t31, i38)=>t31.draw(s16, a16.TRIANGLES, m7, e1.StencilMode.disabled, p11, e1.CullFaceMode.disabled, yi(u16.projMatrix, x5, x5, E1, 0, g6, u16.frustumCorners.TL, u16.frustumCorners.TR, u16.frustumCorners.BR, u16.frustumCorners.BL, u16.globeCenterInViewSpace, u16.globeRadius, y5), "globe_pole_raster", i38, b4, T1)
                                    ;
                                    i37.setupElevationDraw(c16, l20, w4), t30.prepareDrawProgram(s16, l20, n11.toUnwrapped()), _3 && C1(l20, f10), d9 && (x5 = e1.scale(e1.create(), x5, [
                                        1,
                                        -1,
                                        1
                                    ]), C1(l20, v5));
                                }
                            }
                        }
                    }(t29, i36, o31, r13, n8);
                    else {
                        const s16 = t29.context, a16 = s16.gl;
                        let l20, c14;
                        const h13 = t29.options.showTerrainWireframe ? 2 : 0, u16 = (e29, i37)=>{
                            if (c14 === e29) return;
                            const o32 = [
                                Ti[e29]
                            ];
                            i37 && o32.push(Ti[h13]), l20 = t29.useProgram("terrainRaster", null, o32), c14 = e29;
                        }, _2 = t29.colorModeForRenderPass(), d8 = new e1.DepthMode(a16.LEQUAL, e1.DepthMode.ReadWrite, t29.depthRangeFor3D);
                        wi.update(n8);
                        const p11 = t29.transform, m7 = 6 * Math.pow(1.5, 22 - p11.zoom) * i36.exaggeration();
                        (h13 ? [
                            !1,
                            !0
                        ] : [
                            !1
                        ]).forEach((h14)=>{
                            c14 = -1;
                            const f9 = h14 ? a16.LINES : a16.TRIANGLES, [g6, v4] = h14 ? i36.getWirefameBuffer() : [
                                i36.gridIndexBuffer,
                                i36.gridSegments
                            ];
                            for (const c15 of r13){
                                const r14 = o31.getTile(c15), x4 = e1.StencilMode.disabled, y5 = i36.prevTerrainTileForTile[c15.key], b3 = i36.terrainTileForTile[c15.key];
                                bi(y5, b3) && wi.newMorphing(c15.key, y5, b3, n8, 250), s16.activeTexture.set(a16.TEXTURE0), r14.texture.bind(a16.LINEAR, a16.CLAMP_TO_EDGE, a16.LINEAR_MIPMAP_NEAREST);
                                const w4 = wi.getMorphValuesForProxy(c15.key), T1 = w4 ? 1 : 0;
                                let E1;
                                w4 && (E1 = {
                                    morphing: {
                                        srcDemTile: w4.from,
                                        dstDemTile: w4.to,
                                        phase: e1.easeCubicInOut(w4.phase)
                                    }
                                });
                                const C1 = xi(c15.projMatrix, Ei(c15.canonical, p11.renderWorldCopies) ? m7 / 10 : m7);
                                u16(T1, h14), i36.setupElevationDraw(r14, l20, E1), t29.prepareDrawProgram(s16, l20, c15.toUnwrapped()), l20.draw(s16, f9, d8, x4, _2, e1.CullFaceMode.backCCW, C1, "terrain_raster", i36.gridBuffer, g6, v4);
                            }
                        });
                    }
                })(i35, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, i35.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));
            }
            renderBatch(t) {
                if (0 === this._drapedRenderBatches.length) return t + 1;
                this.renderingToTexture = !0;
                const i35 = this.painter, o30 = this.painter.context, r13 = this.proxySourceCache, n8 = this.proxiedCoords[r13.id], s16 = this._drapedRenderBatches.shift(), a16 = [], l20 = i35.style.order;
                let c14 = 0;
                for (const h13 of n8){
                    const n9 = r13.getTileByID(h13.proxyTileKey), u16 = r13.proxyCachedFBO[h13.key] ? r13.proxyCachedFBO[h13.key][t] : void 0, _2 = (void 0) !== u16 ? r13.renderCache[u16] : this.pool[c14++], d8 = (void 0) !== u16;
                    if (n9.texture = _2.tex, d8 && !_2.dirty) {
                        a16.push(n9.tileID);
                        continue;
                    }
                    let p11;
                    o30.bindFramebuffer.set(_2.fb.framebuffer), this.renderedToTile = !1, _2.dirty && (o30.clear({
                        color: e1.Color.transparent,
                        stencil: 0
                    }), _2.dirty = !1);
                    for(let e29 = s16.start; e29 <= s16.end; ++e29){
                        const t29 = i35.style._layers[l20[e29]];
                        if (t29.isHidden(i35.transform.zoom)) continue;
                        const r14 = i35.style._getLayerSourceCache(t29), n10 = r14 ? this.proxyToSource[h13.key][r14.id] : [
                            h13
                        ];
                        if (!n10) continue;
                        const s17 = n10;
                        o30.viewport.set([
                            0,
                            0,
                            _2.fb.width,
                            _2.fb.height
                        ]), p11 !== (r14 ? r14.id : null) && (this._setupStencil(_2, n10, t29, r14), p11 = r14 ? r14.id : null), i35.renderLayer(i35, r14, t29, s17);
                    }
                    this.renderedToTile ? (_2.dirty = !0, a16.push(n9.tileID)) : d8 || --c14, 5 === c14 && (c14 = 0, this.renderToBackBuffer(a16));
                }
                return this.renderToBackBuffer(a16), this.renderingToTexture = !1, o30.bindFramebuffer.set(null), o30.viewport.set([
                    0,
                    0,
                    i35.width,
                    i35.height
                ]), s16.end + 1;
            }
            postRender() {
            }
            renderCacheEfficiency(e) {
                const t29 = e.order.length;
                if (0 === t29) return {
                    efficiency: 100
                };
                let i35, o30 = 0, r13 = 0, n8 = !1;
                for(let s16 = 0; s16 < t29; ++s16){
                    const t30 = e._layers[e.order[s16]];
                    this._style.isLayerDraped(t30) ? (n8 && ++o30, ++r13) : n8 || (n8 = !0, i35 = t30.id);
                }
                return 0 === r13 ? {
                    efficiency: 100
                } : {
                    efficiency: 100 * (1 - o30 / r13),
                    firstUndrapedLayer: i35
                };
            }
            getMinElevationBelowMSL() {
                let e29 = 0;
                return this._visibleDemTiles.filter((e30)=>e30.dem
                ).forEach((t29)=>{
                    e29 = Math.min(e29, t29.dem.tree.minimums[0]);
                }), 0 === e29 ? e29 : (e29 - 30) * this._exaggeration;
            }
            raycast(e, t, i) {
                if (!this._visibleDemTiles) return null;
                const o30 = this._visibleDemTiles.filter((e29)=>e29.dem
                ).map((o31)=>{
                    const r13 = o31.tileID, n8 = 1 << r13.overscaledZ, { x: s16 , y: a16  } = r13.canonical, l20 = s16 / n8, c14 = (s16 + 1) / n8, h13 = a16 / n8, u16 = (a16 + 1) / n8;
                    return {
                        minx: l20,
                        miny: h13,
                        maxx: c14,
                        maxy: u16,
                        t: o31.dem.tree.raycastRoot(l20, h13, c14, u16, e, t, i),
                        tile: o31
                    };
                });
                o30.sort((e29, t29)=>(null !== e29.t ? e29.t : Number.MAX_VALUE) - (null !== t29.t ? t29.t : Number.MAX_VALUE)
                );
                for (const r13 of o30){
                    if (null == r13.t) return null;
                    const o31 = r13.tile.dem.tree.raycast(r13.minx, r13.miny, r13.maxx, r13.maxy, e, t, i);
                    if (null != o31) return o31;
                }
                return null;
            }
            _createFBO() {
                const t29 = this.painter.context, i35 = t29.gl, o30 = this.drapeBufferSize;
                t29.activeTexture.set(i35.TEXTURE0);
                const r13 = new e1.Texture(t29, {
                    width: o30[0],
                    height: o30[1],
                    data: null
                }, i35.RGBA);
                r13.bind(i35.LINEAR, i35.CLAMP_TO_EDGE);
                const n8 = t29.createFramebuffer(o30[0], o30[1], !1);
                return n8.colorAttachment.set(r13.texture), n8.depthAttachment = new Ee(t29, n8.framebuffer), (void 0) === this._sharedDepthStencil ? (this._sharedDepthStencil = t29.createRenderbuffer(t29.gl.DEPTH_STENCIL, o30[0], o30[1]), this._stencilRef = 0, n8.depthAttachment.set(this._sharedDepthStencil), t29.clear({
                    stencil: 0
                })) : n8.depthAttachment.set(this._sharedDepthStencil), t29.extTextureFilterAnisotropic && !t29.extTextureFilterAnisotropicForceOff && i35.texParameterf(i35.TEXTURE_2D, t29.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t29.extTextureFilterAnisotropicMax), {
                    fb: n8,
                    tex: r13,
                    dirty: !1
                };
            }
            _initFBOPool() {
                for(; this.pool.length < Math.min(5, this.proxyCoords.length);)this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
                if (this._style.light && this._style.light.hasTransition()) return !0;
                for(const e29 in this._style._sourceCaches)if (this._style._sourceCaches[e29].hasTransition()) return !0;
                return this._style.order.some((e30)=>{
                    const t29 = this._style._layers[e30], i35 = t29.isHidden(this.painter.transform.zoom);
                    return "custom" !== t29.type && !i35 && t29.hasTransition();
                });
            }
            _clearRasterFadeFromRenderCache() {
                let e29 = !1;
                for(const t29 in this._style._sourceCaches)if (this._style._sourceCaches[t29]._source instanceof Me) {
                    e29 = !0;
                    break;
                }
                if (e29) for(let e30 = 0; e30 < this._style.order.length; ++e30){
                    const t30 = this._style._layers[this._style.order[e30]], i35 = t30.isHidden(this.painter.transform.zoom), o30 = this._style._getLayerSourceCache(t30);
                    if ("raster" !== t30.type || i35 || !o30) continue;
                    const r13 = t30.paint.get("raster-fade-duration");
                    for (const e31 of this.proxyCoords){
                        const t31 = this.proxyToSource[e31.key][o30.id];
                        if (t31) for (const e32 of t31){
                            const t32 = Ii(o30.getTile(e32), o30.findLoadedParent(e32, 0), o30, this.painter.transform, r13);
                            (1 !== t32.opacity || 0 !== t32.mix) && this._clearRenderCacheForTile(o30.id, e32);
                        }
                    }
                }
            }
            _setupDrapedRenderBatches() {
                const e29 = this._style.order, t29 = e29.length;
                if (0 === t29) return;
                const i35 = [];
                let o30, r13 = 0, n8 = this._style._layers[e29[r13]];
                for(; !this._style.isLayerDraped(n8) && n8.isHidden(this.painter.transform.zoom) && (++r13) < t29;)n8 = this._style._layers[e29[r13]];
                for(; r13 < t29; ++r13){
                    const t30 = this._style._layers[e29[r13]];
                    t30.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t30) ? (void 0) === o30 && (o30 = r13) : (void 0) !== o30 && (i35.push({
                        start: o30,
                        end: r13 - 1
                    }), o30 = void 0));
                }
                (void 0) !== o30 && i35.push({
                    start: o30,
                    end: r13 - 1
                }), this._drapedRenderBatches = i35;
            }
            _setupRenderCache(e) {
                const t29 = this.proxySourceCache;
                if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                    if (this._invalidateRenderCache = !1, t29.renderCache.length > t29.renderCachePool.length) {
                        const e29 = Object.values(t29.proxyCachedFBO);
                        t29.proxyCachedFBO = {
                        };
                        for(let i35 = 0; i35 < e29.length; ++i35){
                            const o30 = Object.values(e29[i35]);
                            t29.renderCachePool.push(...o30);
                        }
                    }
                    return;
                }
                this._clearRasterFadeFromRenderCache();
                const i35 = this.proxyCoords, o30 = this._tilesDirty;
                for(let r13 = i35.length - 1; r13 >= 0; r13--){
                    const n8 = i35[r13];
                    if (t29.getTileByID(n8.key), (void 0) !== t29.proxyCachedFBO[n8.key]) {
                        const i36 = e[n8.key], r14 = this.proxyToSource[n8.key];
                        let s16 = 0;
                        for(const e29 in r14){
                            const t30 = r14[e29], n9 = i36[e29];
                            if (!n9 || n9.length !== t30.length || t30.some((t31, i37)=>t31 !== n9[i37] || o30[e29] && o30[e29].hasOwnProperty(t31.key)
                            )) {
                                s16 = -1;
                                break;
                            }
                            ++s16;
                        }
                        for(const e30 in t29.proxyCachedFBO[n8.key])t29.renderCache[t29.proxyCachedFBO[n8.key][e30]].dirty = s16 < 0 || s16 !== Object.values(i36).length;
                    }
                }
                const r14 = [
                    ...this._drapedRenderBatches
                ];
                r14.sort((e29, t30)=>t30.end - t30.start - (e29.end - e29.start)
                );
                for (const e29 of r14)for (const o31 of i35){
                    if (t29.proxyCachedFBO[o31.key]) continue;
                    let i36 = t29.renderCachePool.pop();
                    (void 0) === i36 && t29.renderCache.length < 50 && (i36 = t29.renderCache.length, t29.renderCache.push(this._createFBO())), (void 0) !== i36 && (t29.proxyCachedFBO[o31.key] = {
                    }, t29.proxyCachedFBO[o31.key][e29.start] = i36, t29.renderCache[i36].dirty = !0);
                }
                this._tilesDirty = {
                };
            }
            _setupStencil(e, t, i, o) {
                if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
                const r13 = this.painter.context, n8 = r13.gl;
                if (t.length <= 1) return void (this._overlapStencilType = !1);
                let s16;
                if (i.isTileClipped()) s16 = t.length, this._overlapStencilMode.test = {
                    func: n8.EQUAL,
                    mask: 255
                }, this._overlapStencilType = "Clip";
                else {
                    if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
                    s16 = 1, this._overlapStencilMode.test = {
                        func: n8.GREATER,
                        mask: 255
                    }, this._overlapStencilType = "Mask";
                }
                this._stencilRef + s16 > 255 && (r13.clear({
                    stencil: 0
                }), this._stencilRef = 0), this._stencilRef += s16, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
                return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }
            stencilModeForRTTOverlap(t) {
                return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : e1.StencilMode.disabled;
            }
            _renderTileClippingMasks(t, i) {
                const o30 = this.painter, r13 = this.painter.context, n8 = r13.gl;
                o30._tileClippingMaskIDs = {
                }, r13.setColorMode(e1.ColorMode.disabled), r13.setDepthMode(e1.DepthMode.disabled);
                const s16 = o30.useProgram("clippingMask");
                for (const a16 of t){
                    const t29 = o30._tileClippingMaskIDs[a16.key] = --i;
                    s16.draw(r13, n8.TRIANGLES, e1.DepthMode.disabled, new e1.StencilMode({
                        func: n8.ALWAYS,
                        mask: 0
                    }, t29, 255, n8.KEEP, n8.KEEP, n8.REPLACE), e1.ColorMode.disabled, e1.CullFaceMode.disabled, Ci(a16.projMatrix), "$clipping", o30.tileExtentBuffer, o30.quadTriangleIndexBuffer, o30.tileExtentSegments);
                }
            }
            pointCoordinate(t) {
                const i35 = this.painter.transform;
                if (t.x < 0 || t.x > i35.width || t.y < 0 || t.y > i35.height) return null;
                const o30 = [
                    t.x,
                    t.y,
                    1,
                    1
                ];
                e1.transformMat4$1(o30, o30, i35.pixelMatrixInverse), e1.scale$1(o30, o30, 1 / o30[3]), o30[0] /= i35.worldSize, o30[1] /= i35.worldSize;
                const r13 = i35._camera.position, n8 = e1.mercatorZfromAltitude(1, i35.center.lat), s16 = [
                    r13[0],
                    r13[1],
                    r13[2] / n8,
                    0
                ], a16 = e1.subtract([], o30.slice(0, 3), s16);
                e1.normalize(a16, a16);
                const l20 = this.raycast(s16, a16, this._exaggeration);
                return null !== l20 && l20 ? (e1.scaleAndAdd(s16, s16, a16, l20), s16[3] = s16[2], s16[2] *= n8, s16) : null;
            }
            drawDepth() {
                const t29 = this.painter, i35 = t29.context, o30 = this.proxySourceCache, r13 = Math.ceil(t29.width), n8 = Math.ceil(t29.height);
                if (!this._depthFBO || this._depthFBO.width === r13 && this._depthFBO.height === n8 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
                    const t30 = i35.gl, o31 = i35.createFramebuffer(r13, n8, !0);
                    i35.activeTexture.set(t30.TEXTURE0);
                    const s16 = new e1.Texture(i35, {
                        width: r13,
                        height: n8,
                        data: null
                    }, t30.RGBA);
                    s16.bind(t30.NEAREST, t30.CLAMP_TO_EDGE), o31.colorAttachment.set(s16.texture);
                    const a16 = i35.createRenderbuffer(i35.gl.DEPTH_COMPONENT16, r13, n8);
                    o31.depthAttachment.set(a16), this._depthFBO = o31, this._depthTexture = s16;
                }
                i35.bindFramebuffer.set(this._depthFBO.framebuffer), i35.viewport.set([
                    0,
                    0,
                    r13,
                    n8
                ]), (function(t30, i36, o31, r14) {
                    if ("globe" === t30.transform.projection.name) return;
                    const n9 = t30.context, s16 = n9.gl;
                    n9.clear({
                        depth: 1
                    });
                    const a16 = t30.useProgram("terrainDepth"), l20 = new e1.DepthMode(s16.LESS, e1.DepthMode.ReadWrite, t30.depthRangeFor3D);
                    for (const t31 of r14){
                        const r15 = o31.getTile(t31), c14 = xi(t31.projMatrix, 0);
                        i36.setupElevationDraw(r15, a16), a16.draw(n9, s16.TRIANGLES, l20, e1.StencilMode.disabled, e1.ColorMode.unblended, e1.CullFaceMode.backCCW, c14, "terrain_depth", i36.gridBuffer, i36.gridIndexBuffer, i36.gridNoSkirtSegments);
                    }
                })(t29, this, o30, this.proxyCoords);
            }
            _setupProxiedCoordsForOrtho(e, t, i) {
                if (e.getSource() instanceof Ae) return this._setupProxiedCoordsForImageSource(e, t, i);
                this._findCoveringTileCache[e.id] = this._findCoveringTileCache[e.id] || {
                };
                const o30 = this.proxiedCoords[e.id] = [], r13 = this.proxyCoords;
                for(let t29 = 0; t29 < r13.length; t29++){
                    const n8 = r13[t29], s16 = this._findTileCoveringTileID(n8, e);
                    if (s16) {
                        const t30 = this._createProxiedId(n8, s16, i[n8.key] && i[n8.key][e.id]);
                        o30.push(t30), this.proxyToSource[n8.key][e.id] = [
                            t30
                        ];
                    }
                }
                let n8 = !1;
                for(let r14 = 0; r14 < t.length; r14++){
                    const s16 = e.getTile(t[r14]);
                    if (!s16 || !s16.hasData()) continue;
                    const a16 = this._findTileCoveringTileID(s16.tileID, this.proxySourceCache);
                    if (a16 && a16.tileID.canonical.z !== s16.tileID.canonical.z) {
                        const t30 = this.proxyToSource[a16.tileID.key][e.id], r15 = this._createProxiedId(a16.tileID, s16, i[a16.tileID.key] && i[a16.tileID.key][e.id]);
                        t30 ? t30.splice(t30.length - 1, 0, r15) : this.proxyToSource[a16.tileID.key][e.id] = [
                            r15
                        ], o30.push(r15), n8 = !0;
                    }
                }
                this._sourceTilesOverlap[e.id] = n8;
            }
            _setupProxiedCoordsForImageSource(t, i, o) {
                if (!t.getSource().loaded()) return;
                const r13 = this.proxiedCoords[t.id] = [], n8 = this.proxyCoords, s16 = t.getSource(), a16 = new e1.pointGeometry(s16.tileID.x, s16.tileID.y)._div(1 << s16.tileID.z), l20 = s16.coordinates.map(e1.MercatorCoordinate.fromLngLat).reduce((e29, t29)=>(e29.min.x = Math.min(e29.min.x, t29.x - a16.x), e29.min.y = Math.min(e29.min.y, t29.y - a16.y), e29.max.x = Math.max(e29.max.x, t29.x - a16.x), e29.max.y = Math.max(e29.max.y, t29.y - a16.y), e29)
                , {
                    min: new e1.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE),
                    max: new e1.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE)
                }), c14 = (t29, i35)=>{
                    const o30 = t29.wrap + t29.canonical.x / (1 << t29.canonical.z), r14 = t29.canonical.y / (1 << t29.canonical.z), n9 = e1.EXTENT / (1 << t29.canonical.z), s17 = i35.wrap + i35.canonical.x / (1 << i35.canonical.z), a17 = i35.canonical.y / (1 << i35.canonical.z);
                    return o30 + n9 < s17 + l20.min.x || o30 > s17 + l20.max.x || r14 + n9 < a17 + l20.min.y || r14 > a17 + l20.max.y;
                };
                for(let e29 = 0; e29 < n8.length; e29++){
                    const s17 = n8[e29];
                    for(let e30 = 0; e30 < i.length; e30++){
                        const n9 = t.getTile(i[e30]);
                        if (!n9 || !n9.hasData()) continue;
                        if (c14(s17, n9.tileID)) continue;
                        const a17 = this._createProxiedId(s17, n9, o[s17.key] && o[s17.key][t.id]), l21 = this.proxyToSource[s17.key][t.id];
                        l21 ? l21.push(a17) : this.proxyToSource[s17.key][t.id] = [
                            a17
                        ], r13.push(a17);
                    }
                }
            }
            _createProxiedId(t, i, o) {
                let r13 = this.orthoMatrix;
                if (o) {
                    const e29 = o.find((e30)=>e30.key === i.tileID.key
                    );
                    if (e29) return e29;
                }
                if (i.tileID.key !== t.key) {
                    const o30 = t.canonical.z - i.tileID.canonical.z;
                    let n8, s16, a16;
                    r13 = e1.create();
                    const l20 = i.tileID.wrap - t.wrap << t.overscaledZ;
                    o30 > 0 ? (n8 = e1.EXTENT >> o30, s16 = n8 * ((i.tileID.canonical.x << o30) - t.canonical.x + l20), a16 = n8 * ((i.tileID.canonical.y << o30) - t.canonical.y)) : (n8 = e1.EXTENT << -o30, s16 = e1.EXTENT * (i.tileID.canonical.x - (t.canonical.x + l20 << -o30)), a16 = e1.EXTENT * (i.tileID.canonical.y - (t.canonical.y << -o30))), e1.ortho(r13, 0, n8, 0, n8, 0, 1), e1.translate(r13, r13, [
                        s16,
                        a16,
                        0
                    ]);
                }
                return new Di(i.tileID, t.key, r13);
            }
            _findTileCoveringTileID(t, i) {
                let o30 = i.getTile(t);
                if (o30 && o30.hasData()) return o30;
                const r13 = this._findCoveringTileCache[i.id], n8 = r13[t.key];
                if (o30 = n8 ? i.getTileByID(n8) : null, o30 && o30.hasData() || null === n8) return o30;
                let s16 = o30 ? o30.tileID : t, a16 = s16.overscaledZ;
                const l20 = i.getSource().minzoom, c14 = [];
                if (!n8) {
                    const r14 = i.getSource().maxzoom;
                    if (t.canonical.z >= r14) {
                        const o31 = t.canonical.z - r14;
                        i.getSource().reparseOverscaled ? (a16 = Math.max(t.canonical.z + 2, i.transform.tileZoom), s16 = new e1.OverscaledTileID(a16, t.wrap, r14, t.canonical.x >> o31, t.canonical.y >> o31)) : 0 !== o31 && (a16 = r14, s16 = new e1.OverscaledTileID(a16, t.wrap, r14, t.canonical.x >> o31, t.canonical.y >> o31));
                    }
                    s16.key !== t.key && (c14.push(s16.key), o30 = i.getTile(s16));
                }
                const h13 = (e29)=>{
                    c14.forEach((t29)=>{
                        r13[t29] = e29;
                    }), c14.length = 0;
                };
                for(a16 -= 1; a16 >= l20 && (!o30 || !o30.hasData()); a16--){
                    o30 && h13(o30.tileID.key);
                    const e29 = s16.calculateScaledKey(a16);
                    if (o30 = i.getTileByID(e29), o30 && o30.hasData()) break;
                    const t29 = r13[e29];
                    if (null === t29) break;
                    (void 0) === t29 ? c14.push(e29) : o30 = i.getTileByID(t29);
                }
                return h13(o30 ? o30.tileID.key : null), o30 && o30.hasData() ? o30 : null;
            }
            findDEMTileFor(e) {
                return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;
            }
            prepareDrawTile() {
                this.renderedToTile = !0;
            }
            _clearRenderCacheForTile(e, t) {
                let i35 = this._tilesDirty[e];
                i35 || (i35 = this._tilesDirty[e] = {
                }), i35[t.key] = !0;
            }
            getWirefameBuffer() {
                if (!this.wireframeSegments) {
                    const t29 = function(t30) {
                        let i35 = 0;
                        const o30 = new e1.StructArrayLayout2ui4, r13 = 131;
                        for(let e29 = 1; e29 < 129; e29++){
                            for(let t31 = 1; t31 < 129; t31++)i35 = e29 * r13 + t31, o30.emplaceBack(i35, i35 + 1), o30.emplaceBack(i35, i35 + r13), o30.emplaceBack(i35 + 1, i35 + r13), 128 === e29 && o30.emplaceBack(i35 + r13, i35 + r13 + 1);
                            o30.emplaceBack(i35 + 1, i35 + 1 + r13);
                        }
                        return o30;
                    }();
                    this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t29), this.wireframeSegments = e1.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t29.length);
                }
                return [
                    this.wireframeIndexBuffer,
                    this.wireframeSegments
                ];
            }
        }
        class Li {
            static cacheKey(e, t, i, o) {
                let r13 = `${t}${o ? o.cacheKey : ""}`;
                for (const t29 of i)e.usedDefines.includes(t29) && (r13 += `/${t29}`);
                return r13;
            }
            constructor(t29, i35, o30, r13, n8, s16){
                const a16 = t29.gl;
                this.program = a16.createProgram();
                const l20 = function(e29) {
                    const t30 = [];
                    for(let i36 = 0; i36 < e29.length; i36++){
                        if (null === e29[i36]) continue;
                        const o31 = e29[i36].split(" ");
                        t30.push(o31.pop());
                    }
                    return t30;
                }(o30.staticAttributes), c14 = r13 ? r13.getBinderAttributes() : [], h13 = l20.concat(c14);
                let u16 = r13 ? r13.defines() : [];
                u16 = u16.concat(s16.map((e29)=>`#define ${e29}`
                ));
                const _2 = u16.concat(t29.extStandardDerivatives ? "#extension GL_OES_standard_derivatives : enable\n".concat(ci) : ci, ci, li, ai.fragmentSource, ni.fragmentSource, o30.fragmentSource).join("\n"), d8 = u16.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", li, ai.vertexSource, ni.vertexSource, ri.vertexSource, o30.vertexSource).join("\n"), p11 = a16.createShader(a16.FRAGMENT_SHADER);
                if (a16.isContextLost()) return void (this.failedToCreate = !0);
                a16.shaderSource(p11, _2), a16.compileShader(p11), a16.attachShader(this.program, p11);
                const m7 = a16.createShader(a16.VERTEX_SHADER);
                if (a16.isContextLost()) this.failedToCreate = !0;
                else {
                    a16.shaderSource(m7, d8), a16.compileShader(m7), a16.attachShader(this.program, m7), this.attributes = {
                    }, this.numAttributes = h13.length;
                    for(let e29 = 0; e29 < this.numAttributes; e29++)h13[e29] && (a16.bindAttribLocation(this.program, e29, h13[e29]), this.attributes[h13[e29]] = e29);
                    a16.linkProgram(this.program), a16.deleteShader(m7), a16.deleteShader(p11), this.fixedUniforms = n8(t29), this.binderUniforms = r13 ? r13.getUniforms(t29) : [], s16.includes("TERRAIN") && (this.terrainUniforms = ((t30)=>({
                            u_dem: new e1.Uniform1i(t30),
                            u_dem_prev: new e1.Uniform1i(t30),
                            u_dem_unpack: new e1.Uniform4f(t30),
                            u_dem_tl: new e1.Uniform2f(t30),
                            u_dem_scale: new e1.Uniform1f(t30),
                            u_dem_tl_prev: new e1.Uniform2f(t30),
                            u_dem_scale_prev: new e1.Uniform1f(t30),
                            u_dem_size: new e1.Uniform1f(t30),
                            u_dem_lerp: new e1.Uniform1f(t30),
                            u_exaggeration: new e1.Uniform1f(t30),
                            u_depth: new e1.Uniform1i(t30),
                            u_depth_size_inv: new e1.Uniform2f(t30),
                            u_meter_to_dem: new e1.Uniform1f(t30),
                            u_label_plane_matrix_inv: new e1.UniformMatrix4f(t30)
                        })
                    )(t29)), s16.includes("GLOBE") && (this.globeUniforms = ((t30)=>({
                            u_tile_tl_up: new e1.Uniform3f(t30),
                            u_tile_tr_up: new e1.Uniform3f(t30),
                            u_tile_br_up: new e1.Uniform3f(t30),
                            u_tile_bl_up: new e1.Uniform3f(t30),
                            u_tile_up_scale: new e1.Uniform1f(t30)
                        })
                    )(t29)), s16.includes("FOG") && (this.fogUniforms = ((t30)=>({
                            u_fog_matrix: new e1.UniformMatrix4f(t30),
                            u_fog_range: new e1.Uniform2f(t30),
                            u_fog_color: new e1.Uniform4f(t30),
                            u_fog_horizon_blend: new e1.Uniform1f(t30),
                            u_fog_temporal_offset: new e1.Uniform1f(t30),
                            u_frustum_tl: new e1.Uniform3f(t30),
                            u_frustum_tr: new e1.Uniform3f(t30),
                            u_frustum_br: new e1.Uniform3f(t30),
                            u_frustum_bl: new e1.Uniform3f(t30),
                            u_globe_pos: new e1.Uniform3f(t30),
                            u_globe_radius: new e1.Uniform1f(t30),
                            u_globe_transition: new e1.Uniform1f(t30),
                            u_is_globe: new e1.Uniform1i(t30),
                            u_viewport: new e1.Uniform2f(t30)
                        })
                    )(t29));
                }
            }
            setTerrainUniformValues(e, t) {
                if (!this.terrainUniforms) return;
                const i36 = this.terrainUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e29 in t)i36[e29] && i36[e29].set(this.program, e29, t[e29]);
                }
            }
            setGlobeUniformValues(e, t) {
                if (!this.globeUniforms) return;
                const i36 = this.globeUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e29 in t)i36[e29] && i36[e29].set(this.program, e29, t[e29]);
                }
            }
            setFogUniformValues(e, t) {
                if (!this.fogUniforms) return;
                const i36 = this.fogUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e29 in t)i36[e29].set(this.program, e29, t[e29]);
                }
            }
            draw(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p) {
                const m8 = e.gl;
                if (this.failedToCreate) return;
                e.program.set(this.program), e.setDepthMode(i), e.setStencilMode(o), e.setColorMode(r), e.setCullFace(n);
                for (const e29 of Object.keys(this.fixedUniforms))this.fixedUniforms[e29].set(this.program, e29, s[e29]);
                d && d.setUniforms(this.program, e, this.binderUniforms, u, {
                    zoom: _
                });
                const f9 = {
                    [m8.LINES]: 2,
                    [m8.TRIANGLES]: 3,
                    [m8.LINE_STRIP]: 1
                }[t];
                for (const i36 of h.get()){
                    const o31 = i36.vaos || (i36.vaos = {
                    });
                    (o31[a] || (o31[a] = new di)).bind(e, this, l, d ? d.getPaintVertexBuffers() : [], c, i36.vertexOffset, p || []), m8.drawElements(t, i36.primitiveLength * f9, m8.UNSIGNED_SHORT, i36.primitiveOffset * f9 * 2);
                }
            }
        }
        function zi(e29, t30) {
            const i36 = Math.pow(2, t30.tileID.overscaledZ), o31 = t30.tileSize * Math.pow(2, e29.transform.tileZoom) / i36, r14 = o31 * (t30.tileID.canonical.x + t30.tileID.wrap * i36), n9 = o31 * t30.tileID.canonical.y;
            return {
                u_image: 0,
                u_texsize: t30.imageAtlasTexture.size,
                u_tile_units_to_pixels: 1 / P2(t30, 1, e29.transform.tileZoom),
                u_pixel_coord_upper: [
                    r14 >> 16,
                    n9 >> 16
                ],
                u_pixel_coord_lower: [
                    65535 & r14,
                    65535 & n9
                ]
            };
        }
        const Pi = e1.create(), Ri = (t30, i36, o31, r14, n9, s17, a17, l21, c15, h14, u17)=>{
            const _3 = i36.style.light, d9 = _3.properties.get("position"), p12 = [
                d9.x,
                d9.y,
                d9.z
            ], m8 = e1.create$1();
            "viewport" === _3.properties.get("anchor") && (e1.fromRotation(m8, -i36.transform.angle), e1.transformMat3(p12, p12, m8));
            const f9 = _3.properties.get("color"), g6 = i36.transform, v4 = {
                u_matrix: t30,
                u_lightpos: p12,
                u_lightintensity: _3.properties.get("intensity"),
                u_lightcolor: [
                    f9.r,
                    f9.g,
                    f9.b
                ],
                u_vertical_gradient: +o31,
                u_opacity: r14,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: Pi,
                u_merc_center: [
                    0,
                    0
                ],
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_height_lift: 0,
                u_ao: n9,
                u_edge_radius: s17
            };
            return "globe" === g6.projection.name && (v4.u_tile_id = [
                a17.canonical.x,
                a17.canonical.y,
                1 << a17.canonical.z
            ], v4.u_zoom_transition = c15, v4.u_inv_rot_matrix = u17, v4.u_merc_center = h14, v4.u_up_dir = g6.projection.upVector(new e1.CanonicalTileID(0, 0, 0), h14[0] * e1.EXTENT, h14[1] * e1.EXTENT), v4.u_height_lift = l21), v4;
        }, Oi = (t30, i36, o31, r14, n9, s17, a17, l21, c15, h14, u17, _3)=>{
            const d9 = Ri(t30, i36, o31, r14, n9, s17, a17, c15, h14, u17, _3), p12 = {
                u_height_factor: -Math.pow(2, a17.overscaledZ) / l21.tileSize / 8
            };
            return e1.extend(d9, zi(i36, l21), p12);
        }, Bi = (e29)=>({
                u_matrix: e29
            })
        , ki = (t30, i36, o31)=>e1.extend(Bi(t30), zi(i36, o31))
        , Fi = (e29, t30)=>({
                u_matrix: e29,
                u_world: t30
            })
        , Ui = (t30, i36, o31, r14)=>e1.extend(ki(t30, i36, o31), {
                u_world: r14
            })
        , Ni = e1.create(), Gi = (t30, i36, o31, r14, n9, s17)=>{
            const a17 = t30.transform, l21 = "globe" === a17.projection.name;
            let c15;
            if ("map" === s17.paint.get("circle-pitch-alignment")) {
                if (l21) {
                    const t31 = e1.globePixelsToTileUnits(a17.zoom, i36.canonical) * a17._pixelsPerMercatorPixel;
                    c15 = Float32Array.from([
                        t31,
                        0,
                        0,
                        t31
                    ]);
                } else c15 = a17.calculatePixelsToTileUnitsMatrix(o31);
            } else c15 = new Float32Array([
                a17.pixelsToGLUnits[0],
                0,
                0,
                a17.pixelsToGLUnits[1]
            ]);
            const h14 = {
                u_camera_to_center_distance: a17.cameraToCenterDistance,
                u_matrix: t30.translatePosMatrix(i36.projMatrix, o31, s17.paint.get("circle-translate"), s17.paint.get("circle-translate-anchor")),
                u_device_pixel_ratio: e1.exported.devicePixelRatio,
                u_extrude_scale: c15,
                u_inv_rot_matrix: Ni,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ]
            };
            if (l21) {
                h14.u_inv_rot_matrix = r14, h14.u_merc_center = n9, h14.u_tile_id = [
                    i36.canonical.x,
                    i36.canonical.y,
                    1 << i36.canonical.z
                ], h14.u_zoom_transition = e1.globeToMercatorTransition(a17.zoom);
                const t31 = n9[0] * e1.EXTENT, o32 = n9[1] * e1.EXTENT;
                h14.u_up_dir = a17.projection.upVector(new e1.CanonicalTileID(0, 0, 0), t31, o32);
            }
            return h14;
        }, ji = (e29)=>{
            const t30 = [];
            return "map" === e29.paint.get("circle-pitch-alignment") && t30.push("PITCH_WITH_MAP"), "map" === e29.paint.get("circle-pitch-scale") && t30.push("SCALE_WITH_MAP"), t30;
        }, Zi = (t30, i36, o31, r14)=>{
            const n9 = e1.EXTENT / o31.tileSize;
            return {
                u_matrix: t30,
                u_camera_to_center_distance: i36.getCameraToCenterDistance(r14),
                u_extrude_scale: [
                    i36.pixelsToGLUnits[0] / n9,
                    i36.pixelsToGLUnits[1] / n9
                ]
            };
        }, Vi = (e29, t30, i36 = 1)=>({
                u_matrix: e29,
                u_color: t30,
                u_overlay: 0,
                u_overlay_scale: i36
            })
        , Wi = e1.create(), Xi = (t30, i36, o31, r14, n9, s17, a17)=>{
            const l21 = t30.transform, c15 = "globe" === l21.projection.name, h14 = c15 ? e1.globePixelsToTileUnits(l21.zoom, i36.canonical) * l21._pixelsPerMercatorPixel : P2(o31, 1, s17), u17 = {
                u_matrix: i36.projMatrix,
                u_extrude_scale: h14,
                u_intensity: a17,
                u_inv_rot_matrix: Wi,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ]
            };
            if (c15) {
                u17.u_inv_rot_matrix = r14, u17.u_merc_center = n9, u17.u_tile_id = [
                    i36.canonical.x,
                    i36.canonical.y,
                    1 << i36.canonical.z
                ], u17.u_zoom_transition = e1.globeToMercatorTransition(l21.zoom);
                const t31 = n9[0] * e1.EXTENT, o32 = n9[1] * e1.EXTENT;
                u17.u_up_dir = l21.projection.upVector(new e1.CanonicalTileID(0, 0, 0), t31, o32);
            }
            return u17;
        }, qi = (e29, t30, i36, o31, r14, n9, s17)=>{
            const a17 = e29.transform, l21 = a17.calculatePixelsToTileUnitsMatrix(t30);
            return {
                u_matrix: Yi(e29, t30, i36, o31),
                u_pixels_to_tile_units: l21,
                u_device_pixel_ratio: n9,
                u_units_to_pixels: [
                    1 / a17.pixelsToGLUnits[0],
                    1 / a17.pixelsToGLUnits[1]
                ],
                u_dash_image: 0,
                u_gradient_image: 1,
                u_image_height: r14,
                u_texsize: Ki(i36) ? t30.lineAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: Hi(t30, e29.transform),
                u_alpha_discard_threshold: 0,
                u_trim_offset: s17
            };
        }, $i = (e29, t30, i36, o31, r14)=>{
            const n9 = e29.transform;
            return {
                u_matrix: Yi(e29, t30, i36, o31),
                u_texsize: t30.imageAtlasTexture.size,
                u_pixels_to_tile_units: n9.calculatePixelsToTileUnitsMatrix(t30),
                u_device_pixel_ratio: r14,
                u_image: 0,
                u_tile_units_to_pixels: Hi(t30, n9),
                u_units_to_pixels: [
                    1 / n9.pixelsToGLUnits[0],
                    1 / n9.pixelsToGLUnits[1]
                ],
                u_alpha_discard_threshold: 0
            };
        };
        function Hi(e29, t30) {
            return 1 / P2(e29, 1, t30.tileZoom);
        }
        function Yi(e29, t30, i36, o31) {
            return e29.translatePosMatrix(o31 || t30.tileID.projMatrix, t30, i36.paint.get("line-translate"), i36.paint.get("line-translate-anchor"));
        }
        function Ki(e29) {
            const t30 = e29.paint.get("line-dasharray").value;
            return t30.value || "constant" !== t30.kind;
        }
        const Ji = (e29, t30, i36, o31, r14, n9)=>{
            var s17, a17;
            return {
                u_matrix: e29,
                u_tl_parent: t30,
                u_scale_parent: i36,
                u_fade_t: o31.mix,
                u_opacity: o31.opacity * r14.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: r14.paint.get("raster-brightness-min"),
                u_brightness_high: r14.paint.get("raster-brightness-max"),
                u_saturation_factor: (a17 = r14.paint.get("raster-saturation"), a17 > 0 ? 1 - 1 / (1.001 - a17) : -a17),
                u_contrast_factor: (s17 = r14.paint.get("raster-contrast"), s17 > 0 ? 1 / (1 - s17) : 1 + s17),
                u_spin_weights: Qi(r14.paint.get("raster-hue-rotate")),
                u_perspective_transform: n9
            };
        };
        function Qi(e29) {
            e29 *= Math.PI / 180;
            const t30 = Math.sin(e29), i36 = Math.cos(e29);
            return [
                (2 * i36 + 1) / 3,
                (-Math.sqrt(3) * t30 - i36 + 1) / 3,
                (Math.sqrt(3) * t30 - i36 + 1) / 3
            ];
        }
        const eo = e1.create(), to = (t30, i36, o31, r14, n9, s18, a18, l21, c15, h14, u17, _3, d9, p12, m8, f9)=>{
            const g6 = n9.transform, v4 = {
                u_is_size_zoom_constant: +("constant" === t30 || "source" === t30),
                u_is_size_feature_constant: +("constant" === t30 || "camera" === t30),
                u_size_t: i36 ? i36.uSizeT : 0,
                u_size: i36 ? i36.uSize : 0,
                u_camera_to_center_distance: g6.cameraToCenterDistance,
                u_rotate_symbol: +o31,
                u_aspect_ratio: g6.width / g6.height,
                u_fade_change: n9.options.fadeDuration ? n9.symbolFadeChange : 1,
                u_matrix: s18,
                u_label_plane_matrix: a18,
                u_coord_matrix: l21,
                u_is_text: +c15,
                u_pitch_with_map: +r14,
                u_texsize: h14,
                u_texture: 0,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: eo,
                u_merc_center: [
                    0,
                    0
                ],
                u_camera_forward: [
                    0,
                    0,
                    0
                ],
                u_ecef_origin: [
                    0,
                    0,
                    0
                ],
                u_tile_matrix: eo,
                u_up_vector: [
                    0,
                    -1,
                    0
                ]
            };
            return "globe" === f9.name && (v4.u_tile_id = [
                u17.canonical.x,
                u17.canonical.y,
                1 << u17.canonical.z
            ], v4.u_zoom_transition = _3, v4.u_inv_rot_matrix = p12, v4.u_merc_center = d9, v4.u_camera_forward = g6._camera.forward(), v4.u_ecef_origin = e1.globeECEFOrigin(g6.globeMatrix, u17.toUnwrapped()), v4.u_tile_matrix = Float32Array.from(g6.globeMatrix), v4.u_up_vector = m8), v4;
        }, io = (t30, i36, o31, r14, n9, s18, a18, l21, c15, h14, u17, _3, d9, p12, m8, f9, g6)=>e1.extend(to(t30, i36, o31, r14, n9, s18, a18, l21, c15, h14, _3, d9, p12, m8, f9, g6), {
                u_gamma_scale: r14 ? n9.transform.cameraToCenterDistance * Math.cos(n9.terrain ? 0 : n9.transform._pitch) : 1,
                u_device_pixel_ratio: e1.exported.devicePixelRatio,
                u_is_halo: +u17
            })
        , oo = (t30, i36, o31, r14, n9, s18, a18, l21, c15, h14, u17, _3, d9, p12, m8, f9)=>e1.extend(io(t30, i36, o31, r14, n9, s18, a18, l21, !0, c15, !0, u17, _3, d9, p12, m8, f9), {
                u_texsize_icon: h14,
                u_texture_icon: 1
            })
        , ro = (e29, t30, i36)=>({
                u_matrix: e29,
                u_opacity: t30,
                u_color: i36
            })
        , no = (t30, i36, o31, r14, n9)=>e1.extend(function(e29, t31, i37) {
                const o32 = t31.imageManager.getPattern(e29.toString()), { width: r15 , height: n10  } = t31.imageManager.getPixelSize(), s18 = Math.pow(2, i37.tileID.overscaledZ), a18 = i37.tileSize * Math.pow(2, t31.transform.tileZoom) / s18, l21 = a18 * (i37.tileID.canonical.x + i37.tileID.wrap * s18), c15 = a18 * i37.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_pattern_tl: o32.tl,
                    u_pattern_br: o32.br,
                    u_texsize: [
                        r15,
                        n10
                    ],
                    u_pattern_size: o32.displaySize,
                    u_tile_units_to_pixels: 1 / P2(i37, 1, t31.transform.tileZoom),
                    u_pixel_coord_upper: [
                        l21 >> 16,
                        c15 >> 16
                    ],
                    u_pixel_coord_lower: [
                        65535 & l21,
                        65535 & c15
                    ]
                };
            }(r14, o31, n9), {
                u_matrix: t30,
                u_opacity: i36
            })
        , so = {
            fillExtrusion: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_lightpos: new e1.Uniform3f(t30),
                    u_lightintensity: new e1.Uniform1f(t30),
                    u_lightcolor: new e1.Uniform3f(t30),
                    u_vertical_gradient: new e1.Uniform1f(t30),
                    u_opacity: new e1.Uniform1f(t30),
                    u_edge_radius: new e1.Uniform1f(t30),
                    u_ao: new e1.Uniform2f(t30),
                    u_tile_id: new e1.Uniform3f(t30),
                    u_zoom_transition: new e1.Uniform1f(t30),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t30),
                    u_merc_center: new e1.Uniform2f(t30),
                    u_up_dir: new e1.Uniform3f(t30),
                    u_height_lift: new e1.Uniform1f(t30)
                })
            ,
            fillExtrusionPattern: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_lightpos: new e1.Uniform3f(t30),
                    u_lightintensity: new e1.Uniform1f(t30),
                    u_lightcolor: new e1.Uniform3f(t30),
                    u_vertical_gradient: new e1.Uniform1f(t30),
                    u_height_factor: new e1.Uniform1f(t30),
                    u_edge_radius: new e1.Uniform1f(t30),
                    u_ao: new e1.Uniform2f(t30),
                    u_tile_id: new e1.Uniform3f(t30),
                    u_zoom_transition: new e1.Uniform1f(t30),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t30),
                    u_merc_center: new e1.Uniform2f(t30),
                    u_up_dir: new e1.Uniform3f(t30),
                    u_height_lift: new e1.Uniform1f(t30),
                    u_image: new e1.Uniform1i(t30),
                    u_texsize: new e1.Uniform2f(t30),
                    u_pixel_coord_upper: new e1.Uniform2f(t30),
                    u_pixel_coord_lower: new e1.Uniform2f(t30),
                    u_tile_units_to_pixels: new e1.Uniform1f(t30),
                    u_opacity: new e1.Uniform1f(t30)
                })
            ,
            fill: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30)
                })
            ,
            fillPattern: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_image: new e1.Uniform1i(t30),
                    u_texsize: new e1.Uniform2f(t30),
                    u_pixel_coord_upper: new e1.Uniform2f(t30),
                    u_pixel_coord_lower: new e1.Uniform2f(t30),
                    u_tile_units_to_pixels: new e1.Uniform1f(t30)
                })
            ,
            fillOutline: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_world: new e1.Uniform2f(t30)
                })
            ,
            fillOutlinePattern: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_world: new e1.Uniform2f(t30),
                    u_image: new e1.Uniform1i(t30),
                    u_texsize: new e1.Uniform2f(t30),
                    u_pixel_coord_upper: new e1.Uniform2f(t30),
                    u_pixel_coord_lower: new e1.Uniform2f(t30),
                    u_tile_units_to_pixels: new e1.Uniform1f(t30)
                })
            ,
            circle: (t30)=>({
                    u_camera_to_center_distance: new e1.Uniform1f(t30),
                    u_extrude_scale: new e1.UniformMatrix2f(t30),
                    u_device_pixel_ratio: new e1.Uniform1f(t30),
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t30),
                    u_merc_center: new e1.Uniform2f(t30),
                    u_tile_id: new e1.Uniform3f(t30),
                    u_zoom_transition: new e1.Uniform1f(t30),
                    u_up_dir: new e1.Uniform3f(t30)
                })
            ,
            collisionBox: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_camera_to_center_distance: new e1.Uniform1f(t30),
                    u_extrude_scale: new e1.Uniform2f(t30)
                })
            ,
            collisionCircle: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_inv_matrix: new e1.UniformMatrix4f(t30),
                    u_camera_to_center_distance: new e1.Uniform1f(t30),
                    u_viewport_size: new e1.Uniform2f(t30)
                })
            ,
            debug: (t30)=>({
                    u_color: new e1.UniformColor(t30),
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_overlay: new e1.Uniform1i(t30),
                    u_overlay_scale: new e1.Uniform1f(t30)
                })
            ,
            clippingMask: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30)
                })
            ,
            heatmap: (t30)=>({
                    u_extrude_scale: new e1.Uniform1f(t30),
                    u_intensity: new e1.Uniform1f(t30),
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t30),
                    u_merc_center: new e1.Uniform2f(t30),
                    u_tile_id: new e1.Uniform3f(t30),
                    u_zoom_transition: new e1.Uniform1f(t30),
                    u_up_dir: new e1.Uniform3f(t30)
                })
            ,
            heatmapTexture: (t30)=>({
                    u_image: new e1.Uniform1i(t30),
                    u_color_ramp: new e1.Uniform1i(t30),
                    u_opacity: new e1.Uniform1f(t30)
                })
            ,
            hillshade: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_image: new e1.Uniform1i(t30),
                    u_latrange: new e1.Uniform2f(t30),
                    u_light: new e1.Uniform2f(t30),
                    u_shadow: new e1.UniformColor(t30),
                    u_highlight: new e1.UniformColor(t30),
                    u_accent: new e1.UniformColor(t30)
                })
            ,
            hillshadePrepare: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_image: new e1.Uniform1i(t30),
                    u_dimension: new e1.Uniform2f(t30),
                    u_zoom: new e1.Uniform1f(t30),
                    u_unpack: new e1.Uniform4f(t30)
                })
            ,
            line: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_pixels_to_tile_units: new e1.UniformMatrix2f(t30),
                    u_device_pixel_ratio: new e1.Uniform1f(t30),
                    u_units_to_pixels: new e1.Uniform2f(t30),
                    u_dash_image: new e1.Uniform1i(t30),
                    u_gradient_image: new e1.Uniform1i(t30),
                    u_image_height: new e1.Uniform1f(t30),
                    u_texsize: new e1.Uniform2f(t30),
                    u_tile_units_to_pixels: new e1.Uniform1f(t30),
                    u_alpha_discard_threshold: new e1.Uniform1f(t30),
                    u_trim_offset: new e1.Uniform2f(t30)
                })
            ,
            linePattern: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_texsize: new e1.Uniform2f(t30),
                    u_pixels_to_tile_units: new e1.UniformMatrix2f(t30),
                    u_device_pixel_ratio: new e1.Uniform1f(t30),
                    u_image: new e1.Uniform1i(t30),
                    u_units_to_pixels: new e1.Uniform2f(t30),
                    u_tile_units_to_pixels: new e1.Uniform1f(t30),
                    u_alpha_discard_threshold: new e1.Uniform1f(t30)
                })
            ,
            raster: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_tl_parent: new e1.Uniform2f(t30),
                    u_scale_parent: new e1.Uniform1f(t30),
                    u_fade_t: new e1.Uniform1f(t30),
                    u_opacity: new e1.Uniform1f(t30),
                    u_image0: new e1.Uniform1i(t30),
                    u_image1: new e1.Uniform1i(t30),
                    u_brightness_low: new e1.Uniform1f(t30),
                    u_brightness_high: new e1.Uniform1f(t30),
                    u_saturation_factor: new e1.Uniform1f(t30),
                    u_contrast_factor: new e1.Uniform1f(t30),
                    u_spin_weights: new e1.Uniform3f(t30),
                    u_perspective_transform: new e1.Uniform2f(t30)
                })
            ,
            symbolIcon: (t30)=>({
                    u_is_size_zoom_constant: new e1.Uniform1i(t30),
                    u_is_size_feature_constant: new e1.Uniform1i(t30),
                    u_size_t: new e1.Uniform1f(t30),
                    u_size: new e1.Uniform1f(t30),
                    u_camera_to_center_distance: new e1.Uniform1f(t30),
                    u_rotate_symbol: new e1.Uniform1i(t30),
                    u_aspect_ratio: new e1.Uniform1f(t30),
                    u_fade_change: new e1.Uniform1f(t30),
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_label_plane_matrix: new e1.UniformMatrix4f(t30),
                    u_coord_matrix: new e1.UniformMatrix4f(t30),
                    u_is_text: new e1.Uniform1i(t30),
                    u_pitch_with_map: new e1.Uniform1i(t30),
                    u_texsize: new e1.Uniform2f(t30),
                    u_tile_id: new e1.Uniform3f(t30),
                    u_zoom_transition: new e1.Uniform1f(t30),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t30),
                    u_merc_center: new e1.Uniform2f(t30),
                    u_camera_forward: new e1.Uniform3f(t30),
                    u_tile_matrix: new e1.UniformMatrix4f(t30),
                    u_up_vector: new e1.Uniform3f(t30),
                    u_ecef_origin: new e1.Uniform3f(t30),
                    u_texture: new e1.Uniform1i(t30)
                })
            ,
            symbolSDF: (t30)=>({
                    u_is_size_zoom_constant: new e1.Uniform1i(t30),
                    u_is_size_feature_constant: new e1.Uniform1i(t30),
                    u_size_t: new e1.Uniform1f(t30),
                    u_size: new e1.Uniform1f(t30),
                    u_camera_to_center_distance: new e1.Uniform1f(t30),
                    u_rotate_symbol: new e1.Uniform1i(t30),
                    u_aspect_ratio: new e1.Uniform1f(t30),
                    u_fade_change: new e1.Uniform1f(t30),
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_label_plane_matrix: new e1.UniformMatrix4f(t30),
                    u_coord_matrix: new e1.UniformMatrix4f(t30),
                    u_is_text: new e1.Uniform1i(t30),
                    u_pitch_with_map: new e1.Uniform1i(t30),
                    u_texsize: new e1.Uniform2f(t30),
                    u_texture: new e1.Uniform1i(t30),
                    u_gamma_scale: new e1.Uniform1f(t30),
                    u_device_pixel_ratio: new e1.Uniform1f(t30),
                    u_tile_id: new e1.Uniform3f(t30),
                    u_zoom_transition: new e1.Uniform1f(t30),
                    u_inv_rot_matrix: new e1.UniformMatrix4f(t30),
                    u_merc_center: new e1.Uniform2f(t30),
                    u_camera_forward: new e1.Uniform3f(t30),
                    u_tile_matrix: new e1.UniformMatrix4f(t30),
                    u_up_vector: new e1.Uniform3f(t30),
                    u_ecef_origin: new e1.Uniform3f(t30),
                    u_is_halo: new e1.Uniform1i(t30)
                })
            ,
            symbolTextAndIcon: (t30)=>({
                    u_is_size_zoom_constant: new e1.Uniform1i(t30),
                    u_is_size_feature_constant: new e1.Uniform1i(t30),
                    u_size_t: new e1.Uniform1f(t30),
                    u_size: new e1.Uniform1f(t30),
                    u_camera_to_center_distance: new e1.Uniform1f(t30),
                    u_rotate_symbol: new e1.Uniform1i(t30),
                    u_aspect_ratio: new e1.Uniform1f(t30),
                    u_fade_change: new e1.Uniform1f(t30),
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_label_plane_matrix: new e1.UniformMatrix4f(t30),
                    u_coord_matrix: new e1.UniformMatrix4f(t30),
                    u_is_text: new e1.Uniform1i(t30),
                    u_pitch_with_map: new e1.Uniform1i(t30),
                    u_texsize: new e1.Uniform2f(t30),
                    u_texsize_icon: new e1.Uniform2f(t30),
                    u_texture: new e1.Uniform1i(t30),
                    u_texture_icon: new e1.Uniform1i(t30),
                    u_gamma_scale: new e1.Uniform1f(t30),
                    u_device_pixel_ratio: new e1.Uniform1f(t30),
                    u_is_halo: new e1.Uniform1i(t30)
                })
            ,
            background: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_opacity: new e1.Uniform1f(t30),
                    u_color: new e1.UniformColor(t30)
                })
            ,
            backgroundPattern: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_opacity: new e1.Uniform1f(t30),
                    u_image: new e1.Uniform1i(t30),
                    u_pattern_tl: new e1.Uniform2f(t30),
                    u_pattern_br: new e1.Uniform2f(t30),
                    u_texsize: new e1.Uniform2f(t30),
                    u_pattern_size: new e1.Uniform2f(t30),
                    u_pixel_coord_upper: new e1.Uniform2f(t30),
                    u_pixel_coord_lower: new e1.Uniform2f(t30),
                    u_tile_units_to_pixels: new e1.Uniform1f(t30)
                })
            ,
            terrainRaster: vi,
            terrainDepth: vi,
            skybox: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_sun_direction: new e1.Uniform3f(t30),
                    u_cubemap: new e1.Uniform1i(t30),
                    u_opacity: new e1.Uniform1f(t30),
                    u_temporal_offset: new e1.Uniform1f(t30)
                })
            ,
            skyboxGradient: (t30)=>({
                    u_matrix: new e1.UniformMatrix4f(t30),
                    u_color_ramp: new e1.Uniform1i(t30),
                    u_center_direction: new e1.Uniform3f(t30),
                    u_radius: new e1.Uniform1f(t30),
                    u_opacity: new e1.Uniform1f(t30),
                    u_temporal_offset: new e1.Uniform1f(t30)
                })
            ,
            skyboxCapture: (t30)=>({
                    u_matrix_3f: new e1.UniformMatrix3f(t30),
                    u_sun_direction: new e1.Uniform3f(t30),
                    u_sun_intensity: new e1.Uniform1f(t30),
                    u_color_tint_r: new e1.Uniform4f(t30),
                    u_color_tint_m: new e1.Uniform4f(t30),
                    u_luminance: new e1.Uniform1f(t30)
                })
            ,
            globeRaster: (t30)=>({
                    u_proj_matrix: new e1.UniformMatrix4f(t30),
                    u_globe_matrix: new e1.UniformMatrix4f(t30),
                    u_normalize_matrix: new e1.UniformMatrix4f(t30),
                    u_merc_matrix: new e1.UniformMatrix4f(t30),
                    u_zoom_transition: new e1.Uniform1f(t30),
                    u_merc_center: new e1.Uniform2f(t30),
                    u_image0: new e1.Uniform1i(t30),
                    u_grid_matrix: new e1.UniformMatrix3f(t30),
                    u_frustum_tl: new e1.Uniform3f(t30),
                    u_frustum_tr: new e1.Uniform3f(t30),
                    u_frustum_br: new e1.Uniform3f(t30),
                    u_frustum_bl: new e1.Uniform3f(t30),
                    u_globe_pos: new e1.Uniform3f(t30),
                    u_globe_radius: new e1.Uniform1f(t30),
                    u_viewport: new e1.Uniform2f(t30)
                })
            ,
            globeAtmosphere: (t30)=>({
                    u_frustum_tl: new e1.Uniform3f(t30),
                    u_frustum_tr: new e1.Uniform3f(t30),
                    u_frustum_br: new e1.Uniform3f(t30),
                    u_frustum_bl: new e1.Uniform3f(t30),
                    u_horizon: new e1.Uniform1f(t30),
                    u_transition: new e1.Uniform1f(t30),
                    u_fadeout_range: new e1.Uniform1f(t30),
                    u_color: new e1.Uniform4f(t30),
                    u_high_color: new e1.Uniform4f(t30),
                    u_space_color: new e1.Uniform4f(t30),
                    u_star_intensity: new e1.Uniform1f(t30),
                    u_star_density: new e1.Uniform1f(t30),
                    u_star_size: new e1.Uniform1f(t30),
                    u_temporal_offset: new e1.Uniform1f(t30),
                    u_horizon_angle: new e1.Uniform1f(t30),
                    u_rotation_matrix: new e1.UniformMatrix4f(t30)
                })
        };
        let ao;
        function lo(t30, i36, o31, r14, n9, s18, a18) {
            const l21 = t30.context, c15 = l21.gl, h14 = t30.transform, u17 = t30.useProgram("collisionBox"), _3 = [];
            let d9 = 0, p12 = 0;
            for(let m8 = 0; m8 < r14.length; m8++){
                const f9 = r14[m8], g6 = i36.getTile(f9), v4 = g6.getBucket(o31);
                if (!v4) continue;
                const x4 = xt(f9, v4, h14);
                let y5 = x4;
                0 === n9[0] && 0 === n9[1] || (y5 = t30.translatePosMatrix(x4, g6, n9, s18));
                const b3 = a18 ? v4.textCollisionBox : v4.iconCollisionBox, w4 = v4.collisionCircleArray;
                if (w4.length > 0) {
                    const t31 = e1.create(), i37 = y5;
                    e1.mul(t31, v4.placementInvProjMatrix, h14.glCoordMatrix), e1.mul(t31, t31, v4.placementViewportMatrix), _3.push({
                        circleArray: w4,
                        circleOffset: p12,
                        transform: i37,
                        invTransform: t31,
                        projection: v4.getProjection()
                    }), d9 += w4.length / 4, p12 = d9;
                }
                b3 && (t30.terrain && t30.terrain.setupElevationDraw(g6, u17), u17.draw(l21, c15.LINES, e1.DepthMode.disabled, e1.StencilMode.disabled, t30.colorModeForRenderPass(), e1.CullFaceMode.disabled, Zi(y5, h14, g6, v4.getProjection()), o31.id, b3.layoutVertexBuffer, b3.indexBuffer, b3.segments, null, h14.zoom, null, [
                    b3.collisionVertexBuffer,
                    b3.collisionVertexBufferExt
                ]));
            }
            if (!a18 || !_3.length) return;
            const m9 = t30.useProgram("collisionCircle"), f9 = new e1.StructArrayLayout2f1f2i16;
            f9.resize(4 * d9), f9._trim();
            let g6 = 0;
            for (const e29 of _3)for(let t31 = 0; t31 < e29.circleArray.length / 4; t31++){
                const i37 = 4 * t31, o32 = e29.circleArray[i37 + 0], r15 = e29.circleArray[i37 + 1], n10 = e29.circleArray[i37 + 2], s19 = e29.circleArray[i37 + 3];
                f9.emplace(g6++, o32, r15, n10, s19, 0), f9.emplace(g6++, o32, r15, n10, s19, 1), f9.emplace(g6++, o32, r15, n10, s19, 2), f9.emplace(g6++, o32, r15, n10, s19, 3);
            }
            (!ao || ao.length < 2 * d9) && (ao = (function(t32) {
                const i37 = 2 * t32, o32 = new e1.StructArrayLayout3ui6;
                o32.resize(i37), o32._trim();
                for(let e30 = 0; e30 < i37; e30++){
                    const t33 = 6 * e30;
                    o32.uint16[t33 + 0] = 4 * e30 + 0, o32.uint16[t33 + 1] = 4 * e30 + 1, o32.uint16[t33 + 2] = 4 * e30 + 2, o32.uint16[t33 + 3] = 4 * e30 + 2, o32.uint16[t33 + 4] = 4 * e30 + 3, o32.uint16[t33 + 5] = 4 * e30 + 0;
                }
                return o32;
            })(d9));
            const v4 = l21.createIndexBuffer(ao, !0), x4 = l21.createVertexBuffer(f9, e1.collisionCircleLayout.members, !0);
            for (const i37 of _3){
                const r15 = {
                    u_matrix: i37.transform,
                    u_inv_matrix: i37.invTransform,
                    u_camera_to_center_distance: (y5 = h14).getCameraToCenterDistance(i37.projection),
                    u_viewport_size: [
                        y5.width,
                        y5.height
                    ]
                };
                m9.draw(l21, c15.TRIANGLES, e1.DepthMode.disabled, e1.StencilMode.disabled, t30.colorModeForRenderPass(), e1.CullFaceMode.disabled, r15, o31.id, x4, v4, e1.SegmentVector.simpleSegment(0, 2 * i37.circleOffset, i37.circleArray.length, i37.circleArray.length / 2), null, h14.zoom);
            }
            var y5;
            x4.destroy(), v4.destroy();
        }
        const co = e1.create();
        function ho({ width: t30 , height: i36 , anchor: o31 , textOffset: r14 , textScale: n9  }, s18) {
            const { horizontalAlign: a18 , verticalAlign: l21  } = e1.getAnchorAlignment(o31), c15 = -(a18 - 0.5) * t30, h14 = -(l21 - 0.5) * i36, u17 = e1.evaluateVariableOffset(o31, r14);
            return new e1.pointGeometry((c15 / n9 + u17[0]) * s18, (h14 / n9 + u17[1]) * s18);
        }
        function uo(t30, i36, o31, r14, n9, s18, a18, l21, c15, h14, u17) {
            const _3 = t30.text.placedSymbolArray, d9 = t30.text.dynamicLayoutVertexArray, p12 = t30.icon.dynamicLayoutVertexArray, m8 = {
            }, f9 = t30.getProjection(), g6 = yt(l21, f9, s18), v4 = s18.elevation, x4 = f9.upVectorScale(l21.canonical, s18.center.lat, s18.worldSize).metersToTile;
            d9.clear();
            for(let p13 = 0; p13 < _3.length; p13++){
                const y5 = _3.get(p13), { tileAnchorX: b3 , tileAnchorY: w4 , numGlyphs: T1  } = y5, E1 = t30.allowVerticalPlacement && !y5.placedOrientation, C1 = y5.hidden || !y5.crossTileID || E1 ? null : r14[y5.crossTileID];
                if (C1) {
                    let r15 = 0, _4 = 0, p14 = 0;
                    if (v4) {
                        const e29 = v4 ? v4.getAtTileOffset(l21, b3, w4) : 0, [t31, i37, o32] = f9.upVector(l21.canonical, b3, w4);
                        r15 = e29 * t31 * x4, _4 = e29 * i37 * x4, p14 = e29 * o32 * x4;
                    }
                    let [E2, I1, M3, S3] = rt(y5.projectedAnchorX + r15, y5.projectedAnchorY + _4, y5.projectedAnchorZ + p14, o31 ? g6 : a18);
                    const D1 = nt(s18.getCameraToCenterDistance(f9), S3);
                    let A1 = n9.evaluateSizeForFeature(t30.textSizeData, h14, y5) * D1 / e1.ONE_EM;
                    o31 && (A1 *= t30.tilePixelRatio / c15);
                    const L1 = ho(C1, A1);
                    o31 ? ({ x: E2 , y: I1 , z: M3  } = f9.projectTilePoint(b3 + L1.x, w4 + L1.y, l21.canonical), [E2, I1, M3] = rt(E2 + r15, I1 + _4, M3 + p14, a18)) : (i36 && L1._rotate(-s18.angle), E2 += L1.x, I1 += L1.y, M3 = 0);
                    const z1 = t30.allowVerticalPlacement && y5.placedOrientation === e1.WritingMode.vertical ? Math.PI / 2 : 0;
                    for(let t31 = 0; t31 < T1; t31++)e1.addDynamicAttributes(d9, E2, I1, M3, z1);
                    u17 && y5.associatedIconIndex >= 0 && (m8[y5.associatedIconIndex] = {
                        x: E2,
                        y: I1,
                        z: M3,
                        angle: z1
                    });
                } else pt(T1, d9);
            }
            if (u17) {
                p12.clear();
                const i37 = t30.icon.placedSymbolArray;
                for(let t31 = 0; t31 < i37.length; t31++){
                    const o32 = i37.get(t31), { numGlyphs: r15  } = o32, n10 = m8[t31];
                    if (o32.hidden || !n10) pt(r15, p12);
                    else {
                        const { x: t32 , y: i38 , z: o33 , angle: s19  } = n10;
                        for(let n11 = 0; n11 < r15; n11++)e1.addDynamicAttributes(p12, t32, i38, o33, s19);
                    }
                }
                t30.icon.dynamicLayoutVertexBuffer.updateData(p12);
            }
            t30.text.dynamicLayoutVertexBuffer.updateData(d9);
        }
        function _o(e29, t30, i36) {
            return i36.iconsInText && t30 ? "symbolTextAndIcon" : e29 ? "symbolSDF" : "symbolIcon";
        }
        function po(t30, i36, o31, r14, n9, s18, a18, l21, c15, h14, u17, _3) {
            const d9 = t30.context, p12 = d9.gl, m8 = t30.transform, f9 = "map" === l21, g6 = "map" === c15, v4 = f9 && "point" !== o31.layout.get("symbol-placement"), x4 = f9 && !g6 && !v4, y5 = (void 0) !== o31.layout.get("symbol-sort-key").constantOr(1);
            let b3 = !1;
            const w4 = t30.depthModeForSublayer(0, e1.DepthMode.ReadOnly), T1 = [
                e1.mercatorXfromLng(m8.center.lng),
                e1.mercatorYfromLat(m8.center.lat)
            ], E1 = o31.layout.get("text-variable-anchor"), C1 = "globe" === m8.projection.name, I1 = [], M3 = [
                0,
                -1,
                0
            ];
            let S3 = M3;
            !C1 && !m8.mercatorFromTransition || f9 || (S3 = (function(t31) {
                const i37 = t31._camera.getWorldToCamera(t31.worldSize, 1), o32 = e1.multiply([], i37, t31.globeMatrix);
                e1.invert(o32, o32);
                const r15 = [
                    0,
                    0,
                    0
                ], n10 = [
                    0,
                    1,
                    0,
                    0
                ];
                return e1.transformMat4$1(n10, n10, o32), r15[0] = n10[0], r15[1] = n10[1], r15[2] = n10[2], e1.normalize(r15, r15), r15;
            })(m8));
            for (const l22 of r14){
                const r15 = i36.getTile(l22), c16 = r15.getBucket(o31);
                if (!c16) continue;
                if ("mercator" === c16.projection.name && C1) continue;
                const u18 = n9 ? c16.text : c16.icon;
                if (!u18 || c16.fullyClipped || !u18.segments.get().length) continue;
                const _4 = u18.programConfigurations.get(o31.id), d10 = n9 || c16.sdfIcons, w5 = n9 ? c16.textSizeData : c16.iconSizeData, D1 = g6 || 0 !== m8.pitch, A1 = e1.evaluateSizeForZoom(w5, m8.zoom);
                let L1, z1, P3, R1, O1 = [
                    0,
                    0
                ], B1 = null;
                if (n9) {
                    if (z1 = r15.glyphAtlasTexture, P3 = p12.LINEAR, L1 = r15.glyphAtlasTexture.size, c16.iconsInText) {
                        O1 = r15.imageAtlasTexture.size, B1 = r15.imageAtlasTexture;
                        const e29 = "composite" === w5.kind || "camera" === w5.kind;
                        R1 = D1 || t30.options.rotating || t30.options.zooming || e29 ? p12.LINEAR : p12.NEAREST;
                    }
                } else {
                    const e29 = 1 !== o31.layout.get("icon-size").constantOr(0) || c16.iconsNeedLinear;
                    z1 = r15.imageAtlasTexture, P3 = d10 || t30.options.rotating || t30.options.zooming || e29 || D1 ? p12.LINEAR : p12.NEAREST, L1 = r15.imageAtlasTexture.size;
                }
                const k1 = "globe" === c16.projection.name, F1 = k1 ? S3 : M3, U1 = k1 ? e1.globeToMercatorTransition(m8.zoom) : 0, N1 = yt(l22, c16.getProjection(), m8), G1 = m8.calculatePixelsToTileUnitsMatrix(r15), j1 = tt(N1, r15.tileID.canonical, g6, f9, m8, c16.getProjection(), G1), Z1 = t30.terrain && g6 && v4 ? e1.invert(e1.create(), j1) : co, V1 = ot(N1, r15.tileID.canonical, g6, f9, m8, c16.getProjection(), G1), W1 = E1 && c16.hasTextData(), X1 = "none" !== o31.layout.get("icon-text-fit") && W1 && c16.hasIconData();
                if (v4) {
                    const e29 = m8.elevation, i37 = e29 ? e29.getAtTileOffsetFunc(l22, m8.center.lat, m8.worldSize, c16.getProjection()) : null, o32 = it(N1, r15.tileID.canonical, g6, f9, m8, c16.getProjection(), G1);
                    at(c16, N1, t30, n9, o32, V1, g6, h14, i37, l22);
                }
                const q1 = v4 || n9 && E1 || X1, $1 = t30.translatePosMatrix(N1, r15, s18, a18), H1 = q1 ? co : j1, Y1 = t30.translatePosMatrix(V1, r15, s18, a18, !0), K1 = c16.getProjection().createInversionMatrix(m8, l22.canonical), J1 = [];
                t30.terrainRenderModeElevated() && g6 && J1.push("PITCH_WITH_MAP_TERRAIN"), k1 && J1.push("PROJECTION_GLOBE_VIEW"), q1 && J1.push("PROJECTED_POS_ON_VIEWPORT");
                const Q1 = d10 && 0 !== o31.paint.get(n9 ? "text-halo-width" : "icon-halo-width").constantOr(1);
                let ee1;
                ee1 = d10 ? c16.iconsInText ? oo(w5.kind, A1, x4, g6, t30, $1, H1, Y1, L1, O1, l22, U1, T1, K1, F1, c16.getProjection()) : io(w5.kind, A1, x4, g6, t30, $1, H1, Y1, n9, L1, !0, l22, U1, T1, K1, F1, c16.getProjection()) : to(w5.kind, A1, x4, g6, t30, $1, H1, Y1, n9, L1, l22, U1, T1, K1, F1, c16.getProjection());
                const te1 = {
                    program: t30.useProgram(_o(d10, n9, c16), _4, J1),
                    buffers: u18,
                    uniformValues: ee1,
                    atlasTexture: z1,
                    atlasTextureIcon: B1,
                    atlasInterpolation: P3,
                    atlasInterpolationIcon: R1,
                    isSDF: d10,
                    hasHalo: Q1,
                    tile: r15,
                    labelPlaneMatrixInv: Z1
                };
                if (y5 && c16.canOverlap) {
                    b3 = !0;
                    const t31 = u18.segments.get();
                    for (const i37 of t31)I1.push({
                        segments: new e1.SegmentVector([
                            i37
                        ]),
                        sortKey: i37.sortKey,
                        state: te1
                    });
                } else I1.push({
                    segments: u18.segments,
                    sortKey: 0,
                    state: te1
                });
            }
            b3 && I1.sort((e29, t31)=>e29.sortKey - t31.sortKey
            );
            for (const e29 of I1){
                const i37 = e29.state;
                if (t30.terrain && t30.terrain.setupElevationDraw(i37.tile, i37.program, {
                    useDepthForOcclusion: !C1,
                    labelPlaneMatrixInv: i37.labelPlaneMatrixInv
                }), d9.activeTexture.set(p12.TEXTURE0), i37.atlasTexture.bind(i37.atlasInterpolation, p12.CLAMP_TO_EDGE), i37.atlasTextureIcon && (d9.activeTexture.set(p12.TEXTURE1), i37.atlasTextureIcon && i37.atlasTextureIcon.bind(i37.atlasInterpolationIcon, p12.CLAMP_TO_EDGE)), i37.isSDF) {
                    const r15 = i37.uniformValues;
                    i37.hasHalo && (r15.u_is_halo = 1, mo(i37.buffers, e29.segments, o31, t30, i37.program, w4, u17, _3, r15)), r15.u_is_halo = 0;
                }
                mo(i37.buffers, e29.segments, o31, t30, i37.program, w4, u17, _3, i37.uniformValues);
            }
        }
        function mo(t30, i36, o31, r14, n9, s18, a18, l21, c15) {
            const h14 = r14.context, u17 = [
                t30.dynamicLayoutVertexBuffer,
                t30.opacityVertexBuffer,
                t30.globeExtVertexBuffer
            ];
            n9.draw(h14, h14.gl.TRIANGLES, s18, a18, l21, e1.CullFaceMode.disabled, c15, o31.id, t30.layoutVertexBuffer, t30.indexBuffer, i36, o31.paint, r14.transform.zoom, t30.programConfigurations.get(o31.id), u17);
        }
        function fo(t30, i36, o31, r14, n9, s18, a18) {
            const l21 = t30.context.gl, c15 = o31.paint.get("fill-pattern"), h14 = c15 && c15.constantOr(1);
            let u17, _3, d9, p12, m8;
            a18 ? (_3 = h14 && !o31.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u17 = l21.LINES) : (_3 = h14 ? "fillPattern" : "fill", u17 = l21.TRIANGLES);
            for (const f9 of r14){
                const r15 = i36.getTile(f9);
                if (h14 && !r15.patternsLoaded()) continue;
                const g6 = r15.getBucket(o31);
                if (!g6) continue;
                t30.prepareDrawTile();
                const v4 = g6.programConfigurations.get(o31.id), x4 = t30.useProgram(_3, v4);
                h14 && (t30.context.activeTexture.set(l21.TEXTURE0), r15.imageAtlasTexture.bind(l21.LINEAR, l21.CLAMP_TO_EDGE), v4.updatePaintBuffers());
                const y5 = c15.constantOr(null);
                if (y5 && r15.imageAtlas) {
                    const e29 = r15.imageAtlas.patternPositions[y5.toString()];
                    e29 && v4.setConstantPatternPositions(e29);
                }
                const b3 = t30.translatePosMatrix(f9.projMatrix, r15, o31.paint.get("fill-translate"), o31.paint.get("fill-translate-anchor"));
                if (a18) {
                    p12 = g6.indexBuffer2, m8 = g6.segments2;
                    const e29 = t30.terrain && t30.terrain.renderingToTexture ? t30.terrain.drapeBufferSize : [
                        l21.drawingBufferWidth,
                        l21.drawingBufferHeight
                    ];
                    d9 = "fillOutlinePattern" === _3 && h14 ? Ui(b3, t30, r15, e29) : Fi(b3, e29);
                } else p12 = g6.indexBuffer, m8 = g6.segments, d9 = h14 ? ki(b3, t30, r15) : Bi(b3);
                t30.prepareDrawProgram(t30.context, x4, f9.toUnwrapped()), x4.draw(t30.context, u17, n9, t30.stencilModeForClipping(f9), s18, e1.CullFaceMode.disabled, d9, o31.id, g6.layoutVertexBuffer, p12, m8, o31.paint, t30.transform.zoom, v4);
            }
        }
        function go(t30, i36, o31, r14, n9, s18, a18) {
            const l21 = t30.context, c15 = l21.gl, h14 = t30.transform, u17 = o31.paint.get("fill-extrusion-pattern"), _3 = u17.constantOr(1), d9 = o31.paint.get("fill-extrusion-opacity"), p12 = [
                o31.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                o31.paint.get("fill-extrusion-ambient-occlusion-radius")
            ], m8 = o31.layout.get("fill-extrusion-edge-radius"), f9 = "globe" === h14.projection.name ? e1.fillExtrusionHeightLift() : 0, g6 = "globe" === h14.projection.name, v4 = g6 ? e1.globeToMercatorTransition(h14.zoom) : 0, x4 = [
                e1.mercatorXfromLng(h14.center.lng),
                e1.mercatorYfromLat(h14.center.lat)
            ], y5 = [];
            g6 && (y5.push("PROJECTION_GLOBE_VIEW"), t30.style.terrainSetForDrapingOnly() && y5.push("TERRAIN")), p12[0] > 0 && y5.push("FAUX_AO");
            for (const b3 of r14){
                const r15 = i36.getTile(b3), w4 = r15.getBucket(o31);
                if (!w4 || w4.projection.name !== h14.projection.name) continue;
                const T1 = w4.programConfigurations.get(o31.id), E1 = t30.useProgram(_3 ? "fillExtrusionPattern" : "fillExtrusion", T1, y5);
                if (t30.terrain) {
                    const e29 = t30.terrain;
                    if (t30.style.terrainSetForDrapingOnly()) e29.setupElevationDraw(r15, E1, {
                        useMeterToDem: !0
                    });
                    else {
                        if (!w4.enableTerrain) continue;
                        if (e29.setupElevationDraw(r15, E1, {
                            useMeterToDem: !0
                        }), vo(l21, i36, b3, w4, o31, e29), !w4.centroidVertexBuffer) {
                            const e30 = E1.attributes.a_centroid_pos;
                            (void 0) !== e30 && c15.vertexAttrib2f(e30, 0, 0);
                        }
                    }
                }
                _3 && (t30.context.activeTexture.set(c15.TEXTURE0), r15.imageAtlasTexture.bind(c15.LINEAR, c15.CLAMP_TO_EDGE), T1.updatePaintBuffers());
                const C1 = u17.constantOr(null);
                if (C1 && r15.imageAtlas) {
                    const e29 = r15.imageAtlas.patternPositions[C1.toString()];
                    e29 && T1.setConstantPatternPositions(e29);
                }
                const I1 = t30.translatePosMatrix(b3.projMatrix, r15, o31.paint.get("fill-extrusion-translate"), o31.paint.get("fill-extrusion-translate-anchor")), M3 = h14.projection.createInversionMatrix(h14, b3.canonical), S3 = o31.paint.get("fill-extrusion-vertical-gradient"), D1 = _3 ? Oi(I1, t30, S3, d9, p12, m8, b3, r15, f9, v4, x4, M3) : Ri(I1, t30, S3, d9, p12, m8, b3, f9, v4, x4, M3);
                t30.prepareDrawProgram(l21, E1, b3.toUnwrapped());
                const A1 = [];
                t30.terrain && A1.push(w4.centroidVertexBuffer), g6 && A1.push(w4.layoutVertexExtBuffer), E1.draw(l21, l21.gl.TRIANGLES, n9, s18, a18, e1.CullFaceMode.backCCW, D1, o31.id, w4.layoutVertexBuffer, w4.indexBuffer, w4.segments, o31.paint, t30.transform.zoom, T1, A1);
            }
        }
        function vo(t30, i36, o31, r14, n9, s18) {
            const a18 = [
                (t31)=>{
                    let i37 = t31.canonical.x - 1, o32 = t31.wrap;
                    return i37 < 0 && (i37 = (1 << t31.canonical.z) - 1, o32--), new e1.OverscaledTileID(t31.overscaledZ, o32, t31.canonical.z, i37, t31.canonical.y);
                },
                (t31)=>{
                    let i37 = t31.canonical.x + 1, o32 = t31.wrap;
                    return i37 === 1 << t31.canonical.z && (i37 = 0, o32++), new e1.OverscaledTileID(t31.overscaledZ, o32, t31.canonical.z, i37, t31.canonical.y);
                },
                (t31)=>new e1.OverscaledTileID(t31.overscaledZ, t31.wrap, t31.canonical.z, t31.canonical.x, (0 === t31.canonical.y ? 1 << t31.canonical.z : t31.canonical.y) - 1)
                ,
                (t31)=>new e1.OverscaledTileID(t31.overscaledZ, t31.wrap, t31.canonical.z, t31.canonical.x, t31.canonical.y === (1 << t31.canonical.z) - 1 ? 0 : t31.canonical.y + 1)
            ], l21 = (e29)=>{
                const t31 = i36.getSource().minzoom, o32 = (e30)=>{
                    const t32 = i36.getTileByID(e30);
                    if (t32 && t32.hasData()) return t32.getBucket(n9);
                }, r15 = [
                    0,
                    -1,
                    1
                ];
                for (const i37 of r15){
                    if (e29.overscaledZ + i37 < t31) continue;
                    const r16 = o32(e29.calculateScaledKey(e29.overscaledZ + i37));
                    if (r16) return r16;
                }
            }, c15 = [
                0,
                0,
                0
            ], h14 = (t31, i37)=>(c15[0] = Math.min(t31.min.y, i37.min.y), c15[1] = Math.max(t31.max.y, i37.max.y), c15[2] = e1.EXTENT - i37.min.x > t31.max.x ? i37.min.x - e1.EXTENT : t31.max.x, c15)
            , u17 = (t31, i37)=>(c15[0] = Math.min(t31.min.x, i37.min.x), c15[1] = Math.max(t31.max.x, i37.max.x), c15[2] = e1.EXTENT - i37.min.y > t31.max.y ? i37.min.y - e1.EXTENT : t31.max.y, c15)
            , _3 = [
                (e29, t31)=>h14(e29, t31)
                ,
                (e29, t31)=>h14(t31, e29)
                ,
                (e29, t31)=>u17(e29, t31)
                ,
                (e29, t31)=>u17(t31, e29)
            ], d9 = new e1.pointGeometry(0, 0);
            let p12, m8, f9;
            const g6 = (t31, i37, r15, n10, a19)=>{
                const l22 = [
                    [
                        n10 ? r15 : t31,
                        n10 ? t31 : r15,
                        0
                    ],
                    [
                        n10 ? r15 : i37,
                        n10 ? i37 : r15,
                        0
                    ]
                ], c16 = a19 < 0 ? e1.EXTENT + a19 : a19, h15 = [
                    n10 ? c16 : (t31 + i37) / 2,
                    n10 ? (t31 + i37) / 2 : c16,
                    0
                ];
                return 0 === r15 && a19 < 0 || 0 !== r15 && a19 > 0 ? s18.getForTilePoints(f9, [
                    h15
                ], !0, m8) : l22.push(h15), s18.getForTilePoints(o31, l22, !0, p12), Math.max(l22[0][2], l22[1][2], h15[2]) / s18.exaggeration();
            };
            for(let t31 = 0; t31 < 4; t31++){
                const i37 = (t31 < 2 ? 1 : 5) - t31, n10 = r14.borders[t31];
                if (0 === n10.length) continue;
                const c16 = f9 = a18[t31](o31), h15 = l21(c16);
                if (!(h15 && h15 instanceof e1.FillExtrusionBucket && h15.enableTerrain)) continue;
                if (r14.borderDoneWithNeighborZ[t31] === h15.canonical.z && h15.borderDoneWithNeighborZ[i37] === r14.canonical.z) continue;
                if (m8 = s18.findDEMTileFor(c16), !m8 || !m8.dem) continue;
                if (!p12) {
                    const e29 = s18.findDEMTileFor(o31);
                    if (!e29 || !e29.dem) return;
                    p12 = e29;
                }
                const u18 = h15.borders[i37];
                let v4 = 0;
                const x4 = h15.borderDoneWithNeighborZ[i37] !== r14.canonical.z;
                if (r14.canonical.z === h15.canonical.z) {
                    for(let o32 = 0; o32 < n10.length; o32++){
                        const s19 = r14.featuresOnBorder[n10[o32]], a19 = s19.borders[t31];
                        let l22;
                        for(; v4 < u18.length && (l22 = h15.featuresOnBorder[u18[v4]], !(l22.borders[i37][1] > a19[0] + 3));)x4 && h15.encodeCentroid(void 0, l22, !1), v4++;
                        if (l22 && v4 < u18.length) {
                            const o33 = v4;
                            let n11 = 0;
                            for(; !(l22.borders[i37][0] > a19[1] - 3) && (n11++, (++v4) !== u18.length);)l22 = h15.featuresOnBorder[u18[v4]];
                            if (l22 = h15.featuresOnBorder[u18[o33]], s19.intersectsCount() > 1 || l22.intersectsCount() > 1 || 1 !== n11) {
                                1 !== n11 && (v4 = o33), r14.encodeCentroid(void 0, s19, !1), x4 && h15.encodeCentroid(void 0, l22, !1);
                                continue;
                            }
                            const c17 = _3[t31](s19, l22), p13 = t31 % 2 ? e1.EXTENT - 1 : 0;
                            d9.x = g6(c17[0], Math.min(e1.EXTENT - 1, c17[1]), p13, t31 < 2, c17[2]), d9.y = 0, r14.encodeCentroid(d9, s19, !1), x4 && h15.encodeCentroid(d9, l22, !1);
                        } else r14.encodeCentroid(void 0, s19, !1);
                    }
                    r14.borderDoneWithNeighborZ[t31] = h15.canonical.z, r14.needsCentroidUpdate = !0, x4 && (h15.borderDoneWithNeighborZ[i37] = r14.canonical.z, h15.needsCentroidUpdate = !0);
                } else {
                    for (const e29 of n10)r14.encodeCentroid(void 0, r14.featuresOnBorder[e29], !1);
                    if (x4) {
                        for (const e30 of u18)h15.encodeCentroid(void 0, h15.featuresOnBorder[e30], !1);
                        h15.borderDoneWithNeighborZ[i37] = r14.canonical.z, h15.needsCentroidUpdate = !0;
                    }
                    r14.borderDoneWithNeighborZ[t31] = h15.canonical.z, r14.needsCentroidUpdate = !0;
                }
            }
            (r14.needsCentroidUpdate || !r14.centroidVertexBuffer && 0 !== r14.centroidVertexArray.length) && r14.uploadCentroid(t30);
        }
        const xo = new e1.Color(1, 0, 0, 1), yo = new e1.Color(0, 1, 0, 1), bo = new e1.Color(0, 0, 1, 1), wo = new e1.Color(1, 0, 1, 1), To = new e1.Color(0, 1, 1, 1);
        function Eo(t30, i36, o31) {
            const r14 = t30.context, n9 = t30.transform, s18 = r14.gl, a18 = "globe" === n9.projection.name, l21 = a18 ? [
                "PROJECTION_GLOBE_VIEW"
            ] : null;
            let c15 = o31.projMatrix;
            if (a18 && e1.globeToMercatorTransition(n9.zoom) > 0) {
                const t31 = e1.transitionTileAABBinECEF(o31.canonical, n9), i37 = e1.globeDenormalizeECEF(t31);
                c15 = e1.multiply(new Float32Array(16), n9.globeMatrix, i37), e1.multiply(c15, n9.projMatrix, c15);
            }
            const h14 = t30.useProgram("debug", null, l21), u17 = i36.getTileByID(o31.key);
            t30.terrain && t30.terrain.setupElevationDraw(u17, h14);
            const _3 = e1.DepthMode.disabled, d9 = e1.StencilMode.disabled, p12 = t30.colorModeForRenderPass(), m8 = "$debug";
            r14.activeTexture.set(s18.TEXTURE0), t30.emptyTexture.bind(s18.LINEAR, s18.CLAMP_TO_EDGE), a18 ? u17._makeGlobeTileDebugBuffers(t30.context, n9) : u17._makeDebugTileBoundsBuffers(t30.context, n9.projection);
            const f9 = u17._tileDebugBuffer || t30.debugBuffer, g6 = u17._tileDebugIndexBuffer || t30.debugIndexBuffer, v4 = u17._tileDebugSegments || t30.debugSegments;
            h14.draw(r14, s18.LINE_STRIP, _3, d9, p12, e1.CullFaceMode.disabled, Vi(c15, e1.Color.red), m8, f9, g6, v4, null, null, null, [
                u17._globeTileDebugBorderBuffer
            ]);
            const x4 = u17.latestRawTileData, y5 = Math.floor((x4 && x4.byteLength || 0) / 1024), b3 = i36.getTile(o31).tileSize, w4 = 512 / Math.min(b3, 512) * (o31.overscaledZ / n9.zoom) * 0.5;
            let T1 = o31.canonical.toString();
            o31.overscaledZ !== o31.canonical.z && (T1 += ` => ${o31.overscaledZ}`), T1 += ` ${y5}kb`, (function(e29, t31) {
                e29.initDebugOverlayCanvas();
                const i37 = e29.debugOverlayCanvas, o32 = e29.context.gl, r15 = e29.debugOverlayCanvas.getContext("2d");
                r15.clearRect(0, 0, i37.width, i37.height), r15.shadowColor = "white", r15.shadowBlur = 2, r15.lineWidth = 1.5, r15.strokeStyle = "white", r15.textBaseline = "top", r15.font = "bold 36px Open Sans, sans-serif", r15.fillText(t31, 5, 5), r15.strokeText(t31, 5, 5), e29.debugOverlayTexture.update(i37), e29.debugOverlayTexture.bind(o32.LINEAR, o32.CLAMP_TO_EDGE);
            })(t30, T1);
            const E1 = u17._tileDebugTextBuffer || t30.debugBuffer, C1 = u17._tileDebugTextIndexBuffer || t30.quadTriangleIndexBuffer, I1 = u17._tileDebugTextSegments || t30.debugSegments;
            h14.draw(r14, s18.TRIANGLES, _3, d9, e1.ColorMode.alphaBlended, e1.CullFaceMode.disabled, Vi(c15, e1.Color.transparent, w4), m8, E1, C1, I1, null, null, null, [
                u17._globeTileDebugTextBuffer
            ]);
        }
        function Co(e29, t30, i36, o31) {
            Mo(e29, 0, t30 + i36 / 2, e29.transform.width, i36, o31);
        }
        function Io(e29, t30, i36, o31) {
            Mo(e29, t30 - i36 / 2, 0, i36, e29.transform.height, o31);
        }
        function Mo(t30, i36, o31, r14, n9, s18) {
            const a18 = t30.context, l21 = a18.gl;
            l21.enable(l21.SCISSOR_TEST), l21.scissor(i36 * e1.exported.devicePixelRatio, o31 * e1.exported.devicePixelRatio, r14 * e1.exported.devicePixelRatio, n9 * e1.exported.devicePixelRatio), a18.clear({
                color: s18
            }), l21.disable(l21.SCISSOR_TEST);
        }
        const So = e1.createLayout([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), { members: Do  } = So;
        function Ao(e29, t30, i36, o31) {
            e29.emplaceBack(t30, i36, o31);
        }
        class Lo {
            constructor(t30){
                this.vertexArray = new e1.StructArrayLayout3f12, this.indices = new e1.StructArrayLayout3ui6, Ao(this.vertexArray, -1, -1, 1), Ao(this.vertexArray, 1, -1, 1), Ao(this.vertexArray, -1, 1, 1), Ao(this.vertexArray, 1, 1, 1), Ao(this.vertexArray, -1, -1, -1), Ao(this.vertexArray, 1, -1, -1), Ao(this.vertexArray, -1, 1, -1), Ao(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t30.createVertexBuffer(this.vertexArray, Do), this.indexBuffer = t30.createIndexBuffer(this.indices), this.segment = e1.SegmentVector.simpleSegment(0, 0, 36, 12);
            }
        }
        function zo(t31, i36, o31, r14, n9, s18) {
            const a18 = t31.gl, l21 = i36.paint.get("sky-atmosphere-color"), c15 = i36.paint.get("sky-atmosphere-halo-color"), h14 = i36.paint.get("sky-atmosphere-sun-intensity"), u17 = ((e29, t32, i37, o32, r15)=>({
                    u_matrix_3f: e29,
                    u_sun_direction: t32,
                    u_sun_intensity: i37,
                    u_color_tint_r: [
                        o32.r,
                        o32.g,
                        o32.b,
                        o32.a
                    ],
                    u_color_tint_m: [
                        r15.r,
                        r15.g,
                        r15.b,
                        r15.a
                    ],
                    u_luminance: 0.00005
                })
            )(e1.fromMat4(e1.create$1(), r14), n9, h14, l21, c15);
            a18.framebufferTexture2D(a18.FRAMEBUFFER, a18.COLOR_ATTACHMENT0, a18.TEXTURE_CUBE_MAP_POSITIVE_X + s18, i36.skyboxTexture, 0), o31.draw(t31, a18.TRIANGLES, e1.DepthMode.disabled, e1.StencilMode.disabled, e1.ColorMode.unblended, e1.CullFaceMode.frontCW, u17, "skyboxCapture", i36.skyboxGeometry.vertexBuffer, i36.skyboxGeometry.indexBuffer, i36.skyboxGeometry.segment);
        }
        const Po = e1.createLayout([
            {
                type: "Float32",
                name: "a_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]);
        class Ro {
            constructor(t31){
                const i36 = new e1.StructArrayLayout5f20;
                i36.emplaceBack(-1, 1, 1, 0, 0), i36.emplaceBack(1, 1, 1, 1, 0), i36.emplaceBack(1, -1, 1, 1, 1), i36.emplaceBack(-1, -1, 1, 0, 1);
                const o31 = new e1.StructArrayLayout3ui6;
                o31.emplaceBack(0, 1, 2), o31.emplaceBack(2, 3, 0), this.vertexBuffer = t31.createVertexBuffer(i36, Po.members), this.indexBuffer = t31.createIndexBuffer(o31), this.segments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
                this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
        }
        const Oo = {
            symbol: function(t32, i37, o32, r14, n9) {
                if ("translucent" !== t32.renderPass) return;
                const s18 = e1.StencilMode.disabled, a18 = t32.colorModeForRenderPass();
                o32.layout.get("text-variable-anchor") && (function(t33, i38, o33, r15, n10, s19, a19) {
                    const l21 = i38.transform, c15 = "map" === n10, h14 = "map" === s19;
                    for (const i39 of t33){
                        const t34 = r15.getTile(i39), n11 = t34.getBucket(o33);
                        if (!n11 || !n11.text || !n11.text.segments.get().length) continue;
                        const s20 = e1.evaluateSizeForZoom(n11.textSizeData, l21.zoom), u17 = yt(i39, n11.getProjection(), l21), _3 = l21.calculatePixelsToTileUnitsMatrix(t34), d9 = tt(u17, t34.tileID.canonical, h14, c15, l21, n11.getProjection(), _3), p12 = "none" !== o33.layout.get("icon-text-fit") && n11.hasIconData();
                        if (s20) {
                            const o34 = Math.pow(2, l21.zoom - t34.tileID.overscaledZ);
                            uo(n11, c15, h14, a19, e1.symbolSize, l21, d9, i39, o34, s20, p12);
                        }
                    }
                })(r14, t32, o32, i37, o32.layout.get("text-rotation-alignment"), o32.layout.get("text-pitch-alignment"), n9), 0 !== o32.paint.get("icon-opacity").constantOr(1) && po(t32, i37, o32, r14, !1, o32.paint.get("icon-translate"), o32.paint.get("icon-translate-anchor"), o32.layout.get("icon-rotation-alignment"), o32.layout.get("icon-pitch-alignment"), o32.layout.get("icon-keep-upright"), s18, a18), 0 !== o32.paint.get("text-opacity").constantOr(1) && po(t32, i37, o32, r14, !0, o32.paint.get("text-translate"), o32.paint.get("text-translate-anchor"), o32.layout.get("text-rotation-alignment"), o32.layout.get("text-pitch-alignment"), o32.layout.get("text-keep-upright"), s18, a18), i37.map.showCollisionBoxes && (lo(t32, i37, o32, r14, o32.paint.get("text-translate"), o32.paint.get("text-translate-anchor"), !0), lo(t32, i37, o32, r14, o32.paint.get("icon-translate"), o32.paint.get("icon-translate-anchor"), !1));
            },
            circle: function(t32, i37, o32, r14) {
                if ("translucent" !== t32.renderPass) return;
                const n9 = o32.paint.get("circle-opacity"), s18 = o32.paint.get("circle-stroke-width"), a18 = o32.paint.get("circle-stroke-opacity"), l21 = (void 0) !== o32.layout.get("circle-sort-key").constantOr(1);
                if (0 === n9.constantOr(1) && (0 === s18.constantOr(1) || 0 === a18.constantOr(1))) return;
                const c15 = t32.context, h14 = c15.gl, u17 = t32.transform, _3 = t32.depthModeForSublayer(0, e1.DepthMode.ReadOnly), d9 = e1.StencilMode.disabled, p12 = t32.colorModeForRenderPass(), m8 = "globe" === u17.projection.name, f9 = [
                    e1.mercatorXfromLng(u17.center.lng),
                    e1.mercatorYfromLat(u17.center.lat)
                ], g6 = [];
                for(let n10 = 0; n10 < r14.length; n10++){
                    const s19 = r14[n10], a19 = i37.getTile(s19), c16 = a19.getBucket(o32);
                    if (!c16 || c16.projection.name !== u17.projection.name) continue;
                    const h15 = c16.programConfigurations.get(o32.id), _4 = ji(o32);
                    m8 && _4.push("PROJECTION_GLOBE_VIEW");
                    const d10 = t32.useProgram("circle", h15, _4), p13 = c16.layoutVertexBuffer, v4 = c16.globeExtVertexBuffer, x4 = c16.indexBuffer, y5 = u17.projection.createInversionMatrix(u17, s19.canonical), b3 = {
                        programConfiguration: h15,
                        program: d10,
                        layoutVertexBuffer: p13,
                        globeExtVertexBuffer: v4,
                        indexBuffer: x4,
                        uniformValues: Gi(t32, s19, a19, y5, f9, o32),
                        tile: a19
                    };
                    if (l21) {
                        const t33 = c16.segments.get();
                        for (const i38 of t33)g6.push({
                            segments: new e1.SegmentVector([
                                i38
                            ]),
                            sortKey: i38.sortKey,
                            state: b3
                        });
                    } else g6.push({
                        segments: c16.segments,
                        sortKey: 0,
                        state: b3
                    });
                }
                l21 && g6.sort((e29, t33)=>e29.sortKey - t33.sortKey
                );
                const v4 = {
                    useDepthForOcclusion: !m8
                };
                for (const i38 of g6){
                    const { programConfiguration: r15 , program: n11 , layoutVertexBuffer: s19 , globeExtVertexBuffer: a19 , indexBuffer: l22 , uniformValues: m9 , tile: f10  } = i38.state, g7 = i38.segments;
                    t32.terrain && t32.terrain.setupElevationDraw(f10, n11, v4), t32.prepareDrawProgram(c15, n11, f10.tileID.toUnwrapped()), n11.draw(c15, h14.TRIANGLES, _3, d9, p12, e1.CullFaceMode.disabled, m9, o32.id, s19, l22, g7, o32.paint, u17.zoom, r15, [
                        a19
                    ]);
                }
            },
            heatmap: function(t32, i37, o32, r14) {
                if (0 !== o32.paint.get("heatmap-opacity")) {
                    if ("offscreen" === t32.renderPass) {
                        const n9 = t32.context, s18 = n9.gl, a18 = e1.StencilMode.disabled, l21 = new e1.ColorMode([
                            s18.ONE,
                            s18.ONE
                        ], e1.Color.transparent, [
                            !0,
                            !0,
                            !0,
                            !0
                        ]);
                        !function(e29, t33, i38, o33) {
                            const r15 = e29.gl, n10 = t33.width * o33, s19 = t33.height * o33;
                            e29.activeTexture.set(r15.TEXTURE1), e29.viewport.set([
                                0,
                                0,
                                n10,
                                s19
                            ]);
                            let a19 = i38.heatmapFbo;
                            if (!a19 || a19 && (a19.width !== n10 || a19.height !== s19)) {
                                a19 && a19.destroy();
                                const t34 = r15.createTexture();
                                r15.bindTexture(r15.TEXTURE_2D, t34), r15.texParameteri(r15.TEXTURE_2D, r15.TEXTURE_WRAP_S, r15.CLAMP_TO_EDGE), r15.texParameteri(r15.TEXTURE_2D, r15.TEXTURE_WRAP_T, r15.CLAMP_TO_EDGE), r15.texParameteri(r15.TEXTURE_2D, r15.TEXTURE_MIN_FILTER, r15.LINEAR), r15.texParameteri(r15.TEXTURE_2D, r15.TEXTURE_MAG_FILTER, r15.LINEAR), a19 = i38.heatmapFbo = e29.createFramebuffer(n10, s19, !1), (function(e30, t35, i39, o34, r16, n11) {
                                    const s20 = e30.gl;
                                    s20.texImage2D(s20.TEXTURE_2D, 0, s20.RGBA, r16, n11, 0, s20.RGBA, e30.extRenderToTextureHalfFloat ? e30.extTextureHalfFloat.HALF_FLOAT_OES : s20.UNSIGNED_BYTE, null), o34.colorAttachment.set(i39);
                                })(e29, 0, t34, a19, n10, s19);
                            } else r15.bindTexture(r15.TEXTURE_2D, a19.colorAttachment.get()), e29.bindFramebuffer.set(a19.framebuffer);
                        }(n9, t32, o32, "globe" === t32.transform.projection.name ? 0.5 : 0.25), n9.clear({
                            color: e1.Color.transparent
                        });
                        const c15 = t32.transform, h14 = "globe" === c15.projection.name, u17 = h14 ? [
                            "PROJECTION_GLOBE_VIEW"
                        ] : null, _3 = h14 ? e1.CullFaceMode.frontCCW : e1.CullFaceMode.disabled, d9 = [
                            e1.mercatorXfromLng(c15.center.lng),
                            e1.mercatorYfromLat(c15.center.lat)
                        ];
                        for(let p12 = 0; p12 < r14.length; p12++){
                            const m8 = r14[p12];
                            if (i37.hasRenderableParent(m8)) continue;
                            const f9 = i37.getTile(m8), g6 = f9.getBucket(o32);
                            if (!g6 || g6.projection.name !== c15.projection.name) continue;
                            const v4 = g6.programConfigurations.get(o32.id), x4 = t32.useProgram("heatmap", v4, u17), { zoom: y5  } = t32.transform;
                            t32.terrain && t32.terrain.setupElevationDraw(f9, x4), t32.prepareDrawProgram(n9, x4, m8.toUnwrapped());
                            const b3 = c15.projection.createInversionMatrix(c15, m8.canonical);
                            x4.draw(n9, s18.TRIANGLES, e1.DepthMode.disabled, a18, l21, _3, Xi(t32, m8, f9, b3, d9, y5, o32.paint.get("heatmap-intensity")), o32.id, g6.layoutVertexBuffer, g6.indexBuffer, g6.segments, o32.paint, t32.transform.zoom, v4, h14 ? [
                                g6.globeExtVertexBuffer
                            ] : null);
                        }
                        n9.viewport.set([
                            0,
                            0,
                            t32.width,
                            t32.height
                        ]);
                    } else "translucent" === t32.renderPass && (t32.context.setColorMode(t32.colorModeForRenderPass()), (function(t33, i38) {
                        const o33 = t33.context, r15 = o33.gl, n9 = i38.heatmapFbo;
                        if (!n9) return;
                        o33.activeTexture.set(r15.TEXTURE0), r15.bindTexture(r15.TEXTURE_2D, n9.colorAttachment.get()), o33.activeTexture.set(r15.TEXTURE1);
                        let s18 = i38.colorRampTexture;
                        s18 || (s18 = i38.colorRampTexture = new e1.Texture(o33, i38.colorRamp, r15.RGBA)), s18.bind(r15.LINEAR, r15.CLAMP_TO_EDGE), t33.useProgram("heatmapTexture").draw(o33, r15.TRIANGLES, e1.DepthMode.disabled, e1.StencilMode.disabled, t33.colorModeForRenderPass(), e1.CullFaceMode.disabled, ((e29, t34, i39, o34)=>({
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: t34.paint.get("heatmap-opacity")
                            })
                        )(0, i38), i38.id, t33.viewportBuffer, t33.quadTriangleIndexBuffer, t33.viewportSegments, i38.paint, t33.transform.zoom);
                    })(t32, o32));
                }
            },
            line: function(t32, i37, o32, r14) {
                if ("translucent" !== t32.renderPass) return;
                const n9 = o32.paint.get("line-opacity"), s18 = o32.paint.get("line-width");
                if (0 === n9.constantOr(1) || 0 === s18.constantOr(1)) return;
                const a18 = t32.depthModeForSublayer(0, e1.DepthMode.ReadOnly), l21 = t32.colorModeForRenderPass(), c15 = t32.terrain && t32.terrain.renderingToTexture ? 1 : e1.exported.devicePixelRatio, h14 = o32.paint.get("line-dasharray"), u17 = h14.constantOr(1), _3 = o32.layout.get("line-cap"), d9 = o32.paint.get("line-pattern"), p12 = d9.constantOr(1), m8 = o32.paint.get("line-gradient"), f9 = p12 ? "linePattern" : "line", g6 = t32.context, v4 = g6.gl, x4 = ((e29)=>{
                    const t33 = [];
                    Ki(e29) && t33.push("RENDER_LINE_DASH"), e29.paint.get("line-gradient") && t33.push("RENDER_LINE_GRADIENT");
                    const i38 = e29.paint.get("line-trim-offset");
                    0 === i38[0] && 0 === i38[1] || t33.push("RENDER_LINE_TRIM_OFFSET");
                    const o33 = e29.paint.get("line-pattern").constantOr(1), r15 = 1 !== e29.paint.get("line-opacity").constantOr(1);
                    return !o33 && r15 && t33.push("RENDER_LINE_ALPHA_DISCARD"), t33;
                })(o32);
                let y5 = x4.includes("RENDER_LINE_ALPHA_DISCARD");
                t32.terrain && t32.terrain.clipOrMaskOverlapStencilType() && (y5 = !1);
                for (const n10 of r14){
                    const r15 = i37.getTile(n10);
                    if (p12 && !r15.patternsLoaded()) continue;
                    const s19 = r15.getBucket(o32);
                    if (!s19) continue;
                    t32.prepareDrawTile();
                    const b3 = s19.programConfigurations.get(o32.id), w4 = t32.useProgram(f9, b3, x4), T1 = d9.constantOr(null);
                    if (T1 && r15.imageAtlas) {
                        const e29 = r15.imageAtlas.patternPositions[T1.toString()];
                        e29 && b3.setConstantPatternPositions(e29);
                    }
                    const E1 = h14.constantOr(null), C1 = _3.constantOr(null);
                    if (!p12 && E1 && C1 && r15.lineAtlas) {
                        const e29 = r15.lineAtlas.getDash(E1, C1);
                        e29 && b3.setConstantPatternPositions(e29);
                    }
                    let [I1, M3] = o32.paint.get("line-trim-offset");
                    if ("round" === C1 || "square" === C1) {
                        const e29 = 1;
                        I1 !== M3 && (0 === I1 && (I1 -= e29), 1 === M3 && (M3 += e29));
                    }
                    const S3 = t32.terrain ? n10.projMatrix : null, D1 = p12 ? $i(t32, r15, o32, S3, c15) : qi(t32, r15, o32, S3, s19.lineClipsArray.length, c15, [
                        I1,
                        M3
                    ]);
                    if (m8) {
                        const r16 = s19.gradients[o32.id];
                        let a19 = r16.texture;
                        if (o32.gradientVersion !== r16.version) {
                            let l22 = 256;
                            if (o32.stepInterpolant) {
                                const o33 = i37.getSource().maxzoom, r17 = n10.canonical.z === o33 ? Math.ceil(1 << t32.transform.maxZoom - n10.canonical.z) : 1;
                                l22 = e1.clamp(e1.nextPowerOfTwo(s19.maxLineLength / e1.EXTENT * 1024 * r17), 256, g6.maxTextureSize);
                            }
                            r16.gradient = e1.renderColorRamp({
                                expression: o32.gradientExpression(),
                                evaluationKey: "lineProgress",
                                resolution: l22,
                                image: r16.gradient || void 0,
                                clips: s19.lineClipsArray
                            }), r16.texture ? r16.texture.update(r16.gradient) : r16.texture = new e1.Texture(g6, r16.gradient, v4.RGBA), r16.version = o32.gradientVersion, a19 = r16.texture;
                        }
                        g6.activeTexture.set(v4.TEXTURE1), a19.bind(o32.stepInterpolant ? v4.NEAREST : v4.LINEAR, v4.CLAMP_TO_EDGE);
                    }
                    u17 && (g6.activeTexture.set(v4.TEXTURE0), r15.lineAtlasTexture.bind(v4.LINEAR, v4.REPEAT), b3.updatePaintBuffers()), p12 && (g6.activeTexture.set(v4.TEXTURE0), r15.imageAtlasTexture.bind(v4.LINEAR, v4.CLAMP_TO_EDGE), b3.updatePaintBuffers()), t32.prepareDrawProgram(g6, w4, n10.toUnwrapped());
                    const A1 = (i38)=>{
                        w4.draw(g6, v4.TRIANGLES, a18, i38, l21, e1.CullFaceMode.disabled, D1, o32.id, s19.layoutVertexBuffer, s19.indexBuffer, s19.segments, o32.paint, t32.transform.zoom, b3, [
                            s19.layoutVertexBuffer2
                        ]);
                    };
                    if (y5) {
                        const i38 = t32.stencilModeForClipping(n10).ref;
                        0 === i38 && t32.terrain && g6.clear({
                            stencil: 0
                        });
                        const o33 = {
                            func: v4.EQUAL,
                            mask: 255
                        };
                        D1.u_alpha_discard_threshold = 0.8, A1(new e1.StencilMode(o33, i38, 255, v4.KEEP, v4.KEEP, v4.INVERT)), D1.u_alpha_discard_threshold = 0, A1(new e1.StencilMode(o33, i38, 255, v4.KEEP, v4.KEEP, v4.KEEP));
                    } else A1(t32.stencilModeForClipping(n10));
                }
                y5 && (t32.resetStencilClippingMasks(), t32.terrain && g6.clear({
                    stencil: 0
                }));
            },
            fill: function(t32, i37, o32, r14) {
                const n9 = o32.paint.get("fill-color"), s18 = o32.paint.get("fill-opacity");
                if (0 === s18.constantOr(1)) return;
                const a18 = t32.colorModeForRenderPass(), l21 = o32.paint.get("fill-pattern"), c15 = t32.opaquePassEnabledForLayer() && !l21.constantOr(1) && 1 === n9.constantOr(e1.Color.transparent).a && 1 === s18.constantOr(0) ? "opaque" : "translucent";
                if (t32.renderPass === c15) {
                    const n10 = t32.depthModeForSublayer(1, "opaque" === t32.renderPass ? e1.DepthMode.ReadWrite : e1.DepthMode.ReadOnly);
                    fo(t32, i37, o32, r14, n10, a18, !1);
                }
                if ("translucent" === t32.renderPass && o32.paint.get("fill-antialias")) {
                    const n10 = t32.depthModeForSublayer(o32.getPaintProperty("fill-outline-color") ? 2 : 0, e1.DepthMode.ReadOnly);
                    fo(t32, i37, o32, r14, n10, a18, !0);
                }
            },
            "fill-extrusion": function(t32, i37, o32, r14) {
                const n9 = o32.paint.get("fill-extrusion-opacity");
                if (0 !== n9 && "translucent" === t32.renderPass) {
                    const s18 = new e1.DepthMode(t32.context.gl.LEQUAL, e1.DepthMode.ReadWrite, t32.depthRangeFor3D);
                    if (1 !== n9 || o32.paint.get("fill-extrusion-pattern").constantOr(1)) go(t32, i37, o32, r14, s18, e1.StencilMode.disabled, e1.ColorMode.disabled), go(t32, i37, o32, r14, s18, t32.stencilModeFor3D(), t32.colorModeForRenderPass()), t32.resetStencilClippingMasks();
                    else {
                        const n10 = t32.colorModeForRenderPass();
                        go(t32, i37, o32, r14, s18, e1.StencilMode.disabled, n10);
                    }
                }
            },
            hillshade: function(t32, i37, o32, r14) {
                if ("offscreen" !== t32.renderPass && "translucent" !== t32.renderPass) return;
                const n9 = t32.context, s18 = t32.depthModeForSublayer(0, e1.DepthMode.ReadOnly), a18 = t32.colorModeForRenderPass(), l21 = t32.terrain && t32.terrain.renderingToTexture, [c15, h14] = "translucent" !== t32.renderPass || l21 ? [
                    {
                    },
                    r14
                ] : t32.stencilConfigForOverlap(r14);
                for (const r15 of h14){
                    const n10 = i37.getTile(r15);
                    if (n10.needsHillshadePrepare && "offscreen" === t32.renderPass) gi(t32, n10, o32, s18, e1.StencilMode.disabled, a18);
                    else if ("translucent" === t32.renderPass) {
                        const e29 = l21 && t32.terrain ? t32.terrain.stencilModeForRTTOverlap(r15) : c15[r15.overscaledZ];
                        mi(t32, r15, n10, o32, s18, e29, a18);
                    }
                }
                n9.viewport.set([
                    0,
                    0,
                    t32.width,
                    t32.height
                ]), t32.resetStencilClippingMasks();
            },
            raster: function(t32, i37, o32, r14, n9, s18) {
                if ("translucent" !== t32.renderPass) return;
                if (0 === o32.paint.get("raster-opacity")) return;
                if (!r14.length) return;
                const a18 = t32.context, l21 = a18.gl, c15 = i37.getSource(), h14 = t32.useProgram("raster"), u17 = t32.colorModeForRenderPass(), _3 = t32.terrain && t32.terrain.renderingToTexture, [d9, p12] = c15 instanceof Ae || _3 ? [
                    {
                    },
                    r14
                ] : t32.stencilConfigForOverlap(r14), m8 = p12[p12.length - 1].overscaledZ, f9 = !t32.options.moving;
                for (const r15 of p12){
                    const n10 = _3 ? e1.DepthMode.disabled : t32.depthModeForSublayer(r15.overscaledZ - m8, 1 === o32.paint.get("raster-opacity") ? e1.DepthMode.ReadWrite : e1.DepthMode.ReadOnly, l21.LESS), p13 = r15.toUnwrapped(), g6 = i37.getTile(r15);
                    if (_3 && (!g6 || !g6.hasData())) continue;
                    const v4 = _3 ? r15.projMatrix : t32.transform.calculateProjMatrix(p13, f9), x4 = t32.terrain && _3 ? t32.terrain.stencilModeForRTTOverlap(r15) : d9[r15.overscaledZ], y5 = s18 ? 0 : o32.paint.get("raster-fade-duration");
                    g6.registerFadeDuration(y5);
                    const b3 = i37.findLoadedParent(r15, 0), w4 = Ii(g6, b3, i37, t32.transform, y5);
                    let T1, E1;
                    t32.terrain && t32.terrain.prepareDrawTile();
                    const C1 = "nearest" === o32.paint.get("raster-resampling") ? l21.NEAREST : l21.LINEAR;
                    a18.activeTexture.set(l21.TEXTURE0), g6.texture.bind(C1, l21.CLAMP_TO_EDGE), a18.activeTexture.set(l21.TEXTURE1), b3 ? (b3.texture.bind(C1, l21.CLAMP_TO_EDGE), T1 = Math.pow(2, b3.tileID.overscaledZ - g6.tileID.overscaledZ), E1 = [
                        g6.tileID.canonical.x * T1 % 1,
                        g6.tileID.canonical.y * T1 % 1
                    ]) : g6.texture.bind(C1, l21.CLAMP_TO_EDGE);
                    const I1 = Ji(v4, E1 || [
                        0,
                        0
                    ], T1 || 1, w4, o32, c15 instanceof Ae ? c15.perspectiveTransform : [
                        0,
                        0
                    ]);
                    if (t32.prepareDrawProgram(a18, h14, p13), c15 instanceof Ae) c15.boundsBuffer && c15.boundsSegments && h14.draw(a18, l21.TRIANGLES, n10, e1.StencilMode.disabled, u17, e1.CullFaceMode.disabled, I1, o32.id, c15.boundsBuffer, t32.quadTriangleIndexBuffer, c15.boundsSegments);
                    else {
                        const { tileBoundsBuffer: i38 , tileBoundsIndexBuffer: r16 , tileBoundsSegments: s19  } = t32.getTileBoundsBuffers(g6);
                        h14.draw(a18, l21.TRIANGLES, n10, x4, u17, e1.CullFaceMode.disabled, I1, o32.id, i38, r16, s19);
                    }
                }
                t32.resetStencilClippingMasks();
            },
            background: function(t32, i37, o32, r14) {
                const n9 = o32.paint.get("background-color"), s18 = o32.paint.get("background-opacity");
                if (0 === s18) return;
                const a18 = t32.context, l21 = a18.gl, c15 = t32.transform, h14 = c15.tileSize, u17 = o32.paint.get("background-pattern");
                if (t32.isPatternMissing(u17)) return;
                const _3 = !u17 && 1 === n9.a && 1 === s18 && t32.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (t32.renderPass !== _3) return;
                const d9 = e1.StencilMode.disabled, p12 = t32.depthModeForSublayer(0, "opaque" === _3 ? e1.DepthMode.ReadWrite : e1.DepthMode.ReadOnly), m8 = t32.colorModeForRenderPass(), f9 = t32.useProgram(u17 ? "backgroundPattern" : "background");
                let g6, v4 = r14;
                v4 || (g6 = t32.getBackgroundTiles(), v4 = Object.values(g6).map((e29)=>e29.tileID
                )), u17 && (a18.activeTexture.set(l21.TEXTURE0), t32.imageManager.bind(t32.context));
                for (const _4 of v4){
                    const v5 = _4.toUnwrapped(), x4 = r14 ? _4.projMatrix : t32.transform.calculateProjMatrix(v5);
                    t32.prepareDrawTile();
                    const y5 = i37 ? i37.getTile(_4) : g6 ? g6[_4.key] : new e1.Tile(_4, h14, c15.zoom, t32), b3 = u17 ? no(x4, s18, t32, u17, {
                        tileID: _4,
                        tileSize: h14
                    }) : ro(x4, s18, n9);
                    t32.prepareDrawProgram(a18, f9, v5);
                    const { tileBoundsBuffer: w4 , tileBoundsIndexBuffer: T1 , tileBoundsSegments: E1  } = t32.getTileBoundsBuffers(y5);
                    f9.draw(a18, l21.TRIANGLES, p12, d9, m8, e1.CullFaceMode.disabled, b3, o32.id, w4, T1, E1);
                }
            },
            sky: function(t32, i37, o32) {
                const r14 = t32.transform, n9 = "mercator" === r14.projection.name || "globe" === r14.projection.name ? 1 : e1.smoothstep(7, 8, r14.zoom), s18 = o32.paint.get("sky-opacity") * n9;
                if (0 === s18) return;
                const a18 = t32.context, l21 = o32.paint.get("sky-type"), c15 = new e1.DepthMode(a18.gl.LEQUAL, e1.DepthMode.ReadOnly, [
                    0,
                    1
                ]), h14 = t32.frameCounter / 1000 % 1;
                "atmosphere" === l21 ? "offscreen" === t32.renderPass ? o32.needsSkyboxCapture(t32) && ((function(t33, i38, o33, r15) {
                    const n10 = t33.context, s19 = n10.gl;
                    let a19 = i38.skyboxFbo;
                    if (!a19) {
                        a19 = i38.skyboxFbo = n10.createFramebuffer(32, 32, !1), i38.skyboxGeometry = new Lo(n10), i38.skyboxTexture = n10.gl.createTexture(), s19.bindTexture(s19.TEXTURE_CUBE_MAP, i38.skyboxTexture), s19.texParameteri(s19.TEXTURE_CUBE_MAP, s19.TEXTURE_WRAP_S, s19.CLAMP_TO_EDGE), s19.texParameteri(s19.TEXTURE_CUBE_MAP, s19.TEXTURE_WRAP_T, s19.CLAMP_TO_EDGE), s19.texParameteri(s19.TEXTURE_CUBE_MAP, s19.TEXTURE_MIN_FILTER, s19.LINEAR), s19.texParameteri(s19.TEXTURE_CUBE_MAP, s19.TEXTURE_MAG_FILTER, s19.LINEAR);
                        for(let e29 = 0; e29 < 6; ++e29)s19.texImage2D(s19.TEXTURE_CUBE_MAP_POSITIVE_X + e29, 0, s19.RGBA, 32, 32, 0, s19.RGBA, s19.UNSIGNED_BYTE, null);
                    }
                    n10.bindFramebuffer.set(a19.framebuffer), n10.viewport.set([
                        0,
                        0,
                        32,
                        32
                    ]);
                    const l22 = i38.getCenter(t33, !0), c16 = t33.useProgram("skyboxCapture"), h15 = new Float64Array(16);
                    e1.identity(h15), e1.rotateY(h15, h15, 0.5 * -Math.PI), zo(n10, i38, c16, h15, l22, 0), e1.identity(h15), e1.rotateY(h15, h15, 0.5 * Math.PI), zo(n10, i38, c16, h15, l22, 1), e1.identity(h15), e1.rotateX(h15, h15, 0.5 * -Math.PI), zo(n10, i38, c16, h15, l22, 2), e1.identity(h15), e1.rotateX(h15, h15, 0.5 * Math.PI), zo(n10, i38, c16, h15, l22, 3), e1.identity(h15), zo(n10, i38, c16, h15, l22, 4), e1.identity(h15), e1.rotateY(h15, h15, Math.PI), zo(n10, i38, c16, h15, l22, 5), n10.viewport.set([
                        0,
                        0,
                        t33.width,
                        t33.height
                    ]);
                })(t32, o32), o32.markSkyboxValid(t32)) : "sky" === t32.renderPass && (function(t33, i38, o33, r15, n10) {
                    const s19 = t33.context, a19 = s19.gl, l22 = t33.transform, c16 = t33.useProgram("skybox");
                    s19.activeTexture.set(a19.TEXTURE0), a19.bindTexture(a19.TEXTURE_CUBE_MAP, i38.skyboxTexture);
                    const h15 = ((e29, t34, i39, o34, r16)=>({
                            u_matrix: e29,
                            u_sun_direction: t34,
                            u_cubemap: 0,
                            u_opacity: o34,
                            u_temporal_offset: r16
                        })
                    )(l22.skyboxMatrix, i38.getCenter(t33, !1), 0, r15, n10);
                    t33.prepareDrawProgram(s19, c16), c16.draw(s19, a19.TRIANGLES, o33, e1.StencilMode.disabled, t33.colorModeForRenderPass(), e1.CullFaceMode.backCW, h15, "skybox", i38.skyboxGeometry.vertexBuffer, i38.skyboxGeometry.indexBuffer, i38.skyboxGeometry.segment);
                })(t32, o32, c15, s18, h14) : "gradient" === l21 && "sky" === t32.renderPass && (function(t33, i38, o33, r15, n10) {
                    const s19 = t33.context, a19 = s19.gl, l22 = t33.transform, c16 = t33.useProgram("skyboxGradient");
                    i38.skyboxGeometry || (i38.skyboxGeometry = new Lo(s19)), s19.activeTexture.set(a19.TEXTURE0);
                    let h15 = i38.colorRampTexture;
                    h15 || (h15 = i38.colorRampTexture = new e1.Texture(s19, i38.colorRamp, a19.RGBA)), h15.bind(a19.LINEAR, a19.CLAMP_TO_EDGE);
                    const u17 = ((t34, i39, o34, r16, n11)=>({
                            u_matrix: t34,
                            u_color_ramp: 0,
                            u_center_direction: i39,
                            u_radius: e1.degToRad(o34),
                            u_opacity: r16,
                            u_temporal_offset: n11
                        })
                    )(l22.skyboxMatrix, i38.getCenter(t33, !1), i38.paint.get("sky-gradient-radius"), r15, n10);
                    t33.prepareDrawProgram(s19, c16), c16.draw(s19, a19.TRIANGLES, o33, e1.StencilMode.disabled, t33.colorModeForRenderPass(), e1.CullFaceMode.backCW, u17, "skyboxGradient", i38.skyboxGeometry.vertexBuffer, i38.skyboxGeometry.indexBuffer, i38.skyboxGeometry.segment);
                })(t32, o32, c15, s18, h14);
            },
            debug: function(e29, t32, i37) {
                for(let o32 = 0; o32 < i37.length; o32++)Eo(e29, t32, i37[o32]);
            },
            custom: function(t32, i37, o32) {
                const r14 = t32.context, n9 = o32.implementation;
                if (t32.transform.projection.unsupportedLayers && t32.transform.projection.unsupportedLayers.includes("custom")) e1.warnOnce("Custom layers are not yet supported with non-mercator projections. Use mercator to enable custom layers.");
                else if ("offscreen" === t32.renderPass) {
                    const e29 = n9.prerender;
                    e29 && (t32.setCustomLayerDefaults(), r14.setColorMode(t32.colorModeForRenderPass()), e29.call(n9, r14.gl, t32.transform.customLayerMatrix()), r14.setDirty(), t32.setBaseState());
                } else if ("translucent" === t32.renderPass) {
                    t32.setCustomLayerDefaults(), r14.setColorMode(t32.colorModeForRenderPass()), r14.setStencilMode(e1.StencilMode.disabled);
                    const i38 = "3d" === n9.renderingMode ? new e1.DepthMode(t32.context.gl.LEQUAL, e1.DepthMode.ReadWrite, t32.depthRangeFor3D) : t32.depthModeForSublayer(0, e1.DepthMode.ReadOnly);
                    r14.setDepthMode(i38), n9.render(r14.gl, t32.transform.customLayerMatrix()), r14.setDirty(), t32.setBaseState(), r14.bindFramebuffer.set(null);
                }
            }
        };
        class Bo {
            constructor(t32, i37){
                this.context = new Ie(t32), this.transform = i37, this._tileTextures = {
                }, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e1.SourceCache.maxUnderzooming + e1.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Xt, this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {
                }, this.frameCounter = 0, this._backgroundTiles = {
                };
            }
            updateTerrain(e, t) {
                const i38 = !!e && !!e.terrain && this.transform.projection.supportsTerrain;
                if (!(i38 || this._terrain && this._terrain.enabled)) return;
                this._terrain || (this._terrain = new Ai(this, e));
                const o32 = this._terrain;
                this.transform.elevation = i38 ? o32 : null, o32.update(e, this.transform, t);
            }
            _updateFog(e) {
                const t33 = e.fog;
                if (!t33 || "globe" === this.transform.projection.name || t33.getOpacity(this.transform.pitch) < 1 || t33.properties.get("horizon-blend") < 0.03) return void (this.transform.fogCullDistSq = null);
                const [i38, o32] = t33.getFovAdjustedRange(this.transform._fov);
                if (i38 > o32) return void (this.transform.fogCullDistSq = null);
                const r14 = i38 + 0.78 * (o32 - i38);
                this.transform.fogCullDistSq = r14 * r14;
            }
            get terrain() {
                return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
            }
            resize(t, i) {
                if (this.width = t * e1.exported.devicePixelRatio, this.height = i * e1.exported.devicePixelRatio, this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.style) for (const e29 of this.style.order)this.style._layers[e29].resize();
            }
            setup() {
                const t33 = this.context, i38 = new e1.StructArrayLayout2i4;
                i38.emplaceBack(0, 0), i38.emplaceBack(e1.EXTENT, 0), i38.emplaceBack(0, e1.EXTENT), i38.emplaceBack(e1.EXTENT, e1.EXTENT), this.tileExtentBuffer = t33.createVertexBuffer(i38, e1.posAttributes.members), this.tileExtentSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const o32 = new e1.StructArrayLayout2i4;
                o32.emplaceBack(0, 0), o32.emplaceBack(e1.EXTENT, 0), o32.emplaceBack(0, e1.EXTENT), o32.emplaceBack(e1.EXTENT, e1.EXTENT), this.debugBuffer = t33.createVertexBuffer(o32, e1.posAttributes.members), this.debugSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 5);
                const r14 = new e1.StructArrayLayout2i4;
                r14.emplaceBack(-1, -1), r14.emplaceBack(1, -1), r14.emplaceBack(-1, 1), r14.emplaceBack(1, 1), this.viewportBuffer = t33.createVertexBuffer(r14, e1.posAttributes.members), this.viewportSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const n9 = new e1.StructArrayLayout4i8;
                n9.emplaceBack(0, 0, 0, 0), n9.emplaceBack(e1.EXTENT, 0, e1.EXTENT, 0), n9.emplaceBack(0, e1.EXTENT, 0, e1.EXTENT), n9.emplaceBack(e1.EXTENT, e1.EXTENT, e1.EXTENT, e1.EXTENT), this.mercatorBoundsBuffer = t33.createVertexBuffer(n9, e1.boundsAttributes.members), this.mercatorBoundsSegments = e1.SegmentVector.simpleSegment(0, 0, 4, 2);
                const s18 = new e1.StructArrayLayout3ui6;
                s18.emplaceBack(0, 1, 2), s18.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t33.createIndexBuffer(s18);
                const a18 = new e1.StructArrayLayout1ui2;
                for (const e29 of [
                    0,
                    1,
                    3,
                    2,
                    0
                ])a18.emplaceBack(e29);
                this.debugIndexBuffer = t33.createIndexBuffer(a18), this.emptyTexture = new e1.Texture(t33, new e1.RGBAImage({
                    width: 1,
                    height: 1
                }, Uint8Array.of(0, 0, 0, 0)), t33.gl.RGBA), this.identityMat = e1.create();
                const l21 = this.context.gl;
                this.stencilClearMode = new e1.StencilMode({
                    func: l21.ALWAYS,
                    mask: 0
                }, 0, 255, l21.ZERO, l21.ZERO, l21.ZERO), this.loadTimeStamps.push(e1.window.performance.now()), this.atmosphereBuffer = new Ro(this.context);
            }
            getMercatorTileBoundsBuffers() {
                return {
                    tileBoundsBuffer: this.mercatorBoundsBuffer,
                    tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                    tileBoundsSegments: this.mercatorBoundsSegments
                };
            }
            getTileBoundsBuffers(e) {
                return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {
                    tileBoundsBuffer: e._tileBoundsBuffer,
                    tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,
                    tileBoundsSegments: e._tileBoundsSegments
                } : this.getMercatorTileBoundsBuffers();
            }
            clearStencil() {
                const t33 = this.context, i38 = t33.gl;
                this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {
                }, this.useProgram("clippingMask").draw(t33, i38.TRIANGLES, e1.DepthMode.disabled, this.stencilClearMode, e1.ColorMode.disabled, e1.CullFaceMode.disabled, Ci(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
                this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {
                });
            }
            _renderTileClippingMasks(t, i, o) {
                if (!i || this.currentStencilSource === i.id || !t.isTileClipped() || !o || 0 === o.length) return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                    let e29 = !1;
                    for (const t33 of o)if ((void 0) === this._tileClippingMaskIDs[t33.key]) {
                        e29 = !0;
                        break;
                    }
                    if (!e29) return;
                }
                this.currentStencilSource = i.id;
                const r14 = this.context, n9 = r14.gl;
                this.nextStencilID + o.length > 256 && this.clearStencil(), r14.setColorMode(e1.ColorMode.disabled), r14.setDepthMode(e1.DepthMode.disabled);
                const s18 = this.useProgram("clippingMask");
                this._tileClippingMaskIDs = {
                };
                for (const t33 of o){
                    const o32 = i.getTile(t33), a18 = this._tileClippingMaskIDs[t33.key] = this.nextStencilID++, { tileBoundsBuffer: l21 , tileBoundsIndexBuffer: c15 , tileBoundsSegments: h14  } = this.getTileBoundsBuffers(o32);
                    s18.draw(r14, n9.TRIANGLES, e1.DepthMode.disabled, new e1.StencilMode({
                        func: n9.ALWAYS,
                        mask: 0
                    }, a18, 255, n9.KEEP, n9.KEEP, n9.REPLACE), e1.ColorMode.disabled, e1.CullFaceMode.disabled, Ci(t33.projMatrix), "$clipping", l21, c15, h14);
                }
            }
            stencilModeFor3D() {
                this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                const t33 = this.nextStencilID++, i38 = this.context.gl;
                return new e1.StencilMode({
                    func: i38.NOTEQUAL,
                    mask: 255
                }, t33, 255, i38.KEEP, i38.KEEP, i38.REPLACE);
            }
            stencilModeForClipping(t) {
                if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);
                const i38 = this.context.gl;
                return new e1.StencilMode({
                    func: i38.EQUAL,
                    mask: 255
                }, this._tileClippingMaskIDs[t.key], 0, i38.KEEP, i38.KEEP, i38.REPLACE);
            }
            stencilConfigForOverlap(t) {
                const i38 = this.context.gl, o32 = t.sort((e29, t33)=>t33.overscaledZ - e29.overscaledZ
                ), r14 = o32[o32.length - 1].overscaledZ, n9 = o32[0].overscaledZ - r14 + 1;
                if (n9 > 1) {
                    this.currentStencilSource = void 0, this.nextStencilID + n9 > 256 && this.clearStencil();
                    const t33 = {
                    };
                    for(let o33 = 0; o33 < n9; o33++)t33[o33 + r14] = new e1.StencilMode({
                        func: i38.GEQUAL,
                        mask: 255
                    }, o33 + this.nextStencilID, 255, i38.KEEP, i38.KEEP, i38.REPLACE);
                    return this.nextStencilID += n9, [
                        t33,
                        o32
                    ];
                }
                return [
                    {
                        [r14]: e1.StencilMode.disabled
                    },
                    o32
                ];
            }
            colorModeForRenderPass() {
                const t33 = this.context.gl;
                if (this._showOverdrawInspector) {
                    const i38 = 1 / 8;
                    return new e1.ColorMode([
                        t33.CONSTANT_COLOR,
                        t33.ONE
                    ], new e1.Color(i38, i38, i38, 0), [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                }
                return "opaque" === this.renderPass ? e1.ColorMode.unblended : e1.ColorMode.alphaBlended;
            }
            depthModeForSublayer(t, i, o) {
                if (!this.opaquePassEnabledForLayer()) return e1.DepthMode.disabled;
                const r14 = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
                return new e1.DepthMode(o || this.context.gl.LEQUAL, i, [
                    r14,
                    r14
                ]);
            }
            opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
            }
            render(t, i) {
                this.style = t, this.options = i, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(e1.exported.now()), this.imageManager.beginFrame();
                const o32 = this.style.order, r14 = this.style._sourceCaches;
                for(const e29 in r14){
                    const t33 = r14[e29];
                    t33.used && t33.prepare(this.context);
                }
                const n9 = {
                }, s18 = {
                }, a18 = {
                };
                for(const e30 in r14){
                    const t33 = r14[e30];
                    n9[e30] = t33.getVisibleCoordinates(), s18[e30] = n9[e30].slice().reverse(), a18[e30] = t33.getVisibleCoordinates(!0).reverse();
                }
                this.opaquePassCutoff = 1 / 0;
                for(let e31 = 0; e31 < o32.length; e31++)if (this.style._layers[o32[e31]].is3D()) {
                    this.opaquePassCutoff = e31;
                    break;
                }
                if (this.terrain && (this.terrain.updateTileBinding(a18), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e1.GlobeSharedBuffers(this.context)), e1.isMapAuthenticated(this.context.gl)) {
                    this.renderPass = "offscreen";
                    for (const e32 of o32){
                        const i38 = this.style._layers[e32], o33 = t._getLayerSourceCache(i38);
                        if (!i38.hasOffscreenPass() || i38.isHidden(this.transform.zoom)) continue;
                        const r15 = o33 ? s18[o33.id] : void 0;
                        ("custom" === i38.type || i38.isSky() || r15 && r15.length) && this.renderLayer(this, o33, i38, r15);
                    }
                    if (this.depthRangeFor3D = [
                        0,
                        1 - (t.order.length + 2) * this.numSublayers * this.depthEpsilon
                    ], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([
                        0,
                        0,
                        this.width,
                        this.height
                    ]), this.context.clear({
                        color: i.showOverdrawInspector ? e1.Color.black : e1.Color.transparent,
                        depth: 1
                    }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = "opaque", !this.terrain) for(this.currentLayer = o32.length - 1; this.currentLayer >= 0; this.currentLayer--){
                        const e33 = this.style._layers[o32[this.currentLayer]], i38 = t._getLayerSourceCache(e33);
                        if (e33.isSky()) continue;
                        const r15 = i38 ? s18[i38.id] : void 0;
                        this._renderTileClippingMasks(e33, i38, r15), this.renderLayer(this, i38, e33, r15);
                    }
                    if (this.style.fog && this.transform.projection.supportsFog && (function(t33, i38) {
                        const o33 = t33.context, r15 = o33.gl, n10 = t33.transform, s19 = new e1.DepthMode(r15.LEQUAL, e1.DepthMode.ReadOnly, [
                            0,
                            1
                        ]), a19 = t33.useProgram("globeAtmosphere", null, "globe" === n10.projection.name ? [
                            "PROJECTION_GLOBE_VIEW",
                            "FOG"
                        ] : [
                            "FOG"
                        ]), l21 = e1.globeToMercatorTransition(n10.zoom), c15 = i38.properties.get("color").toArray01(), h14 = i38.properties.get("high-color").toArray01(), u17 = i38.properties.get("space-color").toArray01PremultipliedAlpha(), _3 = e1.identity$1([]);
                        e1.rotateY$1(_3, _3, -e1.degToRad(n10._center.lng)), e1.rotateX$1(_3, _3, e1.degToRad(n10._center.lat)), e1.rotateZ$1(_3, _3, n10.angle), e1.rotateX$1(_3, _3, -n10._pitch);
                        const d9 = e1.fromQuat(new Float32Array(16), _3), p12 = e1.mapValue(i38.properties.get("star-intensity"), 0, 1, 0, 0.25), m8 = 0.0005, f9 = e1.mapValue(i38.properties.get("horizon-blend"), 0, 1, m8, 0.25), g6 = e1.globeUseCustomAntiAliasing(t33, o33, n10) && f9 === m8 ? n10.worldSize / (2 * Math.PI * 1.025) - 1 : n10.globeRadius, v4 = t33.frameCounter / 1000 % 1, x4 = e1.length(n10.globeCenterInViewSpace), y5 = Math.sqrt(Math.pow(x4, 2) - Math.pow(g6, 2)), b3 = Math.acos(y5 / x4), w4 = ((t34, i39, o34, r16, n11, s20, a20, l22, c16, h15, u18, _4, d10, p13)=>({
                                u_frustum_tl: t34,
                                u_frustum_tr: i39,
                                u_frustum_br: o34,
                                u_frustum_bl: r16,
                                u_horizon: n11,
                                u_transition: s20,
                                u_fadeout_range: a20,
                                u_color: l22,
                                u_high_color: c16,
                                u_space_color: h15,
                                u_star_intensity: u18,
                                u_star_size: 5 * e1.exported.devicePixelRatio,
                                u_star_density: 0,
                                u_temporal_offset: _4,
                                u_horizon_angle: d10,
                                u_rotation_matrix: p13
                            })
                        )(n10.frustumCorners.TL, n10.frustumCorners.TR, n10.frustumCorners.BR, n10.frustumCorners.BL, n10.frustumCorners.horizon, l21, f9, c15, h14, u17, p12, v4, b3, d9);
                        t33.prepareDrawProgram(o33, a19);
                        const T1 = t33.atmosphereBuffer;
                        T1 && a19.draw(o33, r15.TRIANGLES, s19, e1.StencilMode.disabled, e1.ColorMode.alphaBlended, e1.CullFaceMode.backCW, w4, "skybox", T1.vertexBuffer, T1.indexBuffer, T1.segments);
                    })(this, this.style.fog), this.renderPass = "sky", (e1.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for(this.currentLayer = 0; this.currentLayer < o32.length; this.currentLayer++){
                        const e33 = this.style._layers[o32[this.currentLayer]], i38 = t._getLayerSourceCache(e33);
                        e33.isSky() && this.renderLayer(this, i38, e33, i38 ? s18[i38.id] : void 0);
                    }
                    for(this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o32.length;){
                        const e33 = this.style._layers[o32[this.currentLayer]], i38 = t._getLayerSourceCache(e33);
                        if (e33.isSky()) {
                            ++this.currentLayer;
                            continue;
                        }
                        if (this.terrain && this.style.isLayerDraped(e33)) {
                            if (e33.isHidden(this.transform.zoom)) {
                                ++this.currentLayer;
                                continue;
                            }
                            this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                            continue;
                        }
                        const r15 = i38 ? ("symbol" === e33.type ? a18 : s18)[i38.id] : void 0;
                        this._renderTileClippingMasks(e33, i38, i38 ? n9[i38.id] : void 0), this.renderLayer(this, i38, e33, r15), ++this.currentLayer;
                    }
                    if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                        let i38 = null;
                        e1.values(this.style._layers).forEach((e33)=>{
                            const o33 = t._getLayerSourceCache(e33);
                            o33 && !e33.isHidden(this.transform.zoom) && (!i38 || i38.getSource().maxzoom < o33.getSource().maxzoom) && (i38 = o33);
                        }), i38 && this.options.showTileBoundaries && Oo.debug(this, i38, i38.getVisibleCoordinates());
                    }
                    this.options.showPadding && (function(e33) {
                        const t33 = e33.transform.padding;
                        Co(e33, e33.transform.height - (t33.top || 0), 3, xo), Co(e33, t33.bottom || 0, 3, yo), Io(e33, t33.left || 0, 3, bo), Io(e33, e33.transform.width - (t33.right || 0), 3, wo);
                        const i38 = e33.transform.centerPoint;
                        !function(e34, t34, i39, o33) {
                            Mo(e34, t34 - 1, i39 - 10, 2, 20, o33), Mo(e34, t34 - 10, i39 - 1, 20, 2, o33);
                        }(e33, i38.x, e33.transform.height - i38.y, To);
                    })(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e1.window.performance.now()), this.saveCanvasCopy());
                }
            }
            renderLayer(e, t, i, o) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes(i.type) || Oo[i.type](e, t, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(e) {
                if (!this.options.gpuTiming) return;
                const t33 = this.context.extTimerQuery;
                let i38 = this.gpuTimers[e.id];
                i38 || (i38 = this.gpuTimers[e.id] = {
                    calls: 0,
                    cpuTime: 0,
                    query: t33.createQueryEXT()
                }), i38.calls++, t33.beginQueryEXT(t33.TIME_ELAPSED_EXT, i38.query);
            }
            gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                    const e29 = this.context.extTimerQuery, t33 = e29.createQueryEXT();
                    this.deferredRenderGpuTimeQueries.push(t33), e29.beginQueryEXT(e29.TIME_ELAPSED_EXT, t33);
                }
            }
            gpuTimingDeferredRenderEnd() {
                if (!this.options.gpuTimingDeferredRender) return;
                const e29 = this.context.extTimerQuery;
                e29.endQueryEXT(e29.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
                if (!this.options.gpuTiming) return;
                const e29 = this.context.extTimerQuery;
                e29.endQueryEXT(e29.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
                const e29 = this.gpuTimers;
                return this.gpuTimers = {
                }, e29;
            }
            collectDeferredRenderGpuQueries() {
                const e29 = this.deferredRenderGpuTimeQueries;
                return this.deferredRenderGpuTimeQueries = [], e29;
            }
            queryGpuTimers(e) {
                const t33 = {
                };
                for(const i38 in e){
                    const o32 = e[i38], r14 = this.context.extTimerQuery, n9 = r14.getQueryObjectEXT(o32.query, r14.QUERY_RESULT_EXT) / 1000000;
                    r14.deleteQueryEXT(o32.query), t33[i38] = n9;
                }
                return t33;
            }
            queryGpuTimeDeferredRender(e) {
                if (!this.options.gpuTimingDeferredRender) return 0;
                const t33 = this.context.extTimerQuery;
                let i38 = 0;
                for (const o32 of e)i38 += t33.getQueryObjectEXT(o32, t33.QUERY_RESULT_EXT) / 1000000, t33.deleteQueryEXT(o32);
                return i38;
            }
            translatePosMatrix(t, i, o, r, n) {
                if (!o[0] && !o[1]) return t;
                const s18 = n ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;
                if (s18) {
                    const e29 = Math.sin(s18), t33 = Math.cos(s18);
                    o = [
                        o[0] * t33 - o[1] * e29,
                        o[0] * e29 + o[1] * t33
                    ];
                }
                const a18 = [
                    n ? o[0] : P2(i, o[0], this.transform.zoom),
                    n ? o[1] : P2(i, o[1], this.transform.zoom),
                    0
                ], l21 = new Float32Array(16);
                return e1.translate(l21, t, a18), l21;
            }
            saveTileTexture(e) {
                const t33 = this._tileTextures[e.size[0]];
                t33 ? t33.push(e) : this._tileTextures[e.size[0]] = [
                    e
                ];
            }
            getTileTexture(e) {
                const t33 = this._tileTextures[e];
                return t33 && t33.length > 0 ? t33.pop() : null;
            }
            isPatternMissing(e) {
                return null === e || (void 0) !== e && !this.imageManager.getPattern(e.toString());
            }
            terrainRenderModeElevated() {
                return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
            }
            currentGlobalDefines() {
                const e29 = this.terrain && this.terrain.renderingToTexture, t33 = this.terrain && 0 === this.terrain.exaggeration(), i38 = this.style && this.style.fog, o32 = [];
                return this.terrainRenderModeElevated() && o32.push("TERRAIN"), "globe" === this.transform.projection.name && o32.push("GLOBE"), t33 && o32.push("ZERO_EXAGGERATION"), i38 && !e29 && 0 !== i38.getOpacity(this.transform.pitch) && o32.push("FOG"), e29 && o32.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o32.push("OVERDRAW_INSPECTOR"), o32;
            }
            useProgram(e, t, i) {
                this.cache = this.cache || {
                };
                const o32 = i || [], r14 = this.currentGlobalDefines().concat(o32), n9 = Li.cacheKey(hi[e], e, r14, t);
                return this.cache[n9] || (this.cache[n9] = new Li(this.context, e, hi[e], t, so[e], r14)), this.cache[n9];
            }
            setCustomLayerDefaults() {
                this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
                const e29 = this.context.gl;
                this.context.cullFace.set(!1), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.context.blendEquation.set(e29.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e1.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e1.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
                this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
            }
            prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
            }
            prepareDrawProgram(t, i, o) {
                if (this.terrain && this.terrain.renderingToTexture) return;
                const r14 = this.style.fog;
                if (r14) {
                    const n9 = r14.getOpacity(this.transform.pitch), s18 = ((t33, i38, o32, r15, n10, s19, a18, l21, c15, h14, u17)=>{
                        const _3 = t33.transform, d9 = i38.properties.get("color").toArray01();
                        d9[3] = r15;
                        const p12 = t33.frameCounter / 1000 % 1;
                        return {
                            u_fog_matrix: o32 ? _3.calculateFogTileMatrix(o32) : t33.identityMat,
                            u_fog_range: i38.getFovAdjustedRange(_3._fov),
                            u_fog_color: d9,
                            u_fog_horizon_blend: i38.properties.get("horizon-blend"),
                            u_fog_temporal_offset: p12,
                            u_frustum_tl: n10,
                            u_frustum_tr: s19,
                            u_frustum_br: a18,
                            u_frustum_bl: l21,
                            u_globe_pos: c15,
                            u_globe_radius: h14,
                            u_viewport: u17,
                            u_globe_transition: e1.globeToMercatorTransition(_3.zoom),
                            u_is_globe: +("globe" === _3.projection.name)
                        };
                    })(this, r14, o, n9, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [
                        this.transform.width * e1.exported.devicePixelRatio,
                        this.transform.height * e1.exported.devicePixelRatio
                    ]);
                    i.setFogUniformValues(t, s18);
                }
            }
            setTileLoadedFlag(e) {
                this.tileLoaded = e;
            }
            saveCanvasCopy() {
                this.frameCopies.push(this.canvasCopy()), this.tileLoaded = !1;
            }
            canvasCopy() {
                const e29 = this.context.gl, t33 = e29.createTexture();
                return e29.bindTexture(e29.TEXTURE_2D, t33), e29.copyTexImage2D(e29.TEXTURE_2D, 0, e29.RGBA, 0, 0, e29.drawingBufferWidth, e29.drawingBufferHeight, 0), t33;
            }
            getCanvasCopiesAndTimestamps() {
                return {
                    canvasCopies: this.frameCopies,
                    timeStamps: this.loadTimeStamps
                };
            }
            averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const e29 = this.style && this.style.fog;
                return !!e29 && 0 !== e29.getOpacity(this.transform.pitch);
            }
            getBackgroundTiles() {
                const t33 = this._backgroundTiles, i38 = this._backgroundTiles = {
                }, o32 = this.transform.coveringTiles({
                    tileSize: 512
                });
                for (const r14 of o32)i38[r14.key] = t33[r14.key] || new e1.Tile(r14, 512, this.transform.tileZoom, this);
                return i38;
            }
            clearBackgroundTiles() {
                this._backgroundTiles = {
                };
            }
        }
        class ko {
            constructor(e29 = 0, t33 = 0, i38 = 0, o32 = 0){
                if (isNaN(e29) || e29 < 0 || isNaN(t33) || t33 < 0 || isNaN(i38) || i38 < 0 || isNaN(o32) || o32 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                this.top = e29, this.bottom = t33, this.left = i38, this.right = o32;
            }
            interpolate(t, i, o) {
                return null != i.top && null != t.top && (this.top = e1.number(t.top, i.top, o)), null != i.bottom && null != t.bottom && (this.bottom = e1.number(t.bottom, i.bottom, o)), null != i.left && null != t.left && (this.left = e1.number(t.left, i.left, o)), null != i.right && null != t.right && (this.right = e1.number(t.right, i.right, o)), this;
            }
            getCenter(t, i) {
                const o33 = e1.clamp((this.left + t - this.right) / 2, 0, t), r14 = e1.clamp((this.top + i - this.bottom) / 2, 0, i);
                return new e1.pointGeometry(o33, r14);
            }
            equals(e) {
                return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
            }
            clone() {
                return new ko(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
                return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right
                };
            }
        }
        function Fo(t34, i39) {
            const o33 = e1.getColumn(t34, 3);
            e1.fromQuat(t34, i39), e1.setColumn(t34, 3, o33);
        }
        function Uo(t34, i39) {
            const o33 = e1.identity$1([]);
            return e1.rotateZ$1(o33, o33, -i39), e1.rotateX$1(o33, o33, -t34), o33;
        }
        function No(t34, i39) {
            const o33 = [
                t34[0],
                t34[1],
                0
            ], r14 = [
                i39[0],
                i39[1],
                0
            ];
            if (e1.length(o33) >= 0.000000000000001) {
                const t35 = e1.normalize([], o33);
                e1.scale$2(r14, t35, e1.dot(r14, t35)), i39[0] = r14[0], i39[1] = r14[1];
            }
            const n9 = e1.cross([], i39, t34);
            if (e1.len(n9) < 0.000000000000001) return null;
            const s18 = Math.atan2(-n9[1], n9[0]);
            return Uo(Math.atan2(Math.sqrt(t34[0] * t34[0] + t34[1] * t34[1]), -t34[2]), s18);
        }
        class Go {
            constructor(e30, t34){
                this.position = e30, this.orientation = t34;
            }
            get position() {
                return this._position;
            }
            set position(t) {
                if (t) {
                    const i39 = t instanceof e1.MercatorCoordinate ? t : new e1.MercatorCoordinate(t[0], t[1], t[2]);
                    this._renderWorldCopies && (i39.x = e1.wrap(i39.x, 0, 1)), this._position = i39;
                } else this._position = null;
            }
            lookAtPoint(t, i) {
                if (this.orientation = null, !this.position) return;
                const o33 = this._elevation ? this._elevation.getAtPointOrZero(e1.MercatorCoordinate.fromLngLat(t)) : 0, r14 = this.position, n9 = e1.MercatorCoordinate.fromLngLat(t, o33), s18 = [
                    n9.x - r14.x,
                    n9.y - r14.y,
                    n9.z - r14.z
                ];
                i || (i = [
                    0,
                    0,
                    1
                ]), i[2] = Math.abs(i[2]), this.orientation = No(s18, i);
            }
            setPitchBearing(t, i) {
                this.orientation = Uo(e1.degToRad(t), e1.degToRad(-i));
            }
        }
        class jo {
            constructor(t35, i39){
                this._transform = e1.identity([]), this.orientation = i39, this.position = t35;
            }
            get mercatorPosition() {
                const t36 = this.position;
                return new e1.MercatorCoordinate(t36[0], t36[1], t36[2]);
            }
            get position() {
                const t36 = e1.getColumn(this._transform, 3);
                return [
                    t36[0],
                    t36[1],
                    t36[2]
                ];
            }
            set position(t) {
                var i40;
                t && e1.setColumn(this._transform, 3, [
                    (i40 = t)[0],
                    i40[1],
                    i40[2],
                    1
                ]);
            }
            get orientation() {
                return this._orientation;
            }
            set orientation(t) {
                this._orientation = t || e1.identity$1([]), t && Fo(this._transform, this._orientation);
            }
            getPitchBearing() {
                const e31 = this.forward(), t36 = this.right();
                return {
                    bearing: Math.atan2(-t36[1], t36[0]),
                    pitch: Math.atan2(Math.sqrt(e31[0] * e31[0] + e31[1] * e31[1]), -e31[2])
                };
            }
            setPitchBearing(e, t) {
                this._orientation = Uo(e, t), Fo(this._transform, this._orientation);
            }
            forward() {
                const t36 = e1.getColumn(this._transform, 2);
                return [
                    -t36[0],
                    -t36[1],
                    -t36[2]
                ];
            }
            up() {
                const t36 = e1.getColumn(this._transform, 1);
                return [
                    -t36[0],
                    -t36[1],
                    -t36[2]
                ];
            }
            right() {
                const t36 = e1.getColumn(this._transform, 0);
                return [
                    t36[0],
                    t36[1],
                    t36[2]
                ];
            }
            getCameraToWorld(t, i) {
                const o33 = new Float64Array(16);
                return e1.invert(o33, this.getWorldToCamera(t, i)), o33;
            }
            getWorldToCameraPosition(t, i, o) {
                const r14 = this.position;
                e1.scale$2(r14, r14, -t);
                const n9 = new Float64Array(16);
                return e1.fromScaling(n9, [
                    o,
                    o,
                    o
                ]), e1.translate(n9, n9, r14), n9[10] *= i, n9;
            }
            getWorldToCamera(t, i) {
                const o33 = new Float64Array(16), r14 = new Float64Array(4), n9 = this.position;
                return e1.conjugate(r14, this._orientation), e1.scale$2(n9, n9, -t), e1.fromQuat(o33, r14), e1.translate(o33, o33, n9), o33[1] *= -1, o33[5] *= -1, o33[9] *= -1, o33[13] *= -1, o33[8] *= i, o33[9] *= i, o33[10] *= i, o33[11] *= i, o33;
            }
            getCameraToClipPerspective(t, i, o, r) {
                const n9 = new Float64Array(16);
                return e1.perspective(n9, t, i, o, r), n9;
            }
            getDistanceToElevation(t, i = !1) {
                const o33 = 0 === t ? 0 : e1.mercatorZfromAltitude(t, i ? e1.latFromMercatorY(this.position[1]) : this.position[1]), r14 = this.forward();
                return (o33 - this.position[2]) / r14[2];
            }
            clone() {
                return new jo([
                    ...this.position
                ], [
                    ...this.orientation
                ]);
            }
        }
        function Zo(t36, i41) {
            const o33 = Wo(t36.projection, t36.zoom, t36.width, t36.height), r14 = function(t37, i42, o34, r15, n9) {
                const s18 = new e1.LngLat(o34.lng - 180 * Xo, o34.lat), a18 = new e1.LngLat(o34.lng + 180 * Xo, o34.lat), l21 = t37.project(s18.lng, s18.lat), c15 = t37.project(a18.lng, a18.lat), h14 = -Math.atan2(c15.y - l21.y, c15.x - l21.x), u17 = e1.MercatorCoordinate.fromLngLat(o34);
                u17.y = e1.clamp(u17.y, -0.999975, 0.999975);
                const _3 = u17.toLngLat(), d9 = t37.project(_3.lng, _3.lat), p12 = e1.MercatorCoordinate.fromLngLat(_3);
                p12.x += Xo;
                const m8 = p12.toLngLat(), f9 = t37.project(m8.lng, m8.lat), g6 = $o(f9.x - d9.x, f9.y - d9.y, h14), v4 = e1.MercatorCoordinate.fromLngLat(_3);
                v4.y += Xo;
                const x4 = v4.toLngLat(), y5 = t37.project(x4.lng, x4.lat), b3 = $o(y5.x - d9.x, y5.y - d9.y, h14), w4 = Math.abs(g6.x) / Math.abs(b3.y), T1 = e1.identity([]);
                e1.rotateZ(T1, T1, -h14 * (1 - (n9 ? 0 : r15)));
                const E1 = e1.identity([]);
                return e1.scale(E1, E1, [
                    1,
                    1 - (1 - w4) * r15,
                    1
                ]), E1[4] = -b3.x / b3.y * r15, e1.rotateZ(E1, E1, h14), e1.multiply(E1, T1, E1), E1;
            }(t36.projection, 0, t36.center, o33, i41), n9 = Vo(t36);
            return e1.scale(r14, r14, [
                n9,
                n9,
                1
            ]), r14;
        }
        function Vo(t36) {
            const i41 = t36.projection, o33 = Wo(t36.projection, t36.zoom, t36.width, t36.height), r14 = qo(i41, t36.center), n9 = qo(i41, e1.LngLat.convert(i41.center));
            return Math.pow(2, r14 * o33 + (1 - o33) * n9);
        }
        function Wo(t36, i41, o33, r14, n9 = 1 / 0) {
            const s18 = t36.range;
            if (!s18) return 0;
            const a18 = Math.min(n9, Math.max(o33, r14)), l21 = Math.log(a18 / 1024) / Math.LN2;
            return e1.smoothstep(s18[0] + l21, s18[1] + l21, i41);
        }
        const Xo = 1 / 40000;
        function qo(t36, i41) {
            const o33 = e1.clamp(i41.lat, -e1.MAX_MERCATOR_LATITUDE, e1.MAX_MERCATOR_LATITUDE), r14 = new e1.LngLat(i41.lng - 180 * Xo, o33), n9 = new e1.LngLat(i41.lng + 180 * Xo, o33), s18 = t36.project(r14.lng, o33), a18 = t36.project(n9.lng, o33), l21 = e1.MercatorCoordinate.fromLngLat(r14), c15 = e1.MercatorCoordinate.fromLngLat(n9), h14 = a18.x - s18.x, u17 = a18.y - s18.y, _3 = c15.x - l21.x, d9 = c15.y - l21.y, p12 = Math.sqrt((_3 * _3 + d9 * d9) / (h14 * h14 + u17 * u17));
            return Math.log(p12) / Math.LN2;
        }
        function $o(e31, t36, i41) {
            const o33 = Math.cos(i41), r14 = Math.sin(i41);
            return {
                x: e31 * o33 - t36 * r14,
                y: e31 * r14 + t36 * o33
            };
        }
        class Ho {
            constructor(t36, i41, o33, r14, n9, s18, a18){
                this.tileSize = 512, this._renderWorldCopies = (void 0) === n9 || n9, this._minZoom = t36 || 0, this._maxZoom = i41 || 22, this._minPitch = null == o33 ? 0 : o33, this._maxPitch = null == r14 ? 60 : r14, this.setProjection(s18), this.setMaxBounds(a18), this.width = 0, this.height = 0, this._center = new e1.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new ko, this._projMatrixCache = {
                }, this._alignedProjMatrixCache = {
                }, this._fogTileMatrixCache = {
                }, this._distanceTileDataCache = {
                }, this._camera = new jo, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [
                    0,
                    0,
                    0
                ], this._horizonShift = 0.1;
            }
            clone() {
                const e31 = new Ho(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
                return e31._elevation = this._elevation, e31._centerAltitude = this._centerAltitude, e31._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e31.tileSize = this.tileSize, e31.mercatorFromTransition = this.mercatorFromTransition, e31.width = this.width, e31.height = this.height, e31.cameraElevationReference = this.cameraElevationReference, e31._center = this._center, e31._setZoom(this.zoom), e31._seaLevelZoom = this._seaLevelZoom, e31.angle = this.angle, e31._fov = this._fov, e31._pitch = this._pitch, e31._nearZ = this._nearZ, e31._farZ = this._farZ, e31._averageElevation = this._averageElevation, e31._unmodified = this._unmodified, e31._edgeInsets = this._edgeInsets.clone(), e31._camera = this._camera.clone(), e31._calcMatrices(), e31.freezeTileCoverage = this.freezeTileCoverage, e31.frustumCorners = this.frustumCorners, e31;
            }
            get elevation() {
                return this._elevation;
            }
            set elevation(e) {
                this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());
            }
            updateElevation(e, t = !1) {
                const i42 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || i42) && this._updateCameraOnTerrain(), (e || i42) && this._constrainCamera(t), this._calcMatrices();
            }
            getProjection() {
                return e1.pick(this.projection, [
                    "name",
                    "center",
                    "parallels"
                ]);
            }
            setProjection(i) {
                this.projectionOptions = i || {
                    name: "mercator"
                };
                const o34 = this.projection ? this.getProjection() : void 0;
                this.projection = e1.getProjection(this.projectionOptions);
                const r15 = !t1(o34, this.getProjection());
                return r15 && this._calcMatrices(), this.mercatorFromTransition = !1, r15;
            }
            setMercatorFromTransition() {
                const t37 = this.projection.name;
                this.mercatorFromTransition = !0, this.projectionOptions = {
                    name: "mercator"
                }, this.projection = e1.getProjection({
                    name: "mercator"
                });
                const i42 = t37 !== this.projection.name;
                return i42 && this._calcMatrices(), i42;
            }
            get minZoom() {
                return this._minZoom;
            }
            set minZoom(e) {
                this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
            }
            get maxZoom() {
                return this._maxZoom;
            }
            set maxZoom(e) {
                this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
            }
            get minPitch() {
                return this._minPitch;
            }
            set minPitch(e) {
                this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
            }
            get maxPitch() {
                return this._maxPitch;
            }
            set maxPitch(e) {
                this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
            }
            get renderWorldCopies() {
                return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
            }
            set renderWorldCopies(e) {
                (void 0) === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;
            }
            get worldSize() {
                return this.tileSize * this.scale;
            }
            get cameraWorldSizeForFog() {
                const e31 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e31));
            }
            get cameraWorldSize() {
                const e31 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e31));
            }
            get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }
            get cameraPixelsPerMeter() {
                return e1.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
            }
            get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
                return new e1.pointGeometry(this.width, this.height);
            }
            get bearing() {
                return e1.wrap(this.rotation, -180, 180);
            }
            set bearing(e) {
                this.rotation = e;
            }
            get rotation() {
                return -this.angle / Math.PI * 180;
            }
            set rotation(t) {
                const i42 = -t * Math.PI / 180;
                var o34;
                this.angle !== i42 && (this._unmodified = !1, this.angle = i42, this._calcMatrices(), this.rotationMatrix = (o34 = new e1.ARRAY_TYPE(4), e1.ARRAY_TYPE != Float32Array && (o34[1] = 0, o34[2] = 0), o34[0] = 1, o34[3] = 1, o34), (function(e31, t37, i43) {
                    var o35 = t37[0], r15 = t37[1], n10 = t37[2], s19 = t37[3], a19 = Math.sin(i43), l21 = Math.cos(i43);
                    e31[0] = o35 * l21 + n10 * a19, e31[1] = r15 * l21 + s19 * a19, e31[2] = o35 * -a19 + n10 * l21, e31[3] = r15 * -a19 + s19 * l21;
                })(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
                return this._pitch / Math.PI * 180;
            }
            set pitch(t) {
                const i42 = e1.clamp(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
                this._pitch !== i42 && (this._unmodified = !1, this._pitch = i42, this._calcMatrices());
            }
            get aspect() {
                return this.width / this.height;
            }
            get fovX() {
                return this._fov;
            }
            get fovY() {
                const e31 = 1 / Math.tan(0.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / e31);
            }
            set fov(t) {
                t = Math.max(0.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = e1.degToRad(t), this._calcMatrices());
            }
            get averageElevation() {
                return this._averageElevation;
            }
            set averageElevation(e) {
                this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {
                };
            }
            get zoom() {
                return this._zoom;
            }
            set zoom(e) {
                const t37 = Math.min(Math.max(e, this.minZoom), this.maxZoom);
                this._zoom !== t37 && (this._unmodified = !1, this._setZoom(t37), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }
            _setZoom(e) {
                this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;
            }
            _updateCameraOnTerrain() {
                if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
                const e31 = this._elevation;
                this._centerAltitude = e31.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e31.exaggeration(), this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
                (void 0) !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
            }
            sampleAverageElevation() {
                if (!this._elevation) return 0;
                const t37 = this._elevation, i42 = [
                    [
                        0.5,
                        0.2
                    ],
                    [
                        0.3,
                        0.5
                    ],
                    [
                        0.5,
                        0.5
                    ],
                    [
                        0.7,
                        0.5
                    ],
                    [
                        0.5,
                        0.8
                    ]
                ], o35 = this.horizonLineFromTop();
                let r15 = 0, n10 = 0;
                for(let s19 = 0; s19 < i42.length; s19++){
                    const a19 = new e1.pointGeometry(i42[s19][0] * this.width, o35 + i42[s19][1] * (this.height - o35)), l21 = t37.pointCoordinate(a19);
                    if (!l21) continue;
                    const c15 = 1 / Math.hypot(l21[0] - this._camera.position[0], l21[1] - this._camera.position[1]);
                    r15 += l21[3] * c15, n10 += c15;
                }
                return 0 === n10 ? NaN : r15 / n10;
            }
            get center() {
                return this._center;
            }
            set center(e) {
                e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;
                const e31 = this._seaLevelZoom, t37 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i42 = this.pixelsPerMeter / this.worldSize * t37, o35 = this._mercatorZfromZoom(e31), r15 = this._mercatorZfromZoom(this._maxZoom), n10 = Math.max(o35 - i42, r15);
                this._setZoom(this._zoomFromMercatorZ(n10));
            }
            get padding() {
                return this._edgeInsets.toJSON();
            }
            set padding(e) {
                this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
            }
            computeZoomRelativeTo(t) {
                const i42 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
                let o35;
                o35 = t.z < this._camera.position[2] ? [
                    i42.x,
                    i42.y,
                    i42.z
                ] : [
                    t.x,
                    t.y,
                    t.z
                ];
                const r15 = e1.length(e1.sub([], this._camera.position, o35));
                return e1.clamp(this._zoomFromMercatorZ(r15), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(t) {
                if (!this.height) return;
                if (!t.position && !t.orientation) return;
                this._updateCameraState();
                let i42 = !1;
                if (t.orientation && !e1.exactEquals(t.orientation, this._camera.orientation) && (i42 = this._setCameraOrientation(t.orientation)), t.position) {
                    const o35 = [
                        t.position.x,
                        t.position.y,
                        t.position.z
                    ];
                    e1.exactEquals$1(o35, this._camera.position) || (this._setCameraPosition(o35), i42 = !0);
                }
                i42 && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
                this._updateCameraState();
                const t37 = this._camera.position, i42 = new Go;
                return i42.position = new e1.MercatorCoordinate(t37[0], t37[1], t37[2]), i42.orientation = this._camera.orientation, i42._elevation = this.elevation, i42._renderWorldCopies = this.renderWorldCopies, i42;
            }
            _setCameraOrientation(t) {
                if (!e1.length$1(t)) return !1;
                e1.normalize$1(t, t);
                const i42 = e1.transformQuat([], [
                    0,
                    0,
                    -1
                ], t), o35 = e1.transformQuat([], [
                    0,
                    -1,
                    0
                ], t);
                if (o35[2] < 0) return !1;
                const r15 = No(i42, o35);
                return !!r15 && (this._camera.orientation = r15, !0);
            }
            _setCameraPosition(t) {
                const i42 = this.zoomScale(this.minZoom) * this.tileSize, o35 = this.zoomScale(this.maxZoom) * this.tileSize, r15 = this.cameraToCenterDistance;
                t[2] = e1.clamp(t[2], r15 / o35, r15 / i42), this._camera.position = t;
            }
            get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
                return this._fov * (0.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(e) {
                return this._edgeInsets.equals(e);
            }
            interpolatePadding(e, t, i) {
                this._unmodified = !1, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(e) {
                const t37 = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
                return Math.max(0, t37);
            }
            getVisibleUnwrappedCoordinates(t) {
                const i42 = [
                    new e1.UnwrappedTileID(0, t)
                ];
                if (this.renderWorldCopies) {
                    const o35 = this.pointCoordinate(new e1.pointGeometry(0, 0)), r15 = this.pointCoordinate(new e1.pointGeometry(this.width, 0)), n10 = this.pointCoordinate(new e1.pointGeometry(this.width, this.height)), s19 = this.pointCoordinate(new e1.pointGeometry(0, this.height)), a19 = Math.floor(Math.min(o35.x, r15.x, n10.x, s19.x)), l21 = Math.floor(Math.max(o35.x, r15.x, n10.x, s19.x)), c15 = 1;
                    for(let o36 = a19 - c15; o36 <= l21 + c15; o36++)0 !== o36 && i42.push(new e1.UnwrappedTileID(o36, t));
                }
                return i42;
            }
            coveringTiles(t) {
                let i42 = this.coveringZoomLevel(t);
                const o35 = i42, r15 = this.elevation && !t.isTerrainDEM, n10 = "mercator" === this.projection.name;
                if ((void 0) !== t.minzoom && i42 < t.minzoom) return [];
                (void 0) !== t.maxzoom && i42 > t.maxzoom && (i42 = t.maxzoom);
                const s19 = this.locationCoordinate(this.center), a19 = this.center.lat, l21 = 1 << i42, c15 = [
                    l21 * s19.x,
                    l21 * s19.y,
                    0
                ], h14 = "globe" === this.projection.name, u17 = !h14, _3 = e1.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i42, u17), d9 = h14 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), p12 = l21 * e1.mercatorZfromAltitude(1, this.center.lat), m8 = this._camera.position[2] / e1.mercatorZfromAltitude(1, this.center.lat), f9 = [
                    l21 * d9.x,
                    l21 * d9.y,
                    m8 * (u17 ? 1 : p12)
                ], g6 = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : 0.502), v4 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i42 : 0, x4 = t.isTerrainDEM && this._elevation ? 10000 * this._elevation.exaggeration() : this._centerAltitude, y5 = t.isTerrainDEM ? -x4 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b3 = this.projection.isReprojectedInTileSpace ? Vo(this) : 1, w4 = (t37)=>{
                    const i43 = 1 / 40000, o36 = new e1.MercatorCoordinate(t37.x + i43, t37.y, t37.z), r16 = new e1.MercatorCoordinate(t37.x, t37.y + i43, t37.z), n11 = t37.toLngLat(), s20 = o36.toLngLat(), a20 = r16.toLngLat(), l22 = this.locationCoordinate(n11), c16 = this.locationCoordinate(s20), h15 = this.locationCoordinate(a20), u18 = Math.hypot(c16.x - l22.x, c16.y - l22.y), _4 = Math.hypot(h15.x - l22.x, h15.y - l22.y);
                    return Math.sqrt(u18 * _4) * b3 / i43;
                }, T1 = (t37)=>{
                    const i43 = x4, o36 = y5;
                    return {
                        aabb: e1.tileAABB(this, l21, 0, 0, 0, t37, o36, i43, this.projection),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        minZ: o36,
                        maxZ: i43,
                        wrap: t37,
                        fullyVisible: !1
                    };
                }, E1 = [];
                let C1 = [];
                const I1 = i42, M3 = t.reparseOverscaled ? o35 : i42, S3 = (e31)=>e31 * e31
                , D1 = S3((m8 - this._centerAltitude) * p12), A1 = (e31)=>{
                    if (!this._elevation || !e31.tileID || !n10) return;
                    const t37 = this._elevation.getMinMaxForTile(e31.tileID), i43 = e31.aabb;
                    t37 ? (i43.min[2] = t37.min, i43.max[2] = t37.max, i43.center[2] = (i43.min[2] + i43.max[2]) / 2) : (e31.shouldSplit = L2(e31), e31.shouldSplit || (i43.min[2] = i43.max[2] = i43.center[2] = this._centerAltitude));
                }, L2 = (t37)=>{
                    if (t37.zoom < v4) return !0;
                    if (t37.zoom === I1) return !1;
                    if (null != t37.shouldSplit) return t37.shouldSplit;
                    const i43 = t37.aabb.distanceX(f9), n11 = t37.aabb.distanceY(f9);
                    let s20 = D1, l22 = 1;
                    if (h14) {
                        s20 = S3(t37.aabb.distanceZ(f9));
                        const i44 = Math.pow(2, t37.zoom), o36 = e1.latFromMercatorY((t37.y + 1) / i44), r16 = e1.latFromMercatorY(t37.y / i44), n12 = Math.min(Math.max(a19, o36), r16), c16 = e1.circumferenceAtLatitude(n12) / e1.circumferenceAtLatitude(a19);
                        if (l22 = n12 === a19 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, c16 / this._mercatorScaleRatio), this.zoom <= e1.GLOBE_ZOOM_THRESHOLD_MIN && t37.zoom === I1 - 1 && c16 >= 0.9) return !0;
                    } else if (r15 && (s20 = S3(t37.aabb.distanceZ(f9) * p12)), this.projection.isReprojectedInTileSpace && o35 <= 5) {
                        const i44 = Math.pow(2, t37.zoom), o36 = w4(new e1.MercatorCoordinate((t37.x + 0.5) / i44, (t37.y + 0.5) / i44));
                        l22 = o36 > 0.85 ? 1 : o36;
                    }
                    const c16 = i43 * i43 + n11 * n11 + s20, u18 = S3((1 << I1 - t37.zoom) * g6 * l22 * ((e31, t38)=>{
                        if (t38 * S3(0.707) < e31) return 1;
                        const i44 = Math.sqrt(t38 / e31);
                        return i44 / (1.4144271570014144 + (Math.pow(1.1, i44 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                    })(Math.max(s20, D1), c16));
                    return c16 < u18;
                };
                if (this.renderWorldCopies) for(let e31 = 1; e31 <= 3; e31++)E1.push(T1(-e31)), E1.push(T1(e31));
                for(E1.push(T1(0)); E1.length > 0;){
                    const o36 = E1.pop(), s20 = o36.x, a20 = o36.y;
                    let u18 = o36.fullyVisible;
                    if (!u18) {
                        const e32 = o36.aabb.intersects(_3);
                        if (0 === e32) continue;
                        u18 = 2 === e32;
                    }
                    if (o36.zoom !== I1 && L2(o36)) for(let t37 = 0; t37 < 4; t37++){
                        const i43 = (s20 << 1) + t37 % 2, c16 = (a20 << 1) + (t37 >> 1), _4 = {
                            aabb: n10 ? o36.aabb.quadrant(t37) : e1.tileAABB(this, l21, o36.zoom + 1, i43, c16, o36.wrap, o36.minZ, o36.maxZ, this.projection),
                            zoom: o36.zoom + 1,
                            x: i43,
                            y: c16,
                            wrap: o36.wrap,
                            fullyVisible: u18,
                            tileID: void 0,
                            shouldSplit: void 0,
                            minZ: o36.minZ,
                            maxZ: o36.maxZ
                        };
                        r15 && !h14 && (_4.tileID = new e1.OverscaledTileID(o36.zoom + 1 === I1 ? M3 : o36.zoom + 1, o36.wrap, o36.zoom + 1, i43, c16), A1(_4)), E1.push(_4);
                    }
                    else {
                        const r16 = o36.zoom === I1 ? M3 : o36.zoom;
                        if (t.minzoom && t.minzoom > r16) continue;
                        const n11 = c15[0] - (0.5 + s20 + (o36.wrap << o36.zoom)) * (1 << i42 - o36.zoom), l22 = c15[1] - 0.5 - a20, h15 = o36.tileID ? o36.tileID : new e1.OverscaledTileID(r16, o36.wrap, o36.zoom, s20, a20);
                        C1.push({
                            tileID: h15,
                            distanceSq: n11 * n11 + l22 * l22
                        });
                    }
                }
                if (this.fogCullDistSq) {
                    const i43 = this.fogCullDistSq, o36 = this.horizonLineFromTop();
                    C1 = C1.filter((r16)=>{
                        const n11 = [
                            0,
                            0,
                            0,
                            1
                        ], s20 = [
                            e1.EXTENT,
                            e1.EXTENT,
                            0,
                            1
                        ], a20 = this.calculateFogTileMatrix(r16.tileID.toUnwrapped());
                        e1.transformMat4$1(n11, n11, a20), e1.transformMat4$1(s20, s20, a20);
                        const l22 = e1.getAABBPointSquareDist(n11, s20);
                        if (0 === l22) return !0;
                        let c16 = !1;
                        const h15 = this._elevation;
                        if (h15 && l22 > i43 && 0 !== o36) {
                            const i44 = this.calculateProjMatrix(r16.tileID.toUnwrapped());
                            let n12;
                            t.isTerrainDEM || (n12 = h15.getMinMaxForTile(r16.tileID)), n12 || (n12 = {
                                min: y5,
                                max: x4
                            });
                            const s21 = e1.furthestTileCorner(this.rotation), a21 = [
                                s21[0] * e1.EXTENT,
                                s21[1] * e1.EXTENT,
                                n12.max
                            ];
                            e1.transformMat4(a21, a21, i44), c16 = (1 - a21[1]) * this.height * 0.5 < o36;
                        }
                        return l22 < i43 || c16;
                    });
                }
                return C1.sort((e32, t37)=>e32.distanceSq - t37.distanceSq
                ).map((e32)=>e32.tileID
                );
            }
            resize(e, t) {
                this.width = e, this.height = t, this.pixelsToGLUnits = [
                    2 / e,
                    -2 / t
                ], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
                return this._unmodified;
            }
            zoomScale(e) {
                return Math.pow(2, e);
            }
            scaleZoom(e) {
                return Math.log(e) / Math.LN2;
            }
            project(t) {
                const i42 = e1.clamp(t.lat, -e1.MAX_MERCATOR_LATITUDE, e1.MAX_MERCATOR_LATITUDE), o35 = this.projection.project(t.lng, i42);
                return new e1.pointGeometry(o35.x * this.worldSize, o35.y * this.worldSize);
            }
            unproject(e) {
                return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);
            }
            get point() {
                return this.project(this.center);
            }
            setLocationAtPoint(t, i) {
                let o35, r15;
                const n10 = this.centerPoint;
                if ("globe" === this.projection.name) {
                    const e31 = this.worldSize;
                    o35 = (i.x - n10.x) / e31, r15 = (i.y - n10.y) / e31;
                } else {
                    const e31 = this.pointCoordinate(i), t37 = this.pointCoordinate(n10);
                    o35 = e31.x - t37.x, r15 = e31.y - t37.y;
                }
                const s19 = this.locationCoordinate(t);
                this.setLocation(new e1.MercatorCoordinate(s19.x - o35, s19.y - r15));
            }
            setLocation(e) {
                this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(e) {
                return this.projection.locationPoint(this, e);
            }
            locationPoint3D(e) {
                return this.projection.locationPoint(this, e, !0);
            }
            pointLocation(e) {
                return this.coordinateLocation(this.pointCoordinate(e));
            }
            pointLocation3D(e) {
                return this.coordinateLocation(this.pointCoordinate3D(e));
            }
            locationCoordinate(t, i) {
                const o35 = i ? e1.mercatorZfromAltitude(i, t.lat) : void 0, r15 = this.projection.project(t.lng, t.lat);
                return new e1.MercatorCoordinate(r15.x, r15.y, o35);
            }
            coordinateLocation(e) {
                return this.projection.unproject(e.x, e.y);
            }
            pointRayIntersection(t, i) {
                const o35 = null != i ? i : this._centerAltitude, r15 = [
                    t.x,
                    t.y,
                    0,
                    1
                ], n10 = [
                    t.x,
                    t.y,
                    1,
                    1
                ];
                e1.transformMat4$1(r15, r15, this.pixelMatrixInverse), e1.transformMat4$1(n10, n10, this.pixelMatrixInverse);
                const s19 = n10[3];
                e1.scale$1(r15, r15, 1 / r15[3]), e1.scale$1(n10, n10, 1 / s19);
                const a19 = r15[2], l21 = n10[2];
                return {
                    p0: r15,
                    p1: n10,
                    t: a19 === l21 ? 0 : (o35 - a19) / (l21 - a19)
                };
            }
            screenPointToMercatorRay(t) {
                const i42 = [
                    t.x,
                    t.y,
                    0,
                    1
                ], o35 = [
                    t.x,
                    t.y,
                    1,
                    1
                ];
                return e1.transformMat4$1(i42, i42, this.pixelMatrixInverse), e1.transformMat4$1(o35, o35, this.pixelMatrixInverse), e1.scale$1(i42, i42, 1 / i42[3]), e1.scale$1(o35, o35, 1 / o35[3]), i42[2] = e1.mercatorZfromAltitude(i42[2], this._center.lat) * this.worldSize, o35[2] = e1.mercatorZfromAltitude(o35[2], this._center.lat) * this.worldSize, e1.scale$1(i42, i42, 1 / this.worldSize), e1.scale$1(o35, o35, 1 / this.worldSize), new e1.Ray([
                    i42[0],
                    i42[1],
                    i42[2]
                ], e1.normalize([], e1.sub([], o35, i42)));
            }
            rayIntersectionCoordinate(t) {
                const { p0: i42 , p1: o35 , t: r15  } = t, n10 = e1.mercatorZfromAltitude(i42[2], this._center.lat), s19 = e1.mercatorZfromAltitude(o35[2], this._center.lat);
                return new e1.MercatorCoordinate(e1.number(i42[0], o35[0], r15) / this.worldSize, e1.number(i42[1], o35[1], r15) / this.worldSize, e1.number(n10, s19, r15));
            }
            pointCoordinate(e, t = this._centerAltitude) {
                return this.projection.pointCoordinate(this, e.x, e.y, t);
            }
            pointCoordinate3D(t) {
                if (!this.elevation) return this.pointCoordinate(t);
                let i42 = this.projection.pointCoordinate3D(this, t.x, t.y);
                if (i42) return new e1.MercatorCoordinate(i42[0], i42[1], i42[2]);
                let o35 = 0, r15 = this.horizonLineFromTop();
                if (t.y > r15) return this.pointCoordinate(t);
                const n10 = 0.02 * r15, s19 = t.clone();
                for(let t37 = 0; t37 < 10 && r15 - o35 > n10; t37++){
                    s19.y = e1.number(o35, r15, 0.66);
                    const t37 = this.projection.pointCoordinate3D(this, s19.x, s19.y);
                    t37 ? (r15 = s19.y, i42 = t37) : o35 = s19.y;
                }
                return i42 ? new e1.MercatorCoordinate(i42[0], i42[1], i42[2]) : this.pointCoordinate(t);
            }
            isPointAboveHorizon(e) {
                return this.projection.isPointAboveHorizon(this, e);
            }
            _coordinatePoint(t, i) {
                const o35 = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude, r15 = [
                    t.x * this.worldSize,
                    t.y * this.worldSize,
                    o35 + t.toAltitude(),
                    1
                ];
                return e1.transformMat4$1(r15, r15, this.pixelMatrix), r15[3] > 0 ? new e1.pointGeometry(r15[0] / r15[3], r15[1] / r15[3]) : new e1.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            _getGlobeBounds() {
                const { top: t37 , left: i42  } = this._edgeInsets, o35 = this.height - this._edgeInsets.bottom, r15 = this.width - this._edgeInsets.right, n10 = this.pointCoordinate3D(new e1.pointGeometry(i42, t37)), s19 = this.pointCoordinate3D(new e1.pointGeometry(r15, t37)), a19 = this.pointCoordinate3D(new e1.pointGeometry(r15, o35)), l21 = this.pointCoordinate3D(new e1.pointGeometry(i42, o35));
                let c15 = Math.min(n10.x, l21.x), h14 = Math.max(s19.x, a19.x), u17 = Math.min(n10.y, s19.y), _3 = Math.max(l21.y, a19.y);
                const d9 = Math.pow(2, -this.zoom) / 16, p12 = (t38, i43, o36, r16)=>{
                    const n11 = (t38 + o36) / 2, s20 = (i43 + r16) / 2, a20 = new e1.pointGeometry(n11, s20), l22 = this.pointCoordinate3D(a20), m8 = Math.max(0, c15 - l22.x, u17 - l22.y, l22.x - h14, l22.y - _3);
                    c15 = Math.min(c15, l22.x), h14 = Math.max(h14, l22.x), u17 = Math.min(u17, l22.y), _3 = Math.max(_3, l22.y), m8 > d9 && (p12(t38, i43, n11, s20), p12(n11, s20, o36, r16));
                };
                p12(i42, t37, r15, t37), p12(r15, t37, r15, o35), p12(r15, o35, i42, o35), p12(i42, o35, i42, t37);
                const [m8, f9] = e1.polesInViewport(this), g6 = m8 || f9, v4 = m8 ? 90 : e1.latFromMercatorY(u17), x4 = g6 ? 180 : e1.lngFromMercatorX(h14), y5 = f9 ? -90 : e1.latFromMercatorY(_3), b3 = g6 ? -180 : e1.lngFromMercatorX(c15);
                return new e1.LngLatBounds(new e1.LngLat(b3, y5), new e1.LngLat(x4, v4));
            }
            _getBounds(t, i) {
                if ("globe" === this.projection.name) return this._getGlobeBounds();
                const o35 = new e1.pointGeometry(this._edgeInsets.left, this._edgeInsets.top), r15 = new e1.pointGeometry(this.width - this._edgeInsets.right, this._edgeInsets.top), n10 = new e1.pointGeometry(this.width - this._edgeInsets.right, this.height - this._edgeInsets.bottom), s19 = new e1.pointGeometry(this._edgeInsets.left, this.height - this._edgeInsets.bottom);
                let a19 = this.pointCoordinate(o35, t), l21 = this.pointCoordinate(r15, t);
                const c15 = this.pointCoordinate(n10, i), h14 = this.pointCoordinate(s19, i), u17 = (e31, t37)=>(t37.y - e31.y) / (t37.x - e31.x)
                ;
                return a19.y > 1 && l21.y >= 0 ? a19 = new e1.MercatorCoordinate((1 - h14.y) / u17(h14, a19) + h14.x, 1) : a19.y < 0 && l21.y <= 1 && (a19 = new e1.MercatorCoordinate(-h14.y / u17(h14, a19) + h14.x, 0)), l21.y > 1 && a19.y >= 0 ? l21 = new e1.MercatorCoordinate((1 - c15.y) / u17(c15, l21) + c15.x, 1) : l21.y < 0 && a19.y <= 1 && (l21 = new e1.MercatorCoordinate(-c15.y / u17(c15, l21) + c15.x, 0)), (new e1.LngLatBounds).extend(this.coordinateLocation(a19)).extend(this.coordinateLocation(l21)).extend(this.coordinateLocation(h14)).extend(this.coordinateLocation(c15));
            }
            _getBounds3D() {
                const e31 = this.elevation;
                if (!e31.visibleDemTiles.length || e31.isUsingMockSource()) return this._getBounds(0, 0);
                const t37 = e31.visibleDemTiles.reduce((e32, t38)=>{
                    if (t38.dem) {
                        const i42 = t38.dem.tree;
                        e32.min = Math.min(e32.min, i42.minimums[0]), e32.max = Math.max(e32.max, i42.maximums[0]);
                    }
                    return e32;
                }, {
                    min: Number.MAX_VALUE,
                    max: 0
                });
                return this._getBounds(t37.min * e31.exaggeration(), t37.max * e31.exaggeration());
            }
            getBounds() {
                return this._terrainEnabled() ? this._getBounds3D() : this._getBounds(0, 0);
            }
            horizonLineFromTop(e = !0) {
                const t37 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i42 = this.height / 2 - t37 * (1 - this._horizonShift);
                return e ? Math.max(0, i42) : i42;
            }
            getMaxBounds() {
                return this.maxBounds;
            }
            setMaxBounds(t) {
                this.maxBounds = t, this.minLat = -e1.MAX_MERCATOR_LATITUDE, this.maxLat = e1.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e1.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e1.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e1.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e1.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
            }
            calculatePosMatrix(e, t) {
                return this.projection.createTileMatrix(this, t, e);
            }
            calculateDistanceTileData(t) {
                const i42 = t.key, o35 = this._distanceTileDataCache;
                if (o35[i42]) return o35[i42];
                const r15 = t.canonical, n10 = 1 / this.height, s19 = this.cameraWorldSize, a19 = s19 / this.zoomScale(r15.z), l21 = (r15.x + Math.pow(2, r15.z) * t.wrap) * a19, c15 = r15.y * a19, h14 = this.point;
                h14.x *= s19 / this.worldSize, h14.y *= s19 / this.worldSize;
                const u17 = this.angle, _3 = Math.sin(-u17), d9 = -Math.cos(-u17);
                return o35[i42] = {
                    bearing: [
                        _3,
                        d9
                    ],
                    center: [
                        (h14.x - l21) * n10,
                        (h14.y - c15) * n10
                    ],
                    scale: a19 / e1.EXTENT * n10
                }, o35[i42];
            }
            calculateFogTileMatrix(t) {
                const i42 = t.key, o35 = this._fogTileMatrixCache;
                if (o35[i42]) return o35[i42];
                const r15 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);
                return e1.multiply(r15, this.worldToFogMatrix, r15), o35[i42] = new Float32Array(r15), o35[i42];
            }
            calculateProjMatrix(t, i = !1) {
                const o35 = t.key, r15 = i ? this._alignedProjMatrixCache : this._projMatrixCache;
                if (r15[o35]) return r15[o35];
                const n10 = this.calculatePosMatrix(t, this.worldSize);
                return e1.multiply(n10, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, n10), r15[o35] = new Float32Array(n10), r15[o35];
            }
            calculatePixelsToTileUnitsMatrix(t) {
                const i42 = t.tileID.key, o35 = this._pixelsToTileUnitsCache;
                if (o35[i42]) return o35[i42];
                const r15 = function(t37, i43) {
                    const { scale: o36  } = t37.tileTransform, r16 = o36 * e1.EXTENT / (t37.tileSize * Math.pow(2, i43.zoom - t37.tileID.overscaledZ + t37.tileID.canonical.z));
                    var n10, s19, a19, l21, c15, h14, u17, _3;
                    return n10 = new Float32Array(4), l21 = (s19 = i43.inverseAdjustmentMatrix)[1], c15 = s19[2], h14 = s19[3], _3 = (a19 = [
                        r16,
                        r16
                    ])[1], n10[0] = s19[0] * (u17 = a19[0]), n10[1] = l21 * u17, n10[2] = c15 * _3, n10[3] = h14 * _3, n10;
                }(t, this);
                return o35[i42] = r15, o35[i42];
            }
            customLayerMatrix() {
                return this.mercatorMatrix.slice();
            }
            recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name) return;
                const t37 = this._elevation;
                this._updateCameraState();
                const i42 = e1.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o35 = this._computeCameraPosition(i42), r15 = this._camera.forward(), n10 = e1.mercatorZfromAltitude(1, this._center.lat);
                o35[2] /= n10, r15[2] /= n10, e1.normalize(r15, r15);
                const s19 = t37.raycast(o35, r15, t37.exaggeration());
                if (s19) {
                    const t38 = e1.scaleAndAdd([], o35, r15, s19), i43 = new e1.MercatorCoordinate(t38[0], t38[1], e1.mercatorZfromAltitude(t38[2], e1.latFromMercatorY(t38[1]))), a19 = (i43.z + e1.length([
                        i43.x - o35[0],
                        i43.y - o35[1],
                        i43.z - o35[2] * n10
                    ])) * this._pixelsPerMercatorPixel;
                    this._seaLevelZoom = this._zoomFromMercatorZ(a19), this._centerAltitude = i43.toAltitude(), this._center = this.coordinateLocation(i43), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
                }
            }
            _constrainCamera(t = !1) {
                if (!this._elevation) return;
                const i42 = this._elevation, o35 = e1.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, r15 = this._computeCameraPosition(o35), n10 = i42.getAtPointOrZero(new e1.MercatorCoordinate(...r15)), s19 = this.pixelsPerMeter / this.worldSize * n10, a19 = this._minimumHeightOverTerrain(), l21 = r15[2] - s19;
                if (l21 <= a19) {
                    if (l21 < 0 || t) {
                        const t37 = this.locationCoordinate(this._center, this._centerAltitude), i43 = [
                            r15[0],
                            r15[1],
                            t37.z - r15[2]
                        ], o36 = e1.length(i43);
                        i43[2] -= (a19 - l21) / this._pixelsPerMercatorPixel;
                        const n11 = e1.length(i43);
                        if (0 === n11) return;
                        e1.scale$2(i43, i43, o36 / n11 * this._pixelsPerMercatorPixel), this._camera.position = [
                            r15[0],
                            r15[1],
                            t37.z * this._pixelsPerMercatorPixel - i43[2]
                        ], this._updateStateFromCamera();
                    } else this._isCameraConstrained = !0;
                }
            }
            _constrain() {
                if (!this.center || !this.width || !this.height || this._constraining) return;
                this._constraining = !0;
                const t37 = "globe" === this.projection.name || this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || t37) {
                    const i42 = this.center;
                    return i42.lat = e1.clamp(i42.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t37) && (i42.lng = e1.clamp(i42.lng, this.minLng, this.maxLng)), this.center = i42, void (this._constraining = !1);
                }
                const i42 = this._unmodified, { x: o35 , y: r15  } = this.point;
                let n10 = 0, s19 = o35, a19 = r15;
                const l21 = this.width / 2, c15 = this.height / 2, h14 = this.worldMinY * this.scale, u17 = this.worldMaxY * this.scale;
                if (r15 - c15 < h14 && (a19 = h14 + c15), r15 + c15 > u17 && (a19 = u17 - c15), u17 - h14 < this.height && (n10 = Math.max(n10, this.height / (u17 - h14)), a19 = (u17 + h14) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const e31 = this.worldMinX * this.scale, t38 = this.worldMaxX * this.scale, i43 = this.worldSize / 2 - (e31 + t38) / 2;
                    s19 = (o35 + i43 + this.worldSize) % this.worldSize - i43, s19 - l21 < e31 && (s19 = e31 + l21), s19 + l21 > t38 && (s19 = t38 - l21), t38 - e31 < this.width && (n10 = Math.max(n10, this.width / (t38 - e31)), s19 = (t38 + e31) / 2);
                }
                s19 === o35 && a19 === r15 || (this.center = this.unproject(new e1.pointGeometry(s19, a19))), n10 && (this.zoom += this.scaleZoom(n10)), this._constrainCamera(), this._unmodified = i42, this._constraining = !1;
            }
            _minZoomForBounds() {
                let e31 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                return this.maxBounds && (e31 = Math.max(e31, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e31;
            }
            _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
                if (!this.height) return;
                const t37 = this.centerOffset, i42 = this.pixelsPerMeter;
                "globe" === this.projection.name && (this._mercatorScaleRatio = e1.mercatorZfromAltitude(1, this.center.lat) / e1.mercatorZfromAltitude(1, e1.GLOBE_SCALE_MATCH_LATITUDE));
                const o35 = Wo(this.projection, this.zoom, this.width, this.height, 1024);
                this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o35), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
                const r15 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? i42 : 1), n10 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                n10[8] = 2 * -t37.x / this.width, n10[9] = 2 * t37.y / this.height;
                let s19 = e1.mul([], n10, r15);
                if (this.projection.isReprojectedInTileSpace) {
                    const t38 = this.locationCoordinate(this.center), i43 = e1.identity([]);
                    e1.translate(i43, i43, [
                        t38.x * this.worldSize,
                        t38.y * this.worldSize,
                        0
                    ]), e1.multiply(i43, i43, Zo(this)), e1.translate(i43, i43, [
                        -t38.x * this.worldSize,
                        -t38.y * this.worldSize,
                        0
                    ]), e1.multiply(s19, s19, i43), this.inverseAdjustmentMatrix = (function(e31) {
                        const t39 = Zo(e31, !0);
                        return v3([], [
                            t39[0],
                            t39[1],
                            t39[4],
                            t39[5]
                        ]);
                    })(this);
                } else this.inverseAdjustmentMatrix = [
                    1,
                    0,
                    0,
                    1
                ];
                this.mercatorMatrix = e1.scale([], s19, [
                    this.worldSize,
                    this.worldSize,
                    this.worldSize / i42,
                    1
                ]), this.projMatrix = s19, this.invProjMatrix = e1.invert(new Float64Array(16), this.projMatrix);
                const a19 = e1.invert([], n10);
                this.frustumCorners = e1.FrustumCorners.fromInvProjectionMatrix(a19, this.horizonLineFromTop(), this.height);
                const l21 = new Float32Array(16);
                e1.identity(l21), e1.scale(l21, l21, [
                    1,
                    -1,
                    1
                ]), e1.rotateX(l21, l21, this._pitch), e1.rotateZ(l21, l21, this.angle);
                const c15 = e1.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), h14 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                c15[8] = 2 * -t37.x / this.width, c15[9] = 2 * (t37.y + h14) / this.height, this.skyboxMatrix = e1.multiply(l21, c15, l21);
                const u17 = this.point, _3 = u17.x, d9 = u17.y, p12 = this.width % 2 / 2, m8 = this.height % 2 / 2, f9 = Math.cos(this.angle), g6 = Math.sin(this.angle), x4 = _3 - Math.round(_3) + f9 * p12 + g6 * m8, y5 = d9 - Math.round(d9) + f9 * m8 + g6 * p12, b3 = new Float64Array(s19);
                if (e1.translate(b3, b3, [
                    x4 > 0.5 ? x4 - 1 : x4,
                    y5 > 0.5 ? y5 - 1 : y5,
                    0
                ]), this.alignedProjMatrix = b3, s19 = e1.create(), e1.scale(s19, s19, [
                    this.width / 2,
                    -this.height / 2,
                    1
                ]), e1.translate(s19, s19, [
                    1,
                    -1,
                    0
                ]), this.labelPlaneMatrix = s19, s19 = e1.create(), e1.scale(s19, s19, [
                    1,
                    -1,
                    1
                ]), e1.translate(s19, s19, [
                    -1,
                    -1,
                    0
                ]), e1.scale(s19, s19, [
                    2 / this.width,
                    2 / this.height,
                    1
                ]), this.glCoordMatrix = s19, this.pixelMatrix = e1.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {
                }, s19 = e1.invert(new Float64Array(16), this.pixelMatrix), !s19) throw new Error("failed to invert matrix");
                if (this.pixelMatrixInverse = s19, "globe" === this.projection.name || this.mercatorFromTransition) {
                    this.globeMatrix = e1.calculateGlobeMatrix(this);
                    const t38 = [
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ];
                    this.globeCenterInViewSpace = e1.transformMat4(t38, t38, r15), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
                } else this.globeMatrix = s19;
                this._projMatrixCache = {
                }, this._alignedProjMatrixCache = {
                }, this._pixelsToTileUnitsCache = {
                };
            }
            _calcFogMatrices() {
                this._fogTileMatrixCache = {
                };
                const t37 = this.cameraWorldSizeForFog, i42 = this.cameraPixelsPerMeter, o35 = this._camera.position, r15 = 1 / this.height / this._pixelsPerMercatorPixel, n10 = [
                    t37,
                    t37,
                    i42
                ];
                e1.scale$2(n10, n10, r15), e1.scale$2(o35, o35, -1), e1.multiply$2(o35, o35, n10);
                const s19 = e1.create();
                e1.translate(s19, s19, o35), e1.scale(s19, s19, n10), this.mercatorFogMatrix = s19, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t37, i42, r15);
            }
            _computeCameraPosition(e) {
                const t37 = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter, i42 = this._camera.forward(), o35 = this.point, r15 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t37 - e / this.worldSize * this._centerAltitude;
                return [
                    o35.x / this.worldSize - i42[0] * r15,
                    o35.y / this.worldSize - i42[1] * r15,
                    e / this.worldSize * this._centerAltitude - i42[2] * r15
                ];
            }
            _updateCameraState() {
                this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(t) {
                const i42 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o35 = this._camera.position[2], r15 = t[2];
                let n10 = 1;
                this.projection.wrap && (this.center = this.center.wrap()), r15 > 0 && (n10 = Math.min((i42 - o35) / r15, 1)), this._camera.position = e1.scaleAndAdd([], this._camera.position, t, n10), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
                const t37 = this._camera.position, i42 = this._camera.forward(), { pitch: o35 , bearing: r15  } = this._camera.getPitchBearing(), n10 = e1.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, s19 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e1.degToRad(this._maxPitch)), a19 = Math.max((t37[2] - n10) / Math.cos(o35), s19), l21 = this._zoomFromMercatorZ(a19);
                e1.scaleAndAdd(t37, t37, i42, a19), this._pitch = e1.clamp(o35, e1.degToRad(this.minPitch), e1.degToRad(this.maxPitch)), this.angle = e1.wrap(r15, -Math.PI, Math.PI), this._setZoom(e1.clamp(l21, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e1.MercatorCoordinate(t37[0], t37[1], t37[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(e) {
                return Math.pow(2, e) * this.tileSize;
            }
            _mercatorZfromZoom(e) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(e);
            }
            _minimumHeightOverTerrain() {
                const e31 = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
                return this._mercatorZfromZoom(e31);
            }
            _zoomFromMercatorZ(e) {
                return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize));
            }
            zoomFromMercatorZAdjusted(e) {
                const t37 = (t38)=>{
                    const i42 = this.getCameraToCenterDistance(this.projection, t38);
                    return this.scaleZoom(i42 / (e * this.tileSize));
                };
                let i42, o35 = t37(this.zoom), r15 = Math.abs(o35 - t37(o35));
                for(; i42 !== r15;)o35 = t37(o35), i42 = r15, r15 = Math.abs(o35 - t37(o35));
                return o35;
            }
            _terrainEnabled() {
                return !(!this._elevation || !this.projection.supportsTerrain && (e1.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }
            anyCornerOffEdge(t, i) {
                const o35 = Math.min(t.x, i.x), r15 = Math.max(t.x, i.x), n10 = Math.min(t.y, i.y), s19 = Math.max(t.y, i.y);
                if (n10 < this.horizonLineFromTop(!1)) return !0;
                if ("mercator" !== this.projection.name) return !1;
                const a19 = [
                    new e1.pointGeometry(o35, n10),
                    new e1.pointGeometry(r15, s19),
                    new e1.pointGeometry(o35, s19),
                    new e1.pointGeometry(r15, n10)
                ], l21 = this.renderWorldCopies ? -3 : 0, c15 = this.renderWorldCopies ? 4 : 1;
                for (const e31 of a19){
                    const t37 = this.pointRayIntersection(e31);
                    if (t37.t < 0) return !0;
                    const i42 = this.rayIntersectionCoordinate(t37);
                    if (i42.x < l21 || i42.y < 0 || i42.x > c15 || i42.y > 1) return !0;
                }
                return !1;
            }
            isHorizonVisible() {
                return this.pitch + e1.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e1.pointGeometry(0, 0), new e1.pointGeometry(this.width, this.height));
            }
            zoomDeltaToMovement(t, i) {
                const o35 = e1.length(e1.sub([], this._camera.position, t)), r15 = this._zoomFromMercatorZ(o35) + i;
                return o35 - this._mercatorZfromZoom(r15);
            }
            getCameraPoint() {
                if ("globe" === this.projection.name) {
                    const t37 = function([t38, i42, o35], r15) {
                        const n10 = [
                            t38,
                            i42,
                            o35,
                            1
                        ];
                        e1.transformMat4$1(n10, n10, r15);
                        const s19 = n10[3] = Math.max(n10[3], 0.000001);
                        return n10[0] /= s19, n10[1] /= s19, n10[2] /= s19, n10;
                    }([
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ], this.pixelMatrix);
                    return new e1.pointGeometry(t37[0], t37[1]);
                }
                {
                    const t37 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new e1.pointGeometry(0, t37));
                }
            }
            getCameraToCenterDistance(e, t = this.zoom) {
                const i42 = Wo(e, t, this.width, this.height, 1024), o35 = e.pixelSpaceConversion(this.center.lat, this.worldSize, i42);
                return 0.5 / Math.tan(0.5 * this._fov) * this.height * o35;
            }
            getWorldToCameraMatrix() {
                const t37 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
                return "globe" === this.projection.name && e1.multiply(t37, t37, this.globeMatrix), t37;
            }
        }
        function Yo(e31, t37) {
            let i42 = !1, o35 = null;
            const r15 = ()=>{
                o35 = null, i42 && (e31(), o35 = setTimeout(r15, t37), i42 = !1);
            };
            return ()=>(i42 = !0, o35 || r15(), o35)
            ;
        }
        class Ko {
            constructor(t37){
                this._hashName = t37 && encodeURIComponent(t37), e1.bindAll([
                    "_getCurrentHash",
                    "_onHashChange",
                    "_updateHash"
                ], this), this._updateHash = Yo(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(t) {
                return this._map = t, e1.window.addEventListener("hashchange", this._onHashChange, !1), t.on("moveend", this._updateHash), this;
            }
            remove() {
                return this._map ? (this._map.off("moveend", this._updateHash), e1.window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }
            getHashString() {
                const t38 = this._map;
                if (!t38) return "";
                const i42 = Jo(t38);
                if (this._hashName) {
                    const t39 = this._hashName;
                    let o35 = !1;
                    const r15 = e1.window.location.hash.slice(1).split("&").map((e31)=>{
                        const r16 = e31.split("=")[0];
                        return r16 === t39 ? (o35 = !0, `${r16}=${i42}`) : e31;
                    }).filter((e31)=>e31
                    );
                    return o35 || r15.push(`${t39}=${i42}`), `#${r15.join("&")}`;
                }
                return `#${i42}`;
            }
            _getCurrentHash() {
                const t38 = e1.window.location.hash.replace("#", "");
                if (this._hashName) {
                    let e31;
                    return t38.split("&").map((e32)=>e32.split("=")
                    ).forEach((t39)=>{
                        t39[0] === this._hashName && (e31 = t39);
                    }), (e31 && e31[1] || "").split("/");
                }
                return t38.split("/");
            }
            _onHashChange() {
                const e31 = this._map;
                if (!e31) return !1;
                const t38 = this._getCurrentHash();
                if (t38.length >= 3 && !t38.some((e32)=>isNaN(e32)
                )) {
                    const i42 = e31.dragRotate.isEnabled() && e31.touchZoomRotate.isEnabled() ? +(t38[3] || 0) : e31.getBearing();
                    return e31.jumpTo({
                        center: [
                            +t38[2],
                            +t38[1]
                        ],
                        zoom: +t38[0],
                        bearing: i42,
                        pitch: +(t38[4] || 0)
                    }), !0;
                }
                return !1;
            }
            _updateHashUnthrottled() {
                const t38 = e1.window.location.href.replace(/(#.+)?$/, this.getHashString());
                e1.window.history.replaceState(e1.window.history.state, null, t38);
            }
        }
        function Jo(e31, t38) {
            const i42 = e31.getCenter(), o35 = Math.round(100 * e31.getZoom()) / 100, r15 = Math.ceil((o35 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), n10 = Math.pow(10, r15), s19 = Math.round(i42.lng * n10) / n10, a19 = Math.round(i42.lat * n10) / n10, l21 = e31.getBearing(), c15 = e31.getPitch();
            let h14 = t38 ? `/${s19}/${a19}/${o35}` : `${o35}/${a19}/${s19}`;
            return (l21 || c15) && (h14 += "/" + Math.round(10 * l21) / 10), c15 && (h14 += `/${Math.round(c15)}`), h14;
        }
        const Qo = {
            linearity: 0.3,
            easing: e1.bezier(0, 0, 0.3, 1)
        }, er = e1.extend({
            deceleration: 2500,
            maxSpeed: 1400
        }, Qo), tr = e1.extend({
            deceleration: 20,
            maxSpeed: 1400
        }, Qo), ir = e1.extend({
            deceleration: 1000,
            maxSpeed: 360
        }, Qo), or = e1.extend({
            deceleration: 1000,
            maxSpeed: 90
        }, Qo);
        class rr {
            constructor(e31){
                this._map = e31, this.clear();
            }
            clear() {
                this._inertiaBuffer = [];
            }
            record(t) {
                this._drainInertiaBuffer(), this._inertiaBuffer.push({
                    time: e1.exported.now(),
                    settings: t
                });
            }
            _drainInertiaBuffer() {
                const t38 = this._inertiaBuffer, i42 = e1.exported.now();
                for(; t38.length > 0 && i42 - t38[0].time > 160;)t38.shift();
            }
            _onMoveEnd(t) {
                if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                const i42 = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new e1.pointGeometry(0, 0),
                    pinchAround: void 0,
                    around: void 0
                };
                for (const { settings: e32  } of this._inertiaBuffer)i42.zoom += e32.zoomDelta || 0, i42.bearing += e32.bearingDelta || 0, i42.pitch += e32.pitchDelta || 0, e32.panDelta && i42.pan._add(e32.panDelta), e32.around && (i42.around = e32.around), e32.pinchAround && (i42.pinchAround = e32.pinchAround);
                const o35 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r15 = {
                };
                if (i42.pan.mag()) {
                    const n10 = sr(i42.pan.mag(), o35, e1.extend({
                    }, er, t || {
                    }));
                    r15.offset = i42.pan.mult(n10.amount / i42.pan.mag()), r15.center = this._map.transform.center, nr(r15, n10);
                }
                if (i42.zoom) {
                    const e33 = sr(i42.zoom, o35, tr);
                    r15.zoom = this._map.transform.zoom + e33.amount, nr(r15, e33);
                }
                if (i42.bearing) {
                    const t38 = sr(i42.bearing, o35, ir);
                    r15.bearing = this._map.transform.bearing + e1.clamp(t38.amount, -179, 179), nr(r15, t38);
                }
                if (i42.pitch) {
                    const e33 = sr(i42.pitch, o35, or);
                    r15.pitch = this._map.transform.pitch + e33.amount, nr(r15, e33);
                }
                if (r15.zoom || r15.bearing) {
                    const e33 = (void 0) === i42.pinchAround ? i42.around : i42.pinchAround;
                    r15.around = e33 ? this._map.unproject(e33) : this._map.getCenter();
                }
                return this.clear(), r15.noMoveStart = !0, r15;
            }
        }
        function nr(e32, t38) {
            (!e32.duration || e32.duration < t38.duration) && (e32.duration = t38.duration, e32.easing = t38.easing);
        }
        function sr(t38, i42, o35) {
            const { maxSpeed: r15 , linearity: n10 , deceleration: s19  } = o35, a19 = e1.clamp(t38 * n10 / (i42 / 1000), -r15, r15), l21 = Math.abs(a19) / (s19 * n10);
            return {
                easing: o35.easing,
                duration: 1000 * l21,
                amount: a19 * (l21 / 2)
            };
        }
        class ar extends e1.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t38, i42, o35, r15 = {
            }){
                const n10 = p2(i42.getCanvasContainer(), o35), s19 = i42.unproject(n10);
                super(t38, e1.extend({
                    point: n10,
                    lngLat: s19,
                    originalEvent: o35
                }, r15)), this._defaultPrevented = !1, this.target = i42;
            }
        }
        class lr extends e1.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t39, i43, o36){
                const r16 = "touchend" === t39 ? o36.changedTouches : o36.touches, n11 = m4(i43.getCanvasContainer(), r16), s20 = n11.map((e32)=>i43.unproject(e32)
                ), a19 = n11.reduce((e32, t40, i44, o37)=>e32.add(t40.div(o37.length))
                , new e1.pointGeometry(0, 0));
                super(t39, {
                    points: n11,
                    point: a19,
                    lngLats: s20,
                    lngLat: i43.unproject(a19),
                    originalEvent: o36
                }), this._defaultPrevented = !1;
            }
        }
        class cr extends e1.Event {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(e32, t40, i44){
                super(e32, {
                    originalEvent: i44
                }), this._defaultPrevented = !1;
            }
        }
        class hr {
            constructor(e33, t41){
                this._map = e33, this._clickTolerance = t41.clickTolerance;
            }
            reset() {
                this._mousedownPos = void 0;
            }
            wheel(e) {
                return this._firePreventable(new cr(e.type, this._map, e));
            }
            mousedown(e, t) {
                return this._mousedownPos = t, this._firePreventable(new ar(e.type, this._map, e));
            }
            mouseup(e) {
                this._map.fire(new ar(e.type, this._map, e));
            }
            preclick(t) {
                const i45 = e1.extend({
                }, t);
                i45.type = "preclick", this._map.fire(new ar(i45.type, this._map, i45));
            }
            click(e, t) {
                this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new ar(e.type, this._map, e)));
            }
            dblclick(e) {
                return this._firePreventable(new ar(e.type, this._map, e));
            }
            mouseover(e) {
                this._map.fire(new ar(e.type, this._map, e));
            }
            mouseout(e) {
                this._map.fire(new ar(e.type, this._map, e));
            }
            touchstart(e) {
                return this._firePreventable(new lr(e.type, this._map, e));
            }
            touchmove(e) {
                this._map.fire(new lr(e.type, this._map, e));
            }
            touchend(e) {
                this._map.fire(new lr(e.type, this._map, e));
            }
            touchcancel(e) {
                this._map.fire(new lr(e.type, this._map, e));
            }
            _firePreventable(e) {
                if (this._map.fire(e), e.defaultPrevented) return {
                };
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {
            }
            disable() {
            }
        }
        class ur {
            constructor(e34){
                this._map = e34;
            }
            reset() {
                this._delayContextMenu = !1, this._contextMenuEvent = void 0;
            }
            mousemove(e) {
                this._map.fire(new ar(e.type, this._map, e));
            }
            mousedown() {
                this._delayContextMenu = !0;
            }
            mouseup() {
                this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ar("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e) {
                this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new ar(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {
            }
            disable() {
            }
        }
        class _r {
            constructor(e35, t42){
                this._map = e35, this._el = e35.getCanvasContainer(), this._container = e35.getContainer(), this._clickTolerance = t42.clickTolerance || 1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            enable() {
                this.isEnabled() || (this._enabled = !0);
            }
            disable() {
                this.isEnabled() && (this._enabled = !1);
            }
            mousedown(e, t) {
                this.isEnabled() && e.shiftKey && 0 === e.button && (h2(), this._startPos = this._lastPos = t, this._active = !0);
            }
            mousemoveWindow(e, t) {
                if (!this._active) return;
                const i45 = t, o37 = this._startPos, r17 = this._lastPos;
                if (!o37 || !r17 || r17.equals(i45) || !this._box && i45.dist(o37) < this._clickTolerance) return;
                this._lastPos = i45, this._box || (this._box = n1("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e));
                const s21 = Math.min(o37.x, i45.x), a20 = Math.max(o37.x, i45.x), l21 = Math.min(o37.y, i45.y), c15 = Math.max(o37.y, i45.y);
                this._map._requestDomTask(()=>{
                    this._box && (this._box.style.transform = `translate(${s21}px,${l21}px)`, this._box.style.width = a20 - s21 + "px", this._box.style.height = c15 - l21 + "px");
                });
            }
            mouseupWindow(t, i) {
                if (!this._active) return;
                const o37 = this._startPos, r17 = i;
                if (o37 && 0 === t.button) {
                    if (this.reset(), d2(), o37.x !== r17.x || o37.y !== r17.y) return this._map.fire(new e1.Event("boxzoomend", {
                        originalEvent: t
                    })), {
                        cameraAnimation: (e36)=>e36.fitScreenCoordinates(o37, r17, this._map.getBearing(), {
                                linear: !1
                            })
                    };
                    this._fireEvent("boxzoomcancel", t);
                }
            }
            keydown(e) {
                this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e));
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u3(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(t, i) {
                return this._map.fire(new e1.Event(t, {
                    originalEvent: i
                }));
            }
        }
        function dr(e36, t43) {
            const i45 = {
            };
            for(let o37 = 0; o37 < e36.length; o37++)i45[e36[o37].identifier] = t43[o37];
            return i45;
        }
        class pr {
            constructor(e36){
                this.reset(), this.numTouches = e36.numTouches;
            }
            reset() {
                this.centroid = void 0, this.startTime = 0, this.touches = {
                }, this.aborted = !1;
            }
            touchstart(t, i, o) {
                (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp), o.length === this.numTouches && (this.centroid = (function(t43) {
                    const i45 = new e1.pointGeometry(0, 0);
                    for (const e37 of t43)i45._add(e37);
                    return i45.div(t43.length);
                })(i), this.touches = dr(o, i)));
            }
            touchmove(e, t, i) {
                if (this.aborted || !this.centroid) return;
                const o37 = dr(i, t);
                for(const e37 in this.touches){
                    const t43 = this.touches[e37], i45 = o37[e37];
                    (!i45 || i45.dist(t43) > 30) && (this.aborted = !0);
                }
            }
            touchend(e, t, i) {
                if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
                    const e37 = !this.aborted && this.centroid;
                    if (this.reset(), e37) return e37;
                }
            }
        }
        class mr {
            constructor(e37){
                this.singleTap = new pr(e37), this.numTaps = e37.numTaps, this.reset();
            }
            reset() {
                this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }
            touchstart(e, t, i) {
                this.singleTap.touchstart(e, t, i);
            }
            touchmove(e, t, i) {
                this.singleTap.touchmove(e, t, i);
            }
            touchend(e, t, i) {
                const o37 = this.singleTap.touchend(e, t, i);
                if (o37) {
                    const t43 = e.timeStamp - this.lastTime < 500, i45 = !this.lastTap || this.lastTap.dist(o37) < 30;
                    if (t43 && i45 || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o37, this.count === this.numTaps) return this.reset(), o37;
                }
            }
        }
        class fr {
            constructor(){
                this._zoomIn = new mr({
                    numTouches: 1,
                    numTaps: 2
                }), this._zoomOut = new mr({
                    numTouches: 2,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e, t, i) {
                this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);
            }
            touchmove(e, t, i) {
                this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);
            }
            touchend(e, t, i) {
                const o37 = this._zoomIn.touchend(e, t, i), r17 = this._zoomOut.touchend(e, t, i);
                return o37 ? (this._active = !0, e.preventDefault(), setTimeout(()=>this.reset()
                , 0), {
                    cameraAnimation: (t43)=>t43.easeTo({
                            duration: 300,
                            zoom: t43.getZoom() + 1,
                            around: t43.unproject(o37)
                        }, {
                            originalEvent: e
                        })
                }) : r17 ? (this._active = !0, e.preventDefault(), setTimeout(()=>this.reset()
                , 0), {
                    cameraAnimation: (t43)=>t43.easeTo({
                            duration: 300,
                            zoom: t43.getZoom() - 1,
                            around: t43.unproject(r17)
                        }, {
                            originalEvent: e
                        })
                }) : void 0;
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        const gr = {
            0: 1,
            2: 2
        };
        class vr {
            constructor(e38){
                this.reset(), this._clickTolerance = e38.clickTolerance || 1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
            }
            _correctButton(e, t) {
                return !1;
            }
            _move(e, t) {
                return {
                };
            }
            mousedown(e, t) {
                if (this._lastPoint) return;
                const i45 = f2(e);
                this._correctButton(e, i45) && (this._lastPoint = t, this._eventButton = i45);
            }
            mousemoveWindow(e, t) {
                const i45 = this._lastPoint;
                if (i45) {
                    if (e.preventDefault(), null != this._eventButton && (function(e39, t43) {
                        const i46 = gr[t43];
                        return (void 0) === e39.buttons || (e39.buttons & i46) !== i46;
                    })(e, this._eventButton)) this.reset();
                    else if (this._moved || !(t.dist(i45) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(i45, t);
                }
            }
            mouseupWindow(e) {
                this._lastPoint && f2(e) === this._eventButton && (this._moved && d2(), this.reset());
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class xr extends vr {
            mousedown(e, t) {
                super.mousedown(e, t), this._lastPoint && (this._active = !0);
            }
            _correctButton(e, t) {
                return 0 === t && !e.ctrlKey;
            }
            _move(e, t) {
                return {
                    around: t,
                    panDelta: t.sub(e)
                };
            }
        }
        class yr extends vr {
            _correctButton(e, t) {
                return 0 === t && e.ctrlKey || 2 === t;
            }
            _move(e, t) {
                const i45 = 0.8 * (t.x - e.x);
                if (i45) return this._active = !0, {
                    bearingDelta: i45
                };
            }
            contextmenu(e) {
                e.preventDefault();
            }
        }
        class br extends vr {
            _correctButton(e, t) {
                return 0 === t && e.ctrlKey || 2 === t;
            }
            _move(e, t) {
                const i45 = -0.5 * (t.y - e.y);
                if (i45) return this._active = !0, {
                    pitchDelta: i45
                };
            }
            contextmenu(e) {
                e.preventDefault();
            }
        }
        class wr {
            constructor(t43, i45){
                this._map = t43, this._el = t43.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i45.clickTolerance || 1, this.reset(), e1.bindAll([
                    "_addTouchPanBlocker",
                    "_showTouchPanBlockerAlert"
                ], this);
            }
            reset() {
                this._active = !1, this._touches = {
                }, this._sum = new e1.pointGeometry(0, 0);
            }
            touchstart(e, t, i) {
                return this._calculateTransform(e, t, i);
            }
            touchmove(t, i, o) {
                if (this._active && !(o.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (1 === o.length && !e1.isFullscreen()) return void this._showTouchPanBlockerAlert();
                        "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                    }
                    return t.cancelable && t.preventDefault(), this._calculateTransform(t, i, o);
                }
            }
            touchend(e, t, i) {
                this._calculateTransform(e, t, i), this._active && i.length < this._minTouches && this.reset();
            }
            touchcancel() {
                this.reset();
            }
            _calculateTransform(t, i, o) {
                o.length > 0 && (this._active = !0);
                const r17 = dr(o, i), n12 = new e1.pointGeometry(0, 0), s21 = new e1.pointGeometry(0, 0);
                let a20 = 0;
                for(const e39 in r17){
                    const t44 = r17[e39], i46 = this._touches[e39];
                    i46 && (n12._add(t44), s21._add(t44.sub(i46)), a20++, r17[e39] = t44);
                }
                if (this._touches = r17, a20 < this._minTouches || !s21.mag()) return;
                const l21 = s21.div(a20);
                return this._sum._add(l21), this._sum.mag() < this._clickTolerance ? void 0 : {
                    around: n12.div(a20),
                    panDelta: l21
                };
            }
            enable() {
                this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }
            disable() {
                this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            _addTouchPanBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = n1("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
                }, 500);
            }
        }
        class Tr {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1, this._firstTwoTouches = void 0;
            }
            _start(e) {
            }
            _move(e, t, i) {
                return {
                };
            }
            touchstart(e, t, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [
                    i[0].identifier,
                    i[1].identifier
                ], this._start([
                    t[0],
                    t[1]
                ]));
            }
            touchmove(e, t, i) {
                const o37 = this._firstTwoTouches;
                if (!o37) return;
                e.preventDefault();
                const [r17, n12] = o37, s21 = Er(i, t, r17), a20 = Er(i, t, n12);
                if (!s21 || !a20) return;
                const l21 = this._aroundCenter ? null : s21.add(a20).div(2);
                return this._move([
                    s21,
                    a20
                ], l21, e);
            }
            touchend(e, t, i) {
                if (!this._firstTwoTouches) return;
                const [o37, r17] = this._firstTwoTouches, n12 = Er(i, t, o37), s21 = Er(i, t, r17);
                n12 && s21 || (this._active && d2(), this.reset());
            }
            touchcancel() {
                this.reset();
            }
            enable(e) {
                this._enabled = !0, this._aroundCenter = !!e && "center" === e.around;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        function Er(e39, t44, i46) {
            for(let o37 = 0; o37 < e39.length; o37++)if (e39[o37].identifier === i46) return t44[o37];
        }
        function Cr(e39, t44) {
            return Math.log(e39 / t44) / Math.LN2;
        }
        class Ir extends Tr {
            reset() {
                super.reset(), this._distance = 0, this._startDistance = 0;
            }
            _start(e) {
                this._startDistance = this._distance = e[0].dist(e[1]);
            }
            _move(e, t) {
                const i46 = this._distance;
                if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Cr(this._distance, this._startDistance)) < 0.1)) return this._active = !0, {
                    zoomDelta: Cr(this._distance, i46),
                    pinchAround: t
                };
            }
        }
        function Mr(e39, t44) {
            return 180 * e39.angleWith(t44) / Math.PI;
        }
        class Sr extends Tr {
            reset() {
                super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }
            _start(e) {
                this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
            }
            _move(e, t) {
                const i46 = this._vector;
                if (this._vector = e[0].sub(e[1]), i46 && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {
                    bearingDelta: Mr(this._vector, i46),
                    pinchAround: t
                };
            }
            _isBelowThreshold(e) {
                this._minDiameter = Math.min(this._minDiameter, e.mag());
                const t44 = 25 / (Math.PI * this._minDiameter) * 360, i46 = this._startVector;
                if (!i46) return !1;
                const o37 = Mr(e, i46);
                return Math.abs(o37) < t44;
            }
        }
        function Dr(e39) {
            return Math.abs(e39.y) > Math.abs(e39.x);
        }
        class Ar extends Tr {
            constructor(e39){
                super(), this._map = e39;
            }
            reset() {
                super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }
            _start(e) {
                this._lastPoints = e, Dr(e[0].sub(e[1])) && (this._valid = !1);
            }
            _move(t, i, o) {
                const r17 = this._lastPoints;
                if (!r17) return;
                const n12 = t[0].sub(r17[0]), s21 = t[1].sub(r17[1]);
                return this._map._cooperativeGestures && !e1.isFullscreen() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n12, s21, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, {
                    pitchDelta: (n12.y + s21.y) / 2 * -0.5
                });
            }
            gestureBeginsVertically(e, t, i) {
                if ((void 0) !== this._valid) return this._valid;
                const o37 = e.mag() >= 2, r17 = t.mag() >= 2;
                if (!o37 && !r17) return;
                if (!o37 || !r17) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;
                const n12 = e.y > 0 == t.y > 0;
                return Dr(e) && Dr(t) && n12;
            }
        }
        const Lr = {
            panStep: 100,
            bearingStep: 15,
            pitchStep: 10
        };
        class zr {
            constructor(){
                const e40 = Lr;
                this._panStep = e40.panStep, this._bearingStep = e40.bearingStep, this._pitchStep = e40.pitchStep, this._rotationDisabled = !1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            keydown(e) {
                if (e.altKey || e.ctrlKey || e.metaKey) return;
                let t44 = 0, i46 = 0, o37 = 0, r17 = 0, n12 = 0;
                switch(e.keyCode){
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        t44 = 1;
                        break;
                    case 189:
                    case 109:
                    case 173:
                        t44 = -1;
                        break;
                    case 37:
                        e.shiftKey ? i46 = -1 : (e.preventDefault(), r17 = -1);
                        break;
                    case 39:
                        e.shiftKey ? i46 = 1 : (e.preventDefault(), r17 = 1);
                        break;
                    case 38:
                        e.shiftKey ? o37 = 1 : (e.preventDefault(), n12 = -1);
                        break;
                    case 40:
                        e.shiftKey ? o37 = -1 : (e.preventDefault(), n12 = 1);
                        break;
                    default:
                        return;
                }
                return this._rotationDisabled && (i46 = 0, o37 = 0), {
                    cameraAnimation: (s21)=>{
                        const a20 = s21.getZoom();
                        s21.easeTo({
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: Pr,
                            zoom: t44 ? Math.round(a20) + t44 * (e.shiftKey ? 2 : 1) : a20,
                            bearing: s21.getBearing() + i46 * this._bearingStep,
                            pitch: s21.getPitch() + o37 * this._pitchStep,
                            offset: [
                                -r17 * this._panStep,
                                -n12 * this._panStep
                            ],
                            center: s21.getCenter()
                        }, {
                            originalEvent: e
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
            disableRotation() {
                this._rotationDisabled = !0;
            }
            enableRotation() {
                this._rotationDisabled = !1;
            }
        }
        function Pr(e41) {
            return e41 * (2 - e41);
        }
        const Rr = 4.000244140625;
        class Or {
            constructor(t44, i46){
                this._map = t44, this._el = t44.getCanvasContainer(), this._handler = i46, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, e1.bindAll([
                    "_onTimeout",
                    "_addScrollZoomBlocker",
                    "_showBlockerAlert"
                ], this);
            }
            setZoomRate(e) {
                this._defaultZoomRate = e;
            }
            setWheelZoomRate(e) {
                this._wheelZoomRate = e;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return this._active || (void 0) !== this._finishTimeout;
            }
            isZooming() {
                return !!this._zooming;
            }
            enable(e) {
                this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
                this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }
            wheel(t) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                    if (!(t.ctrlKey || t.metaKey || this.isZooming() || e1.isFullscreen())) return void this._showBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }
                let i47 = t.deltaMode === e1.window.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
                const o37 = e1.exported.now(), r17 = o37 - (this._lastWheelEventTime || 0);
                this._lastWheelEventTime = o37, 0 !== i47 && i47 % Rr == 0 ? this._type = "wheel" : 0 !== i47 && Math.abs(i47) < 4 ? this._type = "trackpad" : r17 > 400 ? (this._type = null, this._lastValue = i47, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(r17 * i47) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i47 += this._lastValue)), t.shiftKey && i47 && (i47 /= 4), this._type && (this._lastWheelEvent = t, this._delta -= i47, this._active || this._start(t)), t.preventDefault();
            }
            _onTimeout(e) {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e);
            }
            _start(e) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                const t45 = p2(this._el, e);
                this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t45, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
            }
            renderFrame() {
                if (!this._frameId) return;
                if (this._frameId = null, !this.isActive()) return;
                const t45 = this._map.transform;
                "wheel" === this._type && t45.projection.wrap && (t45._center.lng >= 180 || t45._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
                const i47 = ()=>t45._terrainEnabled() && this._aroundCoord ? t45.computeZoomRelativeTo(this._aroundCoord) : t45.zoom
                ;
                if (0 !== this._delta) {
                    const e41 = "wheel" === this._type && Math.abs(this._delta) > Rr ? this._wheelZoomRate : this._defaultZoomRate;
                    let o37 = 2 / (1 + Math.exp(-Math.abs(this._delta * e41)));
                    this._delta < 0 && 0 !== o37 && (o37 = 1 / o37);
                    const r17 = i47(), n12 = Math.pow(2, r17), s21 = "number" == typeof this._targetZoom ? t45.zoomScale(this._targetZoom) : n12;
                    this._targetZoom = Math.min(t45.maxZoom, Math.max(t45.minZoom, t45.scaleZoom(s21 * o37))), "wheel" === this._type && (this._startZoom = r17, this._easing = this._smoothOutEasing(200)), this._delta = 0;
                }
                const o37 = "number" == typeof this._targetZoom ? this._targetZoom : i47(), r17 = this._startZoom, n12 = this._easing;
                let s21, a20 = !1;
                if ("wheel" === this._type && r17 && n12) {
                    const t46 = Math.min((e1.exported.now() - this._lastWheelEventTime) / 200, 1), i48 = n12(t46);
                    s21 = e1.number(r17, o37, i48), t46 < 1 ? this._frameId || (this._frameId = !0) : a20 = !0;
                } else s21 = o37, a20 = !0;
                return this._active = !0, a20 && (this._active = !1, this._finishTimeout = setTimeout(()=>{
                    this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
                }, 200)), {
                    noInertia: !0,
                    needsRenderFrame: !a20,
                    zoomDelta: s21 - i47(),
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent
                };
            }
            _smoothOutEasing(t) {
                let i47 = e1.ease;
                if (this._prevEase) {
                    const t45 = this._prevEase, o37 = (e1.exported.now() - t45.start) / t45.duration, r17 = t45.easing(o37 + 0.01) - t45.easing(o37), n12 = 0.27 / Math.sqrt(r17 * r17 + 0.0001) * 0.01, s21 = Math.sqrt(0.0729 - n12 * n12);
                    i47 = e1.bezier(n12, s21, 0.25, 1);
                }
                return this._prevEase = {
                    start: e1.exported.now(),
                    duration: t,
                    easing: i47
                }, i47;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            _addScrollZoomBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = n1("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e1.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
                }, 200);
            }
        }
        class Br {
            constructor(e41, t45){
                this._clickZoom = e41, this._tapZoom = t45;
            }
            enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
        }
        class kr {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            blur() {
                this.reset();
            }
            dblclick(e, t) {
                return e.preventDefault(), {
                    cameraAnimation: (i47)=>{
                        i47.easeTo({
                            duration: 300,
                            zoom: i47.getZoom() + (e.shiftKey ? -1 : 1),
                            around: i47.unproject(t)
                        }, {
                            originalEvent: e
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Fr {
            constructor(){
                this._tap = new mr({
                    numTouches: 1,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }
            touchstart(e, t, i) {
                this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t, i));
            }
            touchmove(e, t, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch) return;
                        const o37 = t[0], r17 = o37.y - this._swipePoint.y;
                        return this._swipePoint = o37, e.preventDefault(), this._active = !0, {
                            zoomDelta: r17 / 128
                        };
                    }
                } else this._tap.touchmove(e, t, i);
            }
            touchend(e, t, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t, i) && (this._tapTime = e.timeStamp);
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Ur {
            constructor(e42, t46, i47){
                this._el = e42, this._mousePan = t46, this._touchPan = i47;
            }
            enable(e) {
                this._inertiaOptions = e || {
                }, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
                this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
            }
        }
        class Nr {
            constructor(e43, t47, i48){
                this._pitchWithRotate = e43.pitchWithRotate, this._mouseRotate = t47, this._mousePitch = i48;
            }
            enable() {
                this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
        }
        class Gr {
            constructor(e44, t48, i49, o37){
                this._el = e44, this._touchZoom = t48, this._touchRotate = i49, this._tapDragZoom = o37, this._rotationDisabled = !1, this._enabled = !0;
            }
            enable(e) {
                this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
                this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
                this._rotationDisabled = !0, this._touchRotate.disable();
            }
            enableRotation() {
                this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
        }
        const jr = (e45)=>e45.zoom || e45.drag || e45.pitch || e45.rotate
        ;
        class Zr extends e1.Event {
        }
        class Vr {
            constructor(){
                this.constants = [
                    1,
                    1,
                    0.01
                ], this.radius = 0;
            }
            setup(t, i) {
                const o38 = e1.sub([], i, t);
                this.radius = e1.length(o38[2] < 0 ? e1.div([], o38, this.constants) : [
                    o38[0],
                    o38[1],
                    0
                ]);
            }
            projectRay(t) {
                e1.div(t, t, this.constants), e1.normalize(t, t), e1.mul$1(t, t, this.constants);
                const i50 = e1.scale$2([], t, this.radius);
                if (i50[2] > 0) {
                    const t49 = e1.scale$2([], [
                        0,
                        0,
                        1
                    ], e1.dot(i50, [
                        0,
                        0,
                        1
                    ])), o38 = e1.scale$2([], e1.normalize([], [
                        i50[0],
                        i50[1],
                        0
                    ]), this.radius), r17 = e1.add([], i50, e1.scale$2([], e1.sub([], e1.add([], o38, t49), i50), 2));
                    i50[0] = r17[0], i50[1] = r17[1];
                }
                return i50;
            }
        }
        function Wr(e45) {
            return e45.panDelta && e45.panDelta.mag() || e45.zoomDelta || e45.bearingDelta || e45.pitchDelta;
        }
        class Xr {
            constructor(t49, i50){
                this._map = t49, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {
                }, this._changes = [], this._inertia = new rr(t49), this._bearingSnap = i50.bearingSnap, this._previousActiveHandlers = {
                }, this._trackingEllipsoid = new Vr, this._dragOrigin = null, this._eventsInProgress = {
                }, this._addDefaultHandlers(i50), e1.bindAll([
                    "handleEvent",
                    "handleWindowEvent"
                ], this);
                const o38 = this._el;
                this._listeners = [
                    [
                        o38,
                        "touchstart",
                        {
                            passive: !0
                        }
                    ],
                    [
                        o38,
                        "touchmove",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o38,
                        "touchend",
                        void 0
                    ],
                    [
                        o38,
                        "touchcancel",
                        void 0
                    ],
                    [
                        o38,
                        "mousedown",
                        void 0
                    ],
                    [
                        o38,
                        "mousemove",
                        void 0
                    ],
                    [
                        o38,
                        "mouseup",
                        void 0
                    ],
                    [
                        e1.window.document,
                        "mousemove",
                        {
                            capture: !0
                        }
                    ],
                    [
                        e1.window.document,
                        "mouseup",
                        void 0
                    ],
                    [
                        o38,
                        "mouseover",
                        void 0
                    ],
                    [
                        o38,
                        "mouseout",
                        void 0
                    ],
                    [
                        o38,
                        "dblclick",
                        void 0
                    ],
                    [
                        o38,
                        "click",
                        void 0
                    ],
                    [
                        o38,
                        "keydown",
                        {
                            capture: !1
                        }
                    ],
                    [
                        o38,
                        "keyup",
                        void 0
                    ],
                    [
                        o38,
                        "wheel",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o38,
                        "contextmenu",
                        void 0
                    ],
                    [
                        e1.window,
                        "blur",
                        void 0
                    ]
                ];
                for (const [t50, i51, o39] of this._listeners)t50.addEventListener(i51, t50 === e1.window.document ? this.handleWindowEvent : this.handleEvent, o39);
            }
            destroy() {
                for (const [t51, i52, o40] of this._listeners)t51.removeEventListener(i52, t51 === e1.window.document ? this.handleWindowEvent : this.handleEvent, o40);
            }
            _addDefaultHandlers(e) {
                const t51 = this._map, i52 = t51.getCanvasContainer();
                this._add("mapEvent", new hr(t51, e));
                const o40 = t51.boxZoom = new _r(t51, e);
                this._add("boxZoom", o40);
                const r17 = new fr, n12 = new kr;
                t51.doubleClickZoom = new Br(n12, r17), this._add("tapZoom", r17), this._add("clickZoom", n12);
                const s21 = new Fr;
                this._add("tapDragZoom", s21);
                const a20 = t51.touchPitch = new Ar(t51);
                this._add("touchPitch", a20);
                const l21 = new yr(e), c15 = new br(e);
                t51.dragRotate = new Nr(e, l21, c15), this._add("mouseRotate", l21, [
                    "mousePitch"
                ]), this._add("mousePitch", c15, [
                    "mouseRotate"
                ]);
                const h14 = new xr(e), u17 = new wr(t51, e);
                t51.dragPan = new Ur(i52, h14, u17), this._add("mousePan", h14), this._add("touchPan", u17, [
                    "touchZoom",
                    "touchRotate"
                ]);
                const _3 = new Sr, d9 = new Ir;
                t51.touchZoomRotate = new Gr(i52, d9, _3, s21), this._add("touchRotate", _3, [
                    "touchPan",
                    "touchZoom"
                ]), this._add("touchZoom", d9, [
                    "touchPan",
                    "touchRotate"
                ]), this._add("blockableMapEvent", new ur(t51));
                const p12 = t51.scrollZoom = new Or(t51, this);
                this._add("scrollZoom", p12, [
                    "mousePan"
                ]);
                const m8 = t51.keyboard = new zr;
                this._add("keyboard", m8);
                for (const i53 of [
                    "boxZoom",
                    "doubleClickZoom",
                    "tapDragZoom",
                    "touchPitch",
                    "dragRotate",
                    "dragPan",
                    "touchZoomRotate",
                    "scrollZoom",
                    "keyboard"
                ])e.interactive && e[i53] && t51[i53].enable(e[i53]);
            }
            _add(e, t, i) {
                this._handlers.push({
                    handlerName: e,
                    handler: t,
                    allowed: i
                }), this._handlersById[e] = t;
            }
            stop(e) {
                if (!this._updatingCamera) {
                    for (const { handler: e45  } of this._handlers)e45.reset();
                    this._inertia.clear(), this._fireEvents({
                    }, {
                    }, e), this._changes = [];
                }
            }
            isActive() {
                for (const { handler: e45  } of this._handlers)if (e45.isActive()) return !0;
                return !1;
            }
            isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
                return !!this._eventsInProgress.rotate;
            }
            isMoving() {
                return !!jr(this._eventsInProgress) || this.isZooming();
            }
            _isDragging() {
                return !!this._eventsInProgress.drag;
            }
            _blockedByActive(e, t, i) {
                for(const o40 in e)if (o40 !== i && (!t || t.indexOf(o40) < 0)) return !0;
                return !1;
            }
            handleWindowEvent(e) {
                this.handleEvent(e, `${e.type}Window`);
            }
            _getMapTouches(e) {
                const t51 = [];
                for (const i52 of e)this._el.contains(i52.target) && t51.push(i52);
                return t51;
            }
            handleEvent(e, t) {
                this._updatingCamera = !0;
                const i52 = "renderFrame" === e.type, o40 = i52 ? void 0 : e, r17 = {
                    needsRenderFrame: !1
                }, n12 = {
                }, s21 = {
                }, a20 = e.touches ? this._getMapTouches(e.touches) : void 0, l21 = a20 ? m4(this._el, a20) : i52 ? void 0 : p2(this._el, e);
                for (const { handlerName: i53 , handler: c15 , allowed: h14  } of this._handlers){
                    if (!c15.isEnabled()) continue;
                    let u17;
                    this._blockedByActive(s21, h14, i53) ? c15.reset() : c15[t || e.type] && (u17 = c15[t || e.type](e, l21, a20), this.mergeHandlerResult(r17, n12, u17, i53, o40), u17 && u17.needsRenderFrame && this._triggerRenderFrame()), (u17 || c15.isActive()) && (s21[i53] = c15);
                }
                const c16 = {
                };
                for(const e45 in this._previousActiveHandlers)s21[e45] || (c16[e45] = o40);
                this._previousActiveHandlers = s21, (Object.keys(c16).length || Wr(r17)) && (this._changes.push([
                    r17,
                    n12,
                    c16
                ]), this._triggerRenderFrame()), (Object.keys(s21).length || Wr(r17)) && this._map._stop(!0), this._updatingCamera = !1;
                const { cameraAnimation: h15  } = r17;
                h15 && (this._inertia.clear(), this._fireEvents({
                }, {
                }, !0), this._changes = [], h15(this._map));
            }
            mergeHandlerResult(t, i, o, r, n) {
                if (!o) return;
                e1.extend(t, o);
                const s21 = {
                    handlerName: r,
                    originalEvent: o.originalEvent || n
                };
                (void 0) !== o.zoomDelta && (i.zoom = s21), (void 0) !== o.panDelta && (i.drag = s21), (void 0) !== o.pitchDelta && (i.pitch = s21), (void 0) !== o.bearingDelta && (i.rotate = s21);
            }
            _applyChanges() {
                const t51 = {
                }, i52 = {
                }, o40 = {
                };
                for (const [r17, n12, s21] of this._changes)r17.panDelta && (t51.panDelta = (t51.panDelta || new e1.pointGeometry(0, 0))._add(r17.panDelta)), r17.zoomDelta && (t51.zoomDelta = (t51.zoomDelta || 0) + r17.zoomDelta), r17.bearingDelta && (t51.bearingDelta = (t51.bearingDelta || 0) + r17.bearingDelta), r17.pitchDelta && (t51.pitchDelta = (t51.pitchDelta || 0) + r17.pitchDelta), (void 0) !== r17.around && (t51.around = r17.around), (void 0) !== r17.aroundCoord && (t51.aroundCoord = r17.aroundCoord), (void 0) !== r17.pinchAround && (t51.pinchAround = r17.pinchAround), r17.noInertia && (t51.noInertia = r17.noInertia), e1.extend(i52, n12), e1.extend(o40, s21);
                this._updateMapTransform(t51, i52, o40), this._changes = [];
            }
            _updateMapTransform(t, i, o) {
                const r17 = this._map, n12 = r17.transform, s21 = (e45)=>[
                        e45.x,
                        e45.y,
                        e45.z
                    ]
                ;
                if (((e45)=>{
                    const t51 = this._eventsInProgress.drag;
                    return t51 && !this._handlersById[t51.handlerName].isActive();
                })() && !Wr(t)) {
                    const e45 = n12.zoom;
                    n12.cameraElevationReference = "sea", n12.recenterOnTerrain(), n12.cameraElevationReference = "ground", e45 !== n12.zoom && this._map._update(!0);
                }
                if (n12._isCameraConstrained && r17._stop(!0), !Wr(t)) return void this._fireEvents(i, o, !0);
                let { panDelta: a20 , zoomDelta: l21 , bearingDelta: c15 , pitchDelta: h14 , around: u17 , aroundCoord: _3 , pinchAround: d9  } = t;
                n12._isCameraConstrained && (l21 > 0 && (l21 = 0), n12._isCameraConstrained = !1), (void 0) !== d9 && (u17 = d9), ((e45)=>i.drag && !this._eventsInProgress.drag
                )() && u17 && (this._dragOrigin = s21(n12.pointCoordinate3D(u17)), this._trackingEllipsoid.setup(n12._camera.position, this._dragOrigin)), n12.cameraElevationReference = "sea", r17._stop(!0), u17 = u17 || r17.transform.centerPoint, c15 && (n12.bearing += c15), h14 && (n12.pitch += h14), n12._updateCameraState();
                const p12 = [
                    0,
                    0,
                    0
                ];
                if (a20) {
                    if ("mercator" === n12.projection.name) {
                        const e45 = this._trackingEllipsoid.projectRay(n12.screenPointToMercatorRay(u17).dir), t51 = this._trackingEllipsoid.projectRay(n12.screenPointToMercatorRay(u17.sub(a20)).dir);
                        p12[0] = t51[0] - e45[0], p12[1] = t51[1] - e45[1];
                    } else {
                        const t51 = n12.pointCoordinate(u17);
                        if ("globe" === n12.projection.name) {
                            a20 = a20.rotate(-n12.angle);
                            const i52 = n12._pixelsPerMercatorPixel / n12.worldSize;
                            p12[0] = -a20.x * e1.mercatorScale(e1.latFromMercatorY(t51.y)) * i52, p12[1] = -a20.y * e1.mercatorScale(n12.center.lat) * i52;
                        } else {
                            const e45 = n12.pointCoordinate(u17.sub(a20));
                            t51 && e45 && (p12[0] = e45.x - t51.x, p12[1] = e45.y - t51.y);
                        }
                    }
                }
                const m8 = n12.zoom, f9 = [
                    0,
                    0,
                    0
                ];
                if (l21) {
                    const t51 = s21(_3 || n12.pointCoordinate3D(u17)), i52 = {
                        dir: e1.normalize([], e1.sub([], t51, n12._camera.position))
                    };
                    if (i52.dir[2] < 0) {
                        const o40 = n12.zoomDeltaToMovement(t51, l21);
                        e1.scale$2(f9, i52.dir, o40);
                    }
                }
                const g6 = e1.add(p12, p12, f9);
                n12._translateCameraConstrained(g6), l21 && Math.abs(n12.zoom - m8) > 0.0001 && n12.recenterOnTerrain(), n12.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(i, o, !0);
            }
            _fireEvents(t, i, o) {
                const r17 = jr(this._eventsInProgress), n12 = jr(t), s21 = {
                };
                for(const e45 in t){
                    const { originalEvent: i52  } = t[e45];
                    this._eventsInProgress[e45] || (s21[`${e45}start`] = i52), this._eventsInProgress[e45] = t[e45];
                }
                !r17 && n12 && this._fireEvent("movestart", n12.originalEvent);
                for(const e46 in s21)this._fireEvent(e46, s21[e46]);
                n12 && this._fireEvent("move", n12.originalEvent);
                for(const e47 in t){
                    const { originalEvent: i52  } = t[e47];
                    this._fireEvent(e47, i52);
                }
                const a20 = {
                };
                let l21;
                for(const e48 in this._eventsInProgress){
                    const { handlerName: t51 , originalEvent: o40  } = this._eventsInProgress[e48];
                    this._handlersById[t51].isActive() || (delete this._eventsInProgress[e48], l21 = i[t51] || o40, a20[`${e48}end`] = l21);
                }
                for(const e49 in a20)this._fireEvent(e49, a20[e49]);
                const c15 = jr(this._eventsInProgress);
                if (o && (r17 || n12) && !c15) {
                    this._updatingCamera = !0;
                    const t51 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i52 = (e50)=>0 !== e50 && -this._bearingSnap < e50 && e50 < this._bearingSnap
                    ;
                    t51 ? (i52(t51.bearing || this._map.getBearing()) && (t51.bearing = 0), this._map.easeTo(t51, {
                        originalEvent: l21
                    })) : (this._map.fire(new e1.Event("moveend", {
                        originalEvent: l21
                    })), i52(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
                }
            }
            _fireEvent(t, i) {
                this._map.fire(new e1.Event(t, i ? {
                    originalEvent: i
                } : {
                }));
            }
            _requestFrame() {
                return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e45)=>{
                    this._frameId = void 0, this.handleEvent(new Zr("renderFrame", {
                        timeStamp: e45
                    })), this._applyChanges();
                });
            }
            _triggerRenderFrame() {
                (void 0) === this._frameId && (this._frameId = this._requestFrame());
            }
        }
        const qr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class $r extends e1.Evented {
            constructor(t51, i52){
                super(), this._moving = !1, this._zooming = !1, this.transform = t51, this._bearingSnap = i52.bearingSnap, e1.bindAll([
                    "_renderFrameCallback"
                ], this);
            }
            getCenter() {
                return new e1.LngLat(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e, t) {
                return this.jumpTo({
                    center: e
                }, t);
            }
            panBy(t, i, o) {
                return t = e1.pointGeometry.convert(t).mult(-1), this.panTo(this.transform.center, e1.extend({
                    offset: t
                }, i), o);
            }
            panTo(t, i, o) {
                return this.easeTo(e1.extend({
                    center: t
                }, i), o);
            }
            getZoom() {
                return this.transform.zoom;
            }
            setZoom(e, t) {
                return this.jumpTo({
                    zoom: e
                }, t), this;
            }
            zoomTo(t, i, o) {
                return this.easeTo(e1.extend({
                    zoom: t
                }, i), o);
            }
            zoomIn(e, t) {
                return this.zoomTo(this.getZoom() + 1, e, t), this;
            }
            zoomOut(e, t) {
                return this.zoomTo(this.getZoom() - 1, e, t), this;
            }
            getBearing() {
                return this.transform.bearing;
            }
            setBearing(e, t) {
                return this.jumpTo({
                    bearing: e
                }, t), this;
            }
            getPadding() {
                return this.transform.padding;
            }
            setPadding(e, t) {
                return this.jumpTo({
                    padding: e
                }, t), this;
            }
            rotateTo(t, i, o) {
                return this.easeTo(e1.extend({
                    bearing: t
                }, i), o);
            }
            resetNorth(t, i) {
                return this.rotateTo(0, e1.extend({
                    duration: 1000
                }, t), i), this;
            }
            resetNorthPitch(t, i) {
                return this.easeTo(e1.extend({
                    bearing: 0,
                    pitch: 0,
                    duration: 1000
                }, t), i), this;
            }
            snapToNorth(e, t) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;
            }
            getPitch() {
                return this.transform.pitch;
            }
            setPitch(e, t) {
                return this.jumpTo({
                    pitch: e
                }, t), this;
            }
            cameraForBounds(t, i) {
                t = e1.LngLatBounds.convert(t);
                const o40 = i && i.bearing || 0, r17 = i && i.pitch || 0, n12 = t.getNorthWest(), s21 = t.getSouthEast();
                return this._cameraForBounds(this.transform, n12, s21, o40, r17, i);
            }
            _extendCameraOptions(t) {
                const i53 = {
                    top: 0,
                    bottom: 0,
                    right: 0,
                    left: 0
                };
                if ("number" == typeof (t = e1.extend({
                    padding: i53,
                    offset: [
                        0,
                        0
                    ],
                    maxZoom: this.transform.maxZoom
                }, t)).padding) {
                    const e45 = t.padding;
                    t.padding = {
                        top: e45,
                        bottom: e45,
                        right: e45,
                        left: e45
                    };
                }
                return t.padding = e1.extend(i53, t.padding), t;
            }
            _minimumAABBFrustumDistance(e, t) {
                const i53 = t.max[0] - t.min[0], o40 = t.max[1] - t.min[1];
                return i53 / o40 > e.aspect ? i53 / (2 * Math.tan(0.5 * e.fovX) * e.aspect) : o40 / (2 * Math.tan(0.5 * e.fovY) * e.aspect);
            }
            _cameraForBoundsOnGlobe(t, i, o, r, n, s) {
                const a20 = t.clone(), l21 = this._extendCameraOptions(s);
                a20.bearing = r, a20.pitch = n;
                const c15 = e1.LngLat.convert(i), h14 = e1.LngLat.convert(o), u17 = 0.5 * (c15.lat + h14.lat), _3 = 0.5 * (c15.lng + h14.lng), d9 = e1.latLngToECEF(u17, _3), p12 = e1.normalize([], d9), m8 = e1.normalize([], e1.cross([], p12, [
                    0,
                    1,
                    0
                ])), f9 = e1.cross([], m8, p12), g6 = [
                    m8[0],
                    m8[1],
                    m8[2],
                    0,
                    f9[0],
                    f9[1],
                    f9[2],
                    0,
                    p12[0],
                    p12[1],
                    p12[2],
                    0,
                    0,
                    0,
                    0,
                    1
                ], v4 = [
                    d9,
                    e1.latLngToECEF(c15.lat, c15.lng),
                    e1.latLngToECEF(h14.lat, c15.lng),
                    e1.latLngToECEF(h14.lat, h14.lng),
                    e1.latLngToECEF(c15.lat, h14.lng),
                    e1.latLngToECEF(u17, c15.lng),
                    e1.latLngToECEF(u17, h14.lng),
                    e1.latLngToECEF(c15.lat, _3),
                    e1.latLngToECEF(h14.lat, _3)
                ];
                let x4 = e1.Aabb.fromPoints(v4.map((t52)=>[
                        e1.dot(m8, t52),
                        e1.dot(f9, t52),
                        e1.dot(p12, t52)
                    ]
                ));
                const y5 = e1.transformMat4([], x4.center, g6);
                0 === e1.squaredLength(y5) && e1.set(y5, 0, 0, 1), e1.normalize(y5, y5), e1.scale$2(y5, y5, e1.GLOBE_RADIUS), a20.center = e1.ecefToLatLng(y5);
                const b3 = a20.getWorldToCameraMatrix(), w4 = e1.invert(new Float64Array(16), b3);
                x4 = e1.Aabb.applyTransform(x4, e1.multiply([], b3, g6)), e1.transformMat4(y5, y5, b3);
                const T1 = 0.5 * (x4.max[2] - x4.min[2]), E1 = this._minimumAABBFrustumDistance(a20, x4), C1 = e1.scale$2([], [
                    0,
                    0,
                    1
                ], T1), I1 = e1.add(C1, y5, C1), M3 = E1 + (0 === a20.pitch ? 0 : e1.distance(y5, I1)), S3 = a20.globeCenterInViewSpace, D1 = e1.sub([], y5, [
                    S3[0],
                    S3[1],
                    S3[2]
                ]);
                e1.normalize(D1, D1), e1.scale$2(D1, D1, M3);
                const A1 = e1.add([], y5, D1);
                e1.transformMat4(A1, A1, w4);
                const L2 = e1.earthRadius / e1.GLOBE_RADIUS, z1 = e1.length(A1), P3 = e1.mercatorZfromAltitude(z1 * L2 - e1.earthRadius, 0), R1 = Math.min(a20.zoomFromMercatorZAdjusted(P3), l21.maxZoom);
                return R1 > 0.5 * (e1.GLOBE_ZOOM_THRESHOLD_MIN + e1.GLOBE_ZOOM_THRESHOLD_MAX) ? (a20.setProjection({
                    name: "mercator"
                }), a20.zoom = R1, this._cameraForBounds(a20, i, o, r, n, s)) : {
                    center: a20.center,
                    zoom: R1,
                    bearing: r,
                    pitch: n
                };
            }
            queryTerrainElevation(t, i) {
                const o40 = this.transform.elevation;
                return o40 ? (i = e1.extend({
                }, {
                    exaggerated: !0
                }, i), o40.getAtPoint(e1.MercatorCoordinate.fromLngLat(t), null, i.exaggerated)) : null;
            }
            _cameraForBounds(t, i, o, r, n, s) {
                if ("globe" === t.projection.name) return this._cameraForBoundsOnGlobe(t, i, o, r, n, s);
                const a20 = t.clone(), l21 = this._extendCameraOptions(s), c15 = a20.padding;
                a20.bearing = r, a20.pitch = n;
                const h14 = e1.LngLat.convert(i), u17 = e1.LngLat.convert(o), _3 = new e1.LngLat(h14.lng, u17.lat), d9 = new e1.LngLat(u17.lng, h14.lat), p12 = a20.project(h14), m8 = a20.project(u17), f9 = this.queryTerrainElevation(h14), g6 = this.queryTerrainElevation(u17), v4 = this.queryTerrainElevation(_3), x4 = this.queryTerrainElevation(d9), y5 = [
                    [
                        p12.x,
                        p12.y,
                        Math.min(f9 || 0, g6 || 0, v4 || 0, x4 || 0)
                    ],
                    [
                        m8.x,
                        m8.y,
                        Math.max(f9 || 0, g6 || 0, v4 || 0, x4 || 0)
                    ]
                ];
                let b3 = e1.Aabb.fromPoints(y5);
                const w4 = a20.getWorldToCameraMatrix(), T1 = e1.invert(new Float64Array(16), w4);
                b3 = e1.Aabb.applyTransform(b3, w4);
                const E1 = e1.sub([], b3.max, b3.min), C1 = c15.left || 0, I1 = c15.right || 0, M3 = c15.bottom || 0, S3 = c15.top || 0, { left: D1 , right: A1 , top: L2 , bottom: z1  } = l21.padding, P3 = 0.5 * (C1 + I1), R1 = 0.5 * (S3 + M3), O1 = Math.min(a20.scaleZoom(a20.scale * Math.min((a20.width - (C1 + I1 + D1 + A1)) / E1[0], (a20.height - (M3 + S3 + z1 + L2)) / E1[1])), l21.maxZoom), B1 = a20.scale / a20.zoomScale(O1);
                b3 = new e1.Aabb([
                    b3.min[0] - (D1 + P3) * B1,
                    b3.min[1] - (z1 + R1) * B1,
                    b3.min[2]
                ], [
                    b3.max[0] + (A1 + P3) * B1,
                    b3.max[1] + (L2 + R1) * B1,
                    b3.max[2]
                ]);
                const k1 = 0.5 * E1[2], F1 = this._minimumAABBFrustumDistance(a20, b3), U1 = [
                    0,
                    0,
                    1,
                    0
                ];
                e1.transformMat4$1(U1, U1, w4), e1.normalize$2(U1, U1);
                const N1 = e1.scale$2([], U1, F1 + k1), G1 = e1.add([], b3.center, N1), j1 = ("number" == typeof l21.offset.x && "number" == typeof l21.offset.y ? new e1.pointGeometry(l21.offset.x, l21.offset.y) : e1.pointGeometry.convert(l21.offset)).rotate(-e1.degToRad(r));
                b3.center[0] -= j1.x * B1, b3.center[1] += j1.y * B1, e1.transformMat4(b3.center, b3.center, T1), e1.transformMat4(G1, G1, T1);
                const Z1 = [
                    b3.center[0],
                    b3.center[1],
                    G1[2] * a20.pixelsPerMeter
                ];
                e1.scale$2(Z1, Z1, 1 / a20.worldSize);
                const V1 = e1.lngFromMercatorX(Z1[0]), W1 = e1.latFromMercatorY(Z1[1]), X1 = Math.min(a20._zoomFromMercatorZ(Z1[2]), l21.maxZoom), q1 = new e1.LngLat(V1, W1);
                return a20.mercatorFromTransition && X1 < 0.5 * (e1.GLOBE_ZOOM_THRESHOLD_MIN + e1.GLOBE_ZOOM_THRESHOLD_MAX) ? (a20.setProjection({
                    name: "globe"
                }), a20.zoom = X1, this._cameraForBounds(a20, i, o, r, n, s)) : {
                    center: q1,
                    zoom: X1,
                    bearing: r,
                    pitch: n
                };
            }
            fitBounds(e, t, i) {
                const o40 = this.cameraForBounds(e, t);
                return this._fitInternal(o40, t, i);
            }
            fitScreenCoordinates(t, i, o, r, n) {
                const s21 = e1.pointGeometry.convert(t), a20 = e1.pointGeometry.convert(i), l21 = new e1.pointGeometry(Math.min(s21.x, a20.x), Math.min(s21.y, a20.y)), c15 = new e1.pointGeometry(Math.max(s21.x, a20.x), Math.max(s21.y, a20.y));
                if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s21, a20)) return this;
                const h14 = this.transform.pointLocation3D(l21), u17 = this.transform.pointLocation3D(c15), _3 = this.transform.pointLocation3D(new e1.pointGeometry(l21.x, c15.y)), d9 = this.transform.pointLocation3D(new e1.pointGeometry(c15.x, l21.y)), p12 = [
                    Math.min(h14.lng, u17.lng, _3.lng, d9.lng),
                    Math.min(h14.lat, u17.lat, _3.lat, d9.lat)
                ], m8 = [
                    Math.max(h14.lng, u17.lng, _3.lng, d9.lng),
                    Math.max(h14.lat, u17.lat, _3.lat, d9.lat)
                ], f9 = r && r.pitch ? r.pitch : this.getPitch(), g6 = this._cameraForBounds(this.transform, p12, m8, o, f9, r);
                return this._fitInternal(g6, r, n);
            }
            _fitInternal(t, i, o) {
                return t ? (delete (i = e1.extend(t, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;
            }
            jumpTo(t, i) {
                this.stop();
                const o40 = t.preloadOnly ? this.transform.clone() : this.transform;
                let r17 = !1, n12 = !1, s21 = !1;
                return "zoom" in t && o40.zoom !== +t.zoom && (r17 = !0, o40.zoom = +t.zoom), (void 0) !== t.center && (o40.center = e1.LngLat.convert(t.center)), "bearing" in t && o40.bearing !== +t.bearing && (n12 = !0, o40.bearing = +t.bearing), "pitch" in t && o40.pitch !== +t.pitch && (s21 = !0, o40.pitch = +t.pitch), null == t.padding || o40.isPaddingEqual(t.padding) || (o40.padding = t.padding), t.preloadOnly ? (this._preloadTiles(o40), this) : (this.fire(new e1.Event("movestart", i)).fire(new e1.Event("move", i)), r17 && this.fire(new e1.Event("zoomstart", i)).fire(new e1.Event("zoom", i)).fire(new e1.Event("zoomend", i)), n12 && this.fire(new e1.Event("rotatestart", i)).fire(new e1.Event("rotate", i)).fire(new e1.Event("rotateend", i)), s21 && this.fire(new e1.Event("pitchstart", i)).fire(new e1.Event("pitch", i)).fire(new e1.Event("pitchend", i)), this.fire(new e1.Event("moveend", i)));
            }
            getFreeCameraOptions() {
                return this.transform.projection.supportsFreeCamera || e1.warnOnce(qr), this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(t, i) {
                const o40 = this.transform;
                if (!o40.projection.supportsFreeCamera) return e1.warnOnce(qr), this;
                this.stop();
                const r17 = o40.zoom, n12 = o40.pitch, s21 = o40.bearing;
                o40.setFreeCameraOptions(t);
                const a20 = r17 !== o40.zoom, l21 = n12 !== o40.pitch, c15 = s21 !== o40.bearing;
                return this.fire(new e1.Event("movestart", i)).fire(new e1.Event("move", i)), a20 && this.fire(new e1.Event("zoomstart", i)).fire(new e1.Event("zoom", i)).fire(new e1.Event("zoomend", i)), c15 && this.fire(new e1.Event("rotatestart", i)).fire(new e1.Event("rotate", i)).fire(new e1.Event("rotateend", i)), l21 && this.fire(new e1.Event("pitchstart", i)).fire(new e1.Event("pitch", i)).fire(new e1.Event("pitchend", i)), this.fire(new e1.Event("moveend", i)), this;
            }
            easeTo(t, i) {
                this._stop(!1, t.easeId), (!1 === (t = e1.extend({
                    offset: [
                        0,
                        0
                    ],
                    duration: 500,
                    easing: e1.ease
                }, t)).animate || !t.essential && e1.exported.prefersReducedMotion) && (t.duration = 0);
                const o40 = this.transform, r17 = this.getZoom(), n12 = this.getBearing(), s21 = this.getPitch(), a20 = this.getPadding(), l21 = "zoom" in t ? +t.zoom : r17, c15 = "bearing" in t ? this._normalizeBearing(t.bearing, n12) : n12, h14 = "pitch" in t ? +t.pitch : s21, u17 = "padding" in t ? t.padding : o40.padding, _3 = e1.pointGeometry.convert(t.offset);
                let d9, p12, m8;
                if ("globe" === o40.projection.name) {
                    const i53 = e1.MercatorCoordinate.fromLngLat(o40.center), r18 = _3.rotate(-o40.angle);
                    i53.x += r18.x / o40.worldSize, i53.y += r18.y / o40.worldSize;
                    const n13 = i53.toLngLat(), s22 = e1.LngLat.convert(t.center || n13);
                    this._normalizeCenter(s22), d9 = o40.centerPoint.add(r18), p12 = new e1.pointGeometry(i53.x, i53.y).mult(o40.worldSize), m8 = new e1.pointGeometry(e1.mercatorXfromLng(s22.lng), e1.mercatorYfromLat(s22.lat)).mult(o40.worldSize).sub(p12);
                } else {
                    d9 = o40.centerPoint.add(_3);
                    const i53 = o40.pointLocation(d9), r18 = e1.LngLat.convert(t.center || i53);
                    this._normalizeCenter(r18), p12 = o40.project(i53), m8 = o40.project(r18).sub(p12);
                }
                const f9 = o40.zoomScale(l21 - r17);
                let g6, v4;
                t.around && (g6 = e1.LngLat.convert(t.around), v4 = o40.locationPoint(g6));
                const x4 = this._zooming || l21 !== r17, y5 = this._rotating || n12 !== c15, b3 = this._pitching || h14 !== s21, w4 = !o40.isPaddingEqual(u17), T1 = (o41)=>(T2)=>{
                        if (x4 && (o41.zoom = e1.number(r17, l21, T2)), y5 && (o41.bearing = e1.number(n12, c15, T2)), b3 && (o41.pitch = e1.number(s21, h14, T2)), w4 && (o41.interpolatePadding(a20, u17, T2), d9 = o41.centerPoint.add(_3)), g6) o41.setLocationAtPoint(g6, v4);
                        else {
                            const e45 = o41.zoomScale(o41.zoom - r17), t52 = l21 > r17 ? Math.min(2, f9) : Math.max(0.5, f9), i53 = Math.pow(t52, 1 - T2), n13 = o41.unproject(p12.add(m8.mult(T2 * i53)).mult(e45));
                            o41.setLocationAtPoint(o41.renderWorldCopies ? n13.wrap() : n13, d9);
                        }
                        return t.preloadOnly || this._fireMoveEvents(i), o41;
                    }
                ;
                if (t.preloadOnly) {
                    const e45 = this._emulate(T1, t.duration, o40);
                    return this._preloadTiles(e45), this;
                }
                const E1 = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching
                };
                return this._zooming = x4, this._rotating = y5, this._pitching = b3, this._padding = w4, this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, E1), this._ease(T1(o40), (e45)=>{
                    o40.recenterOnTerrain(), this._afterEase(i, e45);
                }, t), this;
            }
            _prepareEase(t, i, o = {
            }) {
                this._moving = !0, this.transform.cameraElevationReference = "sea", i || o.moving || this.fire(new e1.Event("movestart", t)), this._zooming && !o.zooming && this.fire(new e1.Event("zoomstart", t)), this._rotating && !o.rotating && this.fire(new e1.Event("rotatestart", t)), this._pitching && !o.pitching && this.fire(new e1.Event("pitchstart", t));
            }
            _fireMoveEvents(t) {
                this.fire(new e1.Event("move", t)), this._zooming && this.fire(new e1.Event("zoom", t)), this._rotating && this.fire(new e1.Event("rotate", t)), this._pitching && this.fire(new e1.Event("pitch", t));
            }
            _afterEase(t, i) {
                if (this._easeId && i && this._easeId === i) return;
                this._easeId = void 0, this.transform.cameraElevationReference = "ground";
                const o40 = this._zooming, r17 = this._rotating, n12 = this._pitching;
                this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o40 && this.fire(new e1.Event("zoomend", t)), r17 && this.fire(new e1.Event("rotateend", t)), n12 && this.fire(new e1.Event("pitchend", t)), this.fire(new e1.Event("moveend", t));
            }
            flyTo(t, i) {
                if (!t.essential && e1.exported.prefersReducedMotion) {
                    const o40 = e1.pick(t, [
                        "center",
                        "zoom",
                        "bearing",
                        "pitch",
                        "around"
                    ]);
                    return this.jumpTo(o40, i);
                }
                this.stop(), t = e1.extend({
                    offset: [
                        0,
                        0
                    ],
                    speed: 1.2,
                    curve: 1.42,
                    easing: e1.ease
                }, t);
                const o40 = this.transform, r17 = this.getZoom(), n12 = this.getBearing(), s21 = this.getPitch(), a20 = this.getPadding(), l21 = "zoom" in t ? e1.clamp(+t.zoom, o40.minZoom, o40.maxZoom) : r17, c15 = "bearing" in t ? this._normalizeBearing(t.bearing, n12) : n12, h14 = "pitch" in t ? +t.pitch : s21, u17 = "padding" in t ? t.padding : o40.padding, _3 = o40.zoomScale(l21 - r17), d9 = e1.pointGeometry.convert(t.offset);
                let p12 = o40.centerPoint.add(d9);
                const m8 = o40.pointLocation(p12), f9 = e1.LngLat.convert(t.center || m8);
                this._normalizeCenter(f9);
                const g6 = o40.project(m8), v4 = o40.project(f9).sub(g6);
                let x4 = t.curve;
                const y5 = Math.max(o40.width, o40.height), b3 = y5 / _3, w4 = v4.mag();
                if ("minZoom" in t) {
                    const i53 = e1.clamp(Math.min(t.minZoom, r17, l21), o40.minZoom, o40.maxZoom), n13 = y5 / o40.zoomScale(i53 - r17);
                    x4 = Math.sqrt(n13 / w4 * 2);
                }
                const T1 = x4 * x4;
                function E1(e45) {
                    const t52 = (b3 * b3 - y5 * y5 + (e45 ? -1 : 1) * T1 * T1 * w4 * w4) / (2 * (e45 ? b3 : y5) * T1 * w4);
                    return Math.log(Math.sqrt(t52 * t52 + 1) - t52);
                }
                function C1(e45) {
                    return (Math.exp(e45) - Math.exp(-e45)) / 2;
                }
                function I1(e45) {
                    return (Math.exp(e45) + Math.exp(-e45)) / 2;
                }
                const M3 = E1(0);
                let S3 = function(e45) {
                    return I1(M3) / I1(M3 + x4 * e45);
                }, D1 = function(e45) {
                    var t52;
                    return y5 * ((I1(M3) * (C1(t52 = M3 + x4 * e45) / I1(t52)) - C1(M3)) / T1) / w4;
                }, A1 = (E1(1) - M3) / x4;
                if (Math.abs(w4) < 0.000001 || !isFinite(A1)) {
                    if (Math.abs(y5 - b3) < 0.000001) return this.easeTo(t, i);
                    const e45 = b3 < y5 ? -1 : 1;
                    A1 = Math.abs(Math.log(b3 / y5)) / x4, D1 = function() {
                        return 0;
                    }, S3 = function(t52) {
                        return Math.exp(e45 * x4 * t52);
                    };
                }
                t.duration = "duration" in t ? +t.duration : 1000 * A1 / ("screenSpeed" in t ? +t.screenSpeed / x4 : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);
                const L2 = n12 !== c15, z1 = h14 !== s21, P3 = !o40.isPaddingEqual(u17), R1 = (o41)=>(_4)=>{
                        const m9 = _4 * A1, x5 = 1 / S3(m9);
                        o41.zoom = 1 === _4 ? l21 : r17 + o41.scaleZoom(x5), L2 && (o41.bearing = e1.number(n12, c15, _4)), z1 && (o41.pitch = e1.number(s21, h14, _4)), P3 && (o41.interpolatePadding(a20, u17, _4), p12 = o41.centerPoint.add(d9));
                        const y6 = 1 === _4 ? f9 : o41.unproject(g6.add(v4.mult(D1(m9))).mult(x5));
                        return o41.setLocationAtPoint(o41.renderWorldCopies ? y6.wrap() : y6, p12), o41._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(i), o41;
                    }
                ;
                if (t.preloadOnly) {
                    const e45 = this._emulate(R1, t.duration, o40);
                    return this._preloadTiles(e45), this;
                }
                return this._zooming = !0, this._rotating = L2, this._pitching = z1, this._padding = P3, this._prepareEase(i, !1), this._ease(R1(o40), ()=>this._afterEase(i)
                , t), this;
            }
            isEasing() {
                return !!this._easeFrameId;
            }
            stop() {
                return this._stop();
            }
            _stop(e, t) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                    const e45 = this._onEaseEnd;
                    this._onEaseEnd = void 0, e45.call(this, t);
                }
                if (!e) {
                    const e45 = this.handlers;
                    e45 && e45.stop(!1);
                }
                return this;
            }
            _ease(t, i, o) {
                !1 === o.animate || 0 === o.duration ? (t(1), i()) : (this._easeStart = e1.exported.now(), this._easeOptions = o, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
                const t52 = Math.min((e1.exported.now() - this._easeStart) / this._easeOptions.duration, 1), i53 = this._onEaseFrame;
                i53 && i53(this._easeOptions.easing(t52)), t52 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(t, i) {
                t = e1.wrap(t, -180, 180);
                const o40 = Math.abs(t - i);
                return Math.abs(t - 360 - i) < o40 && (t -= 360), Math.abs(t + 360 - i) < o40 && (t += 360), t;
            }
            _normalizeCenter(e) {
                const t52 = this.transform;
                if (!t52.renderWorldCopies || t52.maxBounds) return;
                const i53 = e.lng - t52.center.lng;
                e.lng += i53 > 180 ? -360 : i53 < -180 ? 360 : 0;
            }
            _emulate(e, t, i) {
                const o40 = Math.ceil(15 * t / 1000), r17 = [], n12 = e(i.clone());
                for(let e45 = 0; e45 <= o40; e45++){
                    const t52 = n12(e45 / o40);
                    r17.push(t52.clone());
                }
                return r17;
            }
        }
        class Hr {
            constructor(t52 = {
            }){
                this.options = t52, e1.bindAll([
                    "_toggleAttribution",
                    "_updateEditLink",
                    "_updateData",
                    "_updateCompact"
                ], this);
            }
            getDefaultPosition() {
                return "bottom-right";
            }
            onAdd(e) {
                const t53 = this.options && this.options.compact;
                return this._map = e, this._container = n1("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n1("button", "mapboxgl-ctrl-attrib-button", this._container), n1("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n1("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t53 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), (void 0) === t53 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(e, t) {
                const i53 = this._map._getUIString(`AttributionControl.${t}`);
                e.setAttribute("aria-label", i53), e.removeAttribute("title"), e.firstElementChild && e.firstElementChild.setAttribute("title", i53);
            }
            _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
                let t53 = this._editLink;
                t53 || (t53 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                const i53 = [
                    {
                        key: "owner",
                        value: this.styleOwner
                    },
                    {
                        key: "id",
                        value: this.styleId
                    },
                    {
                        key: "access_token",
                        value: this._map._requestManager._customAccessToken || e1.config.ACCESS_TOKEN
                    }
                ];
                if (t53) {
                    const o40 = i53.reduce((e45, t54, o41)=>(t54.value && (e45 += `${t54.key}=${t54.value}${o41 < i53.length - 1 ? "&" : ""}`), e45)
                    , "?");
                    t53.href = `${e1.config.FEEDBACK_URL}/${o40}#${Jo(this._map, !0)}`, t53.rel = "noopener nofollow", this._setElementTitle(t53, "MapFeedback");
                }
            }
            _updateData(e) {
                !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
                if (!this._map.style) return;
                let e45 = [];
                if (this._map.style.stylesheet) {
                    const e46 = this._map.style.stylesheet;
                    this.styleOwner = e46.owner, this.styleId = e46.id;
                }
                const t53 = this._map.style._sourceCaches;
                for(const i53 in t53){
                    const o40 = t53[i53];
                    if (o40.used) {
                        const t54 = o40.getSource();
                        t54.attribution && e45.indexOf(t54.attribution) < 0 && e45.push(t54.attribution);
                    }
                }
                e45.sort((e46, t54)=>e46.length - t54.length
                ), e45 = e45.filter((t54, i54)=>{
                    for(let o40 = i54 + 1; o40 < e45.length; o40++)if (e45[o40].indexOf(t54) >= 0) return !1;
                    return !0;
                }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e45 = [
                    ...this.options.customAttribution,
                    ...e45
                ] : e45.unshift(this.options.customAttribution));
                const i54 = e45.join(" | ");
                i54 !== this._attribHTML && (this._attribHTML = i54, e45.length ? (this._innerContainer.innerHTML = i54, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
        }
        class Yr {
            constructor(){
                e1.bindAll([
                    "_updateLogo",
                    "_updateCompact"
                ], this);
            }
            onAdd(e) {
                this._map = e, this._container = n1("div", "mapboxgl-ctrl");
                const t53 = n1("a", "mapboxgl-ctrl-logo");
                return t53.target = "_blank", t53.rel = "noopener nofollow", t53.href = "https://www.mapbox.com/", t53.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t53.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t53), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
                return "bottom-left";
            }
            _updateLogo(e) {
                e && "metadata" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
                if (!this._map.style) return !0;
                const e45 = this._map.style._sourceCaches;
                if (0 === Object.entries(e45).length) return !0;
                for(const t53 in e45){
                    const i53 = e45[t53].getSource();
                    if (i53.hasOwnProperty("mapbox_logo") && !i53.mapbox_logo) return !1;
                }
                return !0;
            }
            _updateCompact() {
                const e45 = this._container.children;
                if (e45.length) {
                    const t53 = e45[0];
                    this._map.getCanvasContainer().offsetWidth < 250 ? t53.classList.add("mapboxgl-compact") : t53.classList.remove("mapboxgl-compact");
                }
            }
        }
        class Kr {
            constructor(){
                this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
            }
            add(e) {
                const t53 = ++this._id;
                return this._queue.push({
                    callback: e,
                    id: t53,
                    cancelled: !1
                }), t53;
            }
            remove(e) {
                const t53 = this._currentlyRunning, i53 = t53 ? this._queue.concat(t53) : this._queue;
                for (const t54 of i53)if (t54.id === e) return void (t54.cancelled = !0);
            }
            run(e = 0) {
                const t53 = this._currentlyRunning = this._queue;
                this._queue = [];
                for (const i53 of t53)if (!i53.cancelled && (i53.callback(e), this._cleared)) break;
                this._cleared = !1, this._currentlyRunning = !1;
            }
            clear() {
                this._currentlyRunning && (this._cleared = !0), this._queue = [];
            }
        }
        function Jr(t53, i53, o40) {
            if (t53 = new e1.LngLat(t53.lng, t53.lat), i53) {
                const r17 = new e1.LngLat(t53.lng - 360, t53.lat), n12 = new e1.LngLat(t53.lng + 360, t53.lat), s21 = 360 * Math.ceil(Math.abs(t53.lng - o40.center.lng) / 360), a20 = o40.locationPoint(t53).distSqr(i53), l21 = i53.x < 0 || i53.y < 0 || i53.x > o40.width || i53.y > o40.height;
                o40.locationPoint(r17).distSqr(i53) < a20 && (l21 || Math.abs(r17.lng - o40.center.lng) < s21) ? t53 = r17 : o40.locationPoint(n12).distSqr(i53) < a20 && (l21 || Math.abs(n12.lng - o40.center.lng) < s21) && (t53 = n12);
            }
            for(; Math.abs(t53.lng - o40.center.lng) > 180;){
                const e45 = o40.locationPoint(t53);
                if (e45.x >= 0 && e45.y >= 0 && e45.x <= o40.width && e45.y <= o40.height) break;
                t53.lng > o40.center.lng ? t53.lng -= 360 : t53.lng += 360;
            }
            return t53;
        }
        const Qr = {
            center: "translate(-50%,-50%)",
            top: "translate(-50%,0)",
            "top-left": "translate(0,0)",
            "top-right": "translate(-100%,0)",
            bottom: "translate(-50%,-100%)",
            "bottom-left": "translate(0,-100%)",
            "bottom-right": "translate(-100%,-100%)",
            left: "translate(0,-50%)",
            right: "translate(-100%,-50%)"
        };
        class en extends e1.Evented {
            constructor(t53, i53){
                if (super(), (t53 instanceof e1.window.HTMLElement || i53) && (t53 = e1.extend({
                    element: t53
                }, i53)), e1.bindAll([
                    "_update",
                    "_onMove",
                    "_onUp",
                    "_addDragHandler",
                    "_onMapClick",
                    "_onKeyPress",
                    "_clearFadeTimer"
                ], this), this._anchor = t53 && t53.anchor || "center", this._color = t53 && t53.color || "#3FB1CE", this._scale = t53 && t53.scale || 1, this._draggable = t53 && t53.draggable || !1, this._clickTolerance = t53 && t53.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t53 && t53.rotation || 0, this._rotationAlignment = t53 && t53.rotationAlignment || "auto", this._pitchAlignment = t53 && t53.pitchAlignment && t53.pitchAlignment || "auto", this._updateMoving = ()=>this._update(!0)
                , this._occludedOpacity = t53 && t53.occludedOpacity || 0.2, t53 && t53.element) this._element = t53.element, this._offset = e1.pointGeometry.convert(t53 && t53.offset || [
                    0,
                    0
                ]);
                else {
                    this._defaultMarker = !0, this._element = n1("div");
                    const i54 = 41, o40 = 27, r17 = s3("svg", {
                        display: "block",
                        height: i54 * this._scale + "px",
                        width: o40 * this._scale + "px",
                        viewBox: `0 0 ${o40} ${i54}`
                    }, this._element), a20 = s3("radialGradient", {
                        id: "shadowGradient"
                    }, s3("defs", {
                    }, r17));
                    s3("stop", {
                        offset: "10%",
                        "stop-opacity": 0.4
                    }, a20), s3("stop", {
                        offset: "100%",
                        "stop-opacity": 0.05
                    }, a20), s3("ellipse", {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)"
                    }, r17), s3("path", {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                    }, r17), s3("path", {
                        opacity: 0.25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                    }, r17), s3("circle", {
                        fill: "white",
                        cx: 13.5,
                        cy: 13.5,
                        r: 5.5
                    }, r17), this._offset = e1.pointGeometry.convert(t53 && t53.offset || [
                        0,
                        -14
                    ]);
                }
                this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e45)=>{
                    e45.preventDefault();
                }), this._element.addEventListener("mousedown", (e45)=>{
                    e45.preventDefault();
                });
                const o40 = this._element.classList;
                for(const e45 in Qr)o40.remove(`mapboxgl-marker-anchor-${e45}`);
                o40.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
            }
            addTo(e) {
                return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on("move", this._updateMoving), e.on("moveend", this._update), e.on("remove", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on("click", this._onMapClick)), this;
            }
            remove() {
                const e46 = this._map;
                return e46 && (e46.off("click", this._onMapClick), e46.off("move", this._updateMoving), e46.off("moveend", this._update), e46.off("mousedown", this._addDragHandler), e46.off("touchstart", this._addDragHandler), e46.off("mouseup", this._onUp), e46.off("touchend", this._onUp), e46.off("mousemove", this._onMove), e46.off("touchmove", this._onMove), e46.off("remove", this._clearFadeTimer), e46._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
                return this._lngLat;
            }
            setLngLat(t) {
                return this._lngLat = e1.LngLat.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
            }
            getElement() {
                return this._element;
            }
            setPopup(e) {
                if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
                    if (!("offset" in e.options)) {
                        const t54 = 38.1, i54 = 13.5, o41 = Math.sqrt(Math.pow(i54, 2) / 2);
                        e.options.offset = this._defaultMarker ? {
                            top: [
                                0,
                                0
                            ],
                            "top-left": [
                                0,
                                0
                            ],
                            "top-right": [
                                0,
                                0
                            ],
                            bottom: [
                                0,
                                -t54
                            ],
                            "bottom-left": [
                                o41,
                                -1 * (t54 - i54 + o41)
                            ],
                            "bottom-right": [
                                -o41,
                                -1 * (t54 - i54 + o41)
                            ],
                            left: [
                                i54,
                                -1 * (t54 - i54)
                            ],
                            right: [
                                -i54,
                                -1 * (t54 - i54)
                            ]
                        } : this._offset;
                    }
                    this._popup = e, e._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
                }
                return this;
            }
            _onKeyPress(e) {
                const t54 = e.code, i54 = e.charCode || e.keyCode;
                "Space" !== t54 && "Enter" !== t54 && 32 !== i54 && 13 !== i54 || this.togglePopup();
            }
            _onMapClick(e) {
                const t54 = e.originalEvent.target, i54 = this._element;
                this._popup && (t54 === i54 || i54.contains(t54)) && this.togglePopup();
            }
            getPopup() {
                return this._popup;
            }
            togglePopup() {
                const e46 = this._popup;
                return e46 ? (e46.isOpen() ? (e46.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e46.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }
            _behindTerrain() {
                const e46 = this._map, t54 = this._pos;
                if (!e46 || !t54) return !1;
                const i54 = e46.unproject(t54), o41 = e46.getFreeCameraOptions();
                if (!o41.position) return !1;
                const r17 = o41.position.toLngLat();
                return r17.distanceTo(i54) < 0.9 * r17.distanceTo(this._lngLat);
            }
            _evaluateOpacity() {
                const t54 = this._map;
                if (!t54) return;
                const i54 = this._pos;
                if (!i54 || i54.x < 0 || i54.x > t54.transform.width || i54.y < 0 || i54.y > t54.transform.height) return void this._clearFadeTimer();
                const o41 = t54.unproject(i54);
                let r17;
                t54._showingGlobe() && e1.isLngLatBehindGlobe(t54.transform, this._lngLat) ? r17 = 0 : (r17 = 1 - t54._queryFogOpacity(o41), t54.transform._terrainEnabled() && t54.getTerrain() && this._behindTerrain() && (r17 *= this._occludedOpacity)), this._element.style.opacity = `${r17}`, this._element.style.pointerEvents = r17 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r17), this._fadeTimer = null;
            }
            _clearFadeTimer() {
                this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _updateDOM() {
                const e46 = this._pos;
                if (!e46 || !this._map) return;
                const t54 = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${e46.x}px,${e46.y}px)\n            ${Qr[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t54.x}px,${t54.y}px)\n        `;
            }
            _calculateXYTransform() {
                const t54 = this._pos, i54 = this._map, o41 = this.getPitchAlignment();
                if (!i54 || !t54 || "map" !== o41) return "";
                if (!i54._showingGlobe()) {
                    const e46 = i54.getPitch();
                    return e46 ? `rotateX(${e46}deg)` : "";
                }
                const r17 = e1.radToDeg(e1.globeTiltAtLngLat(i54.transform, this._lngLat)), n12 = t54.sub(e1.globeCenterToScreenPoint(i54.transform)), s21 = Math.abs(n12.x) + Math.abs(n12.y);
                if (0 === s21) return "";
                const a20 = r17 / s21;
                return `rotateX(${-n12.y * a20}deg) rotateY(${n12.x * a20}deg)`;
            }
            _calculateZTransform() {
                const t54 = this._pos, i54 = this._map;
                if (!i54 || !t54) return "";
                let o41 = 0;
                const r17 = this.getRotationAlignment();
                if ("map" === r17) {
                    if (i54._showingGlobe()) {
                        const t55 = i54.project(new e1.LngLat(this._lngLat.lng, this._lngLat.lat + 0.001)), r18 = i54.project(new e1.LngLat(this._lngLat.lng, this._lngLat.lat - 0.001)).sub(t55);
                        o41 = e1.radToDeg(Math.atan2(r18.y, r18.x)) - 90;
                    } else o41 = -i54.getBearing();
                } else if ("horizon" === r17) {
                    const r18 = e1.smoothstep(4, 6, i54.getZoom()), n12 = e1.globeCenterToScreenPoint(i54.transform);
                    n12.y += r18 * i54.transform.height;
                    const s21 = t54.sub(n12), a20 = e1.radToDeg(Math.atan2(s21.y, s21.x));
                    o41 = (a20 > 90 ? a20 - 270 : a20 + 90) * (1 - r18);
                }
                return o41 += this._rotation, o41 ? `rotateZ(${o41}deg)` : "";
            }
            _update(t) {
                e1.window.cancelAnimationFrame(this._updateFrameId);
                const i54 = this._map;
                i54 && (i54.transform.renderWorldCopies && (this._lngLat = Jr(this._lngLat, this._pos, i54.transform)), this._pos = i54.project(this._lngLat), !0 === t ? this._updateFrameId = e1.window.requestAnimationFrame(()=>{
                    this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
                }) : this._pos = this._pos.round(), i54._requestDomTask(()=>{
                    this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i54._showingGlobe() || i54.getTerrain() || i54.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
                }));
            }
            getOffset() {
                return this._offset;
            }
            setOffset(t) {
                return this._offset = e1.pointGeometry.convert(t), this._update(), this;
            }
            _onMove(t) {
                const i54 = this._map;
                if (!i54) return;
                const o41 = this._pointerdownPos, r17 = this._positionDelta;
                if (o41 && r17) {
                    if (!this._isDragging) {
                        const e46 = this._clickTolerance || i54._clickTolerance;
                        if (t.point.dist(o41) < e46) return;
                        this._isDragging = !0;
                    }
                    this._pos = t.point.sub(r17), this._lngLat = i54.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e1.Event("dragstart"))), this.fire(new e1.Event("drag"));
                }
            }
            _onUp() {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
                const t54 = this._map;
                t54 && (t54.off("mousemove", this._onMove), t54.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e1.Event("dragend")), this._state = "inactive";
            }
            _addDragHandler(e) {
                const t54 = this._map, i54 = this._pos;
                t54 && i54 && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i54), this._pointerdownPos = e.point, this._state = "pending", t54.on("mousemove", this._onMove), t54.on("touchmove", this._onMove), t54.once("mouseup", this._onUp), t54.once("touchend", this._onUp));
            }
            setDraggable(e) {
                this._draggable = !!e;
                const t54 = this._map;
                return t54 && (e ? (t54.on("mousedown", this._addDragHandler), t54.on("touchstart", this._addDragHandler)) : (t54.off("mousedown", this._addDragHandler), t54.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
                return this._draggable;
            }
            setRotation(e) {
                return this._rotation = e || 0, this._update(), this;
            }
            getRotation() {
                return this._rotation;
            }
            setRotationAlignment(e) {
                return this._rotationAlignment = e || "auto", this._update(), this;
            }
            getRotationAlignment() {
                return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }
            setPitchAlignment(e) {
                return this._pitchAlignment = e || "auto", this._update(), this;
            }
            getPitchAlignment() {
                return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }
            setOccludedOpacity(e) {
                return this._occludedOpacity = e || 0.2, this._update(), this;
            }
            getOccludedOpacity() {
                return this._occludedOpacity;
            }
        }
        const tn = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px"
        }, on = [
            "a[href]",
            "[tabindex]:not([tabindex='-1'])",
            "[contenteditable]:not([contenteditable='false'])",
            "button:not([disabled])",
            "input:not([disabled])",
            "select:not([disabled])",
            "textarea:not([disabled])"
        ].join(", ");
        function rn(t54 = new e1.pointGeometry(0, 0), i54 = "bottom") {
            if ("number" == typeof t54) {
                const o41 = Math.round(Math.sqrt(0.5 * Math.pow(t54, 2)));
                switch(i54){
                    case "top":
                        return new e1.pointGeometry(0, t54);
                    case "top-left":
                        return new e1.pointGeometry(o41, o41);
                    case "top-right":
                        return new e1.pointGeometry(-o41, o41);
                    case "bottom":
                        return new e1.pointGeometry(0, -t54);
                    case "bottom-left":
                        return new e1.pointGeometry(o41, -o41);
                    case "bottom-right":
                        return new e1.pointGeometry(-o41, -o41);
                    case "left":
                        return new e1.pointGeometry(t54, 0);
                    case "right":
                        return new e1.pointGeometry(-t54, 0);
                }
                return new e1.pointGeometry(0, 0);
            }
            return t54 instanceof e1.pointGeometry || Array.isArray(t54) ? e1.pointGeometry.convert(t54) : e1.pointGeometry.convert(t54[i54] || [
                0,
                0
            ]);
        }
        class nn {
            constructor(e46){
                this.jumpTo(e46);
            }
            getValue(t) {
                if (t <= this._startTime) return this._start;
                if (t >= this._endTime) return this._end;
                const i54 = e1.easeCubicInOut((t - this._startTime) / (this._endTime - this._startTime));
                return this._start * (1 - i54) + this._end * i54;
            }
            isEasing(e) {
                return e >= this._startTime && e <= this._endTime;
            }
            jumpTo(e) {
                this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;
            }
            easeTo(e, t, i) {
                this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + i;
            }
        }
        const sn = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "AttributionControl.MapFeedback": "Map feedback",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "Mapbox logo",
            "Map.Title": "Map",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
            "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map",
            "TouchPanBlocker.Message": "Use two fingers to move the map"
        }, an = {
            center: [
                0,
                0
            ],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 85,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            performanceMetricsCollection: !0,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            optimizeForTerrain: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            minTileCacheSize: null,
            maxTileCacheSize: null,
            localIdeographFontFamily: "sans-serif",
            localFontFamily: null,
            transformRequest: null,
            accessToken: null,
            fadeDuration: 300,
            crossSourceCollisions: !0
        }, ln = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
        };
        class cn {
            constructor(t54, i54, o41 = !1){
                this._clickTolerance = 10, this.element = i54, this.mouseRotate = new yr({
                    clickTolerance: t54.dragRotate._mouseRotate._clickTolerance
                }), this.map = t54, o41 && (this.mousePitch = new br({
                    clickTolerance: t54.dragRotate._mousePitch._clickTolerance
                })), e1.bindAll([
                    "mousedown",
                    "mousemove",
                    "mouseup",
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "reset"
                ], this), i54.addEventListener("mousedown", this.mousedown), i54.addEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), i54.addEventListener("touchmove", this.touchmove), i54.addEventListener("touchend", this.touchend), i54.addEventListener("touchcancel", this.reset);
            }
            down(e, t) {
                this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), h2();
            }
            move(e, t) {
                const i55 = this.map, o42 = this.mouseRotate.mousemoveWindow(e, t), r17 = o42 && o42.bearingDelta;
                if (r17 && i55.setBearing(i55.getBearing() + r17), this.mousePitch) {
                    const o43 = this.mousePitch.mousemoveWindow(e, t), r18 = o43 && o43.pitchDelta;
                    r18 && i55.setPitch(i55.getPitch() + r18);
                }
            }
            off() {
                const e47 = this.element;
                e47.removeEventListener("mousedown", this.mousedown), e47.removeEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), e47.removeEventListener("touchmove", this.touchmove), e47.removeEventListener("touchend", this.touchend), e47.removeEventListener("touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
                u3(), e1.window.removeEventListener("mousemove", this.mousemove), e1.window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(t) {
                this.down(e1.extend({
                }, t, {
                    ctrlKey: !0,
                    preventDefault: ()=>t.preventDefault()
                }), p2(this.element, t)), e1.window.addEventListener("mousemove", this.mousemove), e1.window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(e) {
                this.move(e, p2(this.element, e));
            }
            mouseup(e) {
                this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();
            }
            touchstart(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m4(this.element, e.targetTouches)[0], this.down({
                    type: "mousedown",
                    button: 0,
                    ctrlKey: !0,
                    preventDefault: ()=>e.preventDefault()
                }, this._startPos));
            }
            touchmove(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._lastPos = m4(this.element, e.targetTouches)[0], this.move({
                    preventDefault: ()=>e.preventDefault()
                }, this._lastPos));
            }
            touchend(e) {
                0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
        }
        const hn = {
            positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6000
            },
            fitBoundsOptions: {
                maxZoom: 15
            },
            trackUserLocation: !1,
            showAccuracyCircle: !0,
            showUserLocation: !0,
            showUserHeading: !1
        }, un = {
            maxWidth: 100,
            unit: "metric"
        };
        function _n(e47, t55, i55) {
            const o42 = dn(t55), r17 = o42 / t55, n12 = {
                kilometer: "km",
                meter: "m",
                mile: "mi",
                foot: "ft",
                "nautical-mile": "nm"
            }[i55];
            this._map._requestDomTask(()=>{
                this._container.style.width = e47 * r17 + "px", this._container.innerHTML = `${o42}&nbsp;${n12}`;
            });
        }
        function dn(e47) {
            const t55 = Math.pow(10, `${Math.floor(e47)}`.length - 1);
            let i55 = e47 / t55;
            return i55 = i55 >= 10 ? 10 : i55 >= 5 ? 5 : i55 >= 3 ? 3 : i55 >= 2 ? 2 : i55 >= 1 ? 1 : (function(e48) {
                const t56 = Math.pow(10, Math.ceil(-Math.log(e48) / Math.LN10));
                return Math.round(e48 * t56) / t56;
            })(i55), t55 * i55;
        }
        const pn = {
            version: e1.version,
            supported: i2,
            setRTLTextPlugin: e1.setRTLTextPlugin,
            getRTLTextPluginStatus: e1.getRTLTextPluginStatus,
            Map: class extends $r {
                constructor(t55){
                    if (e1.LivePerformanceUtils.mark(e1.PerformanceMarkers.create), null != (t55 = e1.extend({
                    }, an, t55)).minZoom && null != t55.maxZoom && t55.minZoom > t55.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                    if (null != t55.minPitch && null != t55.maxPitch && t55.minPitch > t55.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                    if (null != t55.minPitch && t55.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (null != t55.maxPitch && t55.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t55.antialias && e1.isSafariWithAntialiasingBug(e1.window) && (t55.antialias = !1, e1.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ho(t55.minZoom, t55.maxZoom, t55.minPitch, t55.maxPitch, t55.renderWorldCopies), t55), this._interactive = t55.interactive, this._minTileCacheSize = t55.minTileCacheSize, this._maxTileCacheSize = t55.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t55.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t55.preserveDrawingBuffer, this._antialias = t55.antialias, this._trackResize = t55.trackResize, this._bearingSnap = t55.bearingSnap, this._refreshExpiredTiles = t55.refreshExpiredTiles, this._fadeDuration = t55.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t55.crossSourceCollisions, this._collectResourceTiming = t55.collectResourceTiming, this._optimizeForTerrain = t55.optimizeForTerrain, this._language = this._parseLanguage(t55.language), this._worldview = t55.worldview, this._renderTaskQueue = new Kr, this._domRenderTaskQueue = new Kr, this._controls = [], this._markers = [], this._popups = [], this._mapId = e1.uniqueId(), this._locale = e1.extend({
                    }, sn, t55.locale), this._clickTolerance = t55.clickTolerance, this._cooperativeGestures = t55.cooperativeGestures, this._performanceMetricsCollection = t55.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new nn(0), this._interactionRange = [
                        1 / 0,
                        -1 / 0
                    ], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._requestManager = new e1.RequestManager(t55.transformRequest, t55.accessToken, t55.testMode), this._silenceAuthErrors = !!t55.testMode, "string" == typeof t55.container) {
                        if (this._container = e1.window.document.getElementById(t55.container), !this._container) throw new Error(`Container '${t55.container}' not found.`);
                    } else {
                        if (!(t55.container instanceof e1.window.HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = t55.container;
                    }
                    if (this._container.childNodes.length > 0 && e1.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t55.maxBounds && this.setMaxBounds(t55.maxBounds), e1.bindAll([
                        "_onWindowOnline",
                        "_onWindowResize",
                        "_onVisibilityChange",
                        "_onMapScroll",
                        "_contextLost",
                        "_contextRestored"
                    ], this), this._setupContainer(), this._setupPainter(), (void 0) === this.painter) throw new Error("Failed to initialize WebGL.");
                    this.on("move", ()=>this._update(!1)
                    ), this.on("moveend", ()=>this._update(!1)
                    ), this.on("zoom", ()=>this._update(!0)
                    ), (void 0) !== e1.window && (e1.window.addEventListener("online", this._onWindowOnline, !1), e1.window.addEventListener("resize", this._onWindowResize, !1), e1.window.addEventListener("orientationchange", this._onWindowResize, !1), e1.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1), e1.window.addEventListener("visibilitychange", this._onVisibilityChange, !1)), this.handlers = new Xr(this, t55), this._localFontFamily = t55.localFontFamily, this._localIdeographFontFamily = t55.localIdeographFontFamily, t55.style && this.setStyle(t55.style, {
                        localFontFamily: this._localFontFamily,
                        localIdeographFontFamily: this._localIdeographFontFamily
                    }), t55.projection && this.setProjection(t55.projection), this._hash = t55.hash && new Ko("string" == typeof t55.hash && t55.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
                        center: t55.center,
                        zoom: t55.zoom,
                        bearing: t55.bearing,
                        pitch: t55.pitch
                    }), t55.bounds && (this.resize(), this.fitBounds(t55.bounds, e1.extend({
                    }, t55.fitBoundsOptions, {
                        duration: 0
                    })))), this.resize(), t55.attributionControl && this.addControl(new Hr({
                        customAttribution: t55.customAttribution
                    })), this._logoControl = new Yr, this.addControl(this._logoControl, t55.logoPosition), this.on("style.load", ()=>{
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet);
                    }), this.on("data", (t56)=>{
                        this._update("style" === t56.dataType), this.fire(new e1.Event(`${t56.dataType}data`, t56));
                    }), this.on("dataloading", (t56)=>{
                        this.fire(new e1.Event(`${t56.dataType}dataloading`, t56));
                    });
                }
                _getMapId() {
                    return this._mapId;
                }
                addControl(t, i) {
                    if ((void 0) === i && (i = t.getDefaultPosition ? t.getDefaultPosition() : "top-right"), !t || !t.onAdd) return this.fire(new e1.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const o42 = t.onAdd(this);
                    this._controls.push(t);
                    const r17 = this._controlPositions[i];
                    return -1 !== i.indexOf("bottom") ? r17.insertBefore(o42, r17.firstChild) : r17.appendChild(o42), this;
                }
                removeControl(t) {
                    if (!t || !t.onRemove) return this.fire(new e1.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const i55 = this._controls.indexOf(t);
                    return i55 > -1 && this._controls.splice(i55, 1), t.onRemove(this), this;
                }
                hasControl(e) {
                    return this._controls.indexOf(e) > -1;
                }
                getContainer() {
                    return this._container;
                }
                getCanvasContainer() {
                    return this._canvasContainer;
                }
                getCanvas() {
                    return this._canvas;
                }
                resize(t) {
                    if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
                    this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                    const i55 = !this._moving;
                    return i55 && this.fire(new e1.Event("movestart", t)).fire(new e1.Event("move", t)), this.fire(new e1.Event("resize", t)), i55 && this.fire(new e1.Event("moveend", t)), this;
                }
                getBounds() {
                    return this.transform.getBounds();
                }
                getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                }
                setMaxBounds(t) {
                    return this.transform.setMaxBounds(e1.LngLatBounds.convert(t)), this._update();
                }
                setMinZoom(t) {
                    if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e1.Event("zoomstart")).fire(new e1.Event("zoom")).fire(new e1.Event("zoomend")), this;
                    throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
                }
                getMinZoom() {
                    return this.transform.minZoom;
                }
                setMaxZoom(t) {
                    if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e1.Event("zoomstart")).fire(new e1.Event("zoom")).fire(new e1.Event("zoomend")), this;
                    throw new Error("maxZoom must be greater than the current minZoom");
                }
                getMaxZoom() {
                    return this.transform.maxZoom;
                }
                setMinPitch(t) {
                    if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e1.Event("pitchstart")).fire(new e1.Event("pitch")).fire(new e1.Event("pitchend")), this;
                    throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
                }
                getMinPitch() {
                    return this.transform.minPitch;
                }
                setMaxPitch(t) {
                    if ((t = null == t ? 85 : t) > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e1.Event("pitchstart")).fire(new e1.Event("pitch")).fire(new e1.Event("pitchend")), this;
                    throw new Error("maxPitch must be greater than or equal to minPitch");
                }
                getMaxPitch() {
                    return this.transform.maxPitch;
                }
                getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                }
                setRenderWorldCopies(e) {
                    return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
                }
                getLanguage() {
                    return this._language;
                }
                _parseLanguage(t) {
                    return "auto" === t ? e1.window.navigator.language : Array.isArray(t) ? 0 === t.length ? void 0 : t.map((t56)=>"auto" === t56 ? e1.window.navigator.language : t56
                    ) : t;
                }
                setLanguage(e) {
                    const t56 = this._parseLanguage(e);
                    if (!this.style || t56 === this._language) return this;
                    this._language = t56, this.style._reloadSources();
                    for (const e47 of this._controls)e47._setLanguage && e47._setLanguage(this._language);
                    return this;
                }
                getWorldview() {
                    return this._worldview;
                }
                setWorldview(e) {
                    return this.style && e !== this._worldview ? (this._worldview = e, this.style._reloadSources(), this) : this;
                }
                getProjection() {
                    return this.transform.mercatorFromTransition ? {
                        name: "globe",
                        center: [
                            0,
                            0
                        ]
                    } : this.transform.getProjection();
                }
                _showingGlobe() {
                    return "globe" === this.transform.projection.name;
                }
                setProjection(e) {
                    return this._lazyInitEmptyStyle(), e ? "string" == typeof e && (e = {
                        name: e
                    }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.stylesheet ? this.style.stylesheet.projection : null);
                }
                _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;
                    const t56 = this.transform, i55 = t56.projection.name;
                    let o42;
                    "globe" === i55 && t56.zoom >= e1.GLOBE_ZOOM_THRESHOLD_MAX ? (t56.setMercatorFromTransition(), o42 = !0) : "mercator" === i55 && t56.zoom < e1.GLOBE_ZOOM_THRESHOLD_MAX && (t56.setProjection({
                        name: "globe"
                    }), o42 = !0), o42 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
                }
                _prioritizeAndUpdateProjection(e, t) {
                    return this._updateProjection(e || t || {
                        name: "mercator"
                    });
                }
                _updateProjection(t) {
                    let i55;
                    if (i55 = "globe" === t.name && this.transform.zoom >= e1.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t), this.style.applyProjectionUpdate(), i55) {
                        this.painter.clearBackgroundTiles();
                        for(const e47 in this.style._sourceCaches)this.style._sourceCaches[e47].clearTiles();
                        this._update(!0), this._forceMarkerAndPopupUpdate(!0);
                    }
                    return this;
                }
                project(t) {
                    return this.transform.locationPoint3D(e1.LngLat.convert(t));
                }
                unproject(t) {
                    return this.transform.pointLocation3D(e1.pointGeometry.convert(t));
                }
                isMoving() {
                    return this._moving || this.handlers && this.handlers.isMoving() || !1;
                }
                isZooming() {
                    return this._zooming || this.handlers && this.handlers.isZooming() || !1;
                }
                isRotating() {
                    return this._rotating || this.handlers && this.handlers.isRotating() || !1;
                }
                _isDragging() {
                    return this.handlers && this.handlers._isDragging() || !1;
                }
                _createDelegatedListener(e, t, i) {
                    if ("mouseenter" === e || "mouseover" === e) {
                        let o42 = !1;
                        const r17 = (r18)=>{
                            const n12 = t.filter((e47)=>this.getLayer(e47)
                            ), s21 = n12.length ? this.queryRenderedFeatures(r18.point, {
                                layers: n12
                            }) : [];
                            s21.length ? o42 || (o42 = !0, i.call(this, new ar(e, this, r18.originalEvent, {
                                features: s21
                            }))) : o42 = !1;
                        }, n12 = ()=>{
                            o42 = !1;
                        };
                        return {
                            layers: new Set(t),
                            listener: i,
                            delegates: {
                                mousemove: r17,
                                mouseout: n12
                            }
                        };
                    }
                    if ("mouseleave" === e || "mouseout" === e) {
                        let o42 = !1;
                        const r17 = (r18)=>{
                            const n12 = t.filter((e47)=>this.getLayer(e47)
                            );
                            (n12.length ? this.queryRenderedFeatures(r18.point, {
                                layers: n12
                            }) : []).length ? o42 = !0 : o42 && (o42 = !1, i.call(this, new ar(e, this, r18.originalEvent)));
                        }, n12 = (t56)=>{
                            o42 && (o42 = !1, i.call(this, new ar(e, this, t56.originalEvent)));
                        };
                        return {
                            layers: new Set(t),
                            listener: i,
                            delegates: {
                                mousemove: r17,
                                mouseout: n12
                            }
                        };
                    }
                    {
                        const o42 = (e47)=>{
                            const o43 = t.filter((e48)=>this.getLayer(e48)
                            ), r17 = o43.length ? this.queryRenderedFeatures(e47.point, {
                                layers: o43
                            }) : [];
                            r17.length && (e47.features = r17, i.call(this, e47), delete e47.features);
                        };
                        return {
                            layers: new Set(t),
                            listener: i,
                            delegates: {
                                [e]: o42
                            }
                        };
                    }
                }
                on(e, t, i) {
                    if ((void 0) === i) return super.on(e, t);
                    Array.isArray(t) || (t = [
                        t
                    ]);
                    const o42 = this._createDelegatedListener(e, t, i);
                    this._delegatedListeners = this._delegatedListeners || {
                    }, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o42);
                    for(const e47 in o42.delegates)this.on(e47, o42.delegates[e47]);
                    return this;
                }
                once(e, t, i) {
                    if ((void 0) === i) return super.once(e, t);
                    Array.isArray(t) || (t = [
                        t
                    ]);
                    const o42 = this._createDelegatedListener(e, t, i);
                    for(const e47 in o42.delegates)this.once(e47, o42.delegates[e47]);
                    return this;
                }
                off(e, t, i) {
                    if ((void 0) === i) return super.off(e, t);
                    t = new Set(Array.isArray(t) ? t : [
                        t
                    ]);
                    const o42 = (e47, t56)=>{
                        if (e47.size !== t56.size) return !1;
                        for (const i55 of e47)if (!t56.has(i55)) return !1;
                        return !0;
                    }, r17 = this._delegatedListeners ? this._delegatedListeners[e] : void 0;
                    return r17 && ((e47)=>{
                        for(let r18 = 0; r18 < e47.length; r18++){
                            const n12 = e47[r18];
                            if (n12.listener === i && o42(n12.layers, t)) {
                                for(const e48 in n12.delegates)this.off(e48, n12.delegates[e48]);
                                return e47.splice(r18, 1), this;
                            }
                        }
                    })(r17), this;
                }
                queryRenderedFeatures(t, i) {
                    return this.style ? ((void 0) !== i || (void 0) === t || t instanceof e1.pointGeometry || Array.isArray(t) || (i = t, t = void 0), this.style.queryRenderedFeatures(t = t || [
                        [
                            0,
                            0
                        ],
                        [
                            this.transform.width,
                            this.transform.height
                        ]
                    ], i = i || {
                    }, this.transform)) : [];
                }
                querySourceFeatures(e, t) {
                    return this.style.querySourceFeatures(e, t);
                }
                setStyle(t, i) {
                    return !1 !== (i = e1.extend({
                    }, {
                        localIdeographFontFamily: this._localIdeographFontFamily,
                        localFontFamily: this._localFontFamily
                    }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && t ? (this._diffStyle(t, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t, i));
                }
                _getUIString(e) {
                    const t56 = this._locale[e];
                    if (null == t56) throw new Error(`Missing UI string '${e}'`);
                    return t56;
                }
                _updateStyle(e, t) {
                    return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e && (this.style = new Jt(this, t || {
                    }), this.style.setEventedParent(this, {
                        style: this.style
                    }), "string" == typeof e ? this.style.loadURL(e) : this.style.loadJSON(e)), this._updateTerrain(), this;
                }
                _lazyInitEmptyStyle() {
                    this.style || (this.style = new Jt(this, {
                    }), this.style.setEventedParent(this, {
                        style: this.style
                    }), this.style.loadEmpty());
                }
                _diffStyle(t, i) {
                    if ("string" == typeof t) {
                        const o42 = this._requestManager.normalizeStyleURL(t), r17 = this._requestManager.transformRequest(o42, e1.ResourceType.Style);
                        e1.getJSON(r17, (t56, o43)=>{
                            t56 ? this.fire(new e1.ErrorEvent(t56)) : o43 && this._updateDiff(o43, i);
                        });
                    } else "object" == typeof t && this._updateDiff(t, i);
                }
                _updateDiff(t, i) {
                    try {
                        this.style.setState(t) && this._update(!0);
                    } catch (o42) {
                        e1.warnOnce(`Unable to perform style diff: ${o42.message || o42.error || o42}.  Rebuilding the style from scratch.`), this._updateStyle(t, i);
                    }
                }
                getStyle() {
                    if (this.style) return this.style.serialize();
                }
                isStyleLoaded() {
                    return this.style ? this.style.loaded() : (e1.warnOnce("There is no style added to the map."), !1);
                }
                addSource(e, t) {
                    return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0);
                }
                isSourceLoaded(e) {
                    return !!this.style && this.style._isSourceCacheLoaded(e);
                }
                areTilesLoaded() {
                    const e47 = this.style && this.style._sourceCaches;
                    for(const t56 in e47){
                        const i55 = e47[t56]._tiles;
                        for(const e48 in i55){
                            const t57 = i55[e48];
                            if ("loaded" !== t57.state && "errored" !== t57.state) return !1;
                        }
                    }
                    return !0;
                }
                addSourceType(e, t, i) {
                    this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);
                }
                removeSource(e) {
                    return this.style.removeSource(e), this._updateTerrain(), this._update(!0);
                }
                getSource(e) {
                    return this.style.getSource(e);
                }
                addImage(t, i, { pixelRatio: o = 1 , sdf: r = !1 , stretchX: n , stretchY: s , content: a  } = {
                }) {
                    if (this._lazyInitEmptyStyle(), i instanceof e1.window.HTMLImageElement || e1.window.ImageBitmap && i instanceof e1.window.ImageBitmap) {
                        const { width: l21 , height: c15 , data: h14  } = e1.exported.getImageData(i);
                        this.style.addImage(t, {
                            data: new e1.RGBAImage({
                                width: l21,
                                height: c15
                            }, h14),
                            pixelRatio: o,
                            stretchX: n,
                            stretchY: s,
                            content: a,
                            sdf: r,
                            version: 0
                        });
                    } else if ((void 0) === i.width || (void 0) === i.height) this.fire(new e1.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    else {
                        const { width: l21 , height: c15  } = i, h14 = i;
                        this.style.addImage(t, {
                            data: new e1.RGBAImage({
                                width: l21,
                                height: c15
                            }, new Uint8Array(h14.data)),
                            pixelRatio: o,
                            stretchX: n,
                            stretchY: s,
                            content: a,
                            sdf: r,
                            version: 0,
                            userImage: h14
                        }), h14.onAdd && h14.onAdd(this, t);
                    }
                }
                updateImage(t, i) {
                    const o42 = this.style.getImage(t);
                    if (!o42) return void this.fire(new e1.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                    const r17 = i instanceof e1.window.HTMLImageElement || e1.window.ImageBitmap && i instanceof e1.window.ImageBitmap ? e1.exported.getImageData(i) : i, { width: n12 , height: s21  } = r17;
                    (void 0) !== n12 && (void 0) !== s21 ? n12 === o42.data.width && s21 === o42.data.height ? (o42.data.replace(r17.data, !(i instanceof e1.window.HTMLImageElement || e1.window.ImageBitmap && i instanceof e1.window.ImageBitmap)), this.style.updateImage(t, o42)) : this.fire(new e1.ErrorEvent(new Error(`The width and height of the updated image (${n12}, ${s21})\n                must be that same as the previous version of the image\n                (${o42.data.width}, ${o42.data.height})`))) : this.fire(new e1.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                }
                hasImage(t) {
                    return t ? !!this.style.getImage(t) : (this.fire(new e1.ErrorEvent(new Error("Missing required image id"))), !1);
                }
                removeImage(e) {
                    this.style.removeImage(e);
                }
                loadImage(t, i) {
                    e1.getImage(this._requestManager.transformRequest(t, e1.ResourceType.Image), (t56, o42)=>{
                        i(t56, o42 instanceof e1.window.HTMLImageElement ? e1.exported.getImageData(o42) : o42);
                    });
                }
                listImages() {
                    return this.style.listImages();
                }
                addLayer(e, t) {
                    return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0);
                }
                moveLayer(e, t) {
                    return this.style.moveLayer(e, t), this._update(!0);
                }
                removeLayer(e) {
                    return this.style.removeLayer(e), this._update(!0);
                }
                getLayer(e) {
                    return this.style.getLayer(e);
                }
                setLayerZoomRange(e, t, i) {
                    return this.style.setLayerZoomRange(e, t, i), this._update(!0);
                }
                setFilter(e, t, i = {
                }) {
                    return this.style.setFilter(e, t, i), this._update(!0);
                }
                getFilter(e) {
                    return this.style.getFilter(e);
                }
                setPaintProperty(e, t, i, o = {
                }) {
                    return this.style.setPaintProperty(e, t, i, o), this._update(!0);
                }
                getPaintProperty(e, t) {
                    return this.style.getPaintProperty(e, t);
                }
                setLayoutProperty(e, t, i, o = {
                }) {
                    return this.style.setLayoutProperty(e, t, i, o), this._update(!0);
                }
                getLayoutProperty(e, t) {
                    return this.style.getLayoutProperty(e, t);
                }
                setLight(e, t = {
                }) {
                    return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0);
                }
                getLight() {
                    return this.style.getLight();
                }
                setTerrain(e) {
                    return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
                }
                getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                }
                setFog(e) {
                    return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);
                }
                getFog() {
                    return this.style ? this.style.getFog() : null;
                }
                _queryFogOpacity(t) {
                    return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e1.LngLat.convert(t), this.transform) : 0;
                }
                setFeatureState(e, t) {
                    return this.style.setFeatureState(e, t), this._update();
                }
                removeFeatureState(e, t) {
                    return this.style.removeFeatureState(e, t), this._update();
                }
                getFeatureState(e) {
                    return this.style.getFeatureState(e);
                }
                _updateContainerDimensions() {
                    if (!this._container) return;
                    const t56 = this._container.getBoundingClientRect().width || 400, i55 = this._container.getBoundingClientRect().height || 300;
                    let o42, r17, n12, s21 = this._container;
                    for(; s21 && (!r17 || !n12);){
                        const t57 = e1.window.getComputedStyle(s21).transform;
                        t57 && "none" !== t57 && (o42 = t57.match(/matrix.*\((.+)\)/)[1].split(", "), o42[0] && "0" !== o42[0] && "1" !== o42[0] && (r17 = o42[0]), o42[3] && "0" !== o42[3] && "1" !== o42[3] && (n12 = o42[3])), s21 = s21.parentElement;
                    }
                    this._containerWidth = r17 ? Math.abs(t56 / r17) : t56, this._containerHeight = n12 ? Math.abs(i55 / n12) : i55;
                }
                _detectMissingCSS() {
                    "rgb(250, 128, 114)" !== e1.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e1.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
                }
                _setupContainer() {
                    const e47 = this._container;
                    e47.classList.add("mapboxgl-map"), (this._missingCSSCanary = n1("div", "mapboxgl-canary", e47)).style.visibility = "hidden", this._detectMissingCSS();
                    const t56 = this._canvasContainer = n1("div", "mapboxgl-canvas-container", e47);
                    this._interactive && t56.classList.add("mapboxgl-interactive"), this._canvas = n1("canvas", "mapboxgl-canvas", t56), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
                    const i55 = this._controlContainer = n1("div", "mapboxgl-control-container", e47), o42 = this._controlPositions = {
                    };
                    [
                        "top-left",
                        "top-right",
                        "bottom-left",
                        "bottom-right"
                    ].forEach((e48)=>{
                        o42[e48] = n1("div", `mapboxgl-ctrl-${e48}`, i55);
                    }), this._container.addEventListener("scroll", this._onMapScroll, !1);
                }
                _resizeCanvas(t, i) {
                    const o42 = e1.exported.devicePixelRatio || 1;
                    this._canvas.width = o42 * Math.ceil(t), this._canvas.height = o42 * Math.ceil(i), this._canvas.style.width = `${t}px`, this._canvas.style.height = `${i}px`;
                }
                _addMarker(e) {
                    this._markers.push(e);
                }
                _removeMarker(e) {
                    const t56 = this._markers.indexOf(e);
                    -1 !== t56 && this._markers.splice(t56, 1);
                }
                _addPopup(e) {
                    this._popups.push(e);
                }
                _removePopup(e) {
                    const t56 = this._popups.indexOf(e);
                    -1 !== t56 && this._popups.splice(t56, 1);
                }
                _setupPainter() {
                    const t56 = e1.extend({
                    }, i2.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1
                    }), o42 = this._canvas.getContext("webgl", t56) || this._canvas.getContext("experimental-webgl", t56);
                    o42 ? (e1.storeAuthState(o42, !0), this.painter = new Bo(o42, this.transform), this.on("data", (e47)=>{
                        "source" === e47.dataType && this.painter.setTileLoadedFlag(!0);
                    }), e1.exported$1.testSupport(o42)) : this.fire(new e1.ErrorEvent(new Error("Failed to initialize WebGL")));
                }
                _contextLost(t) {
                    t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e1.Event("webglcontextlost", {
                        originalEvent: t
                    }));
                }
                _contextRestored(t) {
                    this._setupPainter(), this.resize(), this._update(), this.fire(new e1.Event("webglcontextrestored", {
                        originalEvent: t
                    }));
                }
                _onMapScroll(e) {
                    if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
                }
                loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
                }
                _update(e) {
                    return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
                }
                _requestRenderFrame(e) {
                    return this._update(), this._renderTaskQueue.add(e);
                }
                _cancelRenderFrame(e) {
                    this._renderTaskQueue.remove(e);
                }
                _requestDomTask(e) {
                    !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);
                }
                _render(t) {
                    let i55;
                    const o42 = this.painter.context.extTimerQuery, r17 = e1.exported.now();
                    if (this.listens("gpu-timing-frame") && (i55 = o42.createQueryEXT(), o42.beginQueryEXT(o42.TIME_ELAPSED_EXT, i55)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e1.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e1.window.performance.now())), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return;
                    this._updateProjectionTransition();
                    const n12 = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const t56 = this.transform.zoom, i56 = this.transform.pitch, o43 = e1.exported.now(), r18 = new e1.EvaluationParameters(t56, {
                            now: o43,
                            fadeDuration: n12,
                            pitch: i56,
                            transition: this.style.getTransition()
                        });
                        this.style.update(r18);
                    }
                    this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
                    let s21 = !1;
                    if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), s21 = this._updateAverageElevation(r17), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s21 = this._updateAverageElevation(r17), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n12, this._crossSourceCollisions), this.style && this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showTerrainWireframe: this.showTerrainWireframe,
                        showOverdrawInspector: this._showOverdrawInspector,
                        showQueryGeometry: !!this._showQueryGeometry,
                        showTileAABBs: this.showTileAABBs,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: n12,
                        isInitialLoad: this._isInitialLoad,
                        showPadding: this.showPadding,
                        gpuTiming: !!this.listens("gpu-timing-layer"),
                        gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                        speedIndexTiming: this.speedIndexTiming
                    }), this.fire(new e1.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e1.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i55) {
                        const t56 = e1.exported.now() - r17;
                        o42.endQueryEXT(o42.TIME_ELAPSED_EXT, i55), setTimeout(()=>{
                            const n13 = o42.getQueryObjectEXT(i55, o42.QUERY_RESULT_EXT) / 1000000;
                            o42.deleteQueryEXT(i55), this.fire(new e1.Event("gpu-timing-frame", {
                                cpuTime: t56,
                                gpuTime: n13
                            })), e1.window.performance.mark("frame-gpu", {
                                startTime: r17,
                                detail: {
                                    gpuTime: n13
                                }
                            });
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                        const t56 = this.painter.collectGpuTimers();
                        setTimeout(()=>{
                            const i56 = this.painter.queryGpuTimers(t56);
                            this.fire(new e1.Event("gpu-timing-layer", {
                                layerTimes: i56
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                        const t56 = this.painter.collectDeferredRenderGpuQueries();
                        setTimeout(()=>{
                            const i56 = this.painter.queryGpuTimeDeferredRender(t56);
                            this.fire(new e1.Event("gpu-timing-deferred-render", {
                                gpuTime: i56
                            }));
                        }, 50);
                    }
                    const a20 = this._sourcesDirty || this._styleDirty || this._placementDirty || s21;
                    if (a20 || this._repaint) this.triggerRepaint();
                    else {
                        const t56 = !this.isMoving() && this.loaded();
                        if (t56 && (s21 = this._updateAverageElevation(r17, !0)), s21) this.triggerRepaint();
                        else if (this._triggerFrame(!1), t56 && (this.fire(new e1.Event("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                            const t57 = this._calculateSpeedIndex();
                            this.fire(new e1.Event("speedindexcompleted", {
                                speedIndex: t57
                            })), this.speedIndexTiming = !1;
                        }
                    }
                    !this._loaded || this._fullyLoaded || a20 || (this._fullyLoaded = !0, e1.LivePerformanceUtils.mark(e1.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e1.postPerformanceEvent(this._requestManager._customAccessToken, {
                        width: this.painter.width,
                        height: this.painter.height,
                        interactionRange: this._interactionRange,
                        visibilityHidden: this._visibilityHidden,
                        terrainEnabled: !!this.painter.style.getTerrain(),
                        fogEnabled: !!this.painter.style.getFog(),
                        projection: this.getProjection().name,
                        zoom: this.transform.zoom,
                        renderer: this.painter.context.renderer,
                        vendor: this.painter.context.vendor
                    }), this._authenticate());
                }
                _forceMarkerAndPopupUpdate(e) {
                    for (const t56 of this._markers)e && !this.getRenderWorldCopies() && (t56._lngLat = t56._lngLat.wrap()), t56._update();
                    for (const t57 of this._popups)!e || this.getRenderWorldCopies() || t57._trackPointer || (t57._lngLat = t57._lngLat.wrap()), t57._update();
                }
                _updateAverageElevation(e, t = !1) {
                    const i55 = (e47)=>(this.transform.averageElevation = e47, this._update(!1), !0)
                    ;
                    if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i55(0);
                    if ((t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {
                        const t56 = this.transform.averageElevation;
                        let o42 = this.transform.sampleAverageElevation(), r17 = !1;
                        this.transform.elevation && (r17 = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o42) ? o42 = 0 : this._averageElevationLastSampledAt = e;
                        const n12 = Math.abs(t56 - o42);
                        if (n12 > 1) {
                            if (this._isInitialLoad || r17) return this._averageElevation.jumpTo(o42), i55(o42);
                            this._averageElevation.easeTo(o42, e, 300);
                        } else if (n12 > 0.0001) return this._averageElevation.jumpTo(o42), i55(o42);
                    }
                    return !!this._averageElevation.isEasing(e) && i55(this._averageElevation.getValue(e));
                }
                _authenticate() {
                    e1.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t56)=>{
                        if (t56 && (t56.message === e1.AUTH_ERR_MSG || 401 === t56.status)) {
                            const t57 = this.painter.context.gl;
                            e1.storeAuthState(t57, !1), this._logoControl instanceof Yr && this._logoControl._updateLogo(), t57 && t57.clear(t57.DEPTH_BUFFER_BIT | t57.COLOR_BUFFER_BIT | t57.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e1.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                        }
                    }), e1.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, ()=>{
                    });
                }
                _updateTerrain() {
                    const e47 = this._isDragging();
                    this.painter.updateTerrain(this.style, e47);
                }
                _calculateSpeedIndex() {
                    const e47 = this.painter.canvasCopy(), t56 = this.painter.getCanvasCopiesAndTimestamps();
                    t56.timeStamps.push(performance.now());
                    const i55 = this.painter.context.gl, o42 = i55.createFramebuffer();
                    function r17(e48) {
                        i55.framebufferTexture2D(i55.FRAMEBUFFER, i55.COLOR_ATTACHMENT0, i55.TEXTURE_2D, e48, 0);
                        const t57 = new Uint8Array(i55.drawingBufferWidth * i55.drawingBufferHeight * 4);
                        return i55.readPixels(0, 0, i55.drawingBufferWidth, i55.drawingBufferHeight, i55.RGBA, i55.UNSIGNED_BYTE, t57), t57;
                    }
                    return i55.bindFramebuffer(i55.FRAMEBUFFER, o42), this._canvasPixelComparison(r17(e47), t56.canvasCopies.map(r17), t56.timeStamps);
                }
                _canvasPixelComparison(e, t, i) {
                    let o42 = i[1] - i[0];
                    const r17 = e.length / 4;
                    for(let n12 = 0; n12 < t.length; n12++){
                        const s21 = t[n12];
                        let a20 = 0;
                        for(let t56 = 0; t56 < s21.length; t56 += 4)s21[t56] === e[t56] && s21[t56 + 1] === e[t56 + 1] && s21[t56 + 2] === e[t56 + 2] && s21[t56 + 3] === e[t56 + 3] && (a20 += 1);
                        o42 += (i[n12 + 2] - i[n12 + 1]) * (1 - a20 / r17);
                    }
                    return o42;
                }
                remove() {
                    this._hash && this._hash.remove();
                    for (const e47 of this._controls)e47.onRemove(this);
                    this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), (void 0) !== e1.window && (e1.window.removeEventListener("resize", this._onWindowResize, !1), e1.window.removeEventListener("orientationchange", this._onWindowResize, !1), e1.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1), e1.window.removeEventListener("online", this._onWindowOnline, !1), e1.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1));
                    const t56 = this.painter.context.gl.getExtension("WEBGL_lose_context");
                    t56 && t56.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), e1.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new e1.Event("remove"));
                }
                triggerRepaint() {
                    this._triggerFrame(!0);
                }
                _triggerFrame(t) {
                    this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e1.exported.frame((e47)=>{
                        const t56 = !!this._renderNextFrame;
                        this._frame = null, this._renderNextFrame = null, t56 && this._render(e47);
                    }));
                }
                _preloadTiles(t) {
                    const i55 = this.style ? Object.values(this.style._sourceCaches) : [];
                    return e1.asyncAll(i55, (e47, i56)=>e47._preloadTiles(t, i56)
                    , ()=>{
                        this.triggerRepaint();
                    }), this;
                }
                _onWindowOnline() {
                    this._update();
                }
                _onWindowResize(e) {
                    this._trackResize && this.resize({
                        originalEvent: e
                    })._update();
                }
                _onVisibilityChange() {
                    "hidden" === e1.window.document.visibilityState && this._visibilityHidden++;
                }
                get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                }
                set showTileBoundaries(e) {
                    this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update());
                }
                get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                }
                set showTerrainWireframe(e) {
                    this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._update());
                }
                get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                }
                set speedIndexTiming(e) {
                    this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());
                }
                get showPadding() {
                    return !!this._showPadding;
                }
                set showPadding(e) {
                    this._showPadding !== e && (this._showPadding = e, this._update());
                }
                get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                }
                set showCollisionBoxes(e) {
                    this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update());
                }
                get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                }
                set showOverdrawInspector(e) {
                    this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update());
                }
                get repaint() {
                    return !!this._repaint;
                }
                set repaint(e) {
                    this._repaint !== e && (this._repaint = e, this.triggerRepaint());
                }
                get vertices() {
                    return !!this._vertices;
                }
                set vertices(e) {
                    this._vertices = e, this._update();
                }
                get showTileAABBs() {
                    return !!this._showTileAABBs;
                }
                set showTileAABBs(e) {
                    this._showTileAABBs !== e && (this._showTileAABBs = e, e && this._update());
                }
                _setCacheLimits(t, i) {
                    e1.setCacheLimits(t, i);
                }
                get version() {
                    return e1.version;
                }
            },
            NavigationControl: class {
                constructor(t56){
                    this.options = e1.extend({
                    }, ln, t56), this._container = n1("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e47)=>e47.preventDefault()
                    ), this.options.showZoom && (e1.bindAll([
                        "_setButtonTitle",
                        "_updateZoomButtons"
                    ], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e47)=>{
                        this._map && this._map.zoomIn({
                        }, {
                            originalEvent: e47
                        });
                    }), n1("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e47)=>{
                        this._map && this._map.zoomOut({
                        }, {
                            originalEvent: e47
                        });
                    }), n1("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e1.bindAll([
                        "_rotateCompassArrow"
                    ], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e47)=>{
                        const t57 = this._map;
                        t57 && (this.options.visualizePitch ? t57.resetNorthPitch({
                        }, {
                            originalEvent: e47
                        }) : t57.resetNorth({
                        }, {
                            originalEvent: e47
                        }));
                    }), this._compassIcon = n1("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
                }
                _updateZoomButtons() {
                    const e47 = this._map;
                    if (!e47) return;
                    const t57 = e47.getZoom(), i55 = t57 === e47.getMaxZoom(), o42 = t57 === e47.getMinZoom();
                    this._zoomInButton.disabled = i55, this._zoomOutButton.disabled = o42, this._zoomInButton.setAttribute("aria-disabled", i55.toString()), this._zoomOutButton.setAttribute("aria-disabled", o42.toString());
                }
                _rotateCompassArrow() {
                    const e47 = this._map;
                    if (!e47) return;
                    const t57 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e47.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e47.transform.pitch}deg) rotateZ(${e47.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e47.transform.angle * (180 / Math.PI)}deg)`;
                    e47._requestDomTask(()=>{
                        this._compassIcon && (this._compassIcon.style.transform = t57);
                    });
                }
                onAdd(e) {
                    return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e.on("pitch", this._rotateCompassArrow), e.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new cn(e, this._compass, this.options.visualizePitch)), this._container;
                }
                onRemove() {
                    const e47 = this._map;
                    e47 && (this._container.remove(), this.options.showZoom && e47.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e47.off("pitch", this._rotateCompassArrow), e47.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
                }
                _createButton(e, t) {
                    const i55 = n1("button", e, this._container);
                    return i55.type = "button", i55.addEventListener("click", t), i55;
                }
                _setButtonTitle(e, t) {
                    if (!this._map) return;
                    const i55 = this._map._getUIString(`NavigationControl.${t}`);
                    e.setAttribute("aria-label", i55), e.firstElementChild && e.firstElementChild.setAttribute("title", i55);
                }
            },
            GeolocateControl: class extends e1.Evented {
                constructor(t57){
                    super(), this.options = e1.extend({
                        geolocation: e1.window.navigator.geolocation
                    }, hn, t57), e1.bindAll([
                        "_onSuccess",
                        "_onError",
                        "_onZoom",
                        "_finish",
                        "_setupUI",
                        "_updateCamera",
                        "_updateMarker",
                        "_updateMarkerRotation",
                        "_onDeviceOrientation"
                    ], this), this._updateMarkerRotationThrottled = Yo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
                }
                onAdd(e) {
                    return this._map = e, this._container = n1("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
                }
                onRemove() {
                    (void 0) !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
                }
                _checkGeolocationSupport(t) {
                    const i55 = (e47 = !!this.options.geolocation)=>{
                        this._supportsGeolocation = e47, t(e47);
                    };
                    (void 0) !== this._supportsGeolocation ? t(this._supportsGeolocation) : (void 0) !== e1.window.navigator.permissions ? e1.window.navigator.permissions.query({
                        name: "geolocation"
                    }).then((e47)=>i55("denied" !== e47.state)
                    ).catch(()=>i55()
                    ) : i55();
                }
                _isOutOfMapMaxBounds(e) {
                    const t58 = this._map.getMaxBounds(), i55 = e.coords;
                    return !!t58 && (i55.longitude < t58.getWest() || i55.longitude > t58.getEast() || i55.latitude < t58.getSouth() || i55.latitude > t58.getNorth());
                }
                _setErrorState() {
                    switch(this._watchState){
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                    }
                }
                _onSuccess(t) {
                    if (this._map) {
                        if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e1.Event("outofmaxbounds", t)), this._updateMarker(), void this._finish();
                        if (this.options.trackUserLocation) switch(this._lastKnownPosition = t, this._watchState){
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "BACKGROUND":
                            case "BACKGROUND_ERROR":
                                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                        }
                        this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e1.Event("geolocate", t)), this._finish();
                    }
                }
                _updateCamera(t) {
                    const i55 = new e1.LngLat(t.coords.longitude, t.coords.latitude), o42 = t.coords.accuracy, r17 = this._map.getBearing(), n12 = e1.extend({
                        bearing: r17
                    }, this.options.fitBoundsOptions);
                    this._map.fitBounds(i55.toBounds(o42), n12, {
                        geolocateSource: !0
                    });
                }
                _updateMarker(t) {
                    if (t) {
                        const i55 = new e1.LngLat(t.coords.longitude, t.coords.latitude);
                        this._accuracyCircleMarker.setLngLat(i55).addTo(this._map), this._userLocationDotMarker.setLngLat(i55).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                    } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
                }
                _updateCircleRadius() {
                    const t58 = this._map.transform, i55 = e1.mercatorZfromAltitude(1, t58._center.lat) * t58.worldSize, o42 = Math.ceil(2 * this._accuracy * i55);
                    this._circleElement.style.width = `${o42}px`, this._circleElement.style.height = `${o42}px`;
                }
                _onZoom() {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                }
                _updateMarkerRotation() {
                    this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
                }
                _onError(t) {
                    if (this._map) {
                        if (this.options.trackUserLocation) {
                            if (1 === t.code) {
                                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                                const e47 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.setAttribute("aria-label", e47), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e47), (void 0) !== this._geolocationWatchID && this._clearWatch();
                            } else {
                                if (3 === t.code && this._noTimeout) return;
                                this._setErrorState();
                            }
                        }
                        "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e1.Event("error", t)), this._finish();
                    }
                }
                _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
                }
                _setupUI(t) {
                    if ((void 0) !== this._map) {
                        if (this._container.addEventListener("contextmenu", (e47)=>e47.preventDefault()
                        ), this._geolocateButton = n1("button", "mapboxgl-ctrl-geolocate", this._container), n1("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t) {
                            e1.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                            const t58 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t58), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t58);
                        } else {
                            const e47 = this._map._getUIString("GeolocateControl.FindMyLocation");
                            this._geolocateButton.setAttribute("aria-label", e47), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e47);
                        }
                        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n1("div", "mapboxgl-user-location"), this._dotElement.appendChild(n1("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n1("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new en({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map"
                        }), this._circleElement = n1("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new en({
                            element: this._circleElement,
                            pitchAlignment: "map"
                        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t58)=>{
                            t58.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t58.originalEvent && "resize" === t58.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e1.Event("trackuserlocationend")));
                        });
                    }
                }
                _onDeviceOrientation(e) {
                    this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());
                }
                trigger() {
                    if (!this._setup) return e1.warnOnce("Geolocate control triggered before added to a map"), !1;
                    if (this.options.trackUserLocation) {
                        switch(this._watchState){
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new e1.Event("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e1.Event("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e1.Event("trackuserlocationstart"));
                        }
                        switch(this._watchState){
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "BACKGROUND":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                break;
                            case "BACKGROUND_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                        }
                        if ("OFF" === this._watchState && (void 0) !== this._geolocationWatchID) this._clearWatch();
                        else if ((void 0) === this._geolocationWatchID) {
                            let e47;
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e47 = {
                                maximumAge: 600000,
                                timeout: 0
                            }, this._noTimeout = !0) : (e47 = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e47), this.options.showUserHeading && this._addDeviceOrientationListener();
                        }
                    } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 10000);
                    return !0;
                }
                _addDeviceOrientationListener() {
                    const t58 = ()=>{
                        e1.window.addEventListener("ondeviceorientationabsolute" in e1.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
                    };
                    (void 0) !== e1.window.DeviceMotionEvent && "function" == typeof e1.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((e47)=>{
                        "granted" === e47 && t58();
                    }).catch(console.error) : t58();
                }
                _clearWatch() {
                    this.options.geolocation.clearWatch(this._geolocationWatchID), e1.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e1.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
                }
            },
            AttributionControl: Hr,
            ScaleControl: class {
                constructor(t58){
                    this.options = e1.extend({
                    }, un, t58), (function() {
                        try {
                            return new Intl.NumberFormat("en", {
                                style: "unit",
                                unitDisplay: "narrow",
                                unit: "meter"
                            }), !0;
                        } catch (e47) {
                            return !1;
                        }
                    })() || (this._setScale = _n.bind(this)), e1.bindAll([
                        "_update",
                        "_setScale",
                        "setUnit"
                    ], this);
                }
                getDefaultPosition() {
                    return "bottom-left";
                }
                _update() {
                    const e47 = this.options.maxWidth || 100, t59 = this._map, i55 = t59._containerHeight / 2, o42 = t59._containerWidth / 2 - e47 / 2, r17 = t59.unproject([
                        o42,
                        i55
                    ]), n12 = t59.unproject([
                        o42 + e47,
                        i55
                    ]), s21 = r17.distanceTo(n12);
                    if ("imperial" === this.options.unit) {
                        const t60 = 3.2808 * s21;
                        t60 > 5280 ? this._setScale(e47, t60 / 5280, "mile") : this._setScale(e47, t60, "foot");
                    } else "nautical" === this.options.unit ? this._setScale(e47, s21 / 1852, "nautical-mile") : s21 >= 1000 ? this._setScale(e47, s21 / 1000, "kilometer") : this._setScale(e47, s21, "meter");
                }
                _setScale(e, t, i) {
                    const o42 = dn(t), r17 = o42 / t;
                    this._map._requestDomTask(()=>{
                        this._container.style.width = e * r17 + "px", this._container.innerHTML = "nautical-mile" !== i ? new Intl.NumberFormat(this._language, {
                            style: "unit",
                            unitDisplay: "narrow",
                            unit: i
                        }).format(o42) : `${o42}&nbsp;nm`;
                    });
                }
                onAdd(e) {
                    return this._map = e, this._language = e.getLanguage(), this._container = n1("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
                }
                onRemove() {
                    this._container.remove(), this._map.off("move", this._update), this._map = void 0;
                }
                _setLanguage(e) {
                    this._language = e, this._update();
                }
                setUnit(e) {
                    this.options.unit = e, this._update();
                }
            },
            FullscreenControl: class {
                constructor(t59){
                    this._fullscreen = !1, t59 && t59.container && (t59.container instanceof e1.window.HTMLElement ? this._container = t59.container : e1.warnOnce("Full screen control 'container' must be a DOM element.")), e1.bindAll([
                        "_onClickFullscreen",
                        "_changeIcon"
                    ], this), "onfullscreenchange" in e1.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e1.window.document && (this._fullscreenchange = "webkitfullscreenchange");
                }
                onAdd(t) {
                    return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = n1("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e1.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
                }
                onRemove() {
                    this._controlContainer.remove(), this._map = null, e1.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
                }
                _checkFullscreenSupport() {
                    return !(!e1.window.document.fullscreenEnabled && !e1.window.document.webkitFullscreenEnabled);
                }
                _setupUI() {
                    const t60 = this._fullscreenButton = n1("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                    n1("span", "mapboxgl-ctrl-icon", t60).setAttribute("aria-hidden", "true"), t60.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e1.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
                }
                _updateTitle() {
                    const e47 = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", e47), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e47);
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
                }
                _isFullscreen() {
                    return this._fullscreen;
                }
                _changeIcon() {
                    (e1.window.document.fullscreenElement || e1.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
                }
                _onClickFullscreen() {
                    this._isFullscreen() ? e1.window.document.exitFullscreen ? e1.window.document.exitFullscreen() : e1.window.document.webkitCancelFullScreen && e1.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
                }
            },
            Popup: class extends e1.Evented {
                constructor(t60){
                    super(), this.options = e1.extend(Object.create(tn), t60), e1.bindAll([
                        "_update",
                        "_onClose",
                        "remove",
                        "_onMouseEvent"
                    ], this), this._classList = new Set(t60 && t60.className ? t60.className.trim().split(/\s+/) : []);
                }
                addTo(t) {
                    return this._map && this.remove(), this._map = t, this.options.closeOnClick && t.on("preclick", this._onClose), this.options.closeOnMove && t.on("move", this._onClose), t.on("remove", this.remove), this._update(), t._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t.on("mousemove", this._onMouseEvent), t.on("mouseup", this._onMouseEvent), t._canvasContainer.classList.add("mapboxgl-track-pointer")) : t.on("move", this._update), this.fire(new e1.Event("open")), this;
                }
                isOpen() {
                    return !!this._map;
                }
                remove() {
                    this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
                    const t61 = this._map;
                    return t61 && (t61.off("move", this._update), t61.off("move", this._onClose), t61.off("preclick", this._onClose), t61.off("click", this._onClose), t61.off("remove", this.remove), t61.off("mousemove", this._onMouseEvent), t61.off("mouseup", this._onMouseEvent), t61.off("drag", this._onMouseEvent), t61._canvasContainer && t61._canvasContainer.classList.remove("mapboxgl-track-pointer"), t61._removePopup(this), this._map = void 0), this.fire(new e1.Event("close")), this;
                }
                getLngLat() {
                    return this._lngLat;
                }
                setLngLat(t) {
                    this._lngLat = e1.LngLat.convert(t), this._pos = null, this._trackPointer = !1, this._update();
                    const i55 = this._map;
                    return i55 && (i55.on("move", this._update), i55.off("mousemove", this._onMouseEvent), i55._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
                }
                trackPointer() {
                    this._trackPointer = !0, this._pos = null, this._update();
                    const e47 = this._map;
                    return e47 && (e47.off("move", this._update), e47.on("mousemove", this._onMouseEvent), e47.on("drag", this._onMouseEvent), e47._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
                }
                getElement() {
                    return this._container;
                }
                setText(t) {
                    return this.setDOMContent(e1.window.document.createTextNode(t));
                }
                setHTML(t) {
                    const i55 = e1.window.document.createDocumentFragment(), o42 = e1.window.document.createElement("body");
                    let r17;
                    for(o42.innerHTML = t; r17 = o42.firstChild, r17;)i55.appendChild(r17);
                    return this.setDOMContent(i55);
                }
                getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                }
                setMaxWidth(e) {
                    return this.options.maxWidth = e, this._update(), this;
                }
                setDOMContent(e) {
                    let t61 = this._content;
                    if (t61) for(; t61.hasChildNodes();)t61.firstChild && t61.removeChild(t61.firstChild);
                    else t61 = this._content = n1("div", "mapboxgl-popup-content", this._container || void 0);
                    if (t61.appendChild(e), this.options.closeButton) {
                        const e47 = this._closeButton = n1("button", "mapboxgl-popup-close-button", t61);
                        e47.type = "button", e47.setAttribute("aria-label", "Close popup"), e47.setAttribute("aria-hidden", "true"), e47.innerHTML = "&#215;", e47.addEventListener("click", this._onClose);
                    }
                    return this._update(), this._focusFirstElement(), this;
                }
                addClassName(e) {
                    return this._classList.add(e), this._updateClassList(), this;
                }
                removeClassName(e) {
                    return this._classList.delete(e), this._updateClassList(), this;
                }
                setOffset(e) {
                    return this.options.offset = e, this._update(), this;
                }
                toggleClassName(e) {
                    let t61;
                    return this._classList.delete(e) ? t61 = !1 : (this._classList.add(e), t61 = !0), this._updateClassList(), t61;
                }
                _onMouseEvent(e) {
                    this._update(e.point);
                }
                _getAnchor(e) {
                    if (this.options.anchor) return this.options.anchor;
                    const t61 = this._map, i55 = this._container, o42 = this._pos;
                    if (!t61 || !i55 || !o42) return "bottom";
                    const r17 = i55.offsetWidth, n12 = i55.offsetHeight, s21 = o42.x < r17 / 2, a20 = o42.x > t61.transform.width - r17 / 2;
                    if (o42.y + e < n12) return s21 ? "top-left" : a20 ? "top-right" : "top";
                    if (o42.y > t61.transform.height - n12) {
                        if (s21) return "bottom-left";
                        if (a20) return "bottom-right";
                    }
                    return s21 ? "left" : a20 ? "right" : "bottom";
                }
                _updateClassList() {
                    const e47 = this._container;
                    if (!e47) return;
                    const t61 = [
                        ...this._classList
                    ];
                    t61.push("mapboxgl-popup"), this._anchor && t61.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t61.push("mapboxgl-popup-track-pointer"), e47.className = t61.join(" ");
                }
                _update(t) {
                    const i55 = this._map, o42 = this._content;
                    if (!i55 || !this._lngLat && !this._trackPointer || !o42) return;
                    let r17 = this._container;
                    if (r17 || (r17 = this._container = n1("div", "mapboxgl-popup", i55.getContainer()), this._tip = n1("div", "mapboxgl-popup-tip", r17), r17.appendChild(o42)), this.options.maxWidth && r17.style.maxWidth !== this.options.maxWidth && (r17.style.maxWidth = this.options.maxWidth), i55.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Jr(this._lngLat, this._pos, i55.transform)), !this._trackPointer || t) {
                        const e47 = this._pos = this._trackPointer && t ? t : i55.project(this._lngLat), o43 = rn(this.options.offset), r18 = this._anchor = this._getAnchor(o43.y), n12 = rn(this.options.offset, r18), s21 = e47.add(n12).round();
                        i55._requestDomTask(()=>{
                            this._container && r18 && (this._container.style.transform = `${Qr[r18]} translate(${s21.x}px,${s21.y}px)`);
                        });
                    }
                    if (!this._marker && i55._showingGlobe()) {
                        const t61 = e1.isLngLatBehindGlobe(i55.transform, this._lngLat) ? 0 : 1;
                        this._setOpacity(t61);
                    }
                    this._updateClassList();
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container) return;
                    const e47 = this._container.querySelector(on);
                    e47 && e47.focus();
                }
                _onClose() {
                    this.remove();
                }
                _setOpacity(e) {
                    this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? "auto" : "none");
                }
            },
            Marker: en,
            Style: Jt,
            LngLat: e1.LngLat,
            LngLatBounds: e1.LngLatBounds,
            Point: e1.pointGeometry,
            MercatorCoordinate: e1.MercatorCoordinate,
            FreeCameraOptions: Go,
            Evented: e1.Evented,
            config: e1.config,
            prewarm: function() {
                Ge().acquire(Fe);
            },
            clearPrewarmedResources: function() {
                const e47 = Ne;
                e47 && (e47.isPreloaded() && 1 === e47.numActive() ? (e47.release(Fe), Ne = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
            },
            get accessToken () {
                return e1.config.ACCESS_TOKEN;
            },
            set accessToken (t61){
                e1.config.ACCESS_TOKEN = t61;
            },
            get baseApiUrl () {
                return e1.config.API_URL;
            },
            set baseApiUrl (t62){
                e1.config.API_URL = t62;
            },
            get workerCount () {
                return Ue.workerCount;
            },
            set workerCount (e47){
                Ue.workerCount = e47;
            },
            get maxParallelImageRequests () {
                return e1.config.MAX_PARALLEL_IMAGE_REQUESTS;
            },
            set maxParallelImageRequests (t63){
                e1.config.MAX_PARALLEL_IMAGE_REQUESTS = t63;
            },
            clearStorage (t) {
                e1.clearTileCache(t);
            },
            workerUrl: "",
            workerClass: null,
            setNow: e1.exported.setNow,
            restoreNow: e1.exported.restoreNow
        };
        return pn;
    });
    //
    var mapboxgl$1 = mapboxgl;
    return mapboxgl$1;
});

},{}],"4HHsO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "updateSettings", ()=>updateSettings
);
/*eslint-disable*/ var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _alert = require("./alert");
const updateSettings = async (data, type)=>{
    try {
        const url = type === 'password' ? '/api/v1/users/updateMyPassword' : '/api/v1/users/updateMe';
        const res = await _axiosDefault.default({
            method: 'PATCH',
            url,
            data
        });
        console.log(res);
        if (res.data.status === 'success') _alert.showAlert('success', `${type.toUpperCase()} updated successfully!`);
    } catch (err) {
        _alert.showAlert('error', err.response.data.message);
    }
}; ////-----------------------------------------------|||||||||-----////
 // export const updateSettings = async (data, type) => {
 //   console.log( email,password);
 //   console.log("login");
 // //type is either password or data
 //   try {
 //     const url = type === "password"
 //       ?'/api/v1/users/updateMyPassword'
 //        : '/api/v1/users/updateMe';
 // const options = {
 //   method: "PATCH",
 //   body: JSON.stringify({
 //    data
 //   }),
 //   headers: {
 //     "Content-Type": "application/json; charset=UTF-8",
 //   }
 // };
 //     // Send a POST request
 //     const res = await fetch(url,options);
 //     console.log(res)
 //     //   const response = await request.json();
 //     // if (res.status ===  200) {
 //     //   showAlert(`${type.toUpperCase()}Data updated successfully`);
 //     // }
 //     if (res.statusText === "OK") {
 //       showAlert("OK", `${type.toUpperCase()} updated successfully!`);
 //     }
 //   } catch (err) {
 //     showAlert("error", err.response.data.message);
 //   }
 // };
 ///
 // export const updateSettings = async (type, data) => {
 //   const dt = { ...data };
 //   try {
 //     let url = "http://localhost:3000/api/v1/users/";
 //     url += type === "data" ? "updateMe" : "updatePassword";
 //     let response = await fetch(url, {
 //       method: "PATCH",
 //       headers: {
 //         "content-type": "application/json",
 //       },
 //       body: JSON.stringify(dt),
 //     });
 //     if (!response.ok) throw response;
 //     let data = await response.json();
 //     if (data.status === "success") {
 //       window.location.reload(true);
 //       showAlert("success", `Updated User ${type.toUpperCase()} successfully`, 2000);
 //     }
 //   } catch (err) {
 //     err.text().then((errorMessage) => {
 //       showAlert("error", JSON.parse(errorMessage).message, 5000);
 //     });
 //   }
 // };

},{"./alert":"ehTc8","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn","axios":"giwFZ"}],"effgQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bookTour", ()=>bookTour
);
/* eslint-disable */ var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _alert = require("./alert");
const stripe = Stripe("pk_test_51MUpgJL0UTQ2FKXOJlIyHdHxR13meI8KELlQum7T0hhQ8pvs6DzmtLI4nDA7bQjazvwO4F5Mj1vu6LpSiTePfEVZ0059u6xqjW");
const bookTour = async (tourId)=>{
    try {
        // 1) Get checkout session from API
        const session = await _axiosDefault.default(`/api/v1/bookings/checkout-session/${tourId}`);
        console.log(session);
        // 2) Create checkout form + chanre credit card
        await stripe.redirectToCheckout({
            sessionId: session.data.session.id
        });
    } catch (err) {
        console.log(err);
        _alert.showAlert("error", err);
    }
};

},{"axios":"giwFZ","./alert":"ehTc8","@parcel/transformer-js/src/esmodule-helpers.js":"6FiJn"}]},["7BNkR","hkC5c"], "hkC5c", "parcelRequire11c7")

//# sourceMappingURL=index.js.map
